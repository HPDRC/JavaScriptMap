"use strict";

/**
 * TerraFly namespace
 * @public
 * @class
 * @namespace
 * @description <b>tf</b> is the TerraFly API root namespace
*/
var tf = {
    /**
     * class types
     * @public
     * @class
     * @namespace
     * @description Components in this namespace define the types used in the TerraFly API.
    */
    types: {},
   /**
     * class consts
     * @public
     * @class
     * @namespace
     * @description Components in this namespace define the constants used in the TerraFly API. Applications should always
     * use these constants instead of referring directly to their corresponding literal values.
    */
    consts: {},
    /**
     * class platform
     * @public
     * @class
     * @namespace
     * @description Components in this namespace are related with the platform (Test, Stage, or Production) in which the application is running.
    */
    platform: {},
    /**
     * class browser
     * @public
     * @class
     * @namespace
     * @description Components in this namespace are related to the Browser that is currently running the application.
    */
    browser: {},
    /**
     * class helpers
     * @public
     * @class
     * @namespace
     * @description This namespace contains miscellaneous auxiliary components.
    */
    helpers: {},
    /**
     * class units
     * @public
     * @class
     * @namespace
     * @description Componenents in this namespace are related to measurements and unit conversions.
    */
    units: {},
    /**
     * class js
     * @public
     * @class
     * @namespace
     * @description Components in this namespace are related to JavaScript programming.
    */
    js: {},
    /**
     * class layout
     * @public
     * @class
     * @namespace
     * @description Components in this namespace support building HTML application layouts.
    */
    layout: {},
    /**
     * class dom
     * @public
     * @class
     * @namespace
     * @description Components in this namespace encapsulate access to HTML elements.
    */
    dom: {},
    /**
     * class events
     * @public
     * @class
     * @namespace
     * @description Components in this namespace support event listener registration and event dispatching.
    */
    events: {},
    /**
     * class ui
     * @public
     * @class
     * @namespace
     * @description Components in this namespace encapsulate access to high level user interface items.
    */
    ui: {},
    /**
     * class apps
     * @private
     * @class
     * @namespace
     * @description Components in this namespace are related to specific TerraFly applications.
    */
    apps: {},
    /**
     * class ajax
     * @public
     * @class
     * @namespace
     * @description Components in this namespace support access to remote services.
    */
    ajax: {},
    /**
     * class styles
     * @public
     * @class
     * @namespace
     * @description Components in this namespace support JavaScript programmatic access to CSS/HTML application styling.
    */
    styles: {},
    /**
     * class canvas
     * @public
     * @class
     * @namespace
     * @description Components in this namespace are related with HTML5 canvas drawing.
    */
    canvas: {},
    /**
     * class map
     * @public
     * @class
     * @namespace
     * @description Components in this namespace implement the TerraFly Map API.
    */
    map: {
        /**
         * class ui
         * @private
         * @class
         * @namespace
         * @description Components in this namespace implement user interface items used by the TerraFly MAP API.
        */
        ui: {},
        /**
         * class aux
         * @private
         * @class
         * @namespace
         * @description Components in this namespace implement auxiliary functionality required by the TerraFly MAP API.
        */
        aux: {}
    },
   /**
   * class urlapi
   * @public
   * @class
   * @namespace
   * @description Components in this namespace implement the TerraFly URL-API and encapsulate the creation of TerraFly maps and applications according to [URL Parameters]{@link tf.types.URLParameters}
  */
    urlapi: { },
    /**
    * class services
    * @public
    * @class
    * @namespace
    * @description Components in this namespace encapsulate access to TerraFly services.
   */
    services: { },
    /**
    * class services
    * @public
    * @class
    * @namespace
    * @description Components in this namespace encapsulate access to mathematical objects and functions.
   */
    math: { }
};
tf.g_Styles = null;
tf.g_SvgGlyphBtnMaker = null;
tf.g_Counter = null;
tf.g_Debug = null;
tf.g_DocMouseListener = null;
tf.g_UtmGdcConverter = null;
tf.g_LevelResolutionConverter = null;
tf.g_scriptCallDispatcher = null;
tf.g_SvgGlyphLib = null;
/**
 * A <b>singleton</b> is an instance of a class designed to create only a single instance of itself. Singletons are usually obtained by calling an API function,
 * e.g. {@link tf.GetDocMouseListener} to obtain the applications' [Doc Mouse Listener]{@link tf.events.DocMouseListener} singleton, or 
 * {@link tf.GetStyles} to obtain the application's [Styles]{@link tf.styles.Styles} singleton
 * @public
 * @typedef {singleton} singleton
 */
/**
 * <b>*</b> can be any JavaScript value or object
 * @public
 * @typedef {*} *
 */
/**
 * <b>undefined</b> is an invalid value for JavaScript objects
 * @public
 * @typedef {undefined} undefined
 */
/**
 * <b>null</b> is an invalid value for JavaScript objects
 * @public
 * @typedef {null} null
 */
/**
 * <b>void</b> means no value, it can be either {@link null} of {@link undefined}, and evaluates to <b>false</b> in logical expressions
 * @public
 * @typedef {void} void
 */
/**
 * boolean variables contain either a <b>true</b> or a <b>false</b> value
 * @public
 * @typedef {boolean} boolean
 */
/**
 * number variables contain <b>numeric</b> values like 0, -4.3, or 100
 * @public
 * @typedef {number} number
 */
/**
 * character variables are strings with a single character
 * @public
 * @typedef {string} character
 */
/**
 * string variables contain <b>sequences of characters</b>, like 'this is a test', or "I am a string"
 * @public
 * @typedef {string} string
 */
/**
 * <b>RegExp</b> is a standard JavaScript regular expression
 * @public
 * @typedef {RegExp} RegExp
 */
/**
 * A color component assuming values between 0 and 255, in a <b>"darkest"</b> to <b>"brightest"</b> scale
 * @public
 * @typedef {number} tf.types.rgbColorComponent
 */
/**
 * An object containing the red, green, and blue [components]{@link tf.types.rgbColorComponent} of a color
 * @public
 * @typedef {object} tf.types.rgbColorComponents
 * @property {tf.types.rgbColorComponent} r - the red color component
 * @property {tf.types.rgbColorComponent} g - the green color component
 * @property {tf.types.rgbColorComponent} b - the blue color component
 */
/**
 * A deprecated {@link string} representation of a {@link hexColor} with a '0x' prefix followed by 6 hexadecimal digits. Example: '0x876543'
 * @public
 * @typedef {string} deprecatedColor
 * @deprecated use {@link hexColor} or {@link color} instead
 */
/**
 * JavaScript [colors]{@link color} represented in {@link string} format with a '#' prefix followed by 3 or 6 hexadecimal digits. Examples: "#f0f" and '#876543'
 * @public
 * @typedef {color} hexColor
 */
/**
 * JavaScript [colors]{@link color} represented in {@link string} format with red, green, and blue components, each assuming values between 0 and 255. Examples: "rgb(0, 0, 0)" and 'rgb(128, 240, 255)'
 * @public
 * @typedef {color} rgbColor
 */
/**
 * JavaScript [colors]{@link color} represented as a string with red, green, and blue components, each assuming values between 0 and 255, followed by an [opacity01]{@link tf.types.opacity01} component.
 * Examples: "rgba(0, 0, 0, 0)", "rgba(0, 255, 0, 0.4)", and 'rgba(128, 240, 255, 1)'
 * @public
 * @typedef {color} rgbaColor
 */
/**
 * JavaScript colors represented in {@link string} format without alpha (transparency) information. Examples: "#fff", '#876543', and 'rgb(255, 0, 129)'
 * @public
 * @typedef {string} color
 */
/**
 * JavaScript colors represented in {@link string} format with or without alpha (transparency) information. Examples: "#fff", '#876543', 'rgb(255, 0, 129)', and 'rgba(255, 0, 129, 0.5)'
 * @public
 * @typedef {string} colorWithOptionalAlpha
 */
/**
 * A JavaScript <b>array</b>, like <b>[0, 0]</b>
 * @public
 * @typedef {array} array
 */
/**
 * A JavaScript <b>object</b>, like <b>{ property1: "value1", property2: value2 }</b>
 * @public
 * @typedef {object} object
 */
/**
 * A JavaScript <b>function</b>
 * @public
 * @typedef {function} function
 */
/**
 * A JavaScript <b>enumerable</b>, is either an {@link array} or an {@link object} whose properties can be enumerated in a JavaScript <b>for(var i in {@link enumerable})</b> loop. 
 * Use of {@link enumberable} provides API functions the flexibility of not distinguishing between {@link array} and {@link object} parameters when processing lists of data
 * It is important that applications follow acceptable JavaScript programming practices, and preserve the integrity of JavaScript {@link array} and {@link object} prototypes,
 * to avoid introducing extraneous enumerable items into these classes.
 * @public
 * @typedef {enumerable} enumerable
 */
/**
 * A JavaScript <b>Date</b> object
 * @public
 * @typedef {Date} Date
 */
/**
 * A JavaScript <b>DOMEvent</b> is an {@link object} associated with Browser and {@link HTMLElement} events. Some of its properties vary from browser to browser.
 * During notifications instances of this type are reported back to event listeners created with the API function {@link tf.events.AddDOMEventListener}
 * @public
 * @typedef {DOMEvent} DOMEvent
 */
/**
 * A JavaScript <b>HTMLNode</b> {@link object}, is a component part of the HTML Document Object Model, like <b>document</b>, <b>head</b>, and <b>body</b>
 * @public
 * @typedef {HTMLNode} HTMLNode
 */
/**
 * A JavaScript <b>HTMLElement</b> {@link object}, like the ones obtained by calling <b>document.getElementById(elementIdStr)</b>
 * @public
 * @typedef {HTMLElement} HTMLElement
 */
/**
 * One of: <br>- an {@link HTMLElement},<br>- a {@link string} containing an {@link HTMLElement} id,<br>- or any JavaScript {@link object} equipped with a function named <b>GetHTMLElement()</b> returning an {@link HTMLElement}
 * @public
 * @typedef {HTMLElementLike} HTMLElementLike
 */
/**
 * One of: <br>- an {@link HTMLElement},<br>- a {@link string} with HTML content,<br>- or any JavaScript {@link object} equipped with a function named <b>GetHTMLElement()</b> returning an {@link HTMLElement}
 * @public
 * @typedef {HTMLContent} HTMLContent
 */
/**
 * A string denoting the size of an HTML element using one of the standard formats: "10px", "5em", "15%", etc.
 * @public
 * @typedef {string} HTMLElementSize
 */
/**
 * Either a [string]{@link HTMLElementSize] denoting the size of an HTML element or a {@link number} interpreted as pixel dimensions
 * @public
 * @typedef {HTMLElementSize|number} HTMLElementSizeOrPxNumber
 */
/**
 * <b>canvasContext</b> is the pre-defined HTML5 canvas context component, used on drawing operations, and obtainable by calling getContext() on a {@link canvas}
 * @public
 * @typedef {object} canvasContext
 */
/**
 * <b>canvas</b> is the pre-defined HTML5 canvas component, used on drawing operations, and obtainable by calling document.createElement('canvas'), or by using the HTML <b>canvas</b> tag
 * @public
 * @typedef {object} canvas
 */
/**
 * An Easing Function takes an argument between 0 and 1 and returns a value also between 0 and 1. 
 * Easing functions are used to modify the rate at which a value changes. For example: 
 * returning the square of an argument that varies linearly from 0 to 1 causes the rate of change
 * to start slowly and accelerate as the argument approaches 1
 * @public
 * @typedef {function} tf.types.EasingFunction
 * @param {tf.types.value01} t - the input value
 * @return {tf.types.value01} - | {@link tf.types.value01} the output value
 */
/**
 * A floating point number from 0 to 1 inclusive
 * @public
 * @typedef {number} tf.types.value01
 */
/**
 * A floating point number from 0 to 1 inclusive representing an opacity value, where 0 means completely transparent and 1 means completely opaque
 * @public
 * @typedef {number} tf.types.opacity01
 */
/**
 * A floating point number from 0 to 100 inclusive representing an opacity value, where 0 means completely transparent and 100 means completely opaque
 * @public
 * @typedef {number} tf.types.opacity0100
 */
/**
 * Pixel coordinates in array format <b>[ {@link number}, {@link number} ]</b>, horizontal coordinate in index 0, vertical coordinate in index 1
 * @public
 * @typedef {array} tf.types.pixelCoordinates
 */
/**
 * One of the geometry types supported by the GeoJSON format: <b>"Point"</b>, <b>"LineString"</b>, <b>"Polygon"</b>, <b>"MultiPoint"</b>, <b>"MultiLineString"</b>, and <b>"MultiPolygon"</b>.
 * Used in the creation of [Map Feature Geometries]{@link tf.map.FeatureGeom}
 * @public
 * @typedef {string} tf.types.GeoJSONGeometryType
 */
/**
 * An array, or arrays nested into arrays, of [Map Coordinates]{@link tf.types.mapCoordinates}, depending on the value of its associated [Geometry Type]{@link tf.types.GeoJSONGeometryType}.
 * Used in the creation of [Map Feature Geometries]{@link tf.map.FeatureGeom}
 * @public
 * @typedef {array<tf.types.mapCoordinates>|array<array<tf.types.mapCoordinates>>} tf.types.GeoJSONGeometryCoordinates
 */
/**
 * An object containing GeoJSON geometry properties.
 * Used in the creation of [Map Feature Geometries]{@link tf.map.FeatureGeom}
 * @public
 * @typedef {object} tf.types.GeoJSONGeometry
 * @property {tf.types.GeoJSONGeometryType} type - the type
 * @property {tf.types.GeoJSONGeometryCoordinates} coordinates - the coordinates
 */
/**
 * A callback capable of extracting [GeoJSON Geometry]{@link tf.types.GeoJSONGeometry} from a JavaScript {@link object} in a format other than standard GeoJSON Feature Lists
 * @public
 * @callback tf.types.GetGeoJSONGeometryCallBack
 * @param {tf.map.Feature} mapFeature - the map feature to show
 * @returns {void} - | {@link void} no return value
 * @see {@link tf.types.MapContinueAnimation}
 */
/**
 * A {@link string} that uniquely identifies a property assigned to a JavaScript {@link object} 
 * @public
 * @typedef {string} tf.types.PropertyName
 * @see [Known API Properties]{@link tf.types.KnownAPIPropertyName}
 */
/**
 * A {@link string} that uniquely identifies a property assigned to a JavaScript {@link object} 
 * @public
 * @typedef {string} tf.types.PropertyName
 * @see [Known API Properties]{@link tf.types.KnownAPIPropertyName}
 */
/**
 * A {@link string} in url encoded format containing the most of the properties found in [URLParameters]{@link tf.types.URLParameters}, 
 * usually obtained directly from the <b>window.location.href</b> string without further processing. Examples: "http://domain.ext/#property1=value1&property2=value2",
 * "http://domain.ext/file.html?property1=value1&property2=value2", "#property1=value1&property2=value2"
 * @public
 * @typedef {string} tf.types.URLParametersString
 * @see [URL Parameter Summary]{@link http://experiment2.cs.fiu.edu/hterramap/test/URLParameters.htm}
 */
/**
 * An {@link object} with [URLParameters]{@link tf.types.URLParameters} properties
 * @public
 * @typedef {object} tf.types.URLParametersObject
 * @see [URL Parameter Summary]{@link http://experiment2.cs.fiu.edu/hterramap/test/URLParameters.htm}
 */
/**
 * Definitions of map and application behavior in [string]{@link tf.types.URLParametersString} or [object]{@link tf.types.URLParametersObject} format
 * @public
 * @typedef {object} tf.types.URLParameters
 * @property {tf.types.mapEngine} - {@link tf.consts.paramNameFMap} - the Map Engine to use
 * @property {tf.types.latitude} - {@link tf.consts.paramNameLat} - the initial map center latitude coordinate
 * @property {tf.types.longitude} - {@link tf.consts.paramNameLon} - the initial map center latitude coordinate
 * @property {tf.types.mapResolution} - {@link tf.consts.paramNameRes} - the initial map resolution
 * @property {tf.types.mapLevel} - {@link tf.consts.paramNameLevel} - the initial map level, ignored if <b>resolution</b> is defined
 * @property {tf.types.mapPanelNamesString} - {@link tf.consts.paramNamePanels} - the initial visibility of [map panels]{@link tf.types.mapPanelNamesString}
 * @property {string} - {@link tf.consts.paramNameAddress} - the initial contents of the map's address bar
 * @property {string} - {@link tf.consts.paramNameHelp} - the contents of the help message displayed by the map
 * @property {string} - {@link tf.consts.paramNameVid} - a string used by the map when interacting with some TerraFly services
 * @property {string} - {@link tf.consts.paramNamePassThrough} - a string used by the map when interacting with some TerraFly services
 * @property {string} - {@link tf.consts.paramNameTFLogo} - whether the TerraFly logo is displayed by the map <b>1</b> for yes, <b>0</b> for no
 * @property {tf.types.mapType} - {@link tf.consts.paramNameType} - the initial map type
 * @property {tf.types.mapType} - {@link tf.consts.paramNameSource} - the initial map source
 * @property {number} - {@link tf.consts.paramNameMessageTimeout} - the number of seconds before the map's Message Popup closes itself
 * @property {tf.types.legendString} - {@link tf.consts.paramNameLegend}- the legend string for Mapnik 1.0 used by the map's Base Layers
 * @property {tf.types.legendString} - {@link tf.consts.paramNameLegendH} - the hybrid legend string for Mapnik 2.0 used by the map's Base Layers
 * @property {tf.types.legendString} - {@link tf.consts.paramNameLegendM} - the Map legend string for Mapnik 2.0 used by the map's Base Layers
 * @property {string} - {@link tf.consts.paramNameApps} - the optional name of a the native TerraFly API application to be executed. Currently {@link tf.consts.appNameRAMB} is supported
 * @property {string} - {@link tf.consts.paramNameAppSpecs} - an optional file name containing additional specifications
 * @property {number} - {@link tf.consts.paramNameDLExtent} - an optional numeric parameter that, when present, determines the minimum number of records of the first DLayer that must initially be displayed either by zooming out or by re-centering the map, or a combination of both
 * @property {string} - {@link tf.consts.paramNameDLLegend} - the name of a [DLayer]{@link tf.urlapi.DLayer}, <b>DLayer</b> parameter names always end with a number
 * identifying the dlayer instance referred by the parameter
 * @property {string} - {@link tf.consts.paramNameDLData} - the remote service associated with a [DLayer]{@link tf.urlapi.DLayer}
 * @property {string} - {@link tf.consts.paramNameDLField} - the [DLayer]{@link tf.urlapi.DLayer} field to display as a [Map Feature]{@link tf.map.Feature}
 * @property {string} - {@link tf.consts.paramNameDLSelect} - the initial map visibility of a [DLayer]{@link tf.urlapi.DLayer}
 * @property {string} - {@link tf.consts.paramNameDLColor} - the color with which to display text markers belonging to a [DLayer]{@link tf.urlapi.DLayer}
 * @see [URL Parameter Summary]{@link http://experiment2.cs.fiu.edu/hterramap/doc/URLParameters.htm}
*/
/**
 * Legend strings control the type of information the [Map]{@link tf.map.Map} requests from the [Map Engine]{@link tf.types.mapEngine}. 
 * Legend strings are defined with the following syntax:<br>
 * <pre>
 * Legend =
 * $$http://vn4.cs.fiu.edu//wm$$
 * {//groupSet begin
 *    (~) &ltgroupSetName&gt : &ltgroupSetDesc&gt ::
 *    (~) &ltgroupName&gt : &ltgroupDesc&gt //Group begin
 *        @ &ltcompositeName1&gt - &ltmin&gt - &ltMax&gt - ( &ltmode&gt ) +
 *        &ltcompositeName2&gt - &ltmin&gt - &ltmax&gt - ( &ltmode&gt )
 *        ( + other composites ); //Group end
 *        (other groups;)
 * };//groupSet end
 * (other {groupSets}; or groups;)
 *
 * <table>
 *  <tr><th style="width: 1px;white-space:nowrap;">Elements</th><th>Description</th></tr>
 *  <tr><td style="width: 1px;white-space:nowrap;">&ltgroupSetName&gt</td><td>The name of the groupSet</td></tr>
 *  <tr><td style="width: 1px;white-space:nowrap;">&ltgroupSetDesc&gt</td><td>The description of the groupSet, shown as a tooltip</td></tr>
 *  <tr><td style="width: 1px;white-space:nowrap;">&ltgroupName&gt</td><td>The label of the group, different groups have different labels</td></tr>
 *  <tr><td style="width: 1px;white-space:nowrap;">&ltgroupDesc&gt</td><td>The detail of the group, shown as a tooltip</td></tr>
 *  <tr><td style="width: 1px;white-space:nowrap;">&ltcompositeName&gt</td><td>The name of the legend composite</td></tr>
 *  <tr><td style="width: 1px;white-space:nowrap;">&ltmin&gt</td><td>The minimum resolution to show this composite's content</td></tr>
 *  <tr><td style="width: 1px;white-space:nowrap;">&ltmax&gt</td><td>The maximum resolution to show this composite's content</td></tr>
 *  <tr><td style="width: 1px;white-space:nowrap;">&ltmode&gt</td><td>The mode of current composite</td></tr>
 *  <tr><td style="width: 1px;white-space:nowrap;">{};</td><td>groupSets are enclosed in braces</td></tr>
 *  <tr><td style="width: 1px;white-space:nowrap;">;</td><td>Separates groups</td></tr>
 *  <tr><td style="width: 1px;white-space:nowrap;">~</td><td>Prefix symbol denoting that the groupSet (or group) is pre-checked</td></tr>
 *  <tr><td style="width: 1px;white-space:nowrap;">::</td><td>Separates groupSet name and description from its sub-items</td></tr>
 *  <tr><td style="width: 1px;white-space:nowrap;">@</td><td>Separates groupSet name and description from its composites</td></tr>
 *  <tr><td style="width: 1px;white-space:nowrap;">:</td><td>Separates a groupSet or group name from its description</td></tr>
 *  <tr><td style="width: 1px;white-space:nowrap;">+</td><td>Separates composites</td></tr>
 *  <tr><td style="width: 1px;white-space:nowrap;">-</td><td>Separates composite values</td></tr>
 *</table>
 * <b>Notes:</b>
 *
 * 1. groupSet: A container of groups, groupSets cannot be nested.
 *
 * 2. Elements enclosed in parenthesis are optional.
 *
 * 3. Items are shown in the Base Layers popup and on a Map whose current resolution is between <b>min</b> and <b>max</b>.
 *
 * 4. The prefix <b>~</b> can be used divide groups into default visible and invisible ranges, e.g.
 *
 *    <b>~owner : Property_owner @ flpropertiesowner-0-0.5-;</b>
 *    <b>owner : Property_owner @ flpropertiesowner-0.5-8-;</b>
 *
 *    the "owner" group is made visible by default in the resolution range from 0 to 0.5, and invisible by default in the 0.5 to 8 range.
 * </pre>
 * @public
 * @typedef {string} tf.types.legendString
*/
/*if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function (obj, fromIndex) {
        fromIndex = tf.js.GetNonNegativeIntFrom(fromIndex);
        for (var i = fromIndex, j = this.length; i < j; ++i) {
            if (this[i] === obj) return i;
        }
        return -1;
    };
}*/
tf.consts.URLAPIDocumentTitle = "TerraMap";
tf.consts.MVideoDocumentTitle = "Data Mapper";
tf.consts.TimeSeriesDocumentTitle = "TerraFly - TimeSeries";
tf.consts.MLSDocumentTitle = "TerraFly MLS Search";
tf.consts.MLSDocumentTitle2 = "Search Tool for S Florida Real Estate Powered by TerraFly";
tf.consts.urlPartsSeparatorStr = "$$";
/**
 * @public
 * @description default map center latitude
*/
tf.consts.defaultLatitude = 25.75869;
tf.consts.minLatitude = -90.0;
tf.consts.maxLatitude = 90.0;
tf.consts.latitudeRange = tf.consts.maxLatitude - tf.consts.minLatitude;
/**
 * Latitude values, between -90 and 90 degrees, in the World Geodetic System, "EPSG:4326"
 * @public
 * @typedef {number} tf.types.latitude
 */
/**
 * @public
 * @description default map center longitude
*/
tf.consts.defaultLongitude = -80.37388;
tf.consts.minLongitude = -180.0;
tf.consts.maxLongitude = 180.0;
tf.consts.longitudeRange = tf.consts.maxlongitude - tf.consts.minlongitude;
/**
 * Longitude values, between -180 and 180 degrees, in the World Geodetic System, "EPSG:4326"
 * @public
 * @typedef {number} tf.types.longitude
 */
/**
 * @public
 * @description default map center coordinates
*/
tf.consts.defaultMapCenter = [tf.consts.defaultLongitude, tf.consts.defaultLatitude];
/**
 * @public
 * @description default map resolution (2.4)
*/
tf.consts.defaultRes = 2.4;
/**
 * Map resolution is closely related with {@link tf.types.mapLevel}. 
 * The [default map resolution]{@link tf.consts.defaultRes} corresponds to the [default level]{@link tf.consts.defaultLevel}
 * The unit of Map resolution values is <b>meters per pixel</b>
 * @public
 * @typedef {number} tf.types.mapResolution
 */
/**
 * @public
 * @description default map level (16)
*/
tf.consts.defaultLevel = 16;
/**
 * @public
 * @description maximum map level (24)
*/
tf.consts.maxLevel = 24;
/**
 * @public
 * @description minimum map level (1)
*/
tf.consts.minLevel = 1;
/**
 * Map levels are sometimes called zoom levels; incrementing / decrementing the map level doubles / halves the map's resolution.
 * Valid values are in the range of [minLevel]{@link tf.consts.minLevel} to [maxLevel]{@link tf.consts.maxLevel}. Map level
 * defaults to [defaultLevel]{@link tf.consts.defaultLevel}
 * See {@link tf.types.mapResolution}
 * @public
 * @typedef {number} tf.types.mapLevel
 */
/*
~osm-lines:Roads_from_Open_Street_Maps@osm_roads-0-7000;
~osm-names:Road_names_from_Open_Street_Maps@osm_road_names-0-240;
~osm-buildings:Building_data_from_Open_Street_Maps@osm_buildings-0-7;
~osm-place-names:Place_names_from_Open_Street_Maps@osm_place_names-0-30000;
~osm-water:Water_data_from_Open_Street_Maps@osm_water-0-4000;
~osm-land:Land_from_Open_Street_Maps@osm_land-0-30000;
~osm-land-use:Land_use_from_Open_Street_Maps@osm_landuse-0-30000;
~osm-land-use:Land_use_from_Open_Street_Maps@osm_landuse-0-30000;~osm-land:Land_from_Open_Street_Maps@osm_land-0-30000;~osm-water:Water_data_from_Open_Street_Maps@osm_water-0-4000;~osm-place-names:Place_names_from_Open_Street_Maps@osm_place_names-0-30000;~osm-buildings:Building_data_from_Open_Street_Maps@osm_buildings-0-7;~osm-names:Road_names_from_Open_Street_Maps@osm_road_names-0-240;~osm-lines:Roads_from_Open_Street_Maps@osm_roads-0-7000;
*/
tf.consts.defaultTFLogoOn = true;
/**
 * @public
 * @description default Mapnik 1.0 Map [Legend String]{@link tf.types.legendString}
*/
tf.consts.defaultLegend = "$$http://vn4.cs.fiu.edu/defaultmap$$";
//tf.consts.defaultLegendH = "{Cities::~Capitals:Capitals_WorldMap@wm_Capitals-120-6000;Capitals:Capitals_WorldMap@wm_Capitals-6000-15000;~Metro:Big_Cities_over_million_WorldMap@wm_Cities_Greater_900K-120-5000;Metro:Big_Cities_over_million_WorldMap@wm_Cities_Greater_900K-5000-15000;~Cities:Cities_WorldMap@wm_Cities_75K_to_900K-120-2400+wm_Cities_Greater_900K-120-2400+wm_Cities_Unknownpop-120-2400;Cities:Cities_WorldMap@wm_Cities_75K_to_900K-2400-15000+wm_Cities_Greater_900K-2400-15000+wm_Cities_Unknownpop-2400-15000;};{Hubs::~Ports:Marine_Ports_WorldMap@wm_Marine_Ports-120-360;Ports:Marine_Ports_WorldMap@wm_Marine_Ports-360-2000;~Railway:Railway_Stations_WorldMap@wm_Railway_Stations-120-240;~Airports:Airports_WorldMap@wm_Airports-120-240;};{Water::Bays:Seas_and_Bays_WorldMap@wm_Seas_Bays-120-2000;Glaciers:Glaciers_WorldMap@wm_Glacier-120-4000;~Rivers_B:Lake_and_River_contours_WorldMap@wm_Water_Poly-120-500;~Great_Lakes_L:Great_Lakes_labels_WorldMap@WM_GREAT_LAKES_NAME-120-4000;~Great_Lakes_B:Great_Lakes_contours_WorldMap@wm_Great_Lakes-120-4000;osm-water:Water_data_from_Open_Street_Maps@osm_water-0-4000;};{Regions::~Admin_L:States_and_Provinces_names_labeled_WorldMap@wm_World_Admin_name-120-2000;~Admin_B:States_and_Provinces_boundaries_WorldMap@wm_World_Admin-120-2000;~Countries_L:Nation_names_labeled_WorldMap@nation_name-2000-5000;Countries_L:Nation_names_labeled_WorldMap@nation_name-5000-30000;~Countries_B:Nations_boundaries_WorldMap@wm_World_Nations-120-15000;osm-admin:Administrative_boundary_data_from_Open_Street_Maps@osm_admin-0-60000;};{Parcels::~owner:Property_owner@flpropertiesowner-0-0.5;year_built:Year_property_built_or_renovated@flpropertiesyear-0-0.5;size:Sizes_of_property_interior_and_lot@flpropertiessize-0-0.5;appraisal:Property_value@flpropertiesvalue-0-0.5;~lines:Property_lines,_from_First_American@fa_parcel-0-1;lines:Property_lines,_from_First_American@fa_parcel-1-2;MLS_Real_estate:MLS_listings_for_sale_and_rent_in_Miami_area@re1n-0-5+re2n-0-5+rntn-0-5+rinn-0-5+rldn-0-5;osm-buildings:Building_data_from_Open_Street_Maps@osm_buildings-0-7;};{People::population:People_per_block_per_Census_2000@blk_pop-0-5;income:Aggregate_Neighborhood_Income_and_number_of_homes,_per_Census-2000@bg_mhinc-0.7-10;};{Services::~business:Yellow_Pages@nypages-0-1.2;business:Yellow_Pages@nypages-1.2-5;food:Restaurants_from_NavTeq@nv_restrnts-0-10;doctors:Physicians_specialties@physicianspecialty-0-5;};Landmarks:Cultural_Landmarks_WorldMap@wm_Cultural_Landmarks-120-1800;Utilities:Utilities_WorldMap@wm_Utilities-120-720;Environment:Hydrology@prism-0-120;~Places:Places@gnis2-0-6+hotels-0-6;Places:Places@gnis2-6-24+hotels-6-24;OSM-place-names:Place_names_from_Open_Street_Maps@osm_place_names-0-30000;{Road::~navteq-lines:Roads,_and_streets@street-5-2000;navteq-lines:Roads,_and_streets@street-0-5;~navteq-names:Roads,_and_streets@street_names-0-240;osm-lines:Open_Street_Maps@osm_roads-0-7000;osm-names:Open_Street_Maps@osm_road_names-0-240;~routes:Routes_WorldMap@wm_Major_Routes-120-1000+wm_Minor_Routes-120-1000;routes:Routes_WorldMap@wm_Major_Routes-1000-5000+wm_Minor_Routes-1000-5000;~railways:Railroad_WorldMap@wm_Railroad_Track-120-2000;};{Town::~borders:Borders@incorp-0-120;~towns:Cities,_towns@wtown-0-60;};";
//tf.consts.defaultLegendH = "$$http://n00.cs.fiu.edu/defaultmapFL$$";
//tf.consts.defaultLegendM = "~osm-land-use:Land_use_from_Open_Street_Maps@osm_landuse-0-30000;~osm-land:Land_from_Open_Street_Maps@osm_land-0-30000;~osm-water:Water_data_from_Open_Street_Maps@osm_water-0-4000;~osm-place-names:Place_names_from_Open_Street_Maps@osm_place_names-0-30000;~osm-buildings:Building_data_from_Open_Street_Maps@osm_buildings-0-7;~osm-names:Road_names_from_Open_Street_Maps@osm_road_names-0-240;~osm-lines:Roads_from_Open_Street_Maps@osm_roads-0-7000;";
/**
 * @public
 * @description default Mapnik 2.0 Map [Legend String]{@link tf.types.legendString}
*/
tf.consts.defaultLegendM = "$$http://n00.cs.fiu.edu/Defaults/layers.maponly.mapnik2$$";
/**
 * @public
 * @description default Mapnik 2.0 Hybrid [Legend String]{@link tf.types.legendString}
*/
tf.consts.defaultLegendH = "$$http://n00.cs.fiu.edu/Defaults/layers.hybrid.mapnik2$$";
/**
 * @public
 * @description Mapnik 1.0 engine
*/
tf.consts.mapnikEngine = "m";
/**
 * @public
 * @description Mapnik 2.0 engine
*/
tf.consts.mapnik2Engine = "m2";
tf.consts.defaultFMap = tf.consts.mapnik2Engine;
/**
 * The Vector Tile engine used by the map, either {@link tf.consts.mapnik2Engine} or {@link tf.consts.mapnikEngine}
 * @public
 * @typedef {tf.types.mapEngine} tf.types.mapEngine
 */
tf.consts.defaultTFPassThrough = "";
tf.consts.defaultVid = "";
tf.consts.defaultHelp =
    "<span>" +
    "<b>Double Click</b>: Local Data Reports and Queries<br />" +
    "<b>Drag</b>: Browse the map<br />" +
    "Buttons: <b>Full Screen</b>, <b>Reset Rotation</b>, <b>Search Location</b>, <b>Zoom</b>, <b>Map Layers</b><br /><br />" +
    "Address bar examples:<br />" +
    "1 Flagler St, Miami, FL<br />Miami<br />Miami, FL<br />33139<br />25.77 -80.19 (coordinates)" +
    "</span>";
tf.consts.defaultAddress = "";
tf.consts.tfLogoOnStr = "1";
tf.consts.tfLogoOffStr = "0";
/**
 * @public
 * @description Hybrid map display (Aerial + Map combined)
*/
tf.consts.typeNameHybrid = "hybrid";
/**
 * @public
 * @description Map display (Vector tiles only)
*/
tf.consts.typeNameMap = "map";
/**
 * @public
 * @description Aerial display (Aerial tiles only)
*/
tf.consts.typeNameAerial = "satellite";
tf.consts.typeNameUndefined = "undefined";
tf.consts.defaultTypeName = tf.consts.typeNameHybrid;
/**
 * The type of map images displayed by the map, either {@link tf.consts.typeNameHybrid}, {@link tf.consts.typeNameMap} or {@link tf.consts.typeNameAerial}
 * @public
 * @typedef {tf.types.mapType} tf.types.mapType
 */
/** 
 * @public 
 * @description Best Available source for map Aerial tiles 
*/
tf.consts.sourceName_best_available = "best_available";
/**
 * @public
 * @description source for map Aerial tiles 
*/
tf.consts.sourceName_naip_1m = "naip_1m";
/**
 * @public
 * @description source for map Aerial tiles 
*/
tf.consts.sourceName_usgs_toop_r = "usgs_toop_r";
/**
 * @public
 * @description source for map Aerial tiles 
*/
tf.consts.sourceName_county_1ft = "county_1ft";
/**
 * @public
 * @description source for map Aerial tiles 
*/
tf.consts.sourceName_landsat7_321 = "landsat7_321";
/**
 * @public
 * @description source for map Aerial tiles 
*/
tf.consts.sourceName_usgs_1m = "usgs_1m";
/**
 * @public
 * @description source for map Aerial tiles 
*/
tf.consts.sourceName_country_3inch = "country_3inch";
/**
 * @public
 * @description source for map Aerial tiles 
*/
tf.consts.sourceName_usgs_ap_cir = "usgs_ap_cir";
/**
 * @public
 * @description source for map Aerial tiles 
*/
tf.consts.sourceName_usgs_ap_r = "usgs_ap_r";
/**
 * @public
 * @description source for map Aerial tiles 
*/
tf.consts.sourceName_dor_1ft = "dor_1ft";
/**
 * @public
 * @description source for map Aerial tiles 
*/
tf.consts.sourceName_usgs_ap_cir = "usgs_ap_cir";
tf.consts.defaultSourceName = tf.consts.sourceName_best_available;
/**
 * The source of aerial tiles displayed by the map, one of:<br>
 * {@link tf.consts.sourceName_best_available},<br>
 * {@link tf.consts.sourceName_naip_1m},<br>
 * {@link tf.consts.sourceName_usgs_toop_r},<br>
 * {@link tf.consts.sourceName_county_1ft},<br>
 * {@link tf.consts.sourceName_landsat7_321},<br>
 * {@link tf.consts.sourceName_usgs_1m},<br>
 * {@link tf.consts.sourceName_country_3inch},<br>
 * {@link tf.consts.sourceName_usgs_ap_cir},<br>
 * {@link tf.consts.sourceName_usgs_ap_r},<br>
 * {@link tf.consts.sourceName_dor_1ft},<br>
 * or {@link tf.consts.sourceName_usgs_ap_cir}
 * @public
 * @typedef {tf.types.mapAerialSource} tf.types.mapAerialSource
 */
/**
 * @public
 * @description map zoom control name: "zoom"
*/
tf.consts.panelNameZoom = "zoom";
/**
 * @public
 * @description map overview control name: "overview"
*/
tf.consts.panelNameOverview = "overview";
/**
 * @public
 * @description map layers control name: "legend"
*/
tf.consts.panelNameLayers = "legend";
/**
 * @public
 * @description map download control name: "download"
*/
tf.consts.panelNameDownload = "download";
/**
 * @public
 * @description map measure control name: "measure"
*/
tf.consts.panelNameMeasure = "measure";
/**
 * @public
 * @description map type control name: "type"
*/
tf.consts.panelNameType = "type";
/**
 * @public
 * @description map fullscreen control name: "fullscreen"
*/
tf.consts.panelNameFullscreen = "fullscreen";
/**
 * @public
 * @description map source control name: "source"
*/
tf.consts.panelNameSource = "source";
/**
 * @public
 * @description map address control name: "address"
*/
tf.consts.panelNameAddress = "address";
/**
 * @public
 * @description map location control name: "maplocation"
*/
tf.consts.panelNameMapLocation = "maplocation";
/**
 * @public
 * @description map scale control name: "mapscale"
*/
tf.consts.panelNameMapScale = "mapscale";
/**
 * @public
 * @description map rotate control name: "maprotate"
*/
tf.consts.panelNameMapRotate = "maprotate";
/**
 * @public
 * @description map user location control name: "userlocation"
*/
tf.consts.panelNameUserLocation = "userlocation";
/**
 * @public
 * @description map logo control name: "tflogo"
*/
tf.consts.panelNameTFLogo = "tflogo";
/**
 * @public
 * @description prevents the map's address bar control from being displayed: "noaddress"
*/
tf.consts.panelNameNoAddress = "noaddress";
/**
 * @public
 * @description prevents the map's location control from being displayed: "nomaplocation"
*/
tf.consts.panelNameNoMapLocation = "nomaplocation";
/**
 * @public
 * @description prevents the map's rotate control from being displayed: "nomaprotate"
*/
tf.consts.panelNameNoMapRotate = "nomaprotate";
/**
 * @public
 * @description prevents the map's scale control from being displayed: "nomapscale"
*/
tf.consts.panelNameNoMapScale = "nomapscale";
/**
 * @public
 * @description prevents the map's user location control from being displayed: "nouserlocation"
*/
tf.consts.panelNameNoUserLocation = "nouserlocation";
/**
 * @public
 * @description character used to separate string component names, like names of map panels ({@link tf.types.mapPanelName}) in a panel name string ({@link tf.types.mapPanelNamesString})
*/
tf.consts.charSplitStrings = '+';
tf.consts.allPanelNames = [
    tf.consts.panelNameAddress,
    tf.consts.panelNameZoom,
    tf.consts.panelNameLayers,
    tf.consts.panelNameType,
    tf.consts.panelNameMeasure,
    tf.consts.panelNameDownload,
    tf.consts.panelNameSource,
    tf.consts.panelNameFullscreen,
    tf.consts.panelNameMapLocation,
    tf.consts.panelNameOverview,
    tf.consts.panelNameMapScale,
    tf.consts.panelNameMapRotate,
    tf.consts.panelNameUserLocation,
    tf.consts.panelNameTFLogo
];
tf.consts.defaultPanels =
    tf.consts.panelNameTFLogo + tf.consts.charSplitStrings +
    tf.consts.panelNameAddress + tf.consts.charSplitStrings +
    tf.consts.panelNameZoom + tf.consts.charSplitStrings +
    tf.consts.panelNameLayers + tf.consts.charSplitStrings +
    tf.consts.panelNameType + tf.consts.charSplitStrings +
    tf.consts.panelNameMeasure + tf.consts.charSplitStrings +
    tf.consts.panelNameMapLocation + tf.consts.charSplitStrings +
    tf.consts.panelNameUserLocation + tf.consts.charSplitStrings +
    tf.consts.panelNameMapRotate + tf.consts.charSplitStrings +
    tf.consts.panelNameMapScale + tf.consts.charSplitStrings +
    tf.consts.panelNameOverview;
tf.consts.charSplitApps = '+';
/**
 * The name of a map panel displayed by default by the URL-API, one of:<br>
 * {@link tf.consts.panelNameAddress},<br>
 * {@link tf.consts.panelNameLayers},<br>
 * {@link tf.consts.panelNameMapLocation},<br>
 * {@link tf.consts.panelNameMapRotate},<br>
 * {@link tf.consts.panelNameMapScale},<br>
 * {@link tf.consts.panelNameMeasure},<br>
 * {@link tf.consts.panelNameOverview},<br>
 * {@link tf.consts.panelNameTFLogo},<br>
 * {@link tf.consts.panelNameType},<br>
 * {@link tf.consts.panelNameUserLocation},<br>
 * or {@link tf.consts.panelNameZoom}
 * @public
 * @typedef {tf.types.mapDefaultPanelName} tf.types.mapDefaultPanelName
 */
/**
 * The name of a map panel, one of:<br>
 * {@link tf.consts.panelNameAddress},<br>
 * {@link tf.consts.panelNameDownload},<br>
 * {@link tf.consts.panelNameFullscreen},<br>
 * {@link tf.consts.panelNameLayers},<br>
 * {@link tf.consts.panelNameMapLocation},<br>
 * {@link tf.consts.panelNameMapRotate},<br>
 * {@link tf.consts.panelNameMapScale},<br>
 * {@link tf.consts.panelNameMeasure},<br>
 * {@link tf.consts.panelNameOverview},<br>
 * {@link tf.consts.panelNameSource},<br>
 * {@link tf.consts.panelNameTFLogo},<br>
 * {@link tf.consts.panelNameType},<br>
 * {@link tf.consts.panelNameUserLocation},<br>
 * {@link tf.consts.panelNameZoom},<br>
 * {@link tf.consts.panelNameNoAddress},<br>
 * {@link tf.consts.panelNameNoMapLocation},<br>
 * {@link tf.consts.panelNameNoMapRotate},<br>
 * {@link tf.consts.panelNameNoMapScale},<br>
 * or {@link tf.consts.panelNameNoUserLocation}
 * @public
 * @typedef {tf.types.mapPanelName} tf.types.mapPanelName
 */
/**
 * A string listing names of map panels (see {@link tf.types.mapPanelName}) separated by the character {@link tf.consts.charSplitStrings}<br>
 * This type of string is used by the namespace {@link tf.urlapi}, and in the creation of [Map]{@link tf.map.Map} instances 
 * @public
 * @typedef {string} tf.types.mapPanelNamesString
 */
/**
*/
 //* Name of the [URL Parameter]{@link tf.types.URLParameters} that activates the "Realtor" native application
 //* @public
 //*/
//tf.consts.appNameRAMB = "ramb";
//tf.consts.appNameALTA = "alta";
/*tf.consts.allAppsNames = [
    //tf.consts.appNameALTA,
    tf.consts.appNameRAMB
];
tf.consts.defaultApps = "";*/
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the Map Engine to use: "fmap"
 * @public
 */
tf.consts.paramNameFMap = "fmap";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the initial map center latitude coordinate: "lat"
 * @public
 */
tf.consts.paramNameLat = "lat";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the initial map center latitude coordinate: "lon"
 * @public
 */
tf.consts.paramNameLon = "lon";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the initial map resolution: "res"
 * @public
 */
tf.consts.paramNameRes = "res";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the initial map level, ignored if <b>resolution</b> is defined: "level"
 * @public
 */
tf.consts.paramNameLevel = "level";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the initial visibility of [map panels]{@link tf.types.mapPanelNamesString}: "panels"
 * @public
 */
tf.consts.paramNamePanels = "panels";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the initial contents of the map's address bar: "address"
 * @public
 */
tf.consts.paramNameAddress = "address";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the contents of the help message displayed by the map: "help"
 * @public
 */
tf.consts.paramNameHelp = "help";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling a string used by the map when interacting with some TerraFly services: "vid"
 * @public
 */
tf.consts.paramNameVid = "vid";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling a string used by the map when interacting with some TerraFly services: "tf_passtrough"
 * @public
 */
tf.consts.paramNamePassThrough = "tf_passtrough";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling whether the TerraFly logo is displayed by the map: "tflogo"
 * @public
 */
tf.consts.paramNameTFLogo = "tflogo";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the initial map type: "type"
 * @public
 */
tf.consts.paramNameType = "type";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the initial map source: "source"
 * @public
 */
tf.consts.paramNameSource = "source";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the number of seconds before the map's Message Popup closes itself: "rgpopup"
 * @public
 */
tf.consts.paramNameMessageTimeout = "rgpopup";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the [Legend String]{@link tf.types.legendString} for Mapnik 1.0 used by the map's Base Layers: "legend"
 * @public
 */
tf.consts.paramNameLegend = "legend";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the hybrid [Legend String]{@link tf.types.legendString} for Mapnik 2.0 used by the map's Base Layers: "legendh"
 * @public
 */
tf.consts.paramNameLegendH = "legendh";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the Map [Legend String]{@link tf.types.legendString} for Mapnik 2.0 used by the map's Base Layers: "legendm"
 * @public
 */
tf.consts.paramNameLegendM = "legendm";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the optional name of a the native TerraFly API application to be executed. Currently {@link tf.consts.appNameRAMB} is supported: "apps"
 * @public
 */
tf.consts.paramNameApps = "apps";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling an optional file name containing additional specifications: "appspecs"
 * @public
 */
tf.consts.paramNameAppSpecs = "appspecs";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the name of a [DLayer]{@link tf.urlapi.DLayer}, ending with the number identifying a dlayer: "dlayerlegend1", "dlayerlegend2", etc.
 * @public
 */
tf.consts.paramNameDLLegend = "dlayerlegend";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the remote service associated with a [DLayer]{@link tf.urlapi.DLayer}, ending with the number identifying a dlayer: "dlayerdata1", "dlayerdata2", etc.
 * @public
 */
tf.consts.paramNameDLData = "dlayerdata";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the [DLayer]{@link tf.urlapi.DLayer} field to display as a [Map Feature]{@link tf.map.Feature}, ending with the number identifying a dlayer: "dlayerfield1", "dlayerfield2", etc.
 * @public
 */
tf.consts.paramNameDLField = "dlayerfield";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the initial map visibility of a [DLayer]{@link tf.urlapi.DLayer}, ending with the number identifying a dlayer: "dlayerselect1", "dlayerselect2", etc.
 * @public
 */
tf.consts.paramNameDLSelect = "dlayerselect";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the color with which to display text markers belonging to a [DLayer]{@link tf.urlapi.DLayer}, ending with the number identifying a dlayer: "dlayercolor1", "dlayercolor2", etc.
 * @public
 */
tf.consts.paramNameDLColor = "dlayercolor";
/**
 * Name of the optional [URL Parameter]{@link tf.types.URLParameters} containing a number that, when present, determines the minimum number of records of the first DLayer that must initially be displayed either by zooming out or by re-centering the map, or a combination of both
 * @public
 */
tf.consts.paramNameDLExtent = "dlayerextent";
/**
 * Name of the optional [URL Parameter]{@link tf.types.URLParameters} governing the optional creation of a perspective map, if set to {@link void} no perspective map is created,
 * if set to {@link boolean} a perspective map is created, and displayed or hidden according to the given boolean value (true = displayed, false = hidden)
 * @public
 */
tf.consts.paramNamePerspectiveMap = "perspectivemap";
tf.consts.MVideoParamNameVideo = "m";
tf.consts.minMessageTimeout = 0;
tf.consts.maxMessageTimeout = 60;
/**
 * @public
 * @description default timeout in secods for the map Message Popup
*/
tf.consts.defaultMessageTimeout = 5;
tf.consts.addressBarName = "Search Location";
tf.consts.mapTypesName = "Display Type";
tf.consts.mapTypesHybridLabel = "Hybrid";
tf.consts.mapTypesAerialLabel = "Aerial";
tf.consts.mapTypesMapLabel = "Map";
tf.consts.mapTypesHybridTip = "Hybrid: Aerial + Map";
tf.consts.mapTypesAerialTip = "Aerial images only";
tf.consts.mapTypesMapTip = "Map images only";
tf.consts.centerToUserLocationTip = "Center Map to User Location";
tf.consts.mapLayersName = "Map Layers";
tf.consts.baseMapLayersName = "Base Layers";
tf.consts.baseMapLayersToolTip = "View Base Layers";
tf.consts.mapSourcesName = "Aerial Source";
tf.consts.mapSourcesItemTip = "Use images from: ";
tf.consts.mapLayerSourceName = "maplayersource";
tf.consts.mapDownloadName = "Download";
tf.consts.mapMeasureName = "Measure";
tf.consts.mapLocationShowTip = "Enable Location Information on Map Move";
tf.consts.mapLocationHideTip = "Disable Location Information on Map Move";
tf.consts.mapLocationPopupHideTip = "Hide Location Information";
tf.consts.fullScreenToolTipNormal = "View Full Screen";
tf.consts.fullScreenToolTipFull = "Exit Full Screen";
tf.consts.minAppWidthNumber = 400;
tf.consts.minAppHeightNumber = 360;
tf.consts.defaultGeocoderError = "ERROR IN ADDRESS, PLEASE REENTER";
/**
 * @public
 * @description {@link TMap} instance panel visible state
 * @deprecated TerraFly applications use should replace the use of {@link TMap} instances with {@link tf.map.Map} instances
*/
tf.consts.strShowPanel = "SHOW";
/**
 * @public
 * @description {@link TMap} instance panel hidden state
 * @deprecated TerraFly applications use should replace the use of {@link TMap} instances with {@link tf.map.Map} instances
*/
tf.consts.strHidePanel = "HIDE";
/**
 * The visibility state of a [TMap]{@link TMap} panel, either {@link tf.consts.strShowPanel} or {@link tf.consts.strHidePanel}
 * @public
 * @typedef {tf.types.mapPanelVisibilityState} tf.types.mapPanelVisibilityState
 */
/**
 * URL to the TerraFly routing service
 * @public
 */
tf.consts.RoutingServiceURL = "http://131.94.133.147:5000/";
/**
 * Mode used by the TerraFly routing service
 * @public
 */
tf.consts.routingServiceModeFoot = "foot";
/**
 * Mode used by the TerraFly routing service
 * @public
 */
tf.consts.routingServiceModeCar = "car";
/**
 * Mode used by the TerraFly routing service
 * @public
 */
tf.consts.routingServiceModeBicycle = "bicycle";
/**
 * A mode string with the TerraFly routing service, one of:<br>
 * {@link tf.consts.routingServiceModeFoot},<br>
 * {@link tf.consts.routingServiceModeBicycle},<br>
 * or {@link tf.consts.routingServiceModeCar}
 * @public
 * @typedef {string} tf.types.routingServiceMode
 */
tf.consts.worldGeodeticSystemStr = "EPSG:4326";
tf.consts.sphericalMercatorSystemStr = "EPSG:3857";
tf.consts.UTMSystemStr = "EPSG:3006";
tf.consts.olSystem = tf.consts.sphericalMercatorSystemStr;
tf.consts.tmSystem = tf.consts.worldGeodeticSystemStr;
tf.consts.downloadSystem = tf.consts.UTMSystemStr;
/**
 * Reserved prefix used by the API for [SVG Glyph Specifications]{@link tf.types.SVGGlyphSpecs} provided by the API's {@link singleton} [SVG Glyph Library]{@link tf.styles.SvgGlyphLib} 
 * @public
 */
tf.consts.SVGGlyphPrefix = "-tf-svgglyph-";
/**
 * Reserved prefix used by the API for known object properties of value <b>"-tf-prop-"</b>. Applications using the API should not name public object properties using with this prefix
 * @public
 */
tf.consts.KnownPropertyPrefix = "-tf-prop-";
/**
 * The reserved and default property name for [DLayer]{@link tf.urlapi.DLayer} instances
 * @public
 */
tf.consts.DLayerProperty = tf.consts.KnownPropertyPrefix + "dlayer";
/**
 * The reserved and default property name for [Table Row]{@link tf.ui.TableRow} instances
 * @public
 */
tf.consts.TableRowProperty = tf.consts.KnownPropertyPrefix + "tablerow";
/**
 * The reserved and default property name for [Keyed Feature]{@link tf.map.KeyedFeature} instances
 * @public
 */
tf.consts.KeyedFeatureProperty = tf.consts.KnownPropertyPrefix + "keyedfeature";
/**
 * The name of a known TerraFly API property, one of:<br>
 * {@link tf.consts.DLayerProperty},<br>
 * {@link tf.consts.TableRowProperty},<br>
 * or {@link tf.consts.KeyedFeatureProperty}
 * @public
 * @typedef {tf.types.KnownAPIPropertyName} tf.types.KnownAPIPropertyName
 * @see [Known Property Prefix]{@link tf.consts.KnownPropertyPrefix}
 */
tf.consts.DOMEventNames = {};
/**
 * @public
 * @description DOM "ended" event
*/
tf.consts.DOMEventNamesEnded = "ended";
/**
 * @public
 * @description DOM "timeupdate" event
*/
tf.consts.DOMEventNamesTimeUpdate = "timeupdate";
/**
 * @public
 * @description DOM "loadmetadata" event
*/
tf.consts.DOMEventNamesLoadMetaData = "loadmetadata";
/**
 * @public
 * @description DOM "click" event
*/
tf.consts.DOMEventNamesClick = "click";
/**
 * @public
 * @description DOM "losefocus" event
*/
tf.consts.DOMEventNamesLoseFocus = "losefocus";
/**
 * @public
 * @description DOM "resize" event
*/
tf.consts.DOMEventNamesResize = "resize";
/**
 * @public
 * @description DOM "keypress" event
*/
tf.consts.DOMEventNamesKeyPress = "keypress";
/**
 * @public
 * @description DOM "keyup" event
*/
tf.consts.DOMEventNamesKeyUp = "keyup";
/**
 * @public
 * @description DOM "mousemove" event
*/
tf.consts.DOMEventNamesMouseMove = "mousemove";
/**
 * @public
 * @description DOM "mouseup" event
*/
tf.consts.DOMEventNamesMouseUp = "mouseup";
/**
 * @public
 * @description DOM "mousedown" event
*/
tf.consts.DOMEventNamesMouseDown = "mousedown";
/**
 * @public
 * @description DOM "mouseover" event
*/
tf.consts.DOMEventNamesMouseOver = "mouseover";
/**
 * @public
 * @description DOM "mouseout" event
*/
tf.consts.DOMEventNamesMouseOut = "mouseout";
/**
 * @public
 * @description DOM "mouseenter" event
*/
tf.consts.DOMEventNamesMouseEnter = "mouseenter";
/**
 * @public
 * @description DOM "mouseleave" event
*/
tf.consts.DOMEventNamesMouseLeave = "mouseleave";
/**
 * @public
 * @description DOM "touchstart" event
*/
tf.consts.DOMEventNamesTouchStart = "touchstart";
/**
 * @public
 * @description DOM "touchmove" event
*/
tf.consts.DOMEventNamesTouchMove = "touchmove";
/**
 * @public
 * @description DOM "touchend" event
*/
tf.consts.DOMEventNamesTouchEnd = "touchend";
/**
 * @public
 * @description DOM "touchenter" event
*/
tf.consts.DOMEventNamesTouchEnter = "touchenter";
/**
 * @public
 * @description DOM "touchleave" event
*/
tf.consts.DOMEventNamesTouchLeave = "touchleave";
/**
 * @public
 * @description DOM "touchcancel" event
*/
tf.consts.DOMEventNamesTouchCancel = "touchcancel";
/**
 * The name of a DOM event, one of:<br>
 * {@link tf.consts.DOMEventNamesEnded},<br>
 * {@link tf.consts.DOMEventNamesTimeUpdate},<br>
 * {@link tf.consts.DOMEventNamesLoadMetaData},<br>
 * {@link tf.consts.DOMEventNamesClick},<br>
 * {@link tf.consts.DOMEventNamesLoseFocus},<br>
 * {@link tf.consts.DOMEventNamesResize},<br>
 * {@link tf.consts.DOMEventNamesKeyPress},<br>
 * {@link tf.consts.DOMEventNamesKeyUp},<br>
 * {@link tf.consts.DOMEventNamesMouseMove},<br>
 * {@link tf.consts.DOMEventNamesMouseUp},<br>
 * {@link tf.consts.DOMEventNamesMouseDown},<br>
 * {@link tf.consts.DOMEventNamesMouseOver},<br>
 * {@link tf.consts.DOMEventNamesMouseOut},<br>
 * {@link tf.consts.DOMEventNamesMouseEnter},<br>
 * {@link tf.consts.DOMEventNamesMouseLeave},<br>
 * {@link tf.consts.DOMEventNamesTouchStart},<br>
 * {@link tf.consts.DOMEventNamesTouchMove},<br>
 * {@link tf.consts.DOMEventNamesTouchEnd},<br>
 * {@link tf.consts.DOMEventNamesTouchEnter},<br>
 * {@link tf.consts.DOMEventNamesTouchLeave},<br>
 * {@link tf.consts.DOMEventNamesTouchCancel},<br>
 * or another {@link string} known to be a DOM event name.
 * @public
 * @typedef {tf.types.DOMEventName} tf.types.DOMEventName
 */
/**
 * The name of a mouse related DOM event, one of:<br>
 * {@link tf.consts.DOMEventNamesMouseMove},<br>
 * {@link tf.consts.DOMEventNamesMouseUp},<br>
 * {@link tf.consts.DOMEventNamesMouseDown},<br>
 * {@link tf.consts.DOMEventNamesMouseOver},<br>
 * {@link tf.consts.DOMEventNamesMouseOut},<br>
 * {@link tf.consts.DOMEventNamesMouseEnter},<br>
 * {@link tf.consts.DOMEventNamesMouseLeave},<br>
 * {@link tf.consts.DOMEventNamesTouchStart},<br>
 * {@link tf.consts.DOMEventNamesTouchMove},<br>
 * {@link tf.consts.DOMEventNamesTouchEnd},<br>
 * {@link tf.consts.DOMEventNamesTouchEnter},<br>
 * {@link tf.consts.DOMEventNamesTouchLeave},<br>
 * or {@link tf.consts.DOMEventNamesTouchCancel}
 * @public
 * @typedef {tf.types.DOMMouseEventName} tf.types.DOMMouseEventName
 */
tf.consts.allMouseEventNames = [
 tf.consts.DOMEventNamesMouseMove,
 tf.consts.DOMEventNamesMouseUp,
 tf.consts.DOMEventNamesMouseDown,
 tf.consts.DOMEventNamesMouseOver,
 tf.consts.DOMEventNamesMouseOut,
 tf.consts.DOMEventNamesMouseEnter,
 tf.consts.DOMEventNamesMouseLeave,
 tf.consts.DOMEventNamesTouchStart,
 tf.consts.DOMEventNamesTouchMove,
 tf.consts.DOMEventNamesTouchEnd,
 tf.consts.DOMEventNamesTouchEnter,
 tf.consts.DOMEventNamesTouchLeave,
 tf.consts.DOMEventNamesTouchCancel
];
tf.consts.DOMEventNameswebkitfullscreenchange = "webkitfullscreenchange";
tf.consts.DOMEventNamesmozfullscreenchange = "mozfullscreenchange";
tf.consts.DOMEventNamesfullscreenchange = "fullscreenchange";
tf.consts.DOMEventNamesMSFullscreenChange = "MSFullscreenChange";
tf.consts.allFullScreenEventNames = [
    tf.consts.DOMEventNameswebkitfullscreenchange,
    tf.consts.DOMEventNamesmozfullscreenchange,
    tf.consts.DOMEventNamesfullscreenchange,
    tf.consts.DOMEventNamesMSFullscreenChange
];
/**
 * @public
 * @description {@link tf.js.KeyedList} list deleted event
*/
tf.consts.keyedListDeleteEvent = "listDelete";
/**
 * @public
 * @description {@link tf.js.KeyedList} items added event
*/
tf.consts.keyedListAddedItemsEvent = "listAddedItems";
/**
 * @public
 * @description {@link tf.js.KeyedList} items updated event
*/
tf.consts.keyedListUpdatedItemsEvent = "listUpdatedItems";
/**
 * @public
 * @description {@link tf.js.KeyedList} items deleted event
*/
tf.consts.keyedListDeletedItemsEvent = "listDeletedItems";
tf.consts.allKeyedListEventNames = [
    tf.consts.keyedListDeleteEvent,
    tf.consts.keyedListAddedItemsEvent,
    tf.consts.keyedListUpdatedItemsEvent,
    tf.consts.keyedListDeletedItemsEvent
];
/**
 * The name of a [Keyed List]{@link tf.js.KeyedList} event, one of:<br>
 * {@link tf.consts.keyedListDeleteEvent},<br>
 * {@link tf.consts.keyedListAddedItemsEvent},<br>
 * {@link tf.consts.keyedListUpdatedItemsEvent},<br>
 * or {@link tf.consts.keyedListDeletedItemsEvent}
 * @public
 * @typedef {tf.types.keyedListEventName} tf.types.keyedListEventName
 */
/**
 * @public
 * @description {@link tf.map.FeatureList} features added event
*/
tf.consts.keyedFeaturesAddedEvent = "featuresAdded";
/**
 * @public
 * @description {@link tf.map.FeatureList} features updated event
*/
tf.consts.keyedFeaturesUpdatedEvent = "featuresUpdated";
/**
 * @public
 * @description {@link tf.map.FeatureList} features deleted event
*/
tf.consts.keyedFeaturesDeletedEvent = "featuresDeleted";
tf.consts.allKeyedFeaturesEventNames = [
    tf.consts.keyedFeaturesAddedEvent,
    tf.consts.keyedFeaturesUpdatedEvent,
    tf.consts.keyedFeaturesDeletedEvent
];
/**
 * The name of a [Keyed Feature List]{@link tf.map.KeyedFeatureList} event, one of:<br>
 * {@link tf.consts.keyedFeaturesAddedEvent},<br>
 * {@link tf.consts.keyedFeaturesUpdatedEvent},<br>
 * or {@link tf.consts.keyedFeaturesDeletedEvent}
 * @public
 * @typedef {tf.types.keyedFeatureListEventName} tf.types.keyedFeatureListEventName
 */
/**
 * @public
 * @description {@link tf.ui.KeyedTable} rows added event
*/
tf.consts.keyedTableRowsAddedEvent = "keyedTableRowsAdded";
/**
 * @public
 * @description {@link tf.ui.KeyedTable} rows updated event
*/
tf.consts.keyedTableRowsUpdatedEvent = "keyedTableRowsUpdated";
/**
 * @public
 * @description {@link tf.ui.KeyedTable} rows deleted event
*/
tf.consts.keyedTableRowsDeletedEvent = "keyedTableRowsDeleted";
tf.consts.keyedTableRowsEventNames = [
    tf.consts.keyedTableRowsAddedEvent,
    tf.consts.keyedTableRowsUpdatedEvent,
    tf.consts.keyedTableRowsDeletedEvent
];
/**
 * The name of a [Keyed Table]{@link tf.ui.KeyedTable} event, one of:<br>
 * {@link tf.consts.keyedRowTableRowsAddedEvent},<br>
 * {@link tf.consts.keyedRowTableRowsUpdatedEvent},<br>
 * or {@link tf.consts.keyedRowTableRowsDeletedEvent}
 * @public
 * @typedef {tf.types.keyedFeatureListEventName} tf.types.keyedFeatureListEventName
 */
/**
 * @public
 * @description {@link tf.map.FeatureLayer} visibility change event
*/
tf.consts.mapFeatureLayerVisibilityChangeEvent = "visibilityChange";
tf.consts.allMapFeatureLayerEventNames = [
    tf.consts.mapFeatureLayerVisibilityChangeEvent
];
/**
 * The name of a {@link tf.map.FeatureLayer} event, one of:<br>
 * {@link tf.consts.mapFeatureLayerVisibilityChangeEvent}
 * @public
 * @typedef {tf.types.mapFeatureLayerEventName} tf.types.mapFeatureLayerEventName
 */
/**
 * @public
 * @description {@link tf.map.Map} move end event
*/
tf.consts.mapMoveEndEvent = "moveEnd";
/**
 * @public
 * @description {@link tf.map.Map} map container resized event
*/
tf.consts.mapResizedEvent = "resized";
/**
 * @public
 * @description {@link tf.map.Map} mouse move event
*/
tf.consts.mapMouseMoveEvent = "mouseMove";
/**
 * @public
 * @description {@link tf.map.Map} mouse click event
*/
tf.consts.mapClickEvent = "click";
/**
 * @public
 * @description {@link tf.map.Map} mouse double click event
*/
tf.consts.mapDblClickEvent = "dblClick";
/**
 * @public
 * @description {@link tf.map.Map} mouse click on map feature event
*/
tf.consts.mapFeatureClickEvent = "featureClick";
/**
 * @public
 * @description {@link tf.map.Map} mouse double click on map feature event
*/
tf.consts.mapFeatureDblClickEvent = "featureDblClick";
/**
 * @public
 * @description {@link tf.map.Map} mouse move on map feature event
*/
tf.consts.mapFeatureMouseMoveEvent = "featureMouseMove";
/**
 * @public
 * @description {@link tf.map.Map} mouse hover in our out of map feature event
*/
tf.consts.mapFeatureHoverInOutEvent = "featureHoverInOut";
/**
 * @public
 * @description {@link tf.map.Map} map mode change event
*/
tf.consts.mapTypeChangeEvent = "modeChange";
/**
 * @public
 * @description {@link tf.map.Map} map level change event
*/
tf.consts.mapLevelChangeEvent = "levelChange";
/**
 * @public
 * @description {@link tf.map.Map} map resolution change event
*/
tf.consts.mapResolutionChangeEvent = "resolutionChange";
/**
 * @public
 * @description {@link tf.map.Map} map switch to/from fullscreen event
*/
tf.consts.mapFullScreenEvent = "fullScreen";
/**
 * @public
 * @description {@link tf.map.Map} map postcompose event
*/
tf.consts.mapPostComposeEvent = "postCompose";
/**
 * @public
 * @description {@link tf.map.Map} map precompose event
*/
tf.consts.mapPreComposeEvent = "preCompose";
/**
 * @public
 * @description {@link tf.map.Map} map postrender event
*/
tf.consts.mapPostRenderEvent = "postRender";
/**
 * @public
 * @description {@link tf.map.Map} map view settings changed event
*/
tf.consts.mapViewSettingsChangedEvent = "viewsettingschanged";
tf.consts.allMapEventNames = [
    tf.consts.mapMoveEndEvent,
    tf.consts.mapResizedEvent,
    tf.consts.mapMouseMoveEvent,
    tf.consts.mapClickEvent,
    tf.consts.mapDblClickEvent,
    tf.consts.mapFeatureClickEvent,
    tf.consts.mapFeatureDblClickEvent,
    tf.consts.mapFeatureMouseMoveEvent,
    tf.consts.mapFeatureHoverInOutEvent,
    tf.consts.mapTypeChangeEvent,
    tf.consts.mapLevelChangeEvent,
    tf.consts.mapResolutionChangeEvent,
    tf.consts.mapFullScreenEvent,
    tf.consts.mapPostComposeEvent,
    tf.consts.mapPreComposeEvent,
    tf.consts.mapPostRenderEvent,
    tf.consts.mapViewSettingsChangedEvent
];
/**
 * The name of a [Map]{@link tf.map.Map} event, one of:<br>
 * {@link tf.consts.mapMoveEndEvent},<br>
 * {@link tf.consts.mapResizedEvent},<br>
 * {@link tf.consts.mapMouseMoveEvent},<br>
 * {@link tf.consts.mapClickEvent},<br>
 * {@link tf.consts.mapDblClickEvent},<br>
 * {@link tf.consts.mapFeatureClickEvent},<br>
 * {@link tf.consts.mapFeatureDblClickEvent},<br>
 * {@link tf.consts.mapFeatureMouseMoveEvent},<br>
 * {@link tf.consts.mapFeatureHoverInOutEvent},<br>
 * {@link tf.consts.mapTypeChangeEvent},<br>
 * {@link tf.consts.mapLevelChangeEvent},<br>
 * {@link tf.consts.mapResolutionChangeEvent},<br>
 * {@link tf.consts.mapFullScreenEvent},<br>
 * {@link tf.consts.mapPreComposeEvent},<br>
 * {@link tf.consts.mapPostComposeEvent},<br>
 * {@link tf.consts.mapPostRenderEvent},<br>
 * or {@link tf.consts.mapViewSettingsChangedEvent}
 * @public
 * @typedef {tf.types.mapEventName} tf.types.mapEventName
 */
/**
 * @public
 * @description positioning specification
*/
tf.consts.positioningCenter = 'center';
/**
 * @public
 * @description positioning specification
*/
tf.consts.positioningLeft = 'left';
/**
 * @public
 * @description positioning specification
*/
tf.consts.positioningRight = 'right';
/**
 * @public
 * @description positioning specification
*/
tf.consts.positioningTop = 'top';
/**
 * @public
 * @description positioning specification
*/
tf.consts.positioningBottom = 'bottom';
/**
 * The name of a horizontal positioning, one of:<br>
 * {@link tf.consts.positioningCenter},<br>
 * {@link tf.consts.positioningLeft},<br>
 * or {@link tf.consts.positioningRight}
 * @public
 * @typedef {tf.types.horizontalPositioning} tf.types.horizontalPositioning
 */
/**
 * The name of a vertical positioning, one of:<br>
 * {@link tf.consts.positioningCenter},<br>
 * {@link tf.consts.positioningTop},<br>
 * or {@link tf.consts.positioningBottom}
 * @public
 * @typedef {tf.types.verticalPositioning} tf.types.verticalPositioning
 */
/**
 * @public
 * @description the default style name used by instances of [Map Feature With Named Styles]{@link tf.map.FeatureWithNamedStyles}
*/
tf.consts.defaultMapFeatureStyleName = "defaultMapFeatureStyleName";
/**
 * @public
 * @description the default duration, in milliseconds, used in [AnimatedSetLevel]{@link tf.map.Map#AnimatedSetLevel}
*/
tf.consts.defaultMapAnimatedDurationPerLevelMillis = 400;
/**
 * @public
 * @description the default duration, in milliseconds, used in [AnimatedSetCenter]{@link tf.map.Map#AnimatedSetLevel}
*/
tf.consts.defaultMapAnimatedCenterDurationMillis = 300;
// tf.platform
tf.platform.TestURL = "http://experiment2.cs.fiu.edu/hterramap/test/";
tf.platform.StageURL = "http://experiment2.cs.fiu.edu/hterramap/stage/";
tf.platform.ProdURL = "http://tfcore.cs.fiu.edu/hterramap/";
tf.platform.LocalURL = "http://localhost/terramap/";
tf.platform.isKnown = false;
/**
 * @public
 * @function
 * @summary - Retrieves the URL of this platform of the <b>TerraFly API</b>
* @returns {string} - | {@link string} the URL string
*/
tf.platform.GetURL = function () {
    function getURLOfScript (scriptFileName) {
        var scriptURL;
        if (typeof scriptFileName === "string") {
            var scriptElements = document.getElementsByTagName('script');
            var i, element;
            for (i = 0; element = scriptElements[i]; ++i) {
                var myfile = element.src, index = myfile.indexOf(scriptFileName);
                if (index >= 0) { scriptURL = myfile.substring(0, index); break; }
            }
        }
        return scriptURL;
    }
    function findURL() {
        var url = getURLOfScript("mapapi.js");
        if (url !== undefined) {
            if (tf.platform.isKnown = (url.indexOf('test') >= 0)) { url = tf.platform.TestURL; }
            else if (tf.platform.isKnown = (url.indexOf('stage') >= 0)) { url = tf.platform.StageURL; }
            else if (tf.platform.isKnown = (url.indexOf('tfcore') >= 0)) { url = tf.platform.ProdURL; }
        }
        if (!tf.platform.isKnown) { url = '';/*url = tf.platform.TestURL;*/ tf.platform.isKnown = false; }
        return url;
    }
    if (tf.platform.PlatformURL == undefined) {
        tf.platform.PlatformURL = findURL();
    }
    return tf.platform.PlatformURL;
}
/**
 * @public
 * @function
 * @summary - Checks if this is a known platform of the <b>TerraFly API</b>
* @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.platform.GetIsKnown = function () { tf.platform.GetURL(); return tf.platform.isKnown; }
/**
 * @public
 * @function
 * @summary - Checks if this is the Test platform of the <b>TerraFly API</b>
* @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.platform.GetIsTest = function () { return tf.platform.GetURL() == tf.platform.TestURL || !tf.platform.isKnown; }
/**
 * @public
 * @function
 * @summary - Checks if this is the Stage platform of the <b>TerraFly API</b>
* @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.platform.GetIsStage = function () { return tf.platform.GetURL() == tf.platform.StageURL; }
/**
 * @public
 * @function
 * @summary - Checks if this is the Production platform of the <b>TerraFly API</b>
* @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.platform.GetIsProduction = function () { return tf.platform.GetURL() == tf.platform.ProdURL; }
// DOMParser support for browsers that may lack it, slightly adapted from https://developer.mozilla.org/en-US/docs/Web/API/DOMParser
(function (DOMParser) {
    var proto = DOMParser.prototype, nativeParse = proto.parseFromString;
    // Firefox/Opera/IE throw errors on unsupported types
    try {
        // WebKit returns null on unsupported types
        if ((new DOMParser()).parseFromString("", "text/html")) {
            // text/html parsing is natively supported
            return;
        }
    } catch (ex) { }
    proto.parseFromString = function (markup, type) {
        if (/^\s*text\/html\s*(?:;|$)/i.test(type)) {
            var doc = document.implementation.createHTMLDocument("");
            if (markup.toLowerCase().indexOf('<!doctype') > -1) { doc.documentElement.innerHTML = markup; }
            else { doc.body.innerHTML = markup; }
            return doc;
        } else { return nativeParse.apply(this, arguments); }
    };
}(DOMParser));
/*if (!String.prototype.trim) {
    Object.defineProperty(String.prototype, 'trim', {
        value: function () { return this.replace(/^\s+|\s+$/g, ''); },
        writable: false, enumerable: false, configurable: false
    });
}*/
/**
 * @public
 * @function
 * @summary - Retrieves the {@link tf.events.DocMouseListener} singleton
 * @returns {tf.events.DocMouseListener} - | {@link tf.events.DocMouseListener} the singleton
*/
tf.GetDocMouseListener = function () { if (!tf.g_DocMouseListener) { tf.g_DocMouseListener = new tf.events.DocMouseListener(); } return tf.g_DocMouseListener; }
/**
 * @public
 * @function
 * @summary - Retrieves the {@link tf.styles.Styles} singleton
 * @param {tf.types.APIStyleSpecs} alternativeSpecs - overrides the default API style specifications, if defined the first time an application calls this function
 * @returns {tf.styles.Styles} - | {@link tf.styles.Styles} the singleton
*/
tf.GetStyles = function (alternativeSpecs) { if (!tf.g_Styles) { tf.g_Styles = new tf.styles.Styles(alternativeSpecs); } return tf.g_Styles; }
/**
 * @public
 * @function
 * @summary - Retrieves the {@link tf.js.Counter} singleton
 * @returns {tf.js.Counter} - | {@link tf.js.Counter} the singleton
*/
tf.GetGlobalCounter = function () { if (!tf.g_Counter) { tf.g_Counter = new tf.js.Counter(); } return tf.g_Counter; }
/**
 * @public
 * @function
 * @summary - Retrieves the {@link tf.Debug} singleton
 * @returns {tf.Debug} - | {@link tf.Debug} the singleton
*/
tf.GetDebug = function () { if (!tf.g_Debug) { tf.g_Debug = new tf.Debug(); } return tf.g_Debug; }
/**
 * @public
 * @function
 * @summary - Retrieves a JavaScript {@link object} from an XML node, such as one in httpRequest.responseXML.documentElement
 * @param {object} XMLNode - the given XML node
 * @returns {object} - | {@link object} the object
*/
tf.helpers.XML2Object = function (XMLNode) {
    var dataObj = {};
    function Add(name, value) {
        if (dataObj[name]) { if (!tf.js.GetIsArray(dataObj[name])) { dataObj[name] = [dataObj[name]]; } dataObj[name][dataObj[name].length] = value; }
        else { dataObj[name] = value; }
    };
    if (tf.js.GetIsValidObject(XMLNode) && tf.js.GetIsValidObject(XMLNode.attributes) && tf.js.GetIsValidObject(XMLNode.childNodes)) {
        var c, cn;
        for (c = 0; cn = XMLNode.attributes[c]; ++c) { Add(cn.name, cn.value); }
        for (c = 0; cn = XMLNode.childNodes[c]; ++c) {
            if (cn.nodeType == 1) {
                if (cn.childNodes.length == 1 && cn.firstChild.nodeType == 3) { Add(cn.nodeName, cn.firstChild.nodeValue); }
                else { Add(cn.nodeName, tf.helpers.XML2Object(cn)); }
            }
        }
    }
    return dataObj;
};
/**
 * @public
 * @function
 * @summary - Retrieves a JavaScript {@link object} from an XML string
 * @param {string} XMLString - the given XML string
 * @returns {object} - | {@link object} the object
*/
tf.helpers.XMLString2Object = function (XMLString) {
    var dataObj = {};
    if (tf.js.GetIsNonEmptyString(XMLString)) {
        var doc = new DOMParser().parseFromString(XMLString, "application/xml");
        if (tf.js.GetIsValidObject(doc) && tf.js.GetIsValidObject(doc.documentElement)) {
            dataObj = tf.helpers.XML2Object(doc.documentElement);
        }
    }
    return dataObj;
};
/**
 * Object returned by {@link tf.helpers.HitTestMapCoordinatesArray}
 * @public
 * @typedef {object} tf.types.HitTestCoordinatesArrayResult
 * @property {number} minDistance - the minimum distance
 * @property {number} minDistanceIndex - the index of the array containing the initial coordinates of the segment where the minimum distance was found
 */
/**
 * @public
 * @function
 * @summary - Calculates the minimum distance between given map coordinates and a given segment defined by an array of map coordinates
 * @param {array<tf.types.mapCoordinates>} mapCoordinatesArray - the array of map coordinates defining a segment
 * @param {tf.types.mapCoordinates} coordinates - the given coordinates
 * @returns {tf.types.HitTestCoordinatesArrayResult} - | {@link tf.types.HitTestCoordinatesArrayResult} the result
*/
tf.helpers.HitTestMapCoordinatesArray = function (mapCoordinatesArray, coordinates) {
    var minDistance = -1;
    var minDistanceIndex = -1;
    if (tf.js.GetIsArrayWithMinLength(mapCoordinatesArray, 1) && tf.js.GetIsArrayWithMinLength(mapCoordinatesArray[0], 2) && tf.js.GetIsArrayWithMinLength(coordinates, 2)) {
        var length = mapCoordinatesArray.length;
        var prevEnd = mapCoordinatesArray[0];
        var time = 0, ptLon = coordinates[0], ptLat = coordinates[1];
        for (var i = 1 ; i < length ; ++i) {
            var start = prevEnd, end = mapCoordinatesArray[i];
            var thisDistance = 0, latPtToStart = ptLat - end[1], lonPtToStart = ptLon - end[0];
            if (end[1] == end[1] && end[0] == end[0]) { thisDistance = (latPtToStart * latPtToStart + lonPtToStart * lonPtToStart); }
            else {
                var latEndToStart = end[1] - end[1], lonEndToStart = end[0] - end[0];
                var distEndStartSq = Math.sqrt(latEndToStart * latEndToStart + lonEndToStart * lonEndToStart);
                var latPtToEnd = ptLat - end[1], lonPtToEnd = ptLon - end[0];
                var proj = (lonPtToStart * lonEndToStart + latPtToStart * latEndToStart) / distEndStartSq;
                if (proj < 0) { thisDistance = (latPtToStart * latPtToStart + lonPtToStart * lonPtToStart); }
                else if (proj > 1) { thisDistance = (latPtToEnd * latPtToEnd + lonPtToEnd * lonPtToEnd); }
                else {
                    var segPtLat = end[1] + latEndToStart * proj;
                    var segPtLon = end[0] + lonEndToStart * proj;
                    var segPtToPtLat = segPtLat - ptLat, segPtToPtLon = segPtLon - ptLon;
                    thisDistance = (segPtToPtLat * segPtToPtLat + segPtToPtLon * segPtToPtLon);
                }
            }
            if (minDistance < 0 || thisDistance < minDistance) { minDistance = thisDistance; minDistanceIndex = i - 1; }
            prevEnd = end;
        }
    }
    return { minDistance: minDistance, minDistanceIndex: minDistanceIndex };
};
/**
 * @public
 * @function
 * @summary - Calculates the average coordinates of a given array of map coordinates
 * @param {array<tf.types.mapCoordinates>} mapCoordinatesArray - the array of map coordinates
 * @param {boolean} skipLastCoordBool - if <b>true</b> the last coordinate in the array is not included in the average
 * @returns {tf.types.mapCoordinates} - | {@link tf.types.mapCoordinates} the average coordinates
*/
tf.helpers.CalcAverageCoordinates = function (coordsArray, skipLastCoordBool) {
    var avg = [0, 0];
    if (tf.js.GetIsNonEmptyArray(coordsArray) && tf.js.GetIsArrayWithLength(coordsArray[0], 2)) {
        var nCoords = 0;
        var length = coordsArray.length;
        skipLastCoordBool = !!skipLastCoordBool;
        for (var i in coordsArray) {
            var coords = coordsArray[i];
            if (!!coords) {
                if (coords.length == 2) {
                    avg[0] += coords[0];
                    avg[1] += coords[1];
                    nCoords++;
                }
                else { break; }
            }
            else { break; }
            if (skipLastCoordBool && i == length - 2) { break; }
        }
        if (nCoords) { avg[0] /= nCoords; avg[1] /= nCoords; }
    }
    return avg;
}
// tf.dom
tf.dom.SetDisplayStyle = function (elem, verb) {
    if (elem = tf.dom.GetHTMLElementFrom(elem)) { elem.style.display = verb; }
}
tf.dom.ToggleDisplayStyle = function(elem, verb1, verb2) {
    if (elem = tf.dom.GetHTMLElementFrom(elem)) { elem.style.display = elem.style.display == verb1 ? verb2 : verb1; }
}
tf.dom.ToggleDisplayBlockNone = function (elem) { return tf.dom.ToggleDisplayStyle(elem, 'block', 'none'); }
tf.dom.SetDisplayBlockNone = function (elem, bool) { return tf.dom.SetDisplayStyle(elem, !!bool? 'block' : 'none'); }
/**
 * @public
 * @function
 * @summary - Inserts an HTML <b>'script'</b> into the Documents head
 * @param {string} scriptSrc - the source url of the script
 * @returns {void} - | {@link void} no return value
*/
tf.dom.AddScript = function (scriptSrc) {
    if (tf.js.GetIsNonEmptyString(scriptSrc)) {
        var script = document.createElement('script'); script.type = "text/javascript"; script.src = scriptSrc; document.head.appendChild(script);
    }
}
/**
 * @public
 * @function
 * @summary - Inserts an HTML <b>'link'</b> into the Documents head
 * @param {string} hRef - the href url of the link
 * @param {string} rel - the rel attribute of the link
 * @param {string} type - the type attribute of the link
 * @param {function} callBack - if defined, called when the link finishes loading
 * @returns {void} - | {@link void} no return value
*/
tf.dom.AddLink = function (hRef, rel, type, callBack) {
    if (tf.js.GetIsNonEmptyString(hRef)) {
        var link = document.createElement('link');
        if (tf.js.GetFunctionOrNull(callBack)) { link.onload = callBack; }
        link.href = hRef;
        if (tf.js.GetIsNonEmptyString(rel)) { link.rel = rel; }
        if (tf.js.GetIsNonEmptyString(type)) { link.type = type; }
        document.head.appendChild(link);
    }
}
/**
 * @public
 * @function
 * @summary - Inserts an HTML <b>'link'</b> into the Documents head to a google font from font.googleapis.com
 * @param {string} fontSpecs - specification of the fonts to retrieve, example: "Cantarell|Tangerine:bold,bolditalic|Inconsolata:italic|Droid+Sans"
 * @param {function} callBack - if defined, called when the font is ready for use
 * @returns {void} - | {@link void} no return value
*/
tf.dom.AddGoogleFont = function (fontSpecs, callBack) {
    if (tf.js.GetIsNonEmptyString(fontSpecs)) { tf.dom.AddLink("http://fonts.googleapis.com/css?family=" + fontSpecs, "stylesheet", "text/css", callBack); }
}
/**
 * @public
 * @function
 * @summary - Calculates the current pixel dimensions of the Browser's window
 * @returns {tf.types.pixelCoordinates} - | {@link tf.types.pixelCoordinates} the dimensions
*/
tf.dom.GetWindowDims = function () {
    var w = window, d = document, e = d.documentElement, g = d.getElementsByTagName('body')[0];
    var winW = w.innerWidth || e.clientWidth || g.clientWidth, winH = w.innerHeight || e.clientHeight || g.clientHeight;
    return [winW - 1, winH - 1];
}
/**
 * @public
 * @function
 * @summary - Calculates the current pixel dimensions of the Browser's window and resizes the given container to the calculated dimensions
 * @param {HTMLElementLike} container - the container to be resized
 * @returns {tf.types.pixelCoordinates} - | {@link tf.types.pixelCoordinates} the dimensions
*/
tf.dom.FitContainerToWindowDims = function (container) {
    var winDims = tf.dom.GetWindowDims();
    var containerUse = tf.dom.GetHTMLElementFrom(container);
    if (!!containerUse) {
        var containerStyle = containerUse.style;
        containerStyle.width = containerStyle.maxWidth = winDims[0] + "px";
        containerStyle.height = containerStyle.maxHeight = winDims[1] + "px";
    }
    return winDims;
}
/**
 * @public
 * @function
 * @summary - Determines if the given parameter is an {@link HTMLNode}
 * @param {object} node - the node candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if node is an {@link HTMLNode}, <b>false</b> otherwise
*/
tf.dom.GetIsHTMLNode = function (node) {
    return (
      typeof Node === "object" ? node instanceof Node :
      node && typeof node === "object" && typeof node.nodeType === "number" && typeof node.nodeName === "string"
    );
}
/**
 * @public
 * @function
 * @summary - Determines if the given parameter is an {@link HTMLElement}
 * @param {object} node - the element candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if node is an {@link HTMLElement}, <b>false</b> otherwise
*/
tf.dom.GetIsHTMLElement = function (element) {
    return tf.js.GetIsValidObject(element) && element.nodeType === 1 && typeof element.nodeName === "string";
    /*return (
      typeof HTMLElement === "object" ? element instanceof HTMLElement : //DOM2
      element && typeof element === "object" && element !== null && element.nodeType === 1 && typeof element.nodeName === "string"
  );*/
}
/**
 * @public
 * @function
 * @summary - Retrieves the {@link HTMLElement associated with the given object, if any
 * @param {object} element - the object from which to retrive an HTMLElement
 * @returns {HTMLElement} - | {@link HTMLElement} the retrieved {@link HTMLElement}, or {@link void}
*/
tf.dom.GetHTMLElementFrom = function (element) {
    if (!!element) {
        if (!tf.dom.GetIsHTMLElement(element)) {
            if (tf.js.GetIsNonEmptyString(element)) { element = document.getElementById(element); }
            else if (tf.js.GetIsValidObject(element) && tf.js.GetFunctionOrNull(element.GetHTMLElement)) { element = element.GetHTMLElement(); }
            else { element = null; }
        }
    }
    return element;
}
/**
 * @private
 * @function
 * @summary - Retrieves the a DOM event listener target from the given element
 * @param {object} element - the object from which to retrive a DOM event listener target
 * @returns {object} - | {@link object} the retrieved DOM event listener target
*/
tf.dom.GetDOMEventListenerFrom = function (element) {
    if (!!element) {
        if (!tf.dom.GetIsHTMLElement(element)) {
            if (tf.js.GetIsNonEmptyString(element)) { element = document.getElementById(element); }
            else if (tf.js.GetIsValidObject(element) && tf.js.GetFunctionOrNull(element.GetHTMLElement)) { element = element.GetHTMLElement(); }
        }
        if (!tf.js.GetIsValidObject(element)) { element = null; }
    }
    return element;
}
/**
 * @public
 * @function
 * @summary - Checks if the given element contains the given CSS style/class name among its class names
 * @param {HTMLElementLike} elem - the element to check
 * @param {tf.types.CSSStyleName} cssStyleName - the CSS style/class name
 * @returns {boolean} - | {@link boolean} <b>true</b> if the given class name is one of the classes of <b>elem</b>, <b>false</b> otherwise
 * @see [AddCSSClass]{@link tf.dom.AddCSSClass}, [RemoveCSSClass]{@link tf.dom.RemoveCSSClass}, and [ReplaceCSSClass]{@link tf.dom.ReplaceCSSClass}
*/
tf.dom.GetContainsCSSClass = function (elem, cssStyleName) {
    if (elem = tf.dom.GetHTMLElementFrom(elem)) {
        return tf.js.GetNonEmptyString(cssStyleName) && new RegExp('(\\s+|^)' + cssStyleName + '(\\s+|$)').test(elem.className);
    }
    return false;
}
/**
 * @public
 * @function
 * @summary - Adds the given CSS style/class name to the class names associated with the given element
 * @param {HTMLElementLike} elem - the element
 * @param {tf.types.CSSStyleName} cssStyleName - the CSS style/class name
 * @returns {void} - | {@link void} no return value
 * @see [RemoveCSSClass]{@link tf.dom.RemoveCSSClass}, [ReplaceCSSClass]{@link tf.dom.ReplaceCSSClass}, and [GetContainsCSSClass]{@link tf.dom.GetContainsCSSClass}
*/
tf.dom.AddCSSClass = function (elem, cssStyleName) {
    if ((elem = tf.dom.GetHTMLElementFrom(elem)) && (!!cssStyleName)) {
        if (!tf.js.GetIsArray(cssStyleName)) { cssStyleName = cssStyleName.split(' '); }
        for (var i = 0, len = cssStyleName.length; i < len; ++i) {
            if (cssStyleName[i] && !new RegExp('(\\s+|^)' + cssStyleName[i] + '(\\s+|$)').test(elem.className)) {
                elem.className = elem.className.trim() + ' ' + cssStyleName[i];
            }
        }
    }
}
/**
 * @public
 * @function
 * @summary - Removes the given CSS style/class name from the class names associated with the given element
 * @param {HTMLElementLike} elem - the element
 * @param {tf.types.CSSStyleName} cssClassStr - the CSS style/class name
 * @returns {void} - | {@link void} no return value
 * @see [AddCSSClass]{@link tf.dom.AddCSSClass}, [ReplaceCSSClass]{@link tf.dom.ReplaceCSSClass}, and [GetContainsCSSClass]{@link tf.dom.GetContainsCSSClass}
*/
tf.dom.RemoveCSSClass = function (elem, cssStyleName) {
    if ((elem = tf.dom.GetHTMLElementFrom(elem)) && (!!cssStyleName)) {
        if (!tf.js.GetIsArray(cssStyleName)) { cssStyleName = cssStyleName.split(' '); }
        for (var i = 0, len = cssStyleName.length; i < len; ++i) {
            elem.className = elem.className.replace(new RegExp('(\\s+|^)' + cssStyleName[i] + '(\\s+|$)'), ' ').trim();
        }
    }
}
/**
 * @public
 * @function
 * @summary - Replaces a given CSS style/class name with another style/class name among the style/class names associated with the given element
 * @param {HTMLElementLike} elem - the element
 * @param {tf.types.CSSStyleName} cssStyleNameOld - the existing CSS style/class name to be replaced
 * @param {tf.types.CSSStyleName} cssStyleNameNew - the new CSS class style/name to replace <b>cssStyleNameOld</b>
 * @returns {void} - | {@link void} no return value
 * @see [AddCSSClass]{@link tf.dom.AddCSSClass}, [RemoveCSSClass]{@link tf.dom.RemoveCSSClass}, and [GetContainsCSSClass]{@link tf.dom.GetContainsCSSClass}
*/
tf.dom.ReplaceCSSClass = function (elem, cssStyleNameOld, cssStyleNameNew) { tf.dom.RemoveCSSClass(elem, cssStyleNameOld); tf.dom.AddCSSClass(elem, cssStyleNameNew); }
/**
 * @private
 * @function
 * @summary - Adds the given child element to the list of children of the given parent element, uses JavaScript <b>appendChild</b>
 * @param {HTMLElementLike} childElem - the child element
 * @param {HTMLElementLike} parentElem - the parent element
 * @returns {void} - | {@link void} no return value
*/
tf.dom.AppendTo = function (childElem, parentElem) {
    if ((parentElem = tf.dom.GetHTMLElementFrom(parentElem)) && (childElem = tf.dom.GetHTMLElementFrom(childElem))) {
        if (tf.js.GetFunctionOrNull(parentElem.appendChild)) {
            parentElem.appendChild(childElem);
        }
    }
}
/**
 * @private
 * @function
 * @summary - Adds the given child element to the list of children of the given parent element, uses child's <b>AppendTo</b> function, if defined
 * @param {HTMLElementLike} child - the child element
 * @param {HTMLElementLike} parent - the parent element
 * @returns {void} - | {@link void} no return value
*/
tf.dom.AddContent = function (child, parent) {
    if (tf.js.GetIsValidObject(child) && tf.js.GetIsValidObject(parent)) {
        if (tf.js.GetFunctionOrNull(child.AppendTo)) { child.AppendTo(parent); }
        else {
            var childElem = tf.dom.GetHTMLElementFrom(child), parentElem = tf.dom.GetHTMLElementFrom(parent);
            if (!!childElem && !!parentElem) { parentElem.appendChild(childElem); }
        }
    }
}
/**
 * @public
 * @function
 * @summary - Removes all children from the given element
 * @param {HTMLElementLike} elem - the element
 * @returns {void} - | {@link void} no return value
*/
tf.dom.RemoveAllChildren = function (elem) { if (elem = tf.dom.GetHTMLElementFrom(elem)) { var lastChild; while (lastChild = elem.lastChild) { elem.removeChild(lastChild); } } }
/**
 * @public
 * @function
 * @summary - Creates an unique id for {@link HTMLElement} using {@link tf.GetGlobalCounter}
 * @param {string} withPrefix - an application defined prefix for the id
 * @returns {string} - | {@link string} the id
*/
tf.dom.CreateDomElementID = function (withPrefix) { return withPrefix + tf.GetGlobalCounter().GetNext() + ''; }
// tf.js
/**
 * @public
 * @function
 * @summary - Creates an {@link object} containing the combined properties of the given objects
 * @param {...object} object - any number of comma separated objects
 * @returns {object} - | {@link object} the merged object
*/
tf.js.ShallowMerge = function () {
    var merged = {}, nContent = arguments.length;
    for (var i = 0 ; i < nContent ; ++i) {
        var thisContent = arguments[i];
        if (!!thisContent && typeof thisContent === "object") {
            for (var property in thisContent) { if (thisContent.hasOwnProperty(property)) { merged[property] = thisContent[property]; } }
        }
    }
    return merged;
}
/**
 * @public
 * @function
 * @summary - Checks if the given candidate is of type {@link boolean}
 * @param {*} candidate - the candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsBoolean = function (candidate) { return typeof candidate === "boolean"; }
/**
 * @public
 * @function
 * @summary - Checks if the given candidate is a {@link string}
 * @param {*} candidate - the candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsString = function (candidate) { return !!candidate && typeof candidate === "string"; }
/**
 * @public
 * @function
 * @summary - Checks if the given candidate is a {@link string} with at least <b>length</b> characters
 * @param {*} candidate - the candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsStringWithMinLength = function (candidate, length) { return tf.js.GetIsString(candidate) && candidate.length >= length; }
/**
 * @public
 * @function
 * @summary - Checks if the given candidate is a {@link string} with at least one character
 * @param {*} candidate - the candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsNonEmptyString = function (candidate) { return tf.js.GetIsString(candidate) && !!candidate.length; }
/**
 * @public
 * @function
 * @summary - Returns the given object if it is a {@link string} with at least one character, otherwise returns the given default
 * @param {object} fromString - the non empty string candidate
 * @param {string} optionalDefaultString - the default string, can be {@link void}
 * @returns {string} - | {@link string} <b>fromString</b> or <b>optionalDefaultString</b>
*/
tf.js.GetNonEmptyString = function (fromString, optionalDefaultString) { return tf.js.GetIsNonEmptyString(fromString) ? fromString : optionalDefaultString; }
/**
 * @public
 * @function
 * @summary - Checks if the given candidate is an {@link array}
 * @param {*} candidate - the candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsArray = function (candidate) {
    if (!!candidate) {
        if (candidate.constructor === Array) { return true; }
        if (!tf.js.GetIsString(candidate) && candidate.length !== undefined) { return typeof candidate.length == 'number'; }
    }
    return false;
    
}
/**
 * @public
 * @function
 * @summary - Checks if the given candidate is an {@link array} with at least one element
 * @param {*} candidate - the candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsNonEmptyArray = function (candidate) { return tf.js.GetIsArray(candidate) && !!candidate.length; }
/**
 * @public
 * @function
 * @summary - Checks if the given candidate is an {@link array} with a number of elements equal to the given length
 * @param {*} candidate - the candidate
 * @param {number} length - the length
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsArrayWithLength = function (candidate, length) { return tf.js.GetIsArray(candidate) && candidate.length == length; }
/**
 * @public
 * @function
 * @summary - Checks if the given candidate is an {@link array} with a number of elements equal to the given length
 * @param {*} candidate - the candidate
 * @param {number} length - the length
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsArrayWithLength = function (candidate, length) { return tf.js.GetIsArray(candidate) && candidate.length == length; }
/**
 * @public
 * @function
 * @summary - Checks if the given candidate is an {@link array} with a number of elements greater or equal to the given length
 * @param {*} candidate - the candidate
 * @param {number} length - the length
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsArrayWithMinLength = function (candidate, length) { return tf.js.GetIsArray(candidate) && candidate.length >= length; }
/**
 * @public
 * @function
 * @summary - Checks if the given object is a valid {@link object}
 * @param {*} candidate - the candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsValidObject = function (candidate) { return !!candidate && (typeof candidate === "object"); }
/**
 * @public
 * @function
 * @summary - Returns the given object if it is a valid {@link object}, otherwise returns an empty object {}
 * @param {*} candidate - the candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetValidObjectFrom = function (candidate) { return tf.js.GetIsValidObject(candidate) ? candidate : {} ; }
/**
 * @public
 * @function
 * @summary - Returns the given candidate if it is a valid {@link function}, or {@link void} otherwise
 * @param {*} fromFunction - the candidate
 * @returns {function} - | {@link function} <b>fromFunction</b> or {@link void}
*/
tf.js.GetFunctionOrNull = function (fromFunction) { return typeof fromFunction === "function" ? fromFunction : null; }
/**
 * @private
 * @function
 * @summary - Parses the given string in JSON format using JavaScript's <b>eval</b> function. Fallback in case Browser does not support JSON. Used internally by the API
 * @param {string} str - a string in JSON format
 * @returns {object} - | {@link object} the object
*/
tf.js.JSONParseWithEval = function (str) { return tf.js.GetNonEmptyString(str) ? eval('(' + str + ')') : null; }
/**
 * @public
 * @function
 * @summary - Parses the given string in JSON format
 * @param {string} str - a string in JSON format
 * @returns {object} - | {@link object} the object
*/
tf.js.JSONParse = function (str) {
    var parsed = null;
    var jsonParse = (!!JSON && !!JSON.parse) ? JSON.parse : tf.js.JSONParseWithEval;
    try { parsed = jsonParse(str); }
    catch (e) {
        if (jsonParse != tf.js.JSONParseWithEval) { try { parsed = tf.js.JSONParseWithEval(str); } catch (e) { parsed = null; } } else { parsed = null; }
        if (!parsed) { tf.GetDebug().LogIfTest("exception on JSON decode"); }
    }
    return parsed;
}
/**
 * @public
 * @function
 * @summary - Retrieves the URL where a the script of the given file name was loaded from
 * @param {string} scriptFileName - the script file name
 * @returns {string} - | {@link string} the the URL
*/
tf.js.GetURLOfScript = function (scriptFileName) {
    var scriptURL;
    if (typeof scriptFileName === "string") {
        var scriptElements = document.getElementsByTagName('script');
        var i, element;
        for (i = 0; element = scriptElements[i]; ++i) {
            var myfile = element.src, index = myfile.indexOf(scriptFileName);
            if (index >= 0) { scriptURL = myfile.substring(0, index); break; }
        }
    }
    return scriptURL;
}
/**
 * @public
 * @function
 * @summary - Returns a valid {@link hexColor} parsed from the given color, or the given default color if parsing fails
 * @param {hexColor|deprecatedColor} fromColorStr - the given color
 * @param {hexColor} defaultColorStr - the default color
 * @returns {hexColor} - | {@link hexColor} a valid color
*/
tf.js.GetHexColorStr = function (fromColorStr, defaultColorStr) {
    var returnColorStr = defaultColorStr;
    if (typeof fromColorStr == "string") {
        if (fromColorStr.length > 0) {
            if (fromColorStr[0] != '#') {
                if (fromColorStr.indexOf("0x") == 0) {
                    returnColorStr = '#' + fromColorStr.substr(2);
                }
                else {
                    fromColorStr = parseInt(fromColorStr, 10);
                    returnColorStr = "#" + fromColorStr.toString(16);
                }
            }
            else {
                returnColorStr = fromColorStr;
            }
        }
    }
    else if (typeof fromColorStr == "number") {
        returnColorStr = "#" + fromColorStr.toString(16);
    }
    return returnColorStr;
}
/**
 * @public
 * @function
 * @summary - Returns a valid {@link rgbaColor} or {@link rgbColor} parsed from the given color and using the given opacity
 * @param {hexColor|deprecatedColor} fromColorStr - the given color
 * @param {hexColor} defaultColorStr - the default color, used if parsing of <b>fromColorStr</b> fails
 * @param {tf.types.opacity01} opacity - the given opacity
 * @returns {rgbaColor|rgbColor} - | {@link rgbaColor}|{@link rgbColor} a valid color, returns {@link rgbColor} if <b>opacity</b> is <b>1</b>
*/
tf.js.GetRGBAColor = function (fromColorStr, defaultColorStr, opacity) {
    var rgbaColor = "rgb(0,0,0)";
    fromColorStr = tf.js.GetHexColorStr(fromColorStr, defaultColorStr);
    if (fromColorStr) {
        var len = fromColorStr.length;
        var nPerColor = len == 7 ? 2 : (len == 4 ? 1 : 0);
        if (nPerColor && fromColorStr.charAt(0) == '#') {
            var r = parseInt(fromColorStr.substr(1, nPerColor), 16);
            var g = parseInt(fromColorStr.substr(1 + nPerColor, nPerColor), 16);
            var b = parseInt(fromColorStr.substr(1 + 2 * nPerColor, nPerColor), 16);
            if (nPerColor == 1) {
                r = r * 16 + r;
                g = g * 16 + g;
                b = b * 16 + b;
            }
            var needOpacity = false;
            if (typeof opacity == "number") {
                opacity = opacity < 0.0 ? 0.0 : (opacity > 1.0 ? 1.0 : opacity);
                needOpacity = opacity != 1.0;
            }
            rgbaColor = needOpacity ? "rgba(" + r + "," + g + "," + b + "," + opacity + ")" : "rgb(" + r + "," + g + "," + b + ")";
        }
    }
    return rgbaColor;
}
/**
 * @public
 * @function
 * @summary - Returns a random {@link hexColor}
 * @returns {hexColor} - | {@link hexColor} a random color
*/
tf.js.GetRandomHexColorStr = function () { return '#' + Math.floor(Math.random() * 16777215).toString(16); }
/**
 * @public
 * @function
 * @summary - Calculates the gray [color component]{@link tf.types.rgbColorComponent} approximately equivalent to the combined <b>"brightness"</b> of the given rgb components
 * @param {tf.types.rgbColorComponents} rgb - the given components
 * @returns {tf.types.rgbColorComponent} - | {@link tf.types.rgbColorComponent} the gray value
*/
tf.js.GetGrayFromRGB = function (rgb) { return rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114; }
/**
 * @public
 * @function
 * @summary - Retrieves the rgb components of a given color
 * @param {hexColor|deprecatedColor} fromColorStr - the given color
 * @param {hexColor} defaultColorStr - the default color, used if parsing of <b>fromColorStr</b> fails
 * @returns {tf.types.rgbColorComponents} - | {@link tf.types.rgbColorComponents} the rgb components
*/
tf.js.GetRGBFromColor = function (fromColorStr, defaultColorStr) {
    var r = 255, g = 255, b = 255;
    fromColorStr = tf.js.GetHexColorStr(fromColorStr, defaultColorStr);
    if (fromColorStr) {
        var len = fromColorStr.length;
        var nPerColor = len == 7 ? 2 : (len == 4 ? 1 : 0);
        if (nPerColor && fromColorStr.charAt(0) == '#') {
            var r = parseInt(fromColorStr.substr(1, nPerColor), 16);
            var g = parseInt(fromColorStr.substr(1 + nPerColor, nPerColor), 16);
            var b = parseInt(fromColorStr.substr(1 + 2 * nPerColor, nPerColor), 16);
        }
    }
    return { r: r, g: g, b: b };
}
/**
 * @public
 * @function
 * @summary - Checks if the parameter is a valid JavaScript {@link number}
 * @param {object} aNumber - the given candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsValidNumber = function (aNumber) { return (Number(aNumber) === aNumber) && isFinite(aNumber); }
/**
 * @public
 * @function
 * @summary - Checks if the parameter is a valid JavaScript non negative {@link number}
 * @param {object} aNumber - the given candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsNonNegativeNumber = function (aNumber) { return tf.js.GetIsValidNumber(aNumber) && aNumber >= 0; }
/**
 * @public
 * @function
 * @summary - Checks if the parameter is a valid JavaScript positive {@link number}
 * @param {object} aNumber - the given candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsPositiveNumber = function (aNumber) { return tf.js.GetIsValidNumber(aNumber) && aNumber > 0; }
/**
 * @public
 * @function
 * @summary - Checks if the parameter is a valid JavaScript integer {@link number}
 * @param {object} aNumber - the given candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsInt = function (aNumber) { return tf.js.GetIsValidNumber(aNumber) && (aNumber % 1 === 0); }
/**
 * @public
 * @function
 * @summary - Checks if the parameter is a valid JavaScript non negative integer {@link number}
 * @param {object} aNumber - the given candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsNonNegativeInt = function (aNumber) { return tf.js.GetIsInt(aNumber) && tf.js.GetIsNonNegativeNumber(aNumber); }
/**
 * @public
 * @function
 * @summary - Checks if the parameter is a valid JavaScript positive integer {@link number}
 * @param {object} aNumber - the given candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsPositiveInt = function (aNumber) { return tf.js.GetIsInt(aNumber) && tf.js.GetIsPositiveNumber(aNumber); }
/**
 * @public
 * @function
 * @summary - Retrieves a valid non negative integer from the given parameter, or returns the given default value
 * @param {string|number} aNumber - the given candidate, strings are parsed in base 10
 * @param {number} defaultValue - the given default
 * @returns {number} - | {@link number} <b>aNumber</b> or <b>defaultValue</b>
*/
tf.js.GetNonNegativeIntFrom = function (aNumber, defaultValue) {
    tf.js.GetIsNonEmptyString(aNumber) && (aNumber = parseInt(aNumber, 10));
    return tf.js.GetIsNonNegativeInt(aNumber) ? aNumber : (defaultValue !== undefined ? defaultValue : 0);
}
/**
 * @public
 * @function
 * @summary - Retrieves a valid positive integer from the given parameter, or returns the given default value
 * @param {string|number} aNumber - the given candidate, [strings]{@link string} are parsed in base 10
 * @param {number} defaultValue - the given default
 * @returns {number} - | {@link number} <b>aNumber</b> or <b>defaultValue</b>
*/
tf.js.GetPositiveIntFrom = function (aNumber, defaultValue) {
    tf.js.GetIsNonEmptyString(aNumber) && (aNumber = parseInt(aNumber, 10));
    return tf.js.GetIsPositiveInt(aNumber) ? aNumber : (defaultValue !== undefined ? defaultValue : 1);
}
/**
 * @public
 * @function
 * @summary - Constrains the given value into the given range
 * @param {number} original - the given value
 * @param {number} minValue - the given minimum acceptable value
 * @param {number} maxValue - the given maximum acceptable value
 * @returns {number} - | {@link number} a number in the given range
*/
tf.js.NumberClip = function (original, minValue, maxValue) { return original < minValue ? minValue : (original > maxValue ? maxValue : original); }
/**
 * @public
 * @function
 * @summary - Retrieves a valid {@link number} from the given number or the given default number
 * @param {number|string|void} fromValue - the given number
 * @param {number} defaultValue - default used when a {@link number} cannot be extracted from <b>fromValue</b>
 * @returns {number} - | {@link number} a valid number
*/
tf.js.GetFloatNumber = function (fromValue, defaultValue) {
    if (fromValue !== undefined) {
        if (typeof fromValue === "string") { fromValue = parseFloat(fromValue); }
        if (typeof fromValue !== "number" || !isFinite(fromValue)) { fromValue = defaultValue; }
    }
    else { fromValue = defaultValue; }
    return fromValue;
}
/**
 * @public
 * @function
 * @summary - Retrieves a valid {@link number} from the given number or the given default number, constrained to the given range
 * @param {number|string|void} fromValue - the given number
 * @param {number} minValue - the given minimum acceptable value
 * @param {number} maxValue - the given maximum acceptable value
 * @param {number} defaultValue - default used when a {@link number} cannot be extracted from <b>fromValue</b>
 * @returns {number} - | {@link number} a valid number
*/
tf.js.GetFloatNumberInRange = function (fromValue, minValue, maxValue, defaultValue) {
    fromValue = tf.js.GetFloatNumber(fromValue, defaultValue);
    return tf.js.NumberClip(fromValue, minValue, maxValue);
}
/**
 * @public
 * @function
 * @summary - Retrieves a valid integer {@link number} from the given number or the given default number, constrained to the given range
 * @param {number|string|void} fromValue - the given number
 * @param {number} minValue - the given minimum acceptable value
 * @param {number} maxValue - the given maximum acceptable value
 * @param {number} defaultValue - default used when a {@link number} cannot be extracted from <b>fromValue</b>
 * @returns {number} - | {@link number} a valid number
*/
tf.js.GetIntNumberInRange = function (fromValue, minValue, maxValue, defaultValue) {
    return Math.floor(tf.js.GetFloatNumberInRange(fromValue, minValue, maxValue, defaultValue));
}
/**
 * @public
 * @function
 * @summary - Checks if the given parameter is a {boolean} <b>false</b>
 * @param {boolean|string|void} value - the given candidate, "false", "FALSE", "False", etc. are acceptable <b>false</b> values
 * @returns {boolean} - | {@link boolean} <b>true</b> if <b>value</b> is <b>false</b>, <b>false</b> otherwise
*/
tf.js.GetIsFalseNotUndefined = function (value) { return value === undefined ? false : ! tf.js.GetBoolFromValue(value, false); }
/**
 * @public
 * @function
 * @summary - Retrieves a valid {@link boolean} value from the given parameter
 * @param {boolean|string|void} fromValue - the given candidate, "false", "FALSE", "False", etc. are acceptable <b>false</b> values
 * @param {boolean|void} defaultOrFalseIfUndefined - default used when a {@link boolean} cannot be extracted from <b>fromValue</b>, defaults to <b>false</b> if undefined
 * @returns {boolean} - | {@link boolean} <b>true</b> if <b>value</b> is <b>true</b>, <b>false</b> otherwise
*/
tf.js.GetBoolFromValue = function (fromValue, defaultOrFalseIfUndefined) {
    if (typeof fromValue === "boolean") { return fromValue; }
    if (typeof fromValue === "string") { return fromValue.length > 0 && fromValue.toLowerCase() !== 'false'; }
    return defaultOrFalseIfUndefined === undefined ? false : !!defaultOrFalseIfUndefined;
}
/**
 * @public
 * @function
 * @summary - Retrieves a valid {@link tf.types.latitude} from the given latitude, defaults to {@link tf.consts.defaultLatitude}
 * @param {number|string|void} latitude - the given latitude
 * @returns {tf.types.latitude} - | {@link tf.types.latitude} a valid latitude
*/
tf.js.GetLatitudeFrom = function (latitude) { return tf.js.GetFloatNumberInRange(latitude, tf.consts.minLatitude, tf.consts.maxLatitude, tf.consts.defaultLatitude); }
/**
 * @public
 * @function
 * @summary - Retrieves a valid {@link tf.types.longitude} from the given longitude, defaults to {@link tf.consts.defaultLongitude}
 * @param {number|string|void} longitude - the given longitude
 * @returns {tf.types.longitude} - | {@link tf.types.longitude} a valid longitude
*/
tf.js.GetLongitudeFrom = function (longitude) { return tf.js.GetFloatNumberInRange(longitude, tf.consts.minLongitude, tf.consts.maxLongitude, tf.consts.defaultLongitude); }
/**
 * @public
 * @function
 * @summary - Creates a random valid {@link tf.types.latitude}
 * @returns {tf.types.latitude} - | {@link tf.types.latitude} a random valid latitude
*/
tf.js.GetRandomLatitude = function () { return Math.random() * tf.consts.latitudeRange - tf.consts.maxLatitude; }
/**
 * @public
 * @function
 * @summary - Creates a random valid {@link tf.types.longitude}
 * @returns {tf.types.longitude} - | {@link tf.types.longitude} a random valid longitude
*/
tf.js.GetRandomLongitude = function () { return Math.random() * tf.consts.longitudeRange - tf.consts.maxLongitude; }
/**
 * @public
 * @function
 * @summary - Retrieves a valid {@link tf.types.mapLevel} from the given level, defaults to {@link tf.consts.defaultLevel}
 * @param {number|string|void} level - the given level
 * @returns {tf.types.mapLevel} - | {@link tf.types.mapLevel} a valid level
*/
tf.js.GetLevelFrom = function (level) { return tf.js.GetIntNumberInRange(level, tf.consts.minLevel, tf.consts.maxLevel, tf.consts.defaultLevel); }
/**
 * @public
 * @function
 * @summary - Validates and retrieves [MinMaxLevels]{@link tf.types.MinMaxLevels} from the given minimum and maximum levels
 * @param {tf.types.mapLevel} minLevel - the minimum level
 * @param {tf.types.mapLevel} maxLevel - the maximum level
 * @returns {tf.types.MinMaxLevels} - | {@link tf.types.MinMaxLevels} the validated minimum and maximum levels
*/
tf.js.GetMinMaxLevelsFrom = function (minLevel, maxLevel) {
    if (minLevel === undefined) { minLevel = tf.consts.minLevel; }
    if (maxLevel === undefined) { maxLevel = tf.consts.maxLevel; }
    minLevel = tf.js.GetLevelFrom(minLevel);
    maxLevel = tf.js.GetLevelFrom(maxLevel);
    if (minLevel < maxLevel) { var t = minLevel; minLevel = maxLevel; maxLevel = t; }
    return { minLevel: minLevel, maxLevel: maxLevel };
}
/**
 * @public
 * @function
 * @summary - Retrieves a valid {@link tf.types.mapExtent} from the given extent
 * @param {tf.types.mapExtent} extent - the given extent
 * @returns {tf.types.mapExtent} - | {@link tf.types.mapExtent} a valid extent
*/
tf.js.GetMapExtentFrom = function (extent) {
    if (tf.js.GetIsArrayWithMinLength(extent, 4)) {
        extent[0] = tf.js.GetLongitudeFrom(extent[0]);
        extent[1] = tf.js.GetLatitudeFrom(extent[1]);
        extent[2] = tf.js.GetLongitudeFrom(extent[2]);
        extent[3] = tf.js.GetLatitudeFrom(extent[3]);
        if (extent[0] > extent[2]) { var t = extent[0]; extent[0] = extent[2]; extent[2] = t; }
        if (extent[1] > extent[3]) { var t = extent[1]; extent[1] = extent[3]; extent[3] = t; }
    }
    else {
        extent = [tf.consts.defaultLongitude, tf.consts.defaultLatitude, tf.consts.defaultLongitude, tf.consts.defaultLatitude];
    }
    return extent;
}
/**
 * @public
 * @function
 * @summary - Updates the given [map extent]{@link tf.types.mapExtent} to include the given [map coordinate]{@link tf.types.mapCoordinates}
 * @param {tf.types.mapExtent} extent - the given extent
 * @param {tf.types.mapCoordinates} coord - the given coordinate
 * @returns {tf.types.mapExtent} - | {@link tf.types.mapExtent} the updated extent
*/
tf.js.UpdateMapExtent = function (extent, coord) {
    extent = tf.js.GetMapExtentFrom(extent);
    coord = tf.js.GetMapCoordsFrom(coord);
    if (extent[0] > coord[0]) { extent[0] = coord[0]; } else if (extent[2] < coord[0]) { extent[2] = coord[0]; }
    if (extent[1] > coord[1]) { extent[1] = coord[1]; } else if (extent[3] < coord[1]) { extent[3] = coord[1]; }
    return extent;
}
/**
 * @public
 * @function
 * @summary - Merges the given [map extents]{@link tf.types.mapExtent}
 * @param {tf.types.mapExtent} extent1 - a given extent
 * @param {tf.types.mapExtent} extent2 - a given extent
 * @returns {tf.types.mapExtent} - | {@link tf.types.mapExtent} the merged extent
*/
tf.js.MergeMapExtents = function (extent1, extent2) {
    extent1 = tf.js.GetMapExtentFrom(extent1);
    extent2 = tf.js.GetMapExtentFrom(extent2);
    var extent = extent1.slice(0);
    extent = tf.js.UpdateMapExtent(extent, [extent2[0], extent2[1]]);
    extent = tf.js.UpdateMapExtent(extent, [extent2[2], extent2[3]]);
    return extent;
}
/**
 * @public
 * @function
 * @summary - Scales the given {@link tf.types.mapExtent} to the given scale multiplier
 * @param {tf.types.mapExtent} extent - the given extent
 * @param {number} scale - the given multiplier
 * @returns {tf.types.mapExtent} - | {@link tf.types.mapExtent} the scaled extent
*/
tf.js.ScaleMapExtent = function (extent, scale) {
    extent = tf.js.GetMapExtentFrom(extent); scale = tf.js.GetFloatNumber(scale, 1);
    var extentHW = (extent[2] - extent[0]) / 2, extentHH = (extent[3] - extent[1]) / 2;
    var extentCX = extent[0] + extentHW, extentCY = extent[1] + extentHH;
    extentHW *= scale; extentHH *= scale;
    return [extentCX - extentHW, extentCY - extentHH, extentCX + extentHW, extentCY + extentHH];
}
/**
 * @public
 * @function
 * @summary - Returns an array containing all properties in the given {@link object}
 * @param {object} theObject - the given object
 * @returns {array} - | {@link array} the array containing <b>theObject</b>'s properties
*/
tf.js.ObjectToArray = function (object) {
    var array = []; for (var i in object) { array.push(object[i]); }
    return array;
}
/**
 * @public
 * @function
 * @summary - Extracts an {@link HTMLElementSize} from the given dimension
 * @param {HTMLElementSizeOrPxNumber} dim - the given dimension, [numbers]{@link number} are treated as pixel dimensions
 * @param {HTMLElementSize} defaultDim - the default dimension
 * @returns {HTMLElementSize} - | {@link HTMLElementSize} the size
*/
tf.js.GetDimFromStrOrPxNumber = function (dim, defaultDim) {
    if (typeof dim === "number") { return dim + 'px' };
    if (typeof dim !== "string" || !dim.length) { return defaultDim; }
    return dim;
}
/**
 * @public
 * @function
 * @summary - Converts the give number of seconds into "HH:MM:SS" format
 * @param {number} numberOfSeconds - the given number of seconds
 * @returns {string} - | {@link string} the number of seconds in "HH:MM:SS" format
*/
tf.js.ConvertToHHMMSS = function (numberOfSeconds) {
    var sec_num = Math.abs(tf.js.GetFloatNumber(numberOfSeconds, 0)), hours = Math.floor(sec_num / 3600);
    var minutes = Math.floor((sec_num - (hours * 3600)) / 60), seconds = Math.floor(sec_num - (hours * 3600) - (minutes * 60));
    if (hours < 10) { hours = "0" + hours; } if (minutes < 10) { minutes = "0" + minutes; } if (seconds < 10) { seconds = "0" + seconds; }
    var timeStr = hours + ':' + minutes + ':' + seconds;
    return timeStr;
}
/**
 * @public
 * @function
 * @summary - Converts the give number of seconds into "HH:MM:SS" format, adds "HH" only if necessary, uses "M" instead of "MM" when possible
 * @param {number} numberOfSeconds - the given number of seconds
 * @returns {string} - | {@link string} the number of seconds in "HH:MM:SS" format
*/
tf.js.ConvertToHHMMSSBrief = function (numberOfSeconds) {
    var sec_num = tf.js.GetFloatNumber(numberOfSeconds, 0);
    var hours = Math.floor(sec_num / 3600);
    var minutes = Math.floor((sec_num - (hours * 3600)) / 60);
    var seconds = Math.floor(sec_num - (hours * 3600) - (minutes * 60));
    if (hours < 10) { if (hours > 0) { hours = "0" + hours + ':' } else { hours = ''; } }
    if (minutes < 10) { if (minutes > 0) { if (hours > 0) { minutes = "0" + minutes + ':'; } else { minutes = minutes + ':'; } } else { minutes = '0:'; } }
    if (seconds < 10) { seconds = "0" + seconds; }
    var time = hours + minutes + seconds;
    return time;
}
/**
 * @public
 * @function
 * @summary - Converts the give number of seconds into "HH:MM:SS" format, adds "HH" only if necessary, uses "M" instead of "MM" when possible
 * @param {number} numberOfSeconds - the given number of seconds
 * @returns {string} - | {@link string} the number of seconds in "HH:MM:SS" format
*/
tf.js.ConvertToHourMinute = function (numberOfSeconds) {
    var sec_num = tf.js.GetFloatNumber(numberOfSeconds, 0);
    var hours = Math.floor(sec_num / 3600);
    var minutes = Math.floor((sec_num - (hours * 3600)) / 60);
    var time;
    if (!!hours) {
        if (minutes < 10) { minutes = '0' + minutes; }
        time = hours + 'h:' + minutes + 'm';
    }
    else {
        time = minutes + 'm';
    }
    return time;
}
/**
 * @public
 * @function
 * @summary - Removes the last character from the given string if it matches the given character
 * @param {string} fromStr - the given string
 * @param {string} theChar - the given character
 * @returns {string} - | {@link string} the string with the character removed
*/
tf.js.ClipEndingChar = function (fromStr, theChar) {
    var fromStrUse = tf.js.GetNonEmptyString(fromStr, "");
    var charUse = tf.js.GetNonEmptyString(theChar, "");
    if (!!fromStrUse && !!charUse) {
        var fromStrUseLen = fromStrUse.length;
        if (fromStrUse.charAt(fromStrUseLen - 1) == charUse.charAt(0)) {
            fromStrUse = fromStrUse.substring(0, --fromStrUseLen);
        }
    }
    return fromStrUse;
}
/**
 * @public
 * @function
 * @summary - Removes parenthesis, '(' and ')', from the start and end of the given string, if present
 * @param {string} fromStr - the given string
 * @returns {string} - | {@link string} the string without parenthesis
*/
tf.js.RemoveParenthesisFrom = function (fromStr) {
    var strUse = tf.js.GetNonEmptyString(fromStr);
    if (strUse) {
        if (strUse.charAt(0) == '(') { strUse = strUse.slice(1); }
        if (!!strUse.length) { if (strUse.charAt(strUse.length - 1) == ')') { strUse = strUse.slice(0, -1); } }
    }
    return strUse;
}
/**
 * @public
 * @function
 * @summary - Removes brackets, '[' and ']', from the start and end of the given string, if present
 * @param {string} fromStr - the given string
 * @returns {string} - | {@link string} the string without brackets
*/
tf.js.RemoveBracketsFrom = function (fromStr) {
    var strUse = tf.js.GetNonEmptyString(fromStr);
    if (strUse) {
        if (strUse.charAt(0) == '[') { strUse = strUse.slice(1); }
        if (!!strUse.length) { if (strUse.charAt(strUse.length - 1) == ']') { strUse = strUse.slice(0, -1); } }
    }
    return strUse;
}
/**
 * @public
 * @function
 * @summary - Capitalizes the first letter of the given string
 * @param {string} string - the given string
 * @returns {string} - | {@link string} the string with the first letter capitalized
*/
tf.js.CapitaliseFirstLetter = function (string) {
    if (tf.js.GetIsNonEmptyString(string)) { string = string.charAt(0).toUpperCase() + string.slice(1); }
    return string;
}
/**
 * @public
 * @function
 * @summary - Capitalizes the first letter of the given string, after converting it to lower case
 * @param {string} string - the given string
 * @returns {string} - | {@link string} the string with only the first letter capitalized
*/
tf.js.CapitaliseFirstLetterOnly = function (string) {
    if (tf.js.GetIsNonEmptyString(string)) { string = tf.js.CapitaliseFirstLetter(string.toLowerCase()) }
    return string;
}
/**
 * @public
 * @function
 * @summary - Retrieves a random element from the given array, or {@link void} if the given array is invalid or empty
 * @param {array<*>} theArray - the given array
 * @returns {*} - | {@link *} a random element from the array, or {@link void} if none is available
*/
tf.js.GetRandomArrayElement = function (theArray) { return tf.js.GetIsNonEmptyArray(theArray) ? theArray[Math.floor(Math.random() * theArray.length)] : null; }
/**
 * @public
 * @function
 * @summary - Determines if the given candidate is an instance of a given type
 * @param {*} obj - the given candidate
 * @param {object} type - the given type
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsInstanceOf = function (obj, type) { return !!obj && !!type && (obj instanceof type); }
/**
 * @public
 * @function
 * @summary - Determines if the given candidate is an instance of the [TerraFly Map]{@link tf.map.Map}
 * @param {*} obj - the given candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsMap = function (obj) { return tf.js.GetIsInstanceOf(obj, tf.map.Map); }
/**
 * @public
 * @function
 * @summary - Determines if the given candidate is an instance of [Feature Layer]{@link tf.map.FeatureLayer}
 * @param {*} obj - the given candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsMapFeatureLayer = function (obj) { return tf.js.GetIsInstanceOf(obj, tf.map.FeatureLayer); }
/**
 * @public
 * @function
 * @summary - Determines if the given candidate is an instance of [Map Feature]{@link tf.map.Feature}
 * @param {*} obj - the given candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsMapFeature = function (obj) { return tf.js.GetIsInstanceOf(obj, tf.map.Feature); }
/**
 * @public
 * @function
 * @summary - Retrieves the given candidate instance of the [TerraFly Map]{@link tf.map.Map} or {@link void} if the candidate is not a valid map
 * @param {*} mapCandidate - the given candidate
 * @returns {tf.map.Map} - | {@link tf.map.Map} <b>mapCandidate</b> or {@link void}
*/
tf.js.GetMapFrom = function (mapCandidate) {
    return tf.js.GetIsMap(mapCandidate) ? mapCandidate : null;
    /*var map = !!tMapCandidate && typeof tMapCandidate === "object" ? tMapCandidate : null;
    if (!!map) {
        if (!tf.js.GetIsMap(map)) {
            while (!!map && tf.js.GetFunctionOrNull(map.GetMap)) { map = map.GetMap(); }
            if (!tf.js.GetIsMap(map)) { map = null; }
        }
    }
    return map;*/
}
/**
 * @private
 * @function
 * @summary - Makes a standard [API Key]{@link tf.types.Key} from a given application defined key. Used internally by the API
 * @param {*} key - the given key
 * @returns {tf.types.Key} - | {@link tf.types.Key} the key
*/
tf.js.MakeObjectKey = function (key) { return !!key ? '#' + key : null; }
/**
 * @public
 * @function
 * @summary - Determines if the given {@link object} has the necessary properties of a [GeoJSON Geometry]{@link tf.types.GeoJSONGeometry}
 * @param {object} obj - the given object
 * @returns {boolean} - | {@link boolean} <b>true</b> if <b>obj</b> has GeoJSON geometry attributes, <b>false</b> otherwise
*/
tf.js.GetHasGeoJSONGeometryProperties = function (obj) {
    if (tf.js.GetIsValidObject(obj) && tf.js.GetIsNonEmptyString(obj.type)) {
        var minLen = obj.type.toLowerCase() == "point" ? 2 : 1;
        return tf.js.GetIsArrayWithMinLength(obj.coordinates, minLen);
    }
    return false;
}
/**
 * @public
 * @function
 * @summary - Returns the given {@link object} if it has the <b>geometry</b> property with the necessary sub-properties of a [GeoJSON Geometry]{@link tf.types.GeoJSONGeometry}
 * @param {object} obj - the given object
 * @returns {tf.types.GeoJSONGeometry} - | {@link tf.types.GeoJSONGeometry} <b>obj</b> or {@link void} if <b>obj</b> lacks the necessary properties
*/
tf.js.GetGeoJSONGeometryFrom = function (obj) {
    var geometry = null;
    if (tf.js.GetIsValidObject(obj)) {
        var geom = obj.geometry;
        if (tf.js.GetIsValidObject(geom) && tf.js.GetIsNonEmptyString(geom.type) && tf.js.GetIsNonEmptyArray(geom.coordinates)) { geometry = geom; }
    }
    return geometry;
}
/**
 * @public
 * @function
 * @summary - Returns a valid [GeoJSON extracting callback]{@link tf.types.GetGeoJSONGeometryCallBack} from the given candidate
 * @param {*} getGeometryFromDataFunction - the given candidate
 * @returns {tf.types.GetGeoJSONGeometryCallBack} - | {@link tf.types.GetGeoJSONGeometryCallBack} a valid GeoJSON extracting callback, defaults to {@link tf.js.GetGeoJSONGeometryFrom}
 * @see [Keyed Feature Lists]{@link tf.map.KeyedFeatureList} and [Keyed Feature List Settings]{@link tf.types.KeyedFeatureListSettings}
*/
tf.js.GetGeoJSONGeometryFunctionFrom = function (getGeometryFromDataFunction) {
    if (!(getGeometryFromDataFunction = tf.js.GetFunctionOrNull(getGeometryFromDataFunction))) {
        getGeometryFromDataFunction = tf.js.GetGeoJSONGeometryFrom;
    }
    return getGeometryFromDataFunction;
}
/**
 * @public
 * @function
 * @summary - Determines if the given <b>coords</b> look like [GeoJSON linestring coordinates]{@link tf.types.GeoJSONGeometryType},
 * i.e. coords is an array with 2 or more elements and its first element is also an array with 2 or more elements
 * @param {object} coords - the given coordinates
 * @returns {boolean} - | {@link boolean} <b>true</b> if the given coordinates seem to be linestring coordinates
*/
tf.js.GetLooksLikeLineStringCoords = function (coords) {
    return tf.js.GetIsArrayWithMinLength(coords, 2) && tf.js.GetIsArrayWithMinLength(coords[0], 2);
}
/**
 * @public
 * @function
 * @summary - Extracts standard [Map Coordinates]{@link tf.types.mapCoordinates} from the given coordinates
 * @param {tf.types.mapCoordinates|deprecatedMapCoords1|deprecatedMapCoords2|deprecatedMapCoords3|deprecatedMapCoords4} coords - the given coordinates
 * @returns {tf.types.mapCoordinates} - | {@link tf.types.mapCoordinates} map coordinates
*/
tf.js.GetMapCoordsFrom = function (coords) {
    var latitude, longitude;
    if (tf.js.GetIsArrayWithMinLength(coords, 2)) { latitude = coords[1]; longitude = coords[0]; }
    else if (typeof coords === "object") {
        if (coords.lat !== undefined) { latitude = coords.lat; longitude = coords.lon; }
        else if (coords.Lat != undefined) { latitude = coords.Lat; longitude = coords.Lon; }
        else if (coords.latitude != undefined) { latitude = coords.latitude; longitude = coords.longitude; }
        else if (coords.Latitude != undefined) { latitude = coords.Latitude; longitude = coords.Longitude; }
    }
    if (latitude === undefined) { latitude = 0; longitude = 0; }
    else { latitude = tf.js.GetLatitudeFrom(latitude); longitude = tf.js.GetLongitudeFrom(longitude); }
    return [longitude, latitude];
}
/**
 * @private
 * @function
 * @summary - Implements a basic inheritance pattern. Used internally by the API
 * @param {object} subClass - the subclass
 * @param {object} superClass - the superclass
 * @returns {void} - | {@link void} no return value
*/
tf.js.InheritFrom = function (subClass, superClass) { return ol.inherits(subClass, superClass); }
/**
 * @public
 * @function
 * @summary - Creates and sets to the given value, or deletes, the given property of the given object
 * @param {object} toObj - the object to which the property will be set
 * @param {string} propertyName - the name of the property to be set
 * @param {object|void} propertyObj - the value of the property to be set, if {@link void} the property <b>propertyName<b> is deleted from <b>toObj</b>
 * @returns {void} - | {@link void} no return value
 * @see {@link tf.js.GetObjProperty} and {@link tf.types.KnownAPIPropertyName}
*/
tf.js.SetObjProperty = function (toObj, propertyName, propertyObj) {
    if (tf.js.GetIsValidObject(toObj) && tf.js.GetIsNonEmptyString(propertyName) && ((! propertyObj) || tf.js.GetIsValidObject(propertyObj))) {
        if (!!propertyObj) { toObj[propertyName] = propertyObj; } else if (!!toObj[propertyName]) { delete toObj[propertyName]; }
    }
}
/**
 * @public
 * @function
 * @summary - Retrieves given property from the given object
 * @param {object} fromObj - the object from which the property will be retrieved
 * @param {string} propertyName - the name of the property to retrieve
 * @returns {object} - | {@link object} the retrieved property, or {@link void} if <b>fromObj</b> does not contain a property named <b>propertyName</b>
 * @see {@link tf.js.SetObjProperty} and {@link tf.types.KnownAPIPropertyName}
*/
tf.js.GetObjProperty = function (fromObj, propertyName) {
    var propertyObj = undefined;
    if (tf.js.GetIsValidObject(fromObj) && tf.js.GetIsNonEmptyString(propertyName)) { propertyObj = fromObj[propertyName]; }
    return propertyObj;
}
/**
 * @public
 * @function
 * @summary - Retrieves a regular expression used by the API to retrieve attribute name references from
 * inside strings, example: to reference an attribute named "tempCelsius" in a string use "The temperature in Celsius is $[tempCelsius], it's a sunny day";
 * the regular expression captures the string enclosed inside brackets that immediately follow a $ sign
 * @returns {RegExp} - | {@link RegExp} the regular expression
*/
tf.js.GetFindReferenceInStringRegExp = function () { return /\$\[(\w+)\]/; }
/**
 * @public
 * @function
 * @summary - Replaces references made in the given string with values from attributes of the given object,
 * or a default given value
 * @param {string} strToReplace - the given string including references
 * @param {object} objectWithValues - the object from which attribute values will be retrieved
 * @param {string} defaultStr - the given default string, used if <b>objectWithValues</b> does not contain a referenced attribute
 * @param {RegExp} attributeNameMatch - if defined, used to locate attribute name references in <b>strToReplace</b>, defaults to
 * the regular expression obtained with the function {@link tf.js.GetFindReferenceInStringRegExp}
 * @returns {string} - | {@link string} the string with replacements
*/
tf.js.ReplaceWithValues = function (strToReplace, objectWithValues, defaultStr, attributeNameMatch) {
    var strReplaced = defaultStr;
    if (tf.js.GetIsString(strToReplace)) {
        strReplaced = strToReplace;
        if (tf.js.GetIsValidObject(objectWithValues)) {
            if (attributeNameMatch === undefined) { attributeNameMatch = tf.js.GetFindReferenceInStringRegExp(); }
            if (tf.js.GetIsInstanceOf(attributeNameMatch, RegExp)) {
                var match;
                while (match = attributeNameMatch.exec(strReplaced)) {
                    var propsVal = objectWithValues[match[1]];
                    if (!tf.js.GetIsString(propsVal)) {
                        if (propsVal !== undefined && tf.js.GetFunctionOrNull(propsVal.toString)) {
                            propsVal = propsVal.toString();
                        }
                        else {
                            propsVal = '';
                        }
                    }
                    strReplaced = strReplaced.replace(match[0], propsVal);
                }
            }
        }
    }
    return strReplaced;
}
/**
 * @public
 * @function
 * @summary - Replaces references in string attributes of the given object with the same named attribute values of another given object
 * @param {object} objectToReplace - the object whose string attribute values will be replaced
 * @param {object} objectWithValues - the object from which attribute values will be retrieved
 * @param {RegExp} attributeNameMatch - if defined, used to locate attribute name references in the string attributes of <b>objectToReplace</b>, defaults to
 * the regular expression obtained with the function {@link tf.js.GetFindReferenceInStringRegExp}
 * @returns {object} - | {@link object} the object with attribute replacements
*/
tf.js.ReplaceObjectWithValues = function (objectToReplace, objectWithValues, attributeNameMatch) {
    if (attributeNameMatch === undefined) { attributeNameMatch = tf.js.GetFindReferenceInStringRegExp(); }
    if (tf.js.GetIsValidObject(objectToReplace) && tf.js.GetIsValidObject(objectWithValues) && tf.js.GetIsInstanceOf(attributeNameMatch, RegExp)) {
        for (var property in objectToReplace) {
            if (objectToReplace.hasOwnProperty(property)) {
                var propertyVal = objectToReplace[property];
                if (tf.js.GetIsNonEmptyString(propertyVal)) { objectToReplace[property] = tf.js.ReplaceWithValues(propertyVal, objectWithValues, propertyVal, attributeNameMatch); }
            }
        }
    }
    return objectToReplace;
}
tf.js.Spline1D = function (startCoord, startControlCoord, endControlCoord, endCoord) {
    var theThis, C1, C2, C3, C4;
    this.GetStartCoord = function () { return C4; }
    this.GetEndCoord = function () { return C1; }
    this.GetControlCoord = function (startControlBool) { return !!startControlBool ? C3 : C2; }
    this.GetCoord = function (t) {
        var t2 = t * t, t3 = t2 * t, invT = 1 - t, invT2 = invT * invT, invT3 = invT2 * invT;
        return C1 * t3 + 3 * (C2 * t2 * invT + C3 * t * invT2) + C4 * invT3;
    }
    this.GetVelocity = function (t) {
        var invT = 1 - t;
        return 3 * ((invT * invT * (C3 - C4)) + (t * t * (C1 - C2))) + 6 * invT * t * (C2 - C3);
    }
    this.GetAcceleration = function (t) { return 6 * ((1 - t) * (C2 - 2 * C3 + C4) + t * (C1 - 2 * C2 + C3)); }
    function initialize() {
        C1 = tf.js.GetFloatNumber(endCoord, 0);
        C2 = tf.js.GetFloatNumber(endControlCoord, 0);
        C3 = tf.js.GetFloatNumber(startControlCoord, 0);
        C4 = tf.js.GetFloatNumber(startCoord, 0);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.Spline2D = function (startCoords, startControlCoords, endControlCoords, endCoords) {
    var theThis, splines;
    this.GetStartCoords = function () { return [splines[0].GetStartCoord(), splines[1].GetStartCoord()]; }
    this.GetEndCoords = function () { return [splines[0].GetEndCoord(), splines[1].GetEndCoord()]; }
    this.GetControlCoords = function (startControlBool) { return [splines[0].GetControlCoord(startControlBool), splines[1].GetControlCoord(startControlBool)]; }
    this.GetCoords = function (t) { return [splines[0].GetCoord(t), splines[1].GetCoord(t)]; }
    this.GetVelocity = function (t) { return [splines[0].GetVelocity(t), splines[1].GetVelocity(t)]; }
    this.GetAcceleration = function (t) { return [splines[0].GetAcceleration(t), splines[1].GetAcceleration(t)]; }
    function initialize() {
        var zz = [0, 0];
        startCoords = tf.js.GetIsArrayWithMinLength(startCoords, 2) ? startCoords.slice(0) : zz,
        startControlCoords = tf.js.GetIsArrayWithMinLength(startControlCoords, 2) ? startControlCoords.slice(0) : zz,
        endControlCoords = tf.js.GetIsArrayWithMinLength(endControlCoords, 2) ? endControlCoords.slice(0) : zz,
        endCoords = tf.js.GetIsArrayWithMinLength(endCoords, 2) ? endCoords.slice(0) : zz,
        splines = [
            new tf.js.Spline1D(startCoords[0], startControlCoords[0], endControlCoords[0], endCoords[0]),
            new tf.js.Spline1D(startCoords[1], startControlCoords[1], endControlCoords[1], endCoords[1])
        ];
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * @public
 * @function
 * @summary - Retrieves the URL to the "Powered by TerraFly" logo in this platform of the <b>TerraFly API</b>
* @returns {string} - | {@link string} the logo URL
*/
tf.platform.GetPoweredByTerraFlyLogoImgStr = function () { return tf.platform.MakePlatformPath("image/svg/poweredByTF.svg"); }
/**
 * @public
 * @function
 * @summary - Retrieves the ["Powered by TerraFly" logo]{@link tf.dom.Img} from this platform of the <b>TerraFly API</b>
* @returns {tf.dom.Img} - | {@link tf.dom.Img} the logo
*/
tf.platform.GetPoweredByTerraFlyLogo = function () { return tf.GetStyles().CreateImageFullWidthHeight(tf.platform.GetPoweredByTerraFlyLogoImgStr()); }
/**
* @public
* @function
* @summary - Retrieves the full url to a resource in this platform of the <b>TerraFly API</b> given a relative path
* @param {string} srcRelPathNoLeadingSlash - the relative path, without a leading '\' or '/' character
* @returns {string} - | {@link string} the full url
*/
tf.platform.MakePlatformPath = function (srcRelPathNoLeadingSlash) { return tf.platform.GetURL() + srcRelPathNoLeadingSlash; }
// tf.units
/**
 * @public
 * @function
 * @summary - An [Easing Function]{@link tf.types.EasingFunction} that starts slow and speeds up
 * @param {tf.types.value01} t - the input value
 * @return {tf.types.value01} - | {@link tf.types.value01} the output value
 */
tf.units.EaseIn = function (t) { return Math.pow(t, 3); }; 
/**
 * @public
 * @function
 * @summary - An [Easing Function]{@link tf.types.EasingFunction} that starts fast and slows down
 * @param {tf.types.value01} t - the input value
 * @return {tf.types.value01} - | {@link tf.types.value01} the output value
 */
tf.units.EaseOut = function (t) { return 1 - ol.easing.easeIn(1 - t); };
/**
 * @public
 * @function
 * @summary - An [Easing Function]{@link tf.types.EasingFunction} that starts slow, speeds up, and then slows down again
 * @param {tf.types.value01} t - the input value
 * @return {tf.types.value01} - | {@link tf.types.value01} the output value
 */
tf.units.EaseInAndOut = function (t) { return 3 * t * t - 2 * t * t * t; }
/**
 * @public
 * @function
 * @summary - An [Easing Function]{@link tf.types.EasingFunction} that maintains the same rate of variation as its argument,
 * and can be used to achieve constant speed over time
 * @param {tf.types.value01} t - the input value
 * @return {tf.types.value01} - | {@link tf.types.value01} the output value
 */
tf.units.EaseLinear = function (t) { return t; }
/**
 * @public
 * @function
 * @summary - Retrieves the number of milliseconds in one day
 * @returns {number} - | {@link number} the number of milliseconds in one day
*/
tf.units.GetOneDayMillis = function () { return 24 * 60 * 60 * 1000; }
/**
 * @public
 * @function
 * @summary - Retrieves the number of days between two given dates
 * @param {Date} date1 - a date
 * @param {Date} date2 - a date
 * @returns {number} - | {@link number} the number of days between the two given dates
*/
tf.units.GetDaysBetweenDates = function (date1, date2) { return Math.round(Math.abs((date1.getTime() - date2.getTime()) / (tf.units.GetOneDayMillis()))); }
/**
 * @public
 * @function
 * @summary - Retrieves the {@link tf.units.UtmGdcConverter} singleton
 * @returns {tf.units.UtmGdcConverter} - | {@link tf.units.UtmGdcConverter} the singleton
*/
tf.units.GetUtmGdcConverter = function () { if (!tf.g_UtmGdcConverter) { tf.g_UtmGdcConverter = new tf.units.UtmGdcConverter(); } return tf.g_UtmGdcConverter; }
/**
 * @public
 * @function
 * @summary - Retrieves the {@link tf.units.LevelResolutionConverter} singleton
 * @returns {tf.units.LevelResolutionConverter} - | {@link tf.units.LevelResolutionConverter} the singleton
*/
tf.units.GetLevelResolutionConverter = function () { if (!tf.g_LevelResolutionConverter) { tf.g_LevelResolutionConverter = new tf.units.LevelResolutionConverter(); } return tf.g_LevelResolutionConverter; }
/**
 * @public
 * @function
 * @summary - Converts an angle in degrees to radians
 * @param {number} angle - in degrees
 * @returns {number} - | {@link number} angle in radians
*/
tf.units.DegreesToRadians = function (angle) { angle = tf.js.GetFloatNumber(angle, 0); return Math.PI * angle / 180; }
/**
 * @public
 * @function
 * @summary - Converts an angle in radians to degrees
 * @param {number} angle - in radians
 * @returns {number} - | {@link number} angle in degrees
*/
tf.units.RadiansToDegrees = function (angle) { angle = tf.js.GetFloatNumber(angle, 0); return 180 * angle / Math.PI; }
/**
 * @public
 * @function
 * @summary - Calculates the total distance in meters between the given <b>coords</b>, that should be formatted like [GeoJSON linestring coordinates]{@link tf.types.GeoJSONGeometryType},
 * i.e. coords is an array with 2 or more elements and its first element is also an array with 2 or more elements
 * @param {object} coords - the given coordinates
 * @param {boolean} wrapBool - if <b>true</b> adds the distance between the first and last points, defaults to {@link void}
 * @returns {number} - | {@link number} the total distance in meters
*/
tf.units.GetTotalDistanceInMeters = function (pointCoords, wrapBool) {
    var totalDist = 0;
    if (tf.js.GetLooksLikeLineStringCoords(pointCoords)) {
        var len = pointCoords.length, lastCoord = len - 1;
        for (var i = 0 ; i < lastCoord ; ++i) {
            totalDist += tf.units.GetDistanceInMetersBetweenMapCoords(pointCoords[i], pointCoords[i + 1]);
        }
        if (!!wrapBool) { totalDist += tf.units.GetDistanceInMetersBetweenMapCoords(pointCoords[0], pointCoords[lastCoord]); }
    }
    return totalDist;
}
tf.units.SplitSegment = function (startPoint, endPoint, nSplits) {
    var splitPoints = [];
    if ((startPoint = tf.js.GetMapCoordsFrom(startPoint)) !== undefined &&
        (endPoint = tf.js.GetMapCoordsFrom(endPoint)) !== undefined) {
        var X = startPoint[0], Y = startPoint[1], offX = endPoint[0] - X, offY = endPoint[1] - Y;
        for (var j = 0 ; j < nSplits ; ++j) {
            var mult = (j + 1) / (nSplits + 1);
            var dX = offX * mult, dY = offY * mult;
            splitPoints.push([X + dX, Y + dY]);
        }
    }
    return splitPoints;
}
tf.units.SplitLineStringSegments = function (pointCoords, maxSegDist, wrapBool, indicesArray) {
    if (tf.js.GetLooksLikeLineStringCoords(pointCoords) && maxSegDist !== undefined && tf.js.GetIsNonNegativeNumber(maxSegDist)) {
        var len = pointCoords.length, lastCoord = len - 1;
        var indexInIndices = 0, nIndices;
        if (tf.js.GetIsNonEmptyArray(indicesArray)) { nIndices = indicesArray.length; indexInIndices = 0; } else { indicesArray = null; }
        for (var i = 0 ; i < lastCoord ; ++i) {
            var pt1 = pointCoords[i], pt2 = pointCoords[i + 1];
            var thisDist = tf.units.GetDistanceInMetersBetweenMapCoords(pt1, pt2);
            if (!!indicesArray) { while (indexInIndices < nIndices && indicesArray[indexInIndices] <= i) { ++ indexInIndices; } }
            if (thisDist > maxSegDist) {
                var nSplits = Math.floor(thisDist / maxSegDist) + 1;
                var splitPoints = tf.units.SplitSegment(pt1, pt2, nSplits);
                for (var j = 0 ; j < splitPoints.length ; ++j) { pointCoords.splice(i + j + 1, 0, splitPoints[j]); }
                if (!!indicesArray) { for (var ind = indexInIndices ; ind < nIndices ; ind++) { indicesArray[ind] += (nSplits); } }
                i += nSplits;
                lastCoord += nSplits;
            }
        }
        if (!!wrapBool) {
            var pt1 = pointCoords[lastCoord], pt2 = pointCoords[0];
            var thisDist = tf.units.GetDistanceInMetersBetweenMapCoords(pt1, pt2);
            if (thisDist > maxSegDist) {
                var nSplits = Math.floor(thisDist / maxSegDist) + 1;
                var splitPoints = tf.units.SplitSegment(pt1, pt2, nSplits);
                pointCoords = pointCoords.concat(splitPoints);
            }
        }
    }
    return pointCoords;
}
tf.units.DisplaceMapCoords = function(mapCoords, angleRad, distanceInMeters) {
    var mc = tf.js.GetMapCoordsFrom(mapCoords);
    var lat = mapCoords[1], lon = mapCoords[0];
    distanceInMeters = distanceInMeters / 6371;
    var latRad = tf.units.RadiansToDegrees(lat);
    var lonRad = tf.units.RadiansToDegrees(lon);
    var newLatRad = Math.asin(Math.sin(latRad) * Math.cos(distanceInMeters) +
        Math.cos(latRad) * Math.sin(distanceInMeters) * Math.cos(angleRad));
    var newLonRad = lonRad + Math.atan2(Math.sin(angleRad) * Math.sin(distanceInMeters) * Math.cos(latRad),
        Math.cos(distanceInMeters) - Math.sin(latRad) * Math.sin(newLatRad));
    return (isNaN(newLatRad) || isNaN(newLonRad)) ? [0, 0] : [tf.units.DegreesToRadians(newLonRad), tf.units.DegreesToRadians(newLatRad)];
}
/**
 * @public
 * @function
 * @summary - Calculates the distance in meters between two given map coordinates
 * @param {tf.types.mapCoordinates} pointCoords1 - map coordinates 1
 * @param {tf.types.mapCoordinates} pointCoords2 - map coordinates 2
 * @returns {number} - | {@link number} the distance in meters
*/
tf.units.GetDistanceInMetersBetweenMapCoords = function (pointCoords1, pointCoords2) {
    /*var REarth = 6378137, toRad = Math.PI / 180;
    var lng1Radian = pointCoords1[0] * toRad, lat1Radian = pointCoords1[1] * toRad;
    var lng2Radian = pointCoords2[0] * toRad, lat2Radian = pointCoords2[1] * toRad;
    var distance = REarth * Math.acos(
        Math.cos(lat1Radian) * Math.cos(lat2Radian)
        * Math.cos(lng1Radian - lng2Radian)
        + Math.sin(lat1Radian) * Math.sin(lat2Radian)
        );
    return distance;*/
    return new tf.map.FeatureGeom({ type: "linestring", coordinates: [pointCoords1, pointCoords2] }).GetLength();
}
/**
 * @public
 * @function
 * @summary - Calculates the heading from the given start to end coordinates
 * @param {tf.types.mapCoordinates} start - start coordinates
 * @param {tf.types.mapCoordinates} end - end coordinates
 * @returns {number} - | {@link number} the angle in radians
*/
tf.units.GetMapHeading = function (start, end) {
    var heading = 0;
    if (tf.js.GetIsArrayWithMinLength(start, 2) && tf.js.GetIsArrayWithMinLength(end, 2)) {
        var fromLon = start[0], toLon = end[0], fromLat = start[1], toLat = end[1];
        var deltaX = (toLon - fromLon);
        var deltaY = (toLat - fromLat);
        heading = Math.atan2(deltaY, deltaX);
        //var len = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        /*if (len) {
            heading = Math.atan2(deltaY / len, deltaX / len) - Math.PI / 2;
            //if (heading < -Math.PI) { heading += 2 * Math.PI; } else if (heading > Math.PI) { heading -= 2 * Math.PI; }
            //while (heading > 0) { heading -= Math.PI * 2; }
        }*/
    }
    return heading;
}
/**
 * @public
 * @function
 * @summary - Normalizes the given angle to the [0..2*PI] range
 * @param {number} angle - the given angle, in radians
 * @returns {number} - | {@link number} the normalized angle, in radians
*/
tf.units.NormalizeAngle0To2PI = function (a) { var TwoPI = Math.PI * 2; return ((a % TwoPI) + TwoPI) % TwoPI; }
/**
 * @public
 * @function
 * @summary - Calculates the smallest arc between two given angles
 * @param {number} fromAngle - the given initial angle, in radians
 * @param {number} toAngle - the given final angle, in radians
 * @returns {number} - | {@link number} the smallest arc, in radians
*/
tf.units.GetShortestArcBetweenAngles = function (fromAngle, toAngle) {
    var PI = Math.PI, twoPI = PI + PI, threePI = twoPI + PI;
    //fromAngle = tf.units.NormalizeAngle0To2PI(fromAngle);
    //toAngle = tf.units.NormalizeAngle0To2PI(toAngle);
    return ((((toAngle - fromAngle) % twoPI) + threePI) % twoPI) - PI;
}
/**
 * @public
 * @class
 * @summary The {@link singleton} instance of this class, obtainable by calling {@link tf.units.GetUtmGdcConverter},
 * converts {@link tf.types.mapCoordinates} to and from {@link tf.types.mapUTMCoordinates}
*/
tf.units.UtmGdcConverter = function () {
    var RADIANS_PER_DEGREE = 0.0174532925199432957692;
    var DEGREES_PER_RADIAN = 57.2957795130823208768;
    var CScale = 0.9996;
    var A = 6378137, F = 1 / 298.257223563, C = (A) * (1 - F);
    var Eps2 = (F) * (2.0 - F), Eps25 = 0.25 * (Eps2), Epps2 = (Eps2) / (1.0 - Eps2), EF = F / (2.0 - F), Epsp2 = 0;
    var Con = (1.0 - Eps2), Con2 = 2 / (1.0 - Eps2), Con6 = 0.166666666666667, Con24 = 4 * .0416666666666667 / (1 - Eps2), Con120 = 0.00833333333333333, Con720 = 4 * 0.00138888888888888 / (1 - Eps2);
    var polx2b_i = 3.0 / 8.0 * (1.0 * Eps2 + 1.0 / 4.0 * Math.pow(Eps2, 2) + 15.0 / 128.0 * Math.pow(Eps2, 3) - 455.0 / 4096.0 * Math.pow(Eps2, 4));
    var polx3b_i = 15.0 / 256.0 * (1.0 * Math.pow(Eps2, 2) + 3.0 / 4.0 * Math.pow(Eps2, 3) - 77.0 / 128.0 * Math.pow(Eps2, 4));
    var polx4b_i = 35.0 / 3072.0 * (Math.pow(Eps2, 3) - 41.0 / 32.0 * Math.pow(Eps2, 4));
    var polx5b_i = -315.0 / 131072.0 * Math.pow(Eps2, 4);
    var poly1b = 1.0 - (1.0 / 4.0 * Eps2) - (3.0 / 64.0 * Math.pow(Eps2, 2)) - (5.0 / 256.0 * Math.pow(Eps2, 3)) - (175.0 / 16384.0 * Math.pow(Eps2, 4));
    var poly2b = polx2b_i * -2.0 + polx3b_i * 4.0 - polx4b_i * 6.0 + polx5b_i * 8.0;
    var poly3b = polx3b_i * -8.0 + polx4b_i * 32.0 - polx5b_i * 80.0;
    var poly4b = polx4b_i * -32.0 + polx5b_i * 192.0;
    var poly5b = polx5b_i * -128.0;
    var polx1a_i = 1.0 - Eps2 / 4.0 - 3.0 / 64.0 * Math.pow(Eps2, 2) - 5.0 / 256.0 * Math.pow(Eps2, 3) - 175.0 / 16384.0 * Math.pow(Eps2, 4);
    var polx2a_i = 3.0 / 2.0 * EF - 27.0 / 32.0 * Math.pow(EF, 3);
    var polx4a_i = 21.0 / 16.0 * Math.pow(EF, 2) - 55.0 / 32.0 * Math.pow(EF, 4);
    var polx6a_i = 151.0 / 96.0 * Math.pow(EF, 3);
    var polx8a_i = 1097.0 / 512.0 * Math.pow(EF, 4);
    var conap = A * polx1a_i;
    var polx2b = polx2a_i * 2.0 + polx4a_i * 4.0 + polx6a_i * 6.0 + polx8a_i * 8.0;
    var polx3b = polx4a_i * -8.0 - polx6a_i * 32.0 - 80.0 * polx8a_i;
    var polx4b = polx6a_i * 32.0 + 192.0 * polx8a_i;
    var polx5b = -128.0 * polx8a_i;
    /**
     * @public
     * @function
     * @summary - Converts UTM coordinates into Map coordinates
     * @param {tf.types.mapUTMCoordinates} xyzoneCoords - UTM coordinates
     * @returns {tf.types.mapCoordinates} - | {@link tf.types.mapCoordinates} map coordinates
    */
    this.UtmToGdc = function (xyzoneCoords) {
        var latitude = 0, longitude = 0;
        if (tf.js.GetIsArrayWithLength(xyzoneCoords, 3)) {
            var x = xyzoneCoords[0];
            var y = xyzoneCoords[1];
            var zone = xyzoneCoords[2];
            var hemisphere_north = zone >= 0; if (!hemisphere_north) { zone = -zone; }
            var source_x = (x - 500000.0) / 0.9996;
            var source_y = hemisphere_north ? y / 0.9996 : (y - 1.0E7) / 0.9996;
            var u = source_y / conap, su = Math.sin(u), cu = Math.cos(u), su2 = su * su; // TEST U TO SEE IF AT POLES
            var xlon0 = (6.0 * (zone) - 183.0) / DEGREES_PER_RADIAN;
            /* THE SNYDER FORMULA FOR PHI1 IS OF THE FORM: PHI1=U+POLY2A*Sin(2U)+POLY3A*Sin(4U)+POLY4ASin(6U)+...
            BY USINGG MULTIPLE ANGLE TRIGONOMETRIC IDENTITIES AND APPROPRIATE FACTORING JUST THE SINE AND COSINE ARE REQUIRED NOW READY TO GET PHI1 */
            var temp = polx2b + su2 * (polx3b + su2 * (polx4b + su2 * polx5b));
            var phi1 = u + su * cu * temp;
            // COMPUTE VARIABLE COEFFICIENTS FOR FINAL RESULT COMPUTE THE VARIABLE COEFFICIENTS OF THE LAT AND LON EXPANSIONS
            var sp = Math.sin(phi1), sp2 = sp * sp, cp = Math.cos(phi1), cp2 = cp * cp, tp = sp / cp, tp2 = tp * tp;
            var eta2 = Epsp2 * cp2; // note 2015-10-14 Epsp2 is always 0 => eta2 is always 0
            var top = 0.25 - (sp2 * (Eps2 / 4));
            // inline sq root
            var rn = A / ((0.25 - Eps25 * sp2 + 0.9999944354799 / 4) + (0.25 - Eps25 * sp2) / (0.25 - Eps25 * sp2 + 0.9999944354799 / 4));
            var b3 = 1.0 + tp2 + tp2 + eta2, b4 = 5 + tp2 * (3 - 9 * eta2) + eta2 * (1 - 4 * eta2);
            var b5 = 5 + tp2 * (tp2 * 24.0 + 28.0) + eta2 * (tp2 * 8.0 + 6.0);
            var b6 = 46.0 - 3.0 * eta2 + tp2 * (-252.0 - tp2 * 90.0);
            b6 = eta2 * (b6 + eta2 * tp2 * (tp2 * 225.0 - 66.0));
            b6 += 61.0 + tp2 * (tp2 * 45.0 + 90.0);
            var d1 = source_x / rn, d2 = d1 * d1;
            latitude = (phi1 - tp * top * (d2 * (Con2 + d2 * ((-Con24) * b4 + d2 * Con720 * b6)))) * DEGREES_PER_RADIAN;
            longitude = (xlon0 + d1 * (1.0 + d2 * (-Con6 * b3 + d2 * Con120 * b5)) / cp) * DEGREES_PER_RADIAN;
        }
        return [longitude, latitude];
    }
    /**
     * @public
     * @function
     * @summary - Converts Map coordinates into UTM coordinates
     * @param {tf.types.mapCoordinates} lonLatCoords - Map coordinates
     * @returns {tf.types.mapUTMCoordinates} - | {@link tf.types.mapUTMCoordinates} UTM coordinates
    */
    this.GdcToUtm = function (lonLatCoords) {
        var x = 0, y = 0, zone = 0;
        if (tf.js.GetIsArrayWithLength(lonLatCoords, 2)) {
            var longitude = lonLatCoords[0];
            var latitude = lonLatCoords[1];
            var hemisphere_north = latitude >= 0;
            var source_lat = latitude * RADIANS_PER_DEGREE, source_lon = longitude * RADIANS_PER_DEGREE;
            var s1 = Math.sin(source_lat), c1 = Math.cos(source_lat), tx = s1 / c1, s12 = s1 * s1;
            // USE IN-LINE SQUARE ROOT
            var rn = A / ((0.25 - Eps25 * s12 + .9999944354799 / 4) + (0.25 - Eps25 * s12) / (0.25 - Eps25 * s12 + 0.9999944354799 / 4));
            // Compute Zone
            zone = (source_lon * 30.0 / 3.1415926 + 31); zone = zone <= 0 ? 1 : zone >= 61 ? 60 : zone;
            // this statement is very important. zone should be an integer. there would be a large deviation without it.
            if ((zone % 1) != 0) { zone = zone - (zone % 1); }
            // COMPUTE UTM COORDINATES
            var axlon0 = (zone * 6 - 183) * RADIANS_PER_DEGREE;
            var al = (source_lon - axlon0) * c1;
            var sm = s1 * c1 * (poly2b + s12 * (poly3b + s12 * (poly4b + s12 * poly5b))); sm = A * (poly1b * source_lat + sm);
            var tn2 = tx * tx, cee = Epps2 * c1 * c1, al2 = al * al;
            var poly1 = 1.0 - tn2 + cee;
            var poly2 = 5.0 + tn2 * (tn2 - 18.0) + cee * (14.0 - tn2 * 58.0);
            // COMPUTE EASTING
            x = (CScale * rn * al * (1.0 + al2 * (0.166666666666667 * poly1 + 0.00833333333333333 * al2 * poly2))) + 5.0E5;
            //COMPUTE NORTHING
            poly1 = 5.0 - tn2 + cee * (cee * 4.0 + 9.0);
            poly2 = 61.0 + tn2 * (tn2 - 58.0) + cee * (270.0 - tn2 * 330.0);
            y = CScale * (sm + rn * tx * al2 * (0.5 + al2 * (0.0416666666666667 * poly1 + 0.00138888888888888 * al2 * poly2)));
            if (source_lat < 0.0) { y += 1.0E7; }
            // compute isnorth
            if (!hemisphere_north) { zone = -zone; }
        }
        return [x, y, zone];
    }
};
/**
 * @public
 * @function
 * @summary - Converts Map coordinates into UTM coordinates
 * @param {tf.types.mapCoordinates} lonLatCoords - Map coordinates
 * @returns {tf.types.mapUTMCoordinates} - | {@link tf.types.mapUTMCoordinates} UTM coordinates
*/
tf.units.GdcToUtm = function (lonlatCoords) { return tf.units.GetUtmGdcConverter().GdcToUtm(lonlatCoords); }
/**
 * @public
 * @function
 * @summary - Converts UTM coordinates into Map coordinates
 * @param {tf.types.mapUTMCoordinates} xyzoneCoords - UTM coordinates
 * @returns {tf.types.mapCoordinates} - | {@link tf.types.mapCoordinates} map coordinates
*/
tf.units.UtmToGdc = function (xyzoneCoords) { return tf.units.GetUtmGdcConverter().UtmToGdc(xyzoneCoords); }
/**
 * @public
 * @class
 * @summary The {@link singleton} instance of this class, obtainable by calling {@link tf.units.GetLevelResolutionConverter},
 * converts {@link tf.types.mapLevel} values to and from {@link tf.types.mapResolution} values
*/
tf.units.LevelResolutionConverter = function () {
    var theThis, zoomLevels, maxLevels, minResolutions;
    /**
     * @public
     * @function
     * @summary - Obtains the map level corresponding to the given map resolution
     * @param {tf.types.mapResolution} resolution - the given map resolution
     * @returns {tf.types.mapLevel} - | {@link tf.types.mapLevel} the corresponding map level
    */
    this.GetLevelByResolution = function (resolution) {
        resolution = tf.js.GetFloatNumber(resolution, tf.consts.defaultRes);
        var level = 0; while (level < maxLevels - 1 && resolution < minResolutions[level]) { ++level; }
        return level + 1;
    }
    /**
     * @public
     * @function
     * @summary - Obtains the map resolution corresponding to the given map level
     * @param {tf.types.mapLevel} level - the given map level
     * @returns {tf.types.mapResolution} - | {@link tf.types.mapResolution} the corresponding map resolution
    */
    this.GetResolutionByLevel = function (level) { return zoomLevels[tf.js.GetIntNumberInRange(level, tf.consts.minLevel, maxLevels/*tf.consts.maxLevel*/, tf.consts.defaultLevel) - 1]; }
    function initialize() {
        var sqrt2 = Math.SQRT2;
        minResolutions = [];
        zoomLevels = [];
        //LatlongData
        zoomLevels[0] = 78271.5170; zoomLevels[1] = 39135.7585; zoomLevels[2] = 19567.8792; zoomLevels[3] = 9783.9396;
        zoomLevels[4] = 4891.9698; zoomLevels[5] = 2445.9849; zoomLevels[6] = 1222.9925; zoomLevels[7] = 611.4962;
        zoomLevels[8] = 305.7481; zoomLevels[9] = 152.8741;
        // UTMData
        zoomLevels[10] = 76.8; zoomLevels[11] = 38.4; zoomLevels[12] = 19.2; zoomLevels[13] = 9.6;
        zoomLevels[14] = 4.8; zoomLevels[15] = 2.4; zoomLevels[16] = 1.2; zoomLevels[17] = 0.6;
        zoomLevels[18] = 0.3; zoomLevels[19] = 0.15; zoomLevels[20] = 0.075;
        zoomLevels[21] = 0.0375; zoomLevels[22] = 0.01875; zoomLevels[23] = 0.009375; zoomLevels[24] = 0.0046875;
        maxLevels = zoomLevels.length;
        for (var i = 0 ; i < maxLevels ; ++i) { minResolutions[i] = zoomLevels[i] / sqrt2; }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * @public
 * @function
 * @summary - Obtains the map level corresponding to the given map resolution
 * @param {tf.types.mapResolution} resolution - the given map resolution
 * @returns {tf.types.mapLevel} - | {@link tf.types.mapLevel} the corresponding map level
*/
tf.units.GetLevelByResolution = function (resolution) { return tf.units.GetLevelResolutionConverter().GetLevelByResolution(resolution); }
/**
 * @public
 * @function
 * @summary - Obtains the map resolution corresponding to the given map level
 * @param {tf.types.mapLevel} level - the given map level
 * @returns {tf.types.mapResolution} - | {@link tf.types.mapResolution} the corresponding map resolution
*/
tf.units.GetResolutionByLevel = function (level) { return tf.units.GetLevelResolutionConverter().GetResolutionByLevel(level); }
/**
 * @public
 * @function
 * @summary - Obtains the minimum map level required to display the given map extent
 * @param {tf.types.mapCoordinates} pointNW - the left top corner of the extent
 * @param {tf.types.mapCoordinates} pointSE - the right bottom corner of the extent
 * @returns {tf.types.mapLevel} - | {@link tf.types.mapLevel} the minimum map level required to display the given map extent
*/
tf.units.GetBoundsZoomLevel = function (pointNW, pointSE, width, height) {
    var res1 = tf.units.GetDistanceInMetersBetweenMapCoords(pointNW, [pointNW[0], pointSE[1]]) / height;
    var res2 = tf.units.GetDistanceInMetersBetweenMapCoords(pointNW, [pointSE[0], pointNW[1]]) / width;
    var res = (res1 > res2) ? res1 : res2;
    return tf.units.GetLevelByResolution(res) - 1;
}
/**
 * @public
 * @function
 * @summary - Converts length in meters to feet
 * @param {number} length - in meters
 * @returns {number} - | {@link number} length in feet
*/
tf.units.GetMetersToFeet = function (length) { return length * 3.28084; }
/**
 * @public
 * @function
 * @summary - Converts speed in km/h to mph
 * @param {number} speed - in km/h
 * @returns {number} - | {@link number} speed in mph
*/
tf.units.GetKMHToMPH = function (speed) { return speed * 0.621371; }
/**
 * @public
 * @function
 * @summary - Converts area in square meters to square feet
 * @param {number} area - in square meters
 * @returns {number} - | {@link number} area in square feet
*/
tf.units.GetSquareMetersToSquareFeet = function (area) { return tf.units.GetMetersToFeet(tf.units.GetMetersToFeet(area)); }
/**
 * @public
 * @function
 * @summary - Converts area in square meters to acres
 * @param {number} area - in square meters
 * @returns {number} - | {@link number} area in acres
*/
tf.units.GetAcresFromSquareMeters = function (area) { return tf.js.GetFloatNumber(area, 0) / 4046.873; }
/**
 * @private
 * @function
 * @summary - Converts map units from the TerraFly API format into the underlying map engine's format
 * @param {tf.types.mapCoordinates} pointCoords - map coordinates
 * @returns {tf.types.mapCoordinates} - | {@link tf.types.mapCoordinates} converted map coordinates
*/
tf.units.TM2OL = function (pointCoords) { return ol.proj.transform(pointCoords, tf.consts.tmSystem, tf.consts.olSystem); }
/**
 * @private
 * @function
 * @summary - Converts map units from the underlying map engine's format into the TerraFly API format
 * @param {tf.types.mapCoordinates} pointCoords - map coordinates
 * @returns {tf.types.mapCoordinates} - | {@link tf.types.mapCoordinates} converted map coordinates
*/
tf.units.OL2TM = function (pointCoords) { return ol.proj.transform(pointCoords, tf.consts.olSystem, tf.consts.tmSystem); }
// tf.browser
/**
 * @public
 * @function
 * @summary - Returns the number of actual pixels corresponding to one logical pixel
 * @returns {number} - | {@link number} the ratio
*/
tf.browser.GetDevicePixelRatio = function () {
    var ratio = 1;
    // To account for zoom, change to use deviceXDPI instead of systemXDPI, only allow for values > 1
    if (window.screen.systemXDPI !== undefined && window.screen.logicalXDPI !== undefined && window.screen.systemXDPI > window.screen.logicalXDPI) {
        ratio = window.screen.systemXDPI / window.screen.logicalXDPI;
    }
    else if (window.devicePixelRatio !== undefined) { ratio = window.devicePixelRatio; }
    return ratio;
}
/**
 * @public
 * @function
 * @summary - Checks if the Browser is in fullscreen mode
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.browser.GetIsFullScreen = function () { var doc = document; return !!(doc.webkitIsFullScreen || doc.mozFullScreen || doc.msFullscreenElement || doc.fullscreenElement); };
/**
 * @public
 * @function
 * @summary - Requests the Browser to display the given container in fullscreen mode
 * @param {HTMLElementLike} container - the container
 * @returns {void} - | {@link void} no return value
*/
tf.browser.RequestFullScreen = function (container) {
    if (container = tf.dom.GetHTMLElementFrom(container)) {
        if (container.webkitRequestFullscreen) { container.webkitRequestFullscreen(); }
        else if (container.mozRequestFullScreen) { container.mozRequestFullScreen(); }
        else if (container.msRequestFullscreen) { container.msRequestFullscreen(); }
        else if (container.requestFullscreen) { container.requestFullscreen(); }
    }
}
/**
 * @public
 * @function
 * @summary - Requests the Browser to exit fullscreen mode
 * @returns {void} - | {@link void} no return value
*/
tf.browser.ExitFullScreen = function () {
    var doc = document;
    if (doc.webkitCancelFullScreen) { doc.webkitCancelFullScreen(); } else if (doc.mozCancelFullScreen) { doc.mozCancelFullScreen(); }
    else if (doc.msExitFullscreen) { doc.msExitFullscreen(); } else if (doc.exitFullscreen) { doc.exitFullscreen(); }
};
/**
 * @private
 * @function
 * @summary Calculates {@link tf.browser.Type} use the pre-calculated object instead
 * @returns {boolean} - | {@link boolean } <b>true</b> if the Browser is compatible, <b>false</b> otherwise
*/
tf.browser.GetBrowserType = function () {
    var userAgent = navigator.userAgent.toLowerCase();
    var type = "unknown";
    var version = -1;
    var isAndroidMobile = !!userAgent.match(/Android/i);
    var isBlackBerryMobile = !!userAgent.match(/BlackBerry/i);
    var isiOSMobile = !!userAgent.match(/iPhone|iPad|iPod/i);
    var isOperaMobile = !!userAgent.match(/Opera Mini/i);
    var isWindowsMobile = !!userAgent.match(/IEMobile/i) || !!userAgent.match(/WPDesktop/i);
    var isAnyMobile = isAndroidMobile || isBlackBerryMobile || isiOSMobile || isOperaMobile || isWindowsMobile;
    var isIE = false, isFireFox = false, isChrome = false;
    if (/webkit/.test(userAgent)) {
        if (/chrome/.test(userAgent)) {
            type = "chrome";
            version = (userAgent.match(/.+(?:chrome)[\/]([\d.]+)/) || [])[1];
            isChrome = true;
        }
        else {
            type = "safari";
            version = (userAgent.match(/.+(?:version)[\/]([\d.]+)/) || [])[1];
        }
    }
    else if (/opera/.test(userAgent)) {
        type = "opera";
        version = (userAgent.match(/.+(?:ra)[\/]([\d.]+)/) || [])[1];
    }
    else if ((/msie/.test(userAgent) || /trident.*rv\:11\./.test(userAgent)) && !/opera/.test(userAgent)) {
        isIE = true;
        type = "msie";
        version = (userAgent.match(/(?:ie)[ ]([\d.]+)/) || [])[1];
    }
    else if (/firefox/.test(userAgent) && !/(compatible|webkit)/.test(userAgent)) {
        isFireFox = true;
        type = "firefox";
        version = (userAgent.match(/.+(?:firefox)[\/]([\d.]+)/) || [])[1];
    }
    else if (/mozilla/.test(userAgent) && !/(compatible|webkit)/.test(userAgent) && !/(compatible|firefox)/.test(userAgent)) {
        type = "mozilla";
        version = (userAgent.match(/.+(?:la)[\/]([\d.]+)/) || [])[1];
    }
    return {
        type: type,
        version: version,
        userAgent: userAgent,
        isIE: isIE,
        isFireFox: isFireFox,
        isChrome: isChrome,
        isAndroidMobile: isAndroidMobile,
        isBlackBerryMobile: isBlackBerryMobile,
        isiOSMobile: isiOSMobile,
        isOperaMobile: isOperaMobile,
        isWindowsMobile: isWindowsMobile,
        isAnyMobile: isAnyMobile
    };
};
/**
 * @public
 * @object
 * @summary Provides information about the Browser being used
 * @property {string} type - one of 'chrome', 'safari', 'opera', 'msie', 'firefox', 'mozilla', or 'unknown'
 * @property {string} version - obtained from navigator.userAgent
 * @property {boolean} isIE - true if IE, false otherwise
 * @property {boolean} isFireFox - true if Firefox, false otherwise
 * @property {boolean} isChrome - true if Chrome, false otherwise
 * @property {boolean} isAndroidMobile - true if Android in mobile platform, false otherwise
 * @property {boolean} isBlackBerryMobile - true if Blackberry in mobile platform, false otherwise
 * @property {boolean} isiOSMobile - true if iOS in mobile platform, false otherwise
 * @property {boolean} isOperaMobile - true if Opera in mobile platform, false otherwise
 * @property {boolean} isWindowsMobile - true if Windows in mobile platform, false otherwise
 * @property {boolean} isAnyMobile - true if in mobile platform, false otherwise
*/
tf.browser.Type = tf.browser.GetBrowserType();
/**
 * @public
 * @function
 * @summary Determines if the Browser is compatible with the TerraFly API
 * @returns {boolean} - | {@link boolean } <b>true</b> if the Browser is compatible, <b>false</b> otherwise
*/
tf.browser.IsCompatible = function () { return tf.browser.HasCanvas(); }
/**
 * @public
 * @function
 * @summary Determines if the Browser supports touch events
 * @returns {boolean} - | {@link boolean } <b>true</b> if the Browser supports touch events, <b>false</b> otherwise
*/
tf.browser.HasTouch = function () { return ol !== undefined ? (ol.has !== undefined ? ol.has.TOUCH : false) : false; }
/**
 * @public
 * @function
 * @summary Determines if the Browser supports the 'canvas' HTML5 element
 * @returns {boolean} - | {@link boolean } <b>true</b> if the Browser supports canvas , <b>false</b> otherwise
*/
tf.browser.HasCanvas = function () {
    var elem = document.createElement('canvas');
    return !!(elem.getContext && elem.getContext('2d'));
}
// tf.map
/**
 * @public
 * @function
 * @summary Retrieves a valid map engine from the given name, defaults to {@link tf.consts.mapnik2Engine}
 * @param {string} mapEngineStr - map engine candidate
 * @returns {tf.types.mapEngine} - | {@link tf.types.mapEngine} a valid map engine
*/
tf.map.GetMapEngineFrom = function (mapEngineStr) {
    var mapEngine = (tf.js.GetNonEmptyString(mapEngineStr, tf.consts.mapnik2Engine)).toLowerCase();
    if (mapEngine !== tf.consts.mapnikEngine) { mapEngine = tf.consts.mapnik2Engine; }
    return mapEngine;
}
/**
 * @public
 * @function
 * @summary Creates an array of convex hull coordinates of the given coordinates, which should be formatted like [GeoJSON linestring coordinates]{@link tf.types.GeoJSONGeometryType},
 * i.e. coords is an array with 2 or more elements and its elemets each an array with 2 or more elements
 * @param {array<tf.types.mapCoordinates>} coords - the given coordinates
 * @returns {array<tf.types.mapCoordinates>} - | {@link array<tf.types.mapCoordinates>} the coordinates of the convex hull
*/
tf.map.GetConvexHull = function (coords) {
    var allBaseLines;
    function getDistant(cpt, bl) { var Vy = bl[1][0] - bl[0][0], Vx = bl[0][1] - bl[1][1]; return (Vx * (cpt[0] - bl[0][0]) + Vy * (cpt[1] - bl[0][1])) }
    function findMostDistantPointFromBaseLine(baseLine, points) {
        var maxD = 0, maxPt = [], newPoints = [];
        for (var idx in points) {
            var pt = points[idx], d = getDistant(pt, baseLine);
            if (d > 0) { newPoints.push(pt); } else { continue; }
            if (d > maxD) { maxD = d; maxPt = pt; }
        }
        return { 'maxPoint': maxPt, 'newPoints': newPoints };
    }
    function buildConvexHull(baseLine, points) {
        var convexHullBaseLines = [];
        var t = findMostDistantPointFromBaseLine(baseLine, points);
        allBaseLines.push(baseLine);
        if (t.maxPoint.length) {
            convexHullBaseLines = convexHullBaseLines.concat(buildConvexHull([baseLine[0], t.maxPoint], t.newPoints));
            convexHullBaseLines = convexHullBaseLines.concat(buildConvexHull([t.maxPoint, baseLine[1]], t.newPoints));
            return convexHullBaseLines;
        } else { return [baseLine]; }
    }
    //function isSamePt(pt1, pt2) { return pt1 !== undefined && pt2 !== undefined && pt1[0] == pt2[0] && pt1[1] == pt2[1]; }
    function getConvexHull(points) {
        var ch = [];
        if (tf.js.GetLooksLikeLineStringCoords(points)) {
            var maxX, minX, maxPt, minPt;
            allBaseLines = [];
            for (var idx in points) {
                var pt = points[idx];
                if (pt[0] > maxX || !maxX) { maxPt = pt; maxX = pt[0]; }
                if (pt[0] < minX || !minX) { minPt = pt; minX = pt[0]; }
            }
            var chSegments = [].concat(buildConvexHull([minPt, maxPt], points), buildConvexHull([maxPt, minPt], points));
            ch.push(chSegments[0][0]); for (var i in chSegments) { ch.push(chSegments[i][1]); }
            /*var lastPt;
            tf.GetDebug().LogIfTest(chSegments.length);
            for (var i in chSegments) {
                if (!isSamePt(lastPt, chSegments[i][0])) { ch.push(lastPt = chSegments[i][0]); } else { tf.GetDebug().LogIfTest('same pt (0)'); }
                if (!isSamePt(lastPt, chSegments[i][1])) { ch.push(lastPt = chSegments[i][1]); } else { tf.GetDebug().LogIfTest('same pt (1)'); }
            }*/
        }
        return ch;
    }
    return getConvexHull(coords);
};
tf.helpers.Timer = function () {
    var theThis, time, lastCheckedAnimationTime, isPaused, speed;
    this.GetTime = function () { return getTime(); }
    this.SetTime = function (timeSet) { time = timeSet; }
    this.GetIsPaused = function () { return isPaused; }
    this.Pause = function (bool) { isPaused = bool; }
    this.SetSpeed = function (speedSet) { speed = speedSet; }
    this.GetSpeed = function () { return speed; }
    function getTime() {
        var now = Date.now();
        if (!isPaused) { time += (now - lastCheckedAnimationTime) * speed; }
        lastCheckedAnimationTime = now;
        return time;
    }
    function initialize() { lastCheckedAnimationTime = Date.now(); time = 0; isPaused = false; speed = 1; }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.Collection = function (settings) {
    var theThis, collection, availableIDs, nextID, count, type;
    this.GetType = function () { return type; }
    this.Add = function (object) {
        var id;
        if (object !== undefined && (type == undefined || tf.js.GetIsInstanceOf(object, type))) {
            id = availableIDs.length > 0 ? availableIDs.shift() : nextID++;
            collection[id] = object;
            ++count;
        }
        return id;
    }
    this.Get = function (id) { return collection[id]; }
    this.Del = function (id) {
        var deleted;
        if (deleted = (collection[id] !== undefined)) {
            availableIDs.push(id); delete collection[id];
            --count;
        }
        return deleted;
    }
    this.GetCount = function () { return count; }
    this.ForEach = function (callback) {
        if (!!(callback = tf.js.GetFunctionOrNull(callback))) { for (var i in collection) { callback(collection[i]); } }
    }
    this.Empty = function () { collection = {}; count = 0; }
    function initialize() {
        collection = {};
        count = 0;
        nextID = 1;
        availableIDs = [];
        if (tf.js.GetIsValidObject(settings)) {
            if (settings.type !== undefined) {
                type = settings.type;
            }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Settings used in the creation of [Insertable]{@link tf.dom.Insertable} instances
 * @public
 * @typedef {object} tf.types.InsertableSettings
 * @property {object} domObj - a mandatory property
 * @property {HTMLElementLike} domElement - a mandatory property
*/
/**
 * @public
 * @class
 * @summary Insertable is a base class for other API classes whose instances can be inserted into the HTML Document Object Model.
 * @param {tf.types.InsertableSettings} settings - creation settings
 */
tf.dom.Insertable = function (settings) {
    var theThis, domObj, domElement;
    /**
     * @public
     * @function
     * @summary - Retrieves the {@link object} associated with this Insertable instance
     * @returns {object} - | {@link object} the element
    */
    this.GetDomObj = function () { return domObj; }
    /**
     * @public
     * @function
     * @summary - Retrieves the {@link HTMLElementLike} associated with this Insertable instance
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the element
    */
    this.GetHTMLElement = function () { return domElement; }
    /**
     * @public
     * @function
     * @summary - Retrieves the {@link HTMLElement} parent node of the {@link HTMLElementLike} instance associated with this Insertable instance
     * @returns {HTMLElement} - | {@link HTMLElement} the parent node object
    */
    this.GetParentNode = function () { return !!domElement ? domElement.parentNode : null; }
    /**
     * @public
     * @function
     * @summary - Adds this Insertable instance to the given {@link HTMLElementLike} instance
     * @param {HTMLElementLike} elem - the given instance
     * @returns {void} - | {@link void} no return value
    */
    this.AppendTo = function (elem) { if (!!domElement) { tf.dom.AppendTo(theThis, elem); } }
    function initialize() {
        if (!!(domObj = tf.js.GetIsValidObject(settings.domObj) ? settings.domObj : null)) {
            if (!(domElement = tf.dom.GetHTMLElementFrom(settings.domElement))) {
                domObj = null;
                tf.GetDebug().LogIfTest("Insertable: failed to get HTML element");
            }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Settings used in the creation of [Element]{@link tf.dom.Element} instances
 * @public
 * @typedef {object} tf.types.ElementSettings
 * @property {object} domObj - a mandatory property
 * @property {HTMLElementLike} domElement - a mandatory property
 * @property {string} id - optional id. If defined, sets the HTML <b>id</b> property, defaults to {@link void}
 * @property {tf.types.CSSStyleName} cssClass - optional css class. If defined, sets the HTML <b>class</b> property, defaults to {@link void}
 * @property {string} tooltip - optional tooltip string. If defined, sets the HTML <b>title</b> property, defaults to {@link void}
 * @property {string} value - optional value string. If defined, sets the HTML <b>value</b> property, defaults to {@link void}
 * @property {boolean} addTextContentAsSpan - If <b>true</b> this instance creates HTML spans when adding text content, if <b>false</b> text content is used as an HTML id. Defaults to <b>true</b>
 * @property {tf.types.CSSStyleName} spanCSSClass - optional css class used when adding HTML spans to this instance, defaults to {@link void}
*/
/**
 * @public
 * @class
 * @summary Element is an [Insertable]{@link tf.dom.Insertable} used as base class for other API classes whose instances are directly 
 * related with standard elements in the HTML Document Object Model, such as <b>'div'</b>.
 * @param {tf.types.ElementSettings} settings - creation settings
 * @extends {tf.dom.Insertable}
 */
tf.dom.Element = function (settings) {
    var theThis, domObj, domElement, spanCSSClass, addTextContentAsSpan, onClick;
    /**
     * @public
     * @function
     * @summary - Call this function before disposing of this Element instance to perform clean-up
     * @param {string} newValue - the value
     * @returns {void} - | {@link void} no return value
    */
    this.OnDelete = function () { return onDelete(); }
    /**
     * @public
     * @function
     * @summary - Sets this instance's HTML <b>value</b> property
     * @param {string} newValue - the value
     * @returns {void} - | {@link void} no return value
    */
    this.SetValue = function (newValue) { if (!!domElement) { domElement.value = tf.js.GetNonEmptyString(newValue, ''); } }
    /**
     * @public
     * @function
     * @summary - Retrieves this instance's HTML <b>value</b> property
     * @returns {string} - | {@link string} the value
    */
    this.GetValue = function () { return !!domElement ? domElement.value.trim() : ''; }
    /**
     * @public
     * @function
     * @summary - Sets a [Click Listener]{@link tf.events.DOMClickListener} for this Element instance
     * @param {tf.types.MultiDOMEventListenerCallBack} callBack - to receive event notifications
     * @param {object} optionalScope - optional scope used with <b>callBack</b>
     * @param {object} callBackSettings - application defined properties, to be passed to <b>callBack</b> during notifications
     * @returns {void} - | {@link void} no return value
    */
    this.SetOnClick = function (callBack, optionalScope, callBackSettings) {
        if (onClick) { onClick.OnDelete(); }
        onClick = new tf.events.DOMClickListener({ target: domElement, callBack: callBack, optionalScope: optionalScope, callBackSettings: callBackSettings });
    }
    /**
     * @public
     * @function
     * @summary - Removes any content that was previously added to this Element instance
     * @returns {void} - | {@link void} no return value
    */
    this.ClearContent = function () { tf.dom.RemoveAllChildren(theThis); domElement.innerHTML = ''; }
    /**
     * @public
     * @function
     * @summary - Replaces any content that was previously added to this Element instance with the given new contents
     * @param {...HTMLElementLike} newContents - zero or more comma separated contents to added
     * @returns {void} - | {@link void} no return value
    */
    this.ReplaceContent = function () { theThis.ClearContent(); theThis.AddContent.apply(theThis, arguments); }
    /**
     * @public
     * @function
     * @summary - Adds the given new content to contents that were previously added to this Element instance
     * @param {...HTMLElementLike} newContents - zero or more comma separated contents to added
     * @returns {void} - | {@link void} no return value
    */
    this.AddContent = function () {
        for (var i in arguments) {
            var elem = arguments[i];
            if (!!elem) {
                if (tf.js.GetIsString(elem)) {
                    if (addTextContentAsSpan) {
                        var htmlSpanDiv = (new tf.dom.Span({ cssClass: spanCSSClass })).GetHTMLElement();
    
                        htmlSpanDiv.innerHTML = elem;
                        domElement.appendChild(htmlSpanDiv);
                    }
                    else { domElement.appendChild(document.createTextNode(elem)); }
                }
                else if (tf.js.GetFunctionOrNull(elem.AppendTo)) { elem.AppendTo(theThis); }
                else if (elem = tf.dom.GetHTMLElementFrom(elem)) { domElement.appendChild(elem); }
            }
        }
    }
    /**
     * @public
     * @function
     * @summary - Inserts the the given new content before an existing content
     * @param {HTMLElementLike} newContent - the content  to insert
     * @param {HTMLElementLike} existingContent - the existing content, before which <b>newContent</b> will be inserted
     * @returns {void} - | {@link void} no return value
    */
    this.InsertContentBefore = function (newContent, existingContent) {
        if (!!(newContent = tf.dom.GetHTMLElementFrom(newContent)) && !!(existingContent = tf.dom.GetHTMLElementFrom(existingContent))) {
            if (existingContent.parentNode == domElement) { domElement.insertBefore(newContent, existingContent); }
        }
    }
    /**
     * @public
     * @function
     * @summary - Inserts the the given new content after an existing content
     * @param {HTMLElementLike} newContent - the content  to insert
     * @param {HTMLElementLike} existingContent - the existing content, after which <b>newContent</b> will be inserted
     * @returns {void} - | {@link void} no return value
    */
    this.InsertContentAfter = function (newContent, existingContent) {
        if (!!(newContent = tf.dom.GetHTMLElementFrom(newContent)) && !!(existingContent = tf.dom.GetHTMLElementFrom(existingContent))) {
            if (existingContent.parentNode == domElement) { if (existingContent = existingContent.nextSibling) { theThis.InsertContentBefore(newContent, existingContent); } }
        }
    }
    /**
     * @public
     * @function
     * @summary - Vertically scrolls the contents of this Element instance to the top of the given existing content
     * @param {HTMLElementLike} existingContent - content belonging to this Element instance, to the top of which this Element's contents will be vertically scrolled
     * @returns {void} - | {@link void} no return value
    */
    this.ScrollContent = function (existingContent) {
        if (existingContent = tf.dom.GetHTMLElementFrom(existingContent) && existingContent.parentNode == domElement) {
            domElement.scrollTop = existingContent.offsetTop - domElement.offsetTop;
        }
    }
    function onDelete() {
        if (!!onClick) { onClick.OnDelete(); onClick = null; }
    }
    function initialize() {
        addTextContentAsSpan = false;
        if (!!(domObj = tf.js.GetIsValidObject(settings.domObj) ? settings.domObj : null)) {
            if (!(domElement = tf.dom.GetHTMLElementFrom(settings.domElement))) {
                domObj = null;
            }
            else {
                !!settings.id && (domElement.id = settings.id);
                tf.js.GetIsNonEmptyString(settings.cssClass) && (domElement.className = settings.cssClass);
                tf.js.GetIsNonEmptyString(settings.tooltip) && (domElement.title = settings.tooltip);
                tf.js.GetIsNonEmptyString(settings.value) && (domElement.value = settings.value);
                spanCSSClass = tf.js.GetNonEmptyString(settings.spanCSSClass, null);
                addTextContentAsSpan = tf.js.GetBoolFromValue(settings.addTextContentAsSpan, true);
            }
        }
        tf.dom.Insertable.call(theThis, settings);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.dom.Element, tf.dom.Insertable);
/**
 * @public
 * @class
 * @summary Div is an [Element]{@link tf.dom.Element} implementing the standard <b>'div'</b> HTML element
 * @param {tf.types.ElementSettings} settings - creation settings, including an additional {@link boolean} property <b>initiallyVisible</b> that, if set to <b>false</b>, creates an invisible <b>div</b> (display='none')
 * @extends {tf.dom.Element}
 */
tf.dom.Div = function (settings) {
    var theThis;
    /**
     * @public
     * @function
     * @summary - Retrieves the <b>div</b> {@link HTMLElement} associated with this instance
     * @returns {HTMLElement} - | {@link HTMLElement} the element
    */
    this.GetDiv = function () { return GetHTMLElement(); }
    function initialize() {
        var domElement = document.createElement('div');
        settings = tf.js.GetValidObjectFrom(settings);
        var cssClass = tf.js.GetIsNonEmptyString(settings.cssClass) ? settings.cssClass : tf.GetStyles().paddedBlockDivStyle;
        if (tf.js.GetIsFalseNotUndefined(settings.initiallyVisible)) { domElement.style.display = 'none'; }
        tf.dom.Element.call(theThis, { id: settings.id, domObj: theThis, domElement: domElement, cssClass: cssClass, tooltip: settings.tooltip });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.dom.Div, tf.dom.Element);
/**
 * @public
 * @class
 * @summary Text Input is an [Element]{@link tf.dom.Element} implementing the standard <b>'input'</b> HTML element of type <b>'text'</b>. 
 * Use this instance's inherited functions [SetValue]{@link tf.dom.Element#SetValue} and [GetValue]{@link tf.dom.Element#GetValue} to set/get the associated input text {@link string}
 * @param {tf.types.ElementSettings} settings - creation settings
 * @extends {tf.dom.Element}
 */
tf.dom.TextInput = function (settings) {
    var theThis = null;
    /**
     * @public
     * @function
     * @summary - Retrieves the <b>text input</b> {@link HTMLElement} associated with this instance
     * @returns {HTMLElement} - | {@link HTMLElement} the element
    */
    this.GetInput = function () { return GetHTMLElement(); }
    function initialize() {
        var domElement = document.createElement('input');
        settings = tf.js.GetValidObjectFrom(settings);
        var labelStr = tf.js.GetNonEmptyString(settings.label, "");
        var toolTipStr = tf.js.GetNonEmptyString(settings.tooltip, labelStr);
        var valueStr = tf.js.GetNonEmptyString(settings.value, "");
        var cssClass = tf.js.GetIsNonEmptyString(settings.cssClass) ? settings.cssClass : tf.GetStyles().inputTextClass;
        domElement.type = "text";
        domElement.placeholder = labelStr;
        tf.dom.Element.call(theThis, { id: settings.id, domObj: theThis, domElement: domElement, cssClass: cssClass, tooltip: toolTipStr, value: valueStr });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.dom.TextInput, tf.dom.Element);
/**
 * @public
 * @class
 * @summary Link is an [Element]{@link tf.dom.Element} implementing the standard <b>'a'</b> (hyperlink) HTML element
 * @param {tf.types.ElementSettings} settings - creation settings, including two additional {@link string} properties <b>href</b> and <b>target</b> used to create the hyperlink
 * @extends {tf.dom.Element}
 */
tf.dom.Link = function (settings) {
    var theThis, onClick, href, target;
    /**
     * @public
     * @function
     * @summary - Retrieves the <b>a</b> {@link HTMLElement} associated with this instance
     * @returns {HTMLElement} - | {@link HTMLElement} the element
    */
    this.GetLink = function () { return GetHTMLElement(); }
    function onClickLink() { window.open(href, target); }
    function initialize() {
        var domElement = document.createElement('a');
        settings = tf.js.GetValidObjectFrom(settings);
        href = domElement.href = settings.href;
        target = domElement.target = settings.target;
        tf.dom.Element.call(theThis, { id: settings.id, domObj: theThis, domElement: domElement, addTextContentAsSpan: false, tooltip: settings.tooltip, cssClass: settings.cssClass });
        if (tf.js.GetIsNonEmptyString(settings.label)) { theThis.AddContent(settings.label) }
        onClick = new tf.events.DOMClickListener({ target: domElement, callBack: onClickLink, optionalScope: theThis, callBackSettings: undefined });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.dom.Link, tf.dom.Element);
/**
 * @public
 * @class
 * @summary Span is an [Element]{@link tf.dom.Element} implementing the standard <b>'span'</b> HTML element
 * @param {tf.types.ElementSettings} settings - creation settings
 * @extends {tf.dom.Element}
 */
tf.dom.Span = function (settings) {
    var theThis;
    /**
     * @public
     * @function
     * @summary - Retrieves the <b>span</b> {@link HTMLElement} associated with this instance
     * @returns {HTMLElement} - | {@link HTMLElement} the element
    */
    this.GetSpan = function () { return GetHTMLElement(); }
    function initialize() {
        var domElement = document.createElement('span');
        settings = tf.js.GetValidObjectFrom(settings);
        var cssClass = tf.js.GetIsNonEmptyString(settings.cssClass) ? settings.cssClass : tf.GetStyles().spanClass;
        var spanClass = tf.js.GetIsNonEmptyString(settings.spanCSSClass) ? settings.spanCSSClass : tf.GetStyles().spanClass;
        tf.dom.Element.call(theThis, { id: settings.id, domObj: theThis, domElement: domElement, addTextContentAsSpan: true, spanCSSClass: spanClass, cssClass: cssClass });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.dom.Span, tf.dom.Element);
/**
 * @public
 * @class
 * @summary Link is an [Element]{@link tf.dom.Element} implementing the standard <b>'a'</b> (hyperlink) HTML element
 * @param {tf.types.ElementSettings} settings - creation settings, including an additional {@link string} property <b>src</b> used to create the <b>img</b>, and
 * an optional callback {@function} property <b>onLoad</b> that, when specified, is called when the image is loaded and is passed this instance as a parameter
 * @extends {tf.dom.Element}
 */
tf.dom.Img = function (settings) {
    var theThis, imgSrcUse, onLoadCallBack, isLoaded, isValid;
    /**
     * @public
     * @function
     * @summary - Determines if the {@link HTMLElement} associated with this instance is valid
     * @returns {boolean} - | {@link boolean} <b>true</b> if the image is valid, </b>false</b> otherwise, e.g. if the image failed to load from the given source
    */
    this.GetIsValid = function () { return isValid; }
    /**
     * @public
     * @function
     * @summary - Retrieves the <b>img</b> {@link HTMLElement} associated with this instance
     * @returns {HTMLElement} - | {@link HTMLElement} the element
    */
    this.GetImg = function () { return theThis.GetHTMLElement(); }
    /**
     * @public
     * @function
     * @summary - Checks if the image is loaded
     * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
    */
    this.GetIsLoaded = function () { return isLoaded; }
    /**
     * @public
     * @function
     * @summary - Retrieves the <b>src</b> {@link string} associated with this instance
     * @returns {string} - | {@link string} the src string
    */
    this.GetSrc = function () { return imgSrcUse; }
    /**
     * @public
     * @function
     * @summary - Retrieves the dimensions of the image associated with this instance
     * @returns dimensions - | array with width and height
    */
    this.GetDimensions = function () {
        var elem = theThis.GetHTMLElement();
        return !!elem ? [elem.width, elem.height] : [0, 0];
    }
    function privateLoadCallBack() {
        var elem = theThis.GetHTMLElement();
        elem.onload = elem.onabort = elem.onerror = undefined;
        isLoaded = true;
        if (!!onLoadCallBack) {
            var olcb = onLoadCallBack;
            onLoadCallBack = undefined;
            olcb(theThis);
        }
    }
    function privateLoadFailure() { isValid = false; privateLoadCallBack(); }
    function initialize() {
        var domElement = document.createElement('img');
        settings = tf.js.GetValidObjectFrom(settings);
        isLoaded = false;
        isValid = true;
        onLoadCallBack = tf.js.GetFunctionOrNull(settings.onLoad);
        domElement.onload = privateLoadCallBack;
        domElement.onabort = privateLoadFailure;
        domElement.onerror = privateLoadFailure;
        if (!!settings.crossOrigin) { domElement.crossOrigin = 'anonymous'; }
        if (imgSrcUse = tf.js.GetNonEmptyString(settings.src)) { domElement.src = imgSrcUse; }
        tf.dom.Element.call(theThis, { id: settings.id, domObj: theThis, domElement: domElement, cssClass: settings.cssClass, tooltip: settings.tooltip });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.dom.Img, tf.dom.Element);
/**
 * Settings used in the creation of [Imgs Pre Loader]{@link tf.dom.ImgsPreLoader} instances
 * @public
 * @typedef {object} tf.types.ImgsPreLoaderSettings
 * @property {enumerable<string>} imgSrcs - an enumerable containing the <b>src</b> properties of the images to preload
 * @property {function} onAllLoaded - an optional callback {@link function} that, when specified, is called when all images have been preloaded and is passed this instance as a parameter
*/
/**
 * @public
 * @class
 * @summary Imgs Pre Loader instances are created to pre-load one or more instances of [Img]{@link tf.dom.Img}
 * @param {tf.types.ImgsPreLoaderSettings} settings - creation settings
 */
tf.dom.ImgsPreLoader = function (settings) {
    var theThis, nLoading, nLoaded, isLoadComplete, onAllLoadedCallBack, imgs;
    /**
     * @public
     * @function
     * @summary - Checks if all images have been loaded
     * @returns {boolean} - | {@link boolean} <b>true</b> if all images have been loaded, <b>false</b> otherwise
    */
    this.GetIsLoadComplete = function () { return isLoadComplete; }
    /**
     * @public
     * @function
     * @summary - returns an enumerable of the preloaded images
     * @returns {enumerable<tf.dom.Img>} - | {@link enumerable}<{@link tf.dom.Img}> the preloaded images
    */
    this.GetImgs = function () { return imgs; }
    function notifyAllLoaded() { onAllLoadedCallBack(theThis); }
    function checkIfAllLoaded() {
        if (nLoading !== undefined) {
            if (nLoaded == nLoading) { isLoadComplete = true; if (!!onAllLoadedCallBack) { setTimeout(notifyAllLoaded, 10); } }
        }
    }
    function onImageLoaded(theImage, theIndex) { imgs[theIndex] = theImage; ++nLoaded; checkIfAllLoaded(); }
    function createImg(thisImgSrc, thisIndex) {
        new tf.dom.Img({ src: thisImgSrc, cssClass: settings.cssClassStr, onLoad: function (theImage) { return onImageLoaded(theImage, thisIndex) } });
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        nLoaded = 0;
        isLoadComplete = false;
        imgs = [];
        onAllLoadedCallBack = tf.js.GetFunctionOrNull(settings.onAllLoaded);
        var imgSrcs = settings.imgSrcs;
        if (tf.js.GetIsValidObject(imgSrcs)) {
            var nLoadingTemp = 0;
            for (var i in imgSrcs) { if (!!tf.js.GetNonEmptyString(imgSrcs[i])) { ++nLoadingTemp; } }
            var nLoadingIndex = 0;
            for (var i in imgSrcs) { var imgSrc = tf.js.GetNonEmptyString(imgSrcs[i]); if (!!imgSrc) { createImg(imgSrc, nLoadingIndex++); } }
            nLoading = nLoadingTemp;
            checkIfAllLoaded();
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * CSS Style specification of a [Text Button]{@link tf.ui.TextBtn} instance. May be set to a [CSS Style Name]{@link tf.types.CSSStyleName} created
 * with the function [CreateTextDivBtnClasses]{@link tf.styles.Styles#CreateTextDivBtnClasses}, or to a {@link boolean} value, in which case
 * a <b>true</b> value selects the API's default <b>light</b> style settings, otherwise the default <b>dark</b> style settings are used
 * @public
 * @typedef {boolean|tf.types.CSSStyleName} tf.types.TextBtnStyle
 */
/**
 * An object used in the creation of [Text Button]{@link tf.ui.TextBtn} instances
 * @public
 * @typedef {object} tf.types.TextBtnSettings
 * @property {tf.types.TextBtnStyle} style - the given style
 * @property {string} label - the given text
 * @property {HTMLElementSizeOrPxNumber} dim - the button's height dimension
 * @property {tf.types.MultiDOMEventListenerCallBack} onClick - sets a [Click Listener]{@link tf.events.DOMClickListener} for the button
 * @property {string} tooltip - tool tip text
 */
/**
 * @public
 * @class
 * @summary - Text Button is an [Insertable]{@link tf.dom.Insertable} containing text and implementing a user interface button
 * @param {tf.types.TextBtnSettings} settings - creation settings
 * @extends {tf.dom.Insertable}
*/
tf.ui.TextBtn = function (settings) {
    var theThis, defaultDim, styles, lightClass, darkClass, heightDeltaPx, div, style, dim, onCallBack;
    this.SetOnClick = function (callBack) { return setCallBack(callBack); }
    /**
     * @public
     * @function
     * @summary - Retrieves this instance's style
     * @returns {tf.types.TextBtnStyle} - | {@link tf.types.TextBtnStyle} the style
    */
    this.GetStyle = function () { return style }
    /**
     * @public
     * @function
     * @summary - Sets this instance's style to the given style
     * @param {tf.types.TextBtnStyle} style - the given style
     * @returns {void} - | {@link void} no return value
    */
    this.SetStyle = function (style) { return setStyle(style); }
    /**
     * @public
     * @function
     * @summary - Sets the text of this Text Button instance to the given text
     * @param {string} text - the given text
     * @returns {void} - | {@link void} no return value
    */
    this.SetText = function (text) { return setText(text); }
    /**
     * @public
     * @function
     * @summary - Changes the tooltip text of this Text Button instance to the given text
     * @param {string} tooltip - the given text
     * @returns {void} - | {@link void} no return value
    */
    this.ChangeToolTip = function (tooltip) { return changeToolTip(tooltip); }
    function setText(textContentStr) { div.textContent = tf.js.GetNonEmptyString(textContentStr, ''); }
    function changeToolTip(toolTipStr) {
        if (tf.js.GetIsNonEmptyString(toolTipStr)) { div.title = toolTipStr; }
        else { if (div.title !== undefined) { delete div.title; } }
    }
    function setStyle(styleSet) {
        if (tf.js.GetIsNonEmptyString(styleSet)) {
            style = div.className = styleSet;
        }
        else if ((styleSet = !!styleSet) != style) {
            style = styleSet; div.className = style ? lightClass : darkClass;
        }
    }
    function setHeight(dimSet) {
        dim = tf.js.GetDimFromStrOrPxNumber(dimSet, defaultDim);
        //div.style.height = "calc(" + dim + " - " + heightDeltaPx + ")";
        div.style.fontSize = "calc(" + dim + " - " + heightDeltaPx + ")";
        //div.style.fontSize = dim;//"calc(" + dim + " - " + heightDeltaPx + " - 2px)";
        //height = !newHeight ? defaultHeight : newHeight;
        //div.style.height = (height - heightDelta + 2) + "px";
        //div.style.fontSize = (height - heightDelta - 2) + "px";
    }
    function setCallBack(onclickCallBack) {
        if (!!onCallBack) { onCallBack.OnDelete(); }
        if (tf.js.GetFunctionOrNull(onclickCallBack)) {
            onCallBack = new tf.events.DOMClickListener({ target: div, callBack: onclickCallBack, optionalScope: theThis, callBackSettings: undefined });
        }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        defaultDim = "1em";
        styles = tf.GetStyles();
        lightClass = styles.textDivBtnLightStyleClass;
        darkClass = styles.textDivBtnDarkStyleClass;
        heightDeltaPx = styles.GetSubStyles().textButtonHeightDelta + 'px';
        style = undefined;
        onCallBack = null;
        var divObj = new tf.dom.Div({ cssClass: styles.GetUnPaddedDivClassNames(false, false) });
        div = divObj.GetHTMLElement();
        setCallBack(settings.onClick);
        setText(settings.label);
        changeToolTip(settings.tooltip);
        setStyle(settings.style);
        setHeight(settings.dim);
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: div });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.ui.TextBtn, tf.dom.Insertable);
tf.ui.LiveStreamPlayer = function (settings) {
    var theThis, isPlaying, jw_width, jw_height, container, playerContainer, divPlayer, divContainerStyle;
    var liveFeedContainerDivID = "liveFeedPlayerContainer", liveFeedPlayerDivID = "liveFeedPlayer";
    this.PlayStream = function (streamURL) { return playStream(streamURL); }
    this.PlayVideo = function (videoURL) { return playVideo(videoURL); }
    this.OnDelete = function () { stopPlay(); container.removeChild(playerContainer.GetHTMLElement()); }
    this.StopPlay = function () { return stopPlay(); }
    this.GetIsPlaying = function () { return isPlaying; }
    function playVideo(videoURL) {
        divContainerStyle.display = 'block';
        jwplayer(liveFeedPlayerDivID).setup({
            height: jw_height, width: jw_width, stretching: 'exactfit', file: videoURL
        });
        jwplayer(liveFeedPlayerDivID).play();
        isPlaying = true;
    }
    function playStream(streamURL) {
        divContainerStyle.display = 'block';
        jwplayer(liveFeedPlayerDivID).setup({
            height: jw_height, width: jw_width, stretching: 'exactfit', sources: [{ file: streamURL }], rtmp: { bufferlength: 3 }
        });
        jwplayer(liveFeedPlayerDivID).onMeta(function (event) { });
        jwplayer(liveFeedPlayerDivID).play();
        isPlaying = true;
    }
    function stopPlay() {
        if (isPlaying) {
            jwplayer(liveFeedPlayerDivID).stop();
            divContainerStyle.display = 'none';
            isPlaying = false;
        }
    }
    function createPlayerPopup() {
        if (!playerContainer) {
            /*var style = {
                position: "absolute", display: "none", backgroundColor: "#fff", width: jw_width + "px", height: jw_height + "px",
                right: "24em", bottom: "10em", margin: "0px", padding: "0px", border: "0px", zIndex: "2000"
            };*/
            var style = {
                position: "relative", display: "block", backgroundColor: "#fff", width: jw_width + "px", height: jw_height + "px",
                left: "0", top: "0", margin: "0px", padding: "0px", border: "0px", zIndex: "2000"
            };
            playerContainer = new tf.dom.Div({ id: liveFeedContainerDivID });
            divPlayer = new tf.dom.Div({ id: liveFeedPlayerDivID });
            divContainerStyle = playerContainer.GetHTMLElement().style;
            tf.GetStyles().ApplyStyleProperties(playerContainer, style);
            divPlayer.AppendTo(playerContainer);
            playerContainer.AppendTo(container);
        }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (!(container = tf.dom.GetHTMLElementFrom(settings.container))) { container = document.body; }
        liveFeedContainerDivID = tf.dom.CreateDomElementID("tf-live-player");
        liveFeedPlayerDivID = tf.dom.CreateDomElementID("tf-live-player");
        jw_width = settings.width !== undefined ? settings.width : 320;
        jw_height = settings.height !== undefined ? settings.height : 240;
        createPlayerPopup();
        isPlaying = false;
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/*\
|*|
|*|  :: cookies.js ::
|*|
|*|  A complete cookies reader/writer framework with full unicode support.
|*|
|*|  Revision #1 - September 4, 2014
|*|
|*|  https://developer.mozilla.org/en-US/docs/Web/API/document.cookie
|*|  https://developer.mozilla.org/User:fusionchess
|*|
|*|  This framework is released under the GNU Public License, version 3 or later.
|*|  http://www.gnu.org/licenses/gpl-3.0-standalone.html
|*|
|*|  Syntaxes:
|*|
|*|  * docCookies.setItem(name, value[, end[, path[, domain[, secure]]]])
|*|  * docCookies.getItem(name)
|*|  * docCookies.removeItem(name[, path[, domain]])
|*|  * docCookies.hasItem(name)
|*|  * docCookies.keys()
|*|
\*/
tf.helpers.DocCookies = {
    getItem: function (sKey) {
        if (!sKey) { return null; }
        return decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;
    },
    setItem: function (sKey, sValue, vEnd, sPath, sDomain, bSecure) {
        if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) { return false; }
        var sExpires = "";
        if (vEnd) {
            switch (vEnd.constructor) {
                case Number:
                    sExpires = vEnd === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" : "; max-age=" + vEnd;
                    break;
                case String:
                    sExpires = "; expires=" + vEnd;
                    break;
                case Date:
                    sExpires = "; expires=" + vEnd.toUTCString();
                    break;
            }
        }
        document.cookie = encodeURIComponent(sKey) + "=" + encodeURIComponent(sValue) + sExpires + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "") + (bSecure ? "; secure" : "");
        return true;
    },
    removeItem: function (sKey, sPath, sDomain) {
        if (!tf.helpers.DocCookies.hasItem(sKey)) { return false; }
        document.cookie = encodeURIComponent(sKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT" + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "");
        return true;
    },
    hasItem: function (sKey) {
        if (!sKey) { return false; }
        return (new RegExp("(?:^|;\\s*)" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(document.cookie);
    },
    keys: function () {
        var aKeys = document.cookie.replace(/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g, "").split(/\s*(?:\=[^;]*)?;\s*/);
        for (var nLen = aKeys.length, nIdx = 0; nIdx < nLen; nIdx++) { aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]); }
        return aKeys;
    }
};
/**
 * A callback function that can be used in the creation of TerraFly API Service requests, such as
 * [Raster Source Lists]{@link tf.services.RasterSourceList} and [Routing]{@link tf.services.Routing}
 * @public
 * @callback tf.types.ServiceCallBack
 * @param {object} serviceObject - the object returned by the TerraFly service, its contents depend on the type of service being used
 * @returns {void} - | {@link void} no return value
 */
/**
 * Settings used in the creation of [Base Service]{@link tf.services.BaseJSONService} instances
 * @private
 * @typedef {object} tf.types.BaseServiceSettings
 * @property {string} serviceURL - the service URL complete with parameters
 * @property {boolean} useRedirect - if <b>true</b> the service is accessed with a redirect proxy, defaults to {@link void}
 * @property {boolean} useAjax - if <b>true</b> the service is accessed via ajax, otherwise JSON is used, defaults to {@link void}
 * @property {tf.types.ServiceCallBack} callBack - to receive the object retrieved from the service
 * @property {object} optionalScope - optional JavaScript scope used with <b>callBack</b>
*/
/**
 * @public
 * @class
 * @summary - Base Service implements functionality common to TerraFly API Service instances
 * @param {tf.types.BaseServiceSettings} settings - creation settings
*/
tf.services.BaseJSONService = function (settings) {
    var theThis, downloadObj, callBack, optionalScope, data, filterData;
    /**
     * @public
     * @function
     * @summary - Checks if the request is in progress (was sent, but a response has not been received)
     * @returns {boolean} - | {@link boolean } <b>true</b> if the request is in progress, <b>false</b> otherwise
    */
    this.GetIsInProgress = function () { return !!downloadObj && downloadObj.GetIsInProgress(); }
    /**
     * @public
     * @function
     * @summary - Cancels an ongoing request
     * @returns {void} - | {@link void} no return value
    */
    this.Cancel = function () { return cancel(); }
    function cancel() { if (downloadObj) { downloadObj.Cancel(); downloadObj = null; } }
    function doCalBack() { callBack.call(optionalScope, data); data = null; }
    function privateCallBack(notification) {
        data = notification.data;
        if (!!filterData) { data = filterData(data); }
        setTimeout(doCalBack, 50);
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsNonEmptyString(settings.serviceURL)) {
            if (!!(callBack = tf.js.GetFunctionOrNull(settings.callBack))) {
                filterData = tf.js.GetFunctionOrNull(settings.filterData);
                optionalScope = settings.optionalScope;
                if (settings.useAjax) {
                    downloadObj = new tf.ajax.GetRequest({ url: settings.serviceURL, useRedirect: settings.useRedirect, autoSend: true, optionalScope: theThis, onDataLoaded: privateCallBack });
                }
                else {
                    downloadObj = new tf.ajax.JSONGet();
                    downloadObj.Request(settings.serviceURL, privateCallBack, theThis, undefined, settings.useRedirect, settings.overrideMimeType, settings.JSONDecode);
                }
            }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * The accuracy of the result returned by the [Geocoder Service]{@link tf.services.Geocoder}, one of:<br>
 * 0 - Service failed,<br>
 * 1 - Exact match,<br>
 * 2 - Approx match - the program could not find the exact range, but found the nearest syntactic match or range,<br>
 * 3 - Zip center - the returned coordinate is the zip code center,<br>
 * 4 - City Center - the returned coordinate is the city center,<br>
 * 5 - Not Found - the address could not be located
 * @public
 * @typedef {number} tf.types.geocoderAccuracy
 */
/**
 * Object retrieved by [Geocoder Service]{@link tf.services.Geocoder} instances
 * @public
 * @typedef {object} tf.types.GeocoderData
 * @property {tf.types.mapCoordinates} pointCoords - the retrieved coordinates
 * @property {tf.types.geocoderAccuracy} geocoderAccuracy - the accuracy of <b>pointCoords</b>
 * @property {string} errorMsg - if the service fails contains an error message, otherwise {@link void}
*/
/**
 * Settings used in the creation of [Geocoder Service]{@link tf.services.Geocoder} instances
 * @public
 * @typedef {object} tf.types.GeocoderSettings
 * @property {string} address - the address for which to retrieve map coordinates
 * @property {tf.types.ServiceCallBack} callBack - to receive a the object retrieved from the service
 * @property {object} optionalScope - optional JavaScript scope used with <b>callBack</b>
*/
/**
 * @public
 * @class
 * @summary - Geocoder Service instances are created to retrieve the map coordinates corresponding to a given address.
 * This service passes an instance of [GeocoderData]{@link tf.types.GeocoderData} to its callBack
 * @param {tf.types.GeocoderSettings} settings - creation settings
 * @extends {tf.services.BaseJSONService}
*/
tf.services.Geocoder = function (settings) {
    var theThis, callBack, optionalScope, localSettings;
    this.GetSettings = function () { return tf.js.ShallowMerge(localSettings); }
    function decode(httpRequest) {
        var data = { pointCoords: [0, 0], geocoderAccuracy: 0 };
        if (!!httpRequest && !!httpRequest.responseText) {
            var rawData = tf.helpers.XMLString2Object(httpRequest.responseText);
            if (tf.js.GetIsValidObject(data)) {
                if (tf.js.GetIsNonEmptyString(rawData.GeocoderErrorMsg)) {
                    data.errorMsg = rawData.GeocoderErrorMsg;
                }
                else {
                    data.pointCoords = [tf.js.GetLongitudeFrom(rawData.Longitude), tf.js.GetLongitudeFrom(rawData.Latitude)];
                    data.geocoderAccuracy = parseInt(rawData.GeocoderLevel, 10);
                }
            }
            //tf.GetDebug().LogIfTest(JSON.stringify(data));
        }
        return data;
    }
    function initialize() {
        localSettings = tf.js.ShallowMerge(settings);
        if (!!(callBack = tf.js.GetFunctionOrNull(localSettings.callBack))) {
            optionalScope = localSettings.optionalScope;
            var address = encodeURI(tf.js.GetNonEmptyString(localSettings.address));
            var geocoderServiceURL = "http://vn4.cs.fiu.edu/cgi-bin/geocoder.cgi?";
            localSettings.serviceURL = geocoderServiceURL + "street=" + address + "&filetype=.xml";
            localSettings.overrideMimeType = "text/xml";
            localSettings.JSONDecode = decode;
            //tf.GetDebug().LogIfTest("Geocoder: " + localSettings.serviceURL);
            tf.services.BaseJSONService.call(theThis, localSettings);
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.services.Geocoder, tf.services.BaseJSONService);
/**
 * Object retrieved by [Reverse Geocoder Service]{@link tf.services.ReverseGeocoder} instances
 * @public
 * @typedef {object} tf.types.ReverseGeocoderData
 * @property {boolean} success - <b>true</b> if the service succeeded, <b>false</b> otherwise
 * @property {tf.types.mapCoordinates} pointCoords - the coordinates associated with the address
 * @property {string} address - the street address
 * @property {string} stdAddress - the street address
 * @property {string} city - the city
 * @property {string} stdCity - the city
 * @property {string} stdState - the state
 * @property {string} stdZip - the zip code
 * @property {string} stdZipPlus - the zip code extension
*/
/**
 * Settings used in the creation of [Reverse Geocoder Service]{@link tf.services.ReverseGeocoder} instances
 * @public
 * @typedef {object} tf.types.ReverseGeocoderSettings
 * @property {tf.types.mapCoordinates} pointCoords - the coordinates for which an address will be retrieved
 * @property {tf.types.ServiceCallBack} callBack - to receive a the object retrieved from the service
 * @property {object} optionalScope - optional JavaScript scope used with <b>callBack</b>
*/
/**
 * @public
 * @class
 * @summary - Reverse Geocoder Service instances are created to retrieve the address corresponding to the given map coordinates.
 * This service passes an instance of [ReverseGeocoderData]{@link tf.types.ReverseGeocoderData} to its callBack
 * @param {tf.types.ReverseGeocoderSettings} settings - creation settings
 * @extends {tf.services.BaseJSONService}
*/
tf.services.ReverseGeocoder = function (settings) {
    var theThis, callBack, optionalScope, localSettings;
    this.GetSettings = function () { return tf.js.ShallowMerge(localSettings); }
    function filterReverseGeocodeData(rawData) {
        var data = { success : false };
        if (tf.js.GetIsValidObject(rawData) && tf.js.GetIsArrayWithMinLength(rawData = rawData.features, 1)) {
            if (tf.js.GetIsValidObject(rawData = rawData[0].properties)){
                data.success = true;
                data.pointCoords = [tf.js.GetLongitudeFrom(rawData.longitude), tf.js.GetLatitudeFrom(rawData.latitude)];
                data.address = rawData.ADDR;
                data.city = rawData.CITY;
                data.stdAddress = rawData.STD_ADDR;
                data.stdCity = rawData.STD_CITY;
                data.stdState = rawData.STD_STATE;
                data.stdZip = rawData.STD_ZIP;
                data.stdZipPlus = rawData.STD_PLUS;
            }
        }
        return data;
    }
    function initialize() {
        localSettings = tf.js.ShallowMerge(settings);
        if (!!(callBack = tf.js.GetFunctionOrNull(localSettings.callBack)) && tf.js.GetIsArrayWithMinLength(localSettings.pointCoords, 2)) {
            optionalScope = localSettings.optionalScope;
            var lon = tf.js.GetLongitudeFrom(localSettings.pointCoords[0]);
            var lat = tf.js.GetLatitudeFrom(localSettings.pointCoords[1]);
            var geocoderServiceURL = "http://vn4.cs.fiu.edu/cgi-bin/arquery.cgi?&tfaction=shortdisplayflash&numfind=1&category=firstamerican_points_2014&filetype=.json";
            localSettings.serviceURL = geocoderServiceURL + "&lat=" + lat + "&lon=" + lon;
            localSettings.filterData = filterReverseGeocodeData;
            tf.GetDebug().LogIfTest("ReverseGeocoder: " + localSettings.serviceURL);
            tf.services.BaseJSONService.call(theThis, localSettings);
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.services.ReverseGeocoder, tf.services.BaseJSONService);
/**
 * Settings used in the creation of [Routing Service]{@link tf.services.RoutingService} instances
 * @public
 * @typedef {object} tf.types.RoutingServiceSettings
 * @property {array<tf.types.mapCoordinates>} lineStringCoords - the given via point coordinates for routing, in [GeoJSON linestring format]{@link tf.types.GeoJSONGeometryType}, a maximum of 25 points can be used
 * @property {tf.types.routingServiceMode} mode - defaults to {@link tf.consts.routingServiceModeFoot}
 * @property {tf.types.mapCoordinates} coords - the given via point coordinates for locating or finding a nearest point, used in conjunction with <b>locateOnly<b> or <b>nearestOnly</b>
 * @property {boolean} locateOnly - if set to <b>true</b> requests the location of the nearest node of the road network to the given <b>coords</b>, defaults to {@link void}, takes precedence over <b>nearestOnly</b>
 * @property {boolean} nearestOnly - if set to <b>true</b> requests the location of the nearest point in any street segment of the road network to the given <b>coords</b>, defaults to {@link void}
 * @property {boolean} findAlternatives - if set to <b>false</b> prevents the service from attempting to find alternative routes, defaults to <b>true</b>
 * @property {boolean} instructions - if set to <b>true</b> requests guidance instructions from the service, defaults to {@link void}
 * @property {tf.types.mapLevel} level - a map level, defaults to <b>18</b>
 * @property {tf.types.ServiceCallBack} callBack - to receive the object retrieved from the service
 * @property {object} optionalScope - optional JavaScript scope used with <b>callBack</b>
*/
/**
 * @public
 * @class
 * @summary - Routing Service instances are created to retrieve directions from the TerraFly Routing Service
 * @param {tf.types.RoutingServiceSettings} settings - creation settings
 * @extends {tf.services.BaseJSONService}
*/
tf.services.Routing = function (settings) {
    var theThis, localSettings;
    var serverURL, useDefaultServer;
    this.GetSettings = function () { return tf.js.ShallowMerge(localSettings); }
    function filterLocateNearestData(data) {
        if (tf.js.GetIsValidObject(data)) {
            if (data.status == 0 || data.status == 200) {
                if (tf.js.GetIsArrayWithMinLength(data.mapped_coordinate, 2)) {
                    var coords = data.mapped_coordinate;
                    var t = coords[0]; coords[0] = coords[1]; coords[1] = t;
                    data.mapped_coordinate = coords;
                }
                else { data.status = 400; }
            }
        }
        return data;
    }
    function filterViaRouteData(data) {
        if (tf.js.GetIsValidObject(data)) {
            if ((data.status !== 0 && data.status !== 200) || ! tf.js.GetLooksLikeLineStringCoords(data.route_geometry)) {
                data.route_geometry = [];
            }
            else {
                var coords = data.route_geometry;
                for (var i in coords) { var c = coords[i], t = c[0]; c[0] = c[1]; c[1] = t; }
                var viaIndices = data.via_indices;
                if (tf.js.GetIsArrayWithMinLength(viaIndices, 2)) {
                    var len = viaIndices.length;
                    if (viaIndices[len - 1] == coords.length) {
                        //tf.GetDebug().LogIfTest('Routing service: fixing via indices');
                        for (var i = 1 ; i < len ; ++i) { viaIndices[i] -= 1; }
                    }
                }
            }
        }
        return data;
    }
    function getModeFrom(modeSet) {
        var mode = tf.js.GetNonEmptyString(modeSet, tf.consts.routingServiceModeFoot);
        switch (mode = mode.toLowerCase()) {
            case tf.consts.routingServiceModeFoot:
            case tf.consts.routingServiceModeBicycle:
            case tf.consts.routingServiceModeCar:
                break;
            default:
                mode = tf.consts.routingServiceModeFoot;
                break;
        }
        return mode;
    }
    function initialize() {
        var callRemoteService = false;
        localSettings = tf.js.GetValidObjectFrom(settings);
        serverURL = tf.js.GetNonEmptyString(settings.serverURL, null);
        useDefaultServer = !serverURL;
    
        if (!!(localSettings.locateOnly || localSettings.nearestOnly)) {
            var coords = localSettings.coords;
            if (tf.js.GetIsArrayWithMinLength(coords, 2)) {
                var mode = getModeFrom(localSettings.mode);
                var serviceVerb = !!localSettings.locateOnly ? "/locate?" : "/nearest?";
                var strPoints = "loc=" + coords[1] + ',' + coords[0];
                if (useDefaultServer) {
                    localSettings.serviceURL = tf.consts.RoutingServiceURL + mode + serviceVerb + strPoints;
                }
                else {
                    localSettings.serviceURL = serverURL + serviceVerb + strPoints;
                }
                localSettings.filterData = filterLocateNearestData;
                callRemoteService = true;
            }
        }
        else {
            var coords = localSettings.lineStringCoords;
            if (tf.js.GetLooksLikeLineStringCoords(coords)) {
                var mode = getModeFrom(localSettings.mode);
                switch (mode = mode.toLowerCase()) {
                    case tf.consts.routingServiceModeFoot:
                    case tf.consts.routingServiceModeBicycle:
                    case tf.consts.routingServiceModeCar:
                        break;
                    default:
                        mode = tf.consts.routingServiceModeCar;
                        break;
                }
                var strPoints = "";
                var maxViaPoints = 25, nViaPoints = coords.length;
                var strLevel = "", strAlt = "", strInstructions = "";
                if (localSettings.level !== undefined) { var level = tf.js.GetLevelFrom(localSettings.level); strLevel = "&z=" + level; }
                if (tf.js.GetIsFalseNotUndefined(localSettings.findAlternatives)) { strAlt = "&alt=false"; }
                if (!!localSettings.instructions) { strInstructions = "&instruction=true"; }
                if (nViaPoints > maxViaPoints) { nViaPoints = maxViaPoints; }
                for (var i = 0 ; i < nViaPoints ; ++i) { var coord = coords[i]; strPoints += "&loc=" + coord[1] + "," + coord[0]; }
                if (useDefaultServer) {
                    localSettings.serviceURL = tf.consts.RoutingServiceURL + mode + "/viaroute?compression=false" + strPoints + strAlt + strInstructions;
                }
                else {
                    localSettings.serviceURL = serverURL + "/viaroute?compression=false" + strPoints + strAlt + strInstructions;
                }
                localSettings.filterData = filterViaRouteData;
                callRemoteService = true;
            }
        }
        if (callRemoteService) {
            //tf.GetDebug().LogIfTest("Routing: " + localSettings.serviceURL);
            tf.services.BaseJSONService.call(theThis, localSettings);
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.services.Routing, tf.services.BaseJSONService);
/**
 * Object passed to [Raster Source List Service]{@link tf.services.RasterSourceList} callbacks
 * @public
 * @typedef {object} tf.types.RasterSourceListResult
 * @property {boolean} success - <b>true</b> on succes, <b>false</b> otherwise, in which case the contents of <b>error_message</b> should be checked
 * @property {string} error_message - if <b>success</b> is <b>false</b> contains an explanation of the reason(s) for failure
 * @property {array<object>} sources - an {@link array} of available sources at the requested location, each element of which contains:
 * @property {string} sources.name - the name of the source
 * @property {array<string>} sources.dates - the dates for which raster information is available for the source, each in the format "YYYYMMDD", as in "20150109"
 * @example {"success":true, "error_message":"", "sources":[{"name":"BEST_AVAILABLE", "dates":["20150109", "20150709"]}]}
*/
/**
 * Settings used in the creation of [Raster Source List]{@link tf.services.RasterSourceList} instances. Use either <b>pointCoordinates</b> or
 * a <b>extent</b>
 * @public
 * @typedef {object} tf.types.RasterSourceListSettings
 * @property {tf.types.mapLevel} level - map level, defaults to {@link tf.consts.defaultLevel}
 * @property {tf.types.mapCoordinates} pointCoordinates - if defined, takes precedence over <b>extent</b>
 * @property {tf.types.mapExtent} extent - map extent
 * @property {tf.types.ServiceCallBack} callBack - to receive a [RasterSourceListResult]{@link tf.types.RasterSourceListResult} object retrieved from the service
 * @property {object} optionalScope - optional JavaScript scope used with <b>callBack</b>
*/
/**
 * @public
 * @class
 * @summary - Raster Source List Service instances are created to retrieve a list of available raster sources and dates from the TerraFly Tile Service
 * @param {tf.types.RasterSourceListSettings} settings - creation settings
 * @extends {tf.services.BaseJSONService}
*/
tf.services.RasterSourceList = function (settings) {
    var theThis, localSettings;
    this.GetSettings = function () { return tf.js.ShallowMerge(localSettings); }
    function initialize() {
        localSettings = tf.js.ShallowMerge(settings);
        var level = tf.js.GetLevelFrom(localSettings.level);
        var extent ;
        
        if (localSettings.pointCoordinates !== undefined) {
            extent = tf.js.GetMapCoordsFrom(localSettings.pointCoordinates);
            extent = [extent[0], extent[1], extent[0], extent[1]];
        }
        else {
            extent = tf.js.GetMapExtentFrom(localSettings.extent);
        }
        
        var tileServiceURL = "http://131.94.133.184/TileService/";
        localSettings.serviceURL = tileServiceURL + "rsourcelist.aspx?projection=bing&z=" + level +
            "&bbox=" + extent[1] + ',' + extent[2] + ',' + extent[3] + ',' + extent[0];
        //tf.GetDebug().LogIfTest("RasterSourceList: " + localSettings.serviceURL);
        tf.services.BaseJSONService.call(theThis, localSettings);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.services.RasterSourceList, tf.services.BaseJSONService);
/**
 * Settings used in the creation of [Raster Mosaic]{@link tf.services.RasterMosaic} instances. The mosaic area can be
 * specified to the service by either providing it with <b>level</b> and <b>leftTop</b> parameters, or with an <b>extent</b>
 * parameter. In both cases the mosaic is created with the given <b>dim</b> dimensions. Use the former invocation 
 * to efficiently construct mosaics at the discrete [resolution]{@link tf.types.mapResolution} values corresponding to valid
 * [levels]{@link tf.types.mapLevel}.
 * Use the latter invocation to construct mosaics of any resolution, at the expense of additional processing time by the service
 * @public
 * @typedef {object} tf.types.RasterMosaicSettings
 * @property {tf.types.mapLevel} level - map level, if defined, together with <b>leftTop</b>, takes precedence over <b>extent</b>, defaults to {@link void}
 * @property {tf.types.mapCoordinates} leftTop - if defined, together with <b>level</b>, takes precedence over <b>extent</b>, defaults to {@link void}
 * @property {tf.types.mapExtent} extent - mosaic's extent coordinates, required when either <b>level</b> or <b>leftTop</b> are undefined
 * @property {tf.types.pixelCoordinates} dims - mosaic's dimensions
 * @property {tf.types.mapAerialSource} source - mosaic's source, defaults to [Best Available]{@link tf.consts.sourceName_best_available}
 * @property {string} date - mosaic's date, in the format "YYYYMMDD", as in "20151007", if not defined tiles from all dates are used to create the mosaic
 * @property {tf.types.ServiceCallBack} callBack - to receive an [Img]{@link tf.dom.Img} instance, whose [GetIsValid]{@link tf.dom.Img#GetIsValid} function can be used to determined success or failure
 * @property {object} optionalScope - optional JavaScript scope used with <b>callBack</b>
*/
/**
 * @public
 * @class
 * @summary - Raster Source List Service instances are created to retrieve a raster mosaic tile from the available aerial images in the TerraFly Tile Service.
 * This service passes an [Img]{@link tf.dom.Img} instance containing the mosaic image to its callback, whose [GetIsValid]{@link tf.dom.Img#GetIsValid} function 
 * can be used to determined success or failure.
 * @param {tf.types.RasterMosaicSettings} settings - creation settings
*/
tf.services.RasterMosaic = function (settings) {
    var theThis, callBack, optionalScope, localSettings, img;
    this.GetSettings = function () { return tf.js.ShallowMerge(localSettings); }
    function onImgLoaded() { setTimeout(doCalBack, 50); }
    function doCalBack() { callBack.call(optionalScope, img); img = null; }
    function initialize() {
        localSettings = tf.js.ShallowMerge(settings);
        if (!!(callBack = tf.js.GetFunctionOrNull(localSettings.callBack))) {
            optionalScope = localSettings.optionalScope;
            var level = tf.js.GetLevelFrom(localSettings.level);
            var leftTop = tf.js.GetMapCoordsFrom(localSettings.leftTop);
            var extent = tf.js.GetMapExtentFrom(localSettings.extent);
            var dim = tf.js.GetIsArrayWithMinLength(settings.dim, 2) ? settings.dim : [16, 16];
            var source = tf.js.GetNonEmptyString(localSettings.source);
            var date = tf.js.GetNonEmptyString(localSettings.date);
            var tileServiceURL = "http://131.94.133.184/TileService/";
            if (localSettings.level !== undefined && localSettings.leftTop !== undefined) {
                localSettings.serviceURL = tileServiceURL + "rmosaic.aspx?projection=bing&z=" + level +
                    "&left=" + leftTop[0] + '&top=' + leftTop[1] + '&width=' + dim[0] + '&height=' + dim[1];
            }
            else {
                var xMinYMin = tf.units.TM2OL([extent[0], extent[3]]);
                var xMaxYMax = tf.units.TM2OL([extent[2], extent[1]]);
                localSettings.serviceURL = tileServiceURL + "rmosaic.aspx?projection=bing" +
                    "&bbox=" + xMinYMin[0] + ',' + xMinYMin[1] + ',' + xMaxYMax[0] + ',' + xMaxYMax[1] + '&width=' + dim[0] + '&height=' + dim[1];
            }
            if (!!source) { localSettings.serviceURL += '&source=' + source; }
            if (!!date) { localSettings.serviceURL += '&date=' + date; }
            //tf.GetDebug().LogIfTest("RasterMosaic: " + localSettings.serviceURL);
            img = new tf.dom.Img({ src: localSettings.serviceURL, onLoad: onImgLoaded, crossOrigin: true });
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Notifications sent by {@link tf.ajax.GetRequest} instances
 * @public
 * @typedef {object} tf.types.AjaxNotification
 * @property {tf.ajax.GetRequest} sender - the instance sending the notification
 * @property {object} httpRequest - the request object
 * @property {object} requestProps - the object that was used in the creation of the [GetRequest]{@link tf.ajax.GetRequest} instance
*/
/**
 * A callback function that can be used in the creation of instances of [GetRequest]{@link tf.ajax.GetRequest}
 * @public
 * @callback tf.types.AjaxCallBack
 * @param {tf.types.AjaxNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * Settings used in the creation of [GetRequest]{@link tf.ajax.GetRequest} instances
 * @public
 * @typedef {object} tf.types.AjaxSettings
 * @property {string} url - the url to access
 * @property {tf.types.AjaxCallBack} onDataLoaded - the callback function that receives the data after it is retrieved
 * @property {boolean} useRedirect - if set to <b>true</b> the request is sent using a redirect proxy, to avoid cross domain violations
 * @property {string} overrideMimeType - a string containing the desired Mime type of the resource being retrieved
 * @property {object} requestProps - an object that will be passed to the callback function
 * @property {boolean} autoSend - if set to <b>true</b> the request is sent automatically upon creation of the {@link tf.ajax.GetRequest} instance, defaults to <b>false</b>
 * @property {object} optionalScope - optional scope used when applying the callback function
*/
/**
 * @public
 * @class
 * @summary Create an instance of this class to retrieve data from a given url pointing to a service or data file
 * @param {tf.types.AjaxSettings} settings - request creation settings
 */
tf.ajax.GetRequest = function (settings) {
    /**
     * @public
     * @function
     * @summary - Sends the request if it is valid and has not been previously sent
     * @returns {void} - | {@link void} no return value
    */
    this.Send = function () { return send(); }
    /**
     * @public
     * @function
     * @summary - Cancels the request if it is in progress
     * @returns {void} - | {@link void} no return value
    */
    this.Cancel = function () { return cancel(); }
    /**
     * @public
     * @function
     * @summary - Checks if the request was cancelled
     * @returns {boolean} - | {@link boolean } <b>true</b> if the request was cancelled, <b>false</b> otherwise
    */
    this.WasCancelled = function () { return wasAborted; }
    /**
     * @public
     * @function
     * @summary - Checks if the request is valid
     * @returns {boolean} - | {@link boolean } <b>true</b> if the request if valid, <b>false</b> otherwise
    */
    this.GetIsValid = function () { return isValid; }
    /**
     * @public
     * @function
     * @summary - Checks if the request was sent
     * @returns {boolean} - | {@link boolean } <b>true</b> if the request was sent, <b>false</b> otherwise
    */
    this.WasSent = function () { return wasSent; }
    /**
     * @public
     * @function
     * @summary - Checks if the request is in progress (was sent, but a response has not been received)
     * @returns {boolean} - | {@link boolean } <b>true</b> if the request is in progress, <b>false</b> otherwise
    */
    this.GetIsInProgress = function () { return getIsInProgress(); }
    /**
     * @public
     * @function
     * @summary - Checks if a response for the request was received
     * @returns {boolean} - | {@link boolean } <b>true</b> if a response was received, <b>false</b> otherwise
    */
    this.WasReceived = function () { return wasReceived; }
    var theThis, httpRequest, urlToDownload, onDataLoaded, requestProps, autoSendBool, wasSent, wasAborted, wasReceived, isValid, overrideMimeType;
    function getIsInProgress() { return wasSent && !wasAborted && !wasReceived; }
    function send() {
        if (!wasSent && isValid) {
            httpRequest.open('GET', urlToDownload, true);
            httpRequest.send(null);
            wasSent = true;
        }
    }
    function cancel() { if (getIsInProgress()) { if (httpRequest) { httpRequest.abort(); httpRequest = null; wasAborted = true; } } }
    function onReadyStateChange() {
        if (!wasAborted) {
            if (httpRequest.readyState == 4) {
                //if (!!onDataLoaded) { onDataLoaded(httpRequest, httpRequest.status, requestProps); }
                if (!!onDataLoaded) { onDataLoaded.call(settings.optionalScope, { sender: theThis, httpRequest: httpRequest, requestProps: requestProps }); }
                wasReceived = true;
                httpRequest = null;
            }
            else {
                //tf.GetDebug().LogIfTest( "state:" + httpRequest.readyState);
                //	0: not initialized.
                //	1: connection established.
                //	2: request received.
                //	3: answer in process.
                //	4: finished.
            }
        }
    }
    function createHttpRequest() {
        if (window.XMLHttpRequest) {
            // Mozilla, Safari,...
            httpRequest = new XMLHttpRequest({ mozSystem: true });
            if (httpRequest.overrideMimeType) {
                if (!!overrideMimeType) { httpRequest.overrideMimeType(overrideMimeType); }
            }
        }
        else if (window.ActiveXObject) {
            // IE
            try { httpRequest = new ActiveXObject("Msxml2.XMLHTTP"); }
            catch (e) { try { httpRequest = new ActiveXObject("Microsoft.XMLHTTP"); } catch (e) { httpRequest = null; } }
        }
        if (httpRequest) { httpRequest.onreadystatechange = onReadyStateChange; } else { isValid = false; }
    }
    function initialize() {
        wasSent = wasAborted = wasReceived = false;
        onDataLoaded = tf.js.GetFunctionOrNull(settings.onDataLoaded);
        urlToDownload = tf.js.GetNonEmptyString(settings.url, null);
        if (isValid = (!!urlToDownload && !!onDataLoaded)) {
            if (!!settings.useRedirect) { urlToDownload = tf.platform.GetURL() + "RedirectStream.aspx?URL=" + escape(urlToDownload); }
            //tf.GetDebug().LogIfTest(urlToDownload);
            overrideMimeType = tf.js.GetNonEmptyString(settings.overrideMimeType, 'text/xml');
            requestProps = settings.requestProps;
            autoSendBool = !!settings.autoSend;
            createHttpRequest();
            if (!!autoSendBool) { send(); }
        }
    }
    (function construct(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Notifications sent by {@link tf.ajax.JSONGet} instances
 * @public
 * @typedef {object} tf.types.JSONNotification
 * @property {tf.ajax.JSONGet} sender - the instance sending the notification
 * @property {object} data - the JavaScript object obtained from the JSON data
 * @property {object} requestProps - the object that was used in the call to {tf.ajax.JSONGet#Request}
*/
/**
 * A callback function that can be passed to the function {@link tf.ajax.JSONGet#Request} to receive the result of the request
 * @public
 * @callback tf.types.JSONCallBack
 * @param {tf.types.JSONNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * A callback function that can be passed to the function {@link tf.ajax.JSONGet#Request} to provide an url string
 * @public
 * @callback tf.types.GetUrlFunction
 * @returns {string} - | {@link string} an url string
 */
/**
 * @public
 * @class
 * @summary Create an instance of this class to retrieve JavaScript objects from JSON data obtained from a given url pointing to a service or data file
 */
tf.ajax.JSONGet = function () {
    var theThis, downloadObj, callBack, optionalScope, overrideMimeType, JSONDecode;
    /**
     * @public
     * @function
     * @summary - Sends the request specified by the parameters
     * @param {string | tf.types.GetUrlFunction} url - the url to access, either the url string itself or a function that returns an url string
     * @param {tf.types.JSONCallBack} onDataLoaded - the callback function that receives the JavaScript object after it is retrieved
     * @param {object} optionalScope - optional scope used when applying the callback function
     * @param {object} requestProps - an object that will be passed to the callback function
     * @param {boolean} useRedirect - if set to <b>true</b> the request is sent using a redirect proxy, to avoid cross domain violations
     * @returns {void} - | {@link void} no return value
    */
    this.Request = function (url, onDataLoaded, optionalScope, requestProps, useRedirect, overrideMimeType, JSONDecode) {
        return request(url, onDataLoaded, optionalScope, requestProps, useRedirect, overrideMimeType, JSONDecode);
    }
    /**
     * @public
     * @function
     * @summary - Checks if the request is in progress (was sent, but a response has not been received)
     * @returns {boolean} - | {@link boolean } <b>true</b> if the request is in progress, <b>false</b> otherwise
    */
    this.GetIsInProgress = function () { return !!downloadObj && downloadObj.GetIsInProgress(); }
    /**
     * @public
     * @function
     * @summary - Cancels the request if it is in progress
     * @returns {void} - | {@link void} no return value
    */
    this.Cancel = function () { return cancel(); }
    function cancel() { if (downloadObj) { downloadObj.Cancel(); downloadObj = null; } }
    function request(fromURL, callBackSet, optionalScopeSet, requestPropsSet, useRedirectSet, overrideMimeType, JSONDecode) {
        if (tf.js.GetFunctionOrNull(fromURL)) { fromURL = fromURL(); }
        if (tf.js.GetNonEmptyString(fromURL)) {
            //tf.GetDebug().LogIfTest(fromURL);
            var mimeType = tf.js.GetNonEmptyString(overrideMimeType, 'application/json');
            var decode = tf.js.GetFunctionOrNull(JSONDecode);
            callBack = tf.js.GetFunctionOrNull(callBackSet);
            optionalScope = optionalScopeSet;
            cancel();
            downloadObj = new tf.ajax.GetRequest({
                optionalScope: theThis, url: fromURL, onDataLoaded: onDataLoaded,
                requestProps: { clientProps: requestPropsSet, JSONDecode: decode },
                overrideMimeType: mimeType, useRedirect: useRedirectSet, autoSend: true
            });
        }
    }
    function onDataLoaded(notification) {
        downloadObj = null;
        var notificationProps = notification.requestProps;
        var decode = notificationProps.JSONDecode;
        var data, httpRequest = notification.httpRequest;
        if (httpRequest.status == 200) {
            if (!!decode) { data = decode(httpRequest); }
            else {
                data = httpRequest.responseText;
                if (!!data) { data = tf.js.JSONParse(data); }
            }
            if (!!callBack) { callBack.call(optionalScope, { sender: theThis, data: data, requestProps: notificationProps.clientProps }); }
        }
        data = null;
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; })(this);
};
/**
 * A callback function that can be used in the creation of instances of {@link tf.ajax.PeriodicJSONGet}
 * @public
 * @callback tf.types.PeriodicJSONCallBack
 * @param {tf.types.PeriodicJSONNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * Notifications sent by {@link tf.ajax.PeriodicJSONGet} instances
 * @public
 * @typedef {object} tf.types.PeriodicJSONNotification
 * @property {tf.ajax.PeriodicJSONGet} sender - the instance sending the notification
 * @property {object} data - the JavaScript object obtained from the JSON data
 * @property {object} requestProps - the object that was used in the creation of the call to {tf.ajax.JSONGet#Request}
*/
/**
 * Settings used in the creation of {@link tf.ajax.PeriodicJSONGet} instances
 * @public
 * @typedef {object} tf.types.PeriodicJSONSettings
 * @property {string | tf.types.GetUrlFunction} url - the url to access, either the url string itself or a function that returns an url string
 * @property {tf.types.PeriodicJSONCallBack} OnRefresh - the callback function that receives JavaScript objects that are retrieved
 * @property {object} optionalScope - optional scope used when applying the callback function
 * @property {boolean} autoRefresh - if set to <b>true</b> requests are sent periodically
 * @property {number} refreshMillis - The desired number of milliseconds between periodic refreshes
 * @property {boolean} useRedirect - if set to <b>true</b> requests are sent using a redirect proxy, to avoid cross domain violations
 *
*/
/**
 * @public
 * @class
 * @summary Create an instance of this class to periodically retrieve JavaScript objects from JSON data obtained from a given url pointing to a service or data file
 * @param {tf.types.PeriodicJSONSettings} settings - request creation settings
 */
tf.ajax.PeriodicJSONGet = function (settings) {
    var theThis, refreshCallBack, isDeleted, lastRefreshTime, actualLastRefreshTime, refreshTimeoutObj;
    var downloadObj, lastData, lastProps, minRefreshTimeOut, maxRefreshTimeOut, defRefreshTimeOut, optionalScope, url, useRedirect, refreshTimeOutMillis, autoRefresh;
    var debug;
    /**
     * @public
     * @function
     * @summary - Returns the last time a JavaScript object was retrieved
     * @returns {Date} - | {@link Date} a Date
    */
    this.GetLastRefreshTime = function () { return actualLastRefreshTime; }
    /**
     * @public
     * @function
     * @summary - Checks if the request is in progress (was sent, but a response has not been received)
     * @returns {boolean} - | {@link boolean } <b>true</b> if the request is in progress, <b>false</b> otherwise
    */
    this.GetIsRefreshing = function () { return !!downloadObj && downloadObj.GetIsInProgress(); }
    /**
     * @public
     * @function
     * @summary - This function must be called when the {@link tf.ajax.PeriodicJSONGet} instance is no longer needed
     * @returns {void} - | {@link void} no return value
    */
    this.OnDelete = function () { return onDelete(); }
    /**
     * @public
     * @function
     * @summary - Call this function to change the callBack function
     * @param {tf.types.PeriodicJSONCallBack} newRefreshCallBack - a new callback function to receive JavaScript objects
     * @returns {void} - | {@link void} no return value
    */
    this.ChangeCallBack = function (newRefreshCallBack) { return changeCallBack(newRefreshCallBack); }
    /**
     * @public
     * @function
     * @summary - Triggers an immediate refresh
     * @returns {void} - | {@link void} no return value
    */
    this.RefreshNow = function () { return onRefresh(); }
    /**
     * @public
     * @function
     * @summary - Cancels the current request if one is in progress
     * @returns {void} - | {@link void} no return value
    */
    this.Cancel = function () { return cancel(); }
    function cancel() { if (downloadObj) { downloadObj.Cancel(); } }
    function onDelete() {
        isDeleted = true;
        if (downloadObj) { downloadObj.Cancel(); }
        destroyRefreshTimeOut();
        refreshCallBack = null;
    }
    function notifyRefreshCallBack() { if (!!refreshCallBack) { refreshCallBack.call(optionalScope, { sender: theThis, data: lastData }); lastData = null; } }
    function onDataLoaded(notification) {
        if (notification.requestProps == lastProps) {
            actualLastRefreshTime = lastRefreshTime = new Date();
            lastData = notification.data;
            //if (!!debug) { debug.LogIfTest("lastProps: " + lastProps); }
            if (lastProps > 10000) { lastProps = 0; }
            resetRefreshTimeout();
            setTimeout(notifyRefreshCallBack, 10);
        }
        else { if (!!debug) { debug.LogIfTest("PeriodicJSONGet: skipping stale response: " + notification.requestProps + ' last requested ' + lastProps); } }
    }
    function onRefresh() { downloadObj.Request(url, onDataLoaded, theThis, lastProps = ++lastProps, useRedirect); }
    function destroyRefreshTimeOut() { if (!!refreshTimeoutObj) { clearTimeout(refreshTimeoutObj); refreshTimeoutObj = null; } }
    function resetRefreshTimeout() { destroyRefreshTimeOut(); if (!!autoRefresh) { refreshTimeoutObj = setTimeout(onRefresh, refreshTimeOutMillis); } }
    function doSetRefreshTimeOutMillis(newRefreshTimeOutMillis) {
        refreshTimeOutMillis = tf.js.GetFloatNumberInRange(newRefreshTimeOutMillis, minRefreshTimeOut, maxRefreshTimeOut, defRefreshTimeOut);
    }
    function setRefreshTimeOutMillis(newRefreshTimeOutMillis) {
        doSetRefreshTimeOutMillis(newRefreshTimeOutMillis);
        resetRefreshTimeout();
        if (!!lastRefreshTime) { lastRefreshTime = new Date(); }
    }
    function changeCallBack(newRefreshCallBack) { if (!isDeleted) { refreshCallBack = tf.js.GetFunctionOrNull(newRefreshCallBack); } }
    function setAutoRefresh(autoRefreshSet) { autoRefresh = tf.js.GetBoolFromValue(autoRefreshSet, true); }
    function initialize() {
        debug = tf.GetDebug();
        optionalScope = settings.optionalScope;
        url = settings.url;
        useRedirect = tf.js.GetBoolFromValue(settings.useRedirect, false);
        setAutoRefresh(settings.autoRefresh);
        lastProps = 0;
        minRefreshTimeOut = 1000; // two seconds
        maxRefreshTimeOut = 1000 * 60 * 60 * 24; // once a day
        defRefreshTimeOut = 5 * minRefreshTimeOut;
        downloadObj = new tf.ajax.JSONGet();
        isDeleted = false;
        changeCallBack(settings.onRefresh);
        if ((!!refreshCallBack) && (!!url)) { setRefreshTimeOutMillis(settings.refreshMillis); }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * An object containing an SVG Glyph specification
 * @public
 * @typedef {string} tf.types.SVGGlyphSpecs
 * @property {string} name - the name associated with this specification
 * @property {number} W - the width of the SVG viewport
 * @property {number} H - the height of the SVG viewport
 * @property {array} paths - the associated SVG paths
 * @property {hexColor} paths.fill - SVG fill
 * @property {object} paths.style - SVG style
 * @property {...string} paths.d - one of more SVG path strings
*/
tf.styles.SvgGlyphMapLensName = tf.consts.SVGGlyphPrefix + "maplens";
tf.styles.SvgGlyphArrowToStartName = tf.consts.SVGGlyphPrefix + "arrowtostart";
tf.styles.SvgGlyphArrowToEndName = tf.consts.SVGGlyphPrefix + "arrowtoend";
tf.styles.SvgGlyphUserLocationName = tf.consts.SVGGlyphPrefix + "userlocation";
tf.styles.SvgGlyphTriangleDownName = tf.consts.SVGGlyphPrefix + "triangledown";
tf.styles.SvgGlyphTriangleRightName = tf.consts.SVGGlyphPrefix + "triangleright";
tf.styles.SvgGlyphBullsEye2Name = tf.consts.SVGGlyphPrefix + "bullseye2";
tf.styles.SvgGlyphBullsEyeName = tf.consts.SVGGlyphPrefix + "bullseye";
tf.styles.SvgGlyphEarthName = tf.consts.SVGGlyphPrefix + "earth";
tf.styles.SvgGlyphDownloadName = tf.consts.SVGGlyphPrefix + "download";
tf.styles.SvgGlyphMeasuringTapeName = tf.consts.SVGGlyphPrefix + "measuringtape";
tf.styles.SvgGlyphMeasure2Name  = tf.consts.SVGGlyphPrefix + "measure2";
tf.styles.SvgGlyphMeasureName  = tf.consts.SVGGlyphPrefix + "measure";
tf.styles.SvgGlyphCloseXName = tf.consts.SVGGlyphPrefix + "closex";
tf.styles.SvgGlyphMapLayersName = tf.consts.SVGGlyphPrefix + "maplayers";
tf.styles.SvgGlyphInfoName = tf.consts.SVGGlyphPrefix + "info";
tf.styles.SvgGlyphMapDirectionsName = tf.consts.SVGGlyphPrefix + "mapdirections";
tf.styles.SvgGlyphMapPinName = tf.consts.SVGGlyphPrefix + "mappin";
tf.styles.SvgGlyphParkingName = tf.consts.SVGGlyphPrefix + "parking";
tf.styles.SvgGlyphMessagesName = tf.consts.SVGGlyphPrefix + "messages";
tf.styles.SvgGlyphRoadName = tf.consts.SVGGlyphPrefix + "road";
tf.styles.SvgGlyphBusStopName = tf.consts.SVGGlyphPrefix + "busstop";
tf.styles.SvgGlyphBusStop2Name = tf.consts.SVGGlyphPrefix + "busstop2";
tf.styles.SvgGlyphBusName = tf.consts.SVGGlyphPrefix + "bus";
tf.styles.SvgGlyphLeftArrowName = tf.consts.SVGGlyphPrefix + "leftarrow";
tf.styles.SvgGlyphRightArrowName = tf.consts.SVGGlyphPrefix + "rightarrow";
tf.styles.SvgGlyphHomeName = tf.consts.SVGGlyphPrefix + "home";
tf.styles.SvgGlyphHollowStarName = tf.consts.SVGGlyphPrefix + "hollowstar";
tf.styles.SvgGlyphStarName = tf.consts.SVGGlyphPrefix + "star";
tf.styles.SvgGlyphUploadVideoName = tf.consts.SVGGlyphPrefix + "uploadvideo";
tf.styles.SvgGlyphLogInName = tf.consts.SVGGlyphPrefix + "login";
tf.styles.SvgGlyphLogOutName = tf.consts.SVGGlyphPrefix + "logout";
tf.styles.SvgGlyphPlusSignName = tf.consts.SVGGlyphPrefix + "plussign";
tf.styles.SvgGlyphMagnifyingLensName = tf.consts.SVGGlyphPrefix + "magnifyinglens";
tf.styles.SvgGlyphQuestionMarkName = tf.consts.SVGGlyphPrefix + "questionmark";
tf.styles.SvgGlyphPlaySelectedName = tf.consts.SVGGlyphPrefix + "playselected";
tf.styles.SvgGlyphDirectionName = tf.consts.SVGGlyphPrefix + "direction";
tf.styles.SvgGlyphCompassName = tf.consts.SVGGlyphPrefix + "compass";
tf.styles.SvgGlyphNoCompassName = tf.consts.SVGGlyphPrefix + "nocompass";
tf.styles.SvgGlyphTargetName = tf.consts.SVGGlyphPrefix + "target";
tf.styles.SvgGlyphNoTargetName = tf.consts.SVGGlyphPrefix + "notarget";
tf.styles.SvgGlyphAutoRepeatName = tf.consts.SVGGlyphPrefix + "autorepeat";
tf.styles.SvgGlyphNoAutoRepeatName = tf.consts.SVGGlyphPrefix + "noautorepeat";
tf.styles.SvgGlyphPlayName = tf.consts.SVGGlyphPrefix + "play";
tf.styles.SvgGlyphPauseName = tf.consts.SVGGlyphPrefix + "pause";
tf.styles.SvgGlyphStopName = tf.consts.SVGGlyphPrefix + "stop";
tf.styles.SvgGlyphGearName = tf.consts.SVGGlyphPrefix + "gear";
tf.styles.SvgGlyphGear2Name = tf.consts.SVGGlyphPrefix + "gear2";
tf.styles.SvgGlyphTwoGearsName = tf.consts.SVGGlyphPrefix + "twogears";
tf.styles.SvgGlyphRefreshName = tf.consts.SVGGlyphPrefix + "refresh";
tf.styles.SvgGlyphUndoName = tf.consts.SVGGlyphPrefix + "undo";
tf.styles.SvgGlyphSortAscendingName = tf.consts.SVGGlyphPrefix + "sortasc";
tf.styles.SvgGlyphSortDescendingName = tf.consts.SVGGlyphPrefix + "sortdsc";
tf.styles.SvgGlyphMaximumVolumeName = tf.consts.SVGGlyphPrefix + "maxvol";
tf.styles.SvgGlyphMediumVolumeName = tf.consts.SVGGlyphPrefix + "medvol";
tf.styles.SvgGlyphMinimumVolumeName = tf.consts.SVGGlyphPrefix + "minvol";
tf.styles.SvgGlyphMuteVolumeName = tf.consts.SVGGlyphPrefix + "mutevol";
tf.styles.SvgGlyphNames = [
    tf.styles.SvgGlyphMapLensName,
    tf.styles.SvgGlyphArrowToStartName,
    tf.styles.SvgGlyphArrowToEndName,
    tf.styles.SvgGlyphUserLocationName,
    tf.styles.SvgGlyphTriangleDownName,
    tf.styles.SvgGlyphTriangleRightName,
    tf.styles.SvgGlyphBullsEye2Name,
    tf.styles.SvgGlyphBullsEyeName,
    tf.styles.SvgGlyphEarthName,
    tf.styles.SvgGlyphDownloadName,
    tf.styles.SvgGlyphMeasuringTapeName,
    tf.styles.SvgGlyphMeasure2Name,
    tf.styles.SvgGlyphMeasureName,
    tf.styles.SvgGlyphCloseXName,
    tf.styles.SvgGlyphMapLayersName,
    tf.styles.SvgGlyphInfoName,
    tf.styles.SvgGlyphMapDirectionsName,
    tf.styles.SvgGlyphMapPinName,
    tf.styles.SvgGlyphParkingName,
    tf.styles.SvgGlyphMessagesName,
    tf.styles.SvgGlyphRoadName,
    tf.styles.SvgGlyphBusStopName,
    tf.styles.SvgGlyphBusStop2Name,
    tf.styles.SvgGlyphBusName,
    tf.styles.SvgGlyphLeftArrowName,
    tf.styles.SvgGlyphRightArrowName,
    tf.styles.SvgGlyphHomeName,
    tf.styles.SvgGlyphHollowStarName,
    tf.styles.SvgGlyphStarName,
    tf.styles.SvgGlyphUploadVideoName,
    tf.styles.SvgGlyphLogInName,
    tf.styles.SvgGlyphLogOutName,
    tf.styles.SvgGlyphPlusSignName,
    tf.styles.SvgGlyphMagnifyingLensName,
    tf.styles.SvgGlyphQuestionMarkName,
    tf.styles.SvgGlyphPlaySelectedName,
    tf.styles.SvgGlyphDirectionName,
    tf.styles.SvgGlyphCompassName,
    tf.styles.SvgGlyphNoCompassName,
    tf.styles.SvgGlyphTargetName,
    tf.styles.SvgGlyphNoTargetName,
    tf.styles.SvgGlyphAutoRepeatName,
    tf.styles.SvgGlyphNoAutoRepeatName,
    tf.styles.SvgGlyphPlayName,
    tf.styles.SvgGlyphPauseName,
    tf.styles.SvgGlyphStopName,
    tf.styles.SvgGlyphGearName,
    tf.styles.SvgGlyphGear2Name,
    tf.styles.SvgGlyphTwoGearsName,
    tf.styles.SvgGlyphRefreshName,
    tf.styles.SvgGlyphUndoName,
    tf.styles.SvgGlyphSortAscendingName,
    tf.styles.SvgGlyphSortDescendingName,
    tf.styles.SvgGlyphMaximumVolumeName,
    tf.styles.SvgGlyphMediumVolumeName,
    tf.styles.SvgGlyphMinimumVolumeName,
    tf.styles.SvgGlyphMuteVolumeName
];
/**
 * The name of a pre-defined [SVG Glyph Specification]{@link tf.types.SVGGlyphSpecs}, one of:<br>
 * - tf.styles.SvgGlyphMapLensName<br>
 * - tf.styles.SvgGlyphArrowToStartName<br>
 * - tf.styles.SvgGlyphArrowToEndName<br>
 * - tf.styles.SvgGlyphUserLocationName<br>
 * - tf.styles.SvgGlyphTriangleDownName<br>
 * - tf.styles.SvgGlyphTriangleRightName<br>
 * - tf.styles.SvgGlyphBullsEye2Name<br>
 * - tf.styles.SvgGlyphBullsEyeName<br>
 * - tf.styles.SvgGlyphEarthName<br>
 * - tf.styles.SvgGlyphDownloadName<br>
 * - tf.styles.SvgGlyphMeasuringTapeName<br>
 * - tf.styles.SvgGlyphMeasure2Name<br>
 * - tf.styles.SvgGlyphMeasureName<br>
 * - tf.styles.SvgGlyphCloseXName<br>
 * - tf.styles.SvgGlyphMapLayersName<br>
 * - tf.styles.SvgGlyphInfoName<br>
 * - tf.styles.SvgGlyphMapDirectionsName<br>
 * - tf.styles.SvgGlyphMapPinName<br>
 * - tf.styles.SvgGlyphParkingName<br>
 * - tf.styles.SvgGlyphMessagesName<br>
 * - tf.styles.SvgGlyphRoadName<br>
 * - tf.styles.SvgGlyphBusStopName<br>
 * - tf.styles.SvgGlyphBusStop2Name<br>
 * - tf.styles.SvgGlyphBusName<br>
 * - tf.styles.SvgGlyphLeftArrowName<br>
 * - tf.styles.SvgGlyphRightArrowName<br>
 * - tf.styles.SvgGlyphHomeName<br>
 * - tf.styles.SvgGlyphHollowStarName<br>
 * - tf.styles.SvgGlyphStarName<br>
 * - tf.styles.SvgGlyphUploadVideoName<br>
 * - tf.styles.SvgGlyphLogInName<br>
 * - tf.styles.SvgGlyphLogOutName<br>
 * - tf.styles.SvgGlyphPlusSignName<br>
 * - tf.styles.SvgGlyphMagnifyingLensName<br>
 * - tf.styles.SvgGlyphQuestionMarkName<br>
 * - tf.styles.SvgGlyphPlaySelectedName<br>
 * - tf.styles.SvgGlyphDirectionName<br>
 * - tf.styles.SvgGlyphCompassName<br>
 * - tf.styles.SvgGlyphNoCompassName<br>
 * - tf.styles.SvgGlyphTargetName<br>
 * - tf.styles.SvgGlyphNoTargetName<br>
 * - tf.styles.SvgGlyphAutoRepeatName<br>
 * - tf.styles.SvgGlyphNoAutoRepeatName<br>
 * - tf.styles.SvgGlyphPlayName<br>
 * - tf.styles.SvgGlyphPauseName<br>
 * - tf.styles.SvgGlyphStopName<br>
 * - tf.styles.SvgGlyphGearName<br>
 * - tf.styles.SvgGlyphGear2Name<br>
 * - tf.styles.SvgGlyphTwoGearsName<br>
 * - tf.styles.SvgGlyphRefreshName<br>
 * - tf.styles.SvgGlyphUndoName<br>
 * - tf.styles.SvgGlyphSortAscendingName<br>
 * - tf.styles.SvgGlyphSortDescendingName<br>
 * - tf.styles.SvgGlyphMaximumVolumeName<br>
 * - tf.styles.SvgGlyphMediumVolumeName<br>
 * - tf.styles.SvgGlyphMinimumVolumeName<br>
 * - tf.styles.SvgGlyphMuteVolumeName
 * @public
 * @typedef {string} tf.types.PredefinedSVGGlyphName
 */
/**
 * @public
 * @class
 * @summary - The {@link singleton} instance of SVG Glyph Lib contains the pre-defined [SVG Glyph Specifications]{@link tf.types.SVGGlyphSpecs} of the
 * [SVG Glyphs]{@link tf.ui.SvgGlyph} displayed by the API in user interface items and also available to applications
*/
tf.styles.SvgGlyphLib = function () {
    /**
     * @public
     * @function
     * @summary - Retrieves the pre-defined [SVG Glyph Specifications]{@link tf.types.SVGGlyphSpecs} associated with the given glyph name
     * @param {tf.types.PredefinedSVGGlyphName} glyphName - the given name
     * @returns {tf.types.SVGGlyphSpecs} - | {@link tf.types.SVGGlyphSpecs} the specifications, or {@link void} if the <b>glyphName</b> is not a valid name
    */
    this.GetGlyphByName = function (glyphName) { return getGlyphByName(glyphName) }
    var theThis, glyphsByName;
    var allSpecs = [
        {
            name: tf.styles.SvgGlyphMapLensName, W: 237.569, H: 237.569,
            paths: [
                { d: "m221.780075,35.150684c-1.790283,-1.250271 -4.07785,-1.547016 -6.130142,-0.793118l-63.811768,23.442291l-63.809097,-23.443184c-1.489082,-0.547157 -3.122559,-0.547157 -4.609856,0l-66.109133,24.288879c-2.630637,0.966885 -4.379049,3.47187 -4.379049,6.273613l0,132.22625c0,2.184174 1.067582,4.23114 2.857881,5.480515c1.137094,0.793991 2.475583,1.203003 3.82566,1.203003c0.77618,0 1.556814,-0.135422 2.304478,-0.409897l63.804638,-23.442291l63.809105,23.442291c1.487305,0.54628 3.120773,0.54628 4.609848,0l66.116272,-24.288879c2.630646,-0.965988 4.379059,-3.470978 4.379059,-6.273605l0,-132.225368c0,-2.185074 -1.066696,-4.231129 -2.857895,-5.480499zm-10.509201,133.041637l-59.432709,21.832916l-63.809097,-23.442291c-0.744102,-0.273605 -1.524742,-0.409943 -2.304489,-0.409943c-0.780632,0 -1.561264,0.136337 -2.305367,0.409943l-57.121103,20.987183l0,-117.985855l59.42647,-21.832886l63.809097,23.442299c1.48732,0.546257 3.120758,0.546257 4.609879,0l57.12822,-20.987221l0,117.985855l-0.0009,0z" },
                { d: "m152.85585,115.300591c0,-22.732948 -18.492905,-41.227638 -41.224083,-41.227638c-22.732948,0 -41.227646,18.49469 -41.227646,41.227638c0,22.732048 18.494698,41.225853 41.227646,41.225853c8.958618,0 17.251564,-2.881058 24.020668,-7.753799l20.106735,20.103195c1.304642,1.304626 3.01474,1.956924 4.725723,1.956924c1.710083,0 3.421097,-0.652298 4.726593,-1.957809c2.610153,-2.610153 2.609268,-6.842178 -0.000885,-9.451416l-20.105865,-20.10321c4.870071,-6.769989 7.751114,-15.062035 7.751114,-24.019737zm-69.084641,0c0,-15.362343 12.498207,-27.86055 27.860558,-27.86055c15.36055,0 27.857002,12.498207 27.857002,27.86055c0,15.361443 -12.496452,27.858757 -27.857002,27.858757c-15.36235,-0.00087 -27.860558,-12.498215 -27.860558,-27.858757z" }
            ]
        }, {
            name: tf.styles.SvgGlyphArrowToStartName, W: 956.199, H: 956.199,
            paths: [
                { d: "m319.474548,483.886353c0.350769,8.505585 2.104492,17.011169 5.086731,24.990631c1.753723,4.559723 4.033569,9.032562 6.664124,13.152985c3.156738,4.911316 6.752747,10.172546 11.224792,14.118408l201.063354,200.976501c30.778809,30.777954 80.760071,30.777954 111.624817,0c30.777954,-30.777954 30.777954,-80.759277 0,-111.624878l-66.290955,-66.291016l223.688232,0c43.5802,0 78.917786,-35.337646 78.917786,-78.917786c0,-43.581116 -35.337585,-78.917847 -78.917786,-78.917847l-223.688232,0l70.587585,-70.675293c30.778015,-30.779663 30.778015,-80.760986 0,-111.625732c-15.4328,-15.432861 -35.600647,-23.149231 -55.768555,-23.149231s-40.423523,7.717285 -55.768616,23.150085l-205.361755,205.360901c-12.101563,12.890747 -20.518555,28.498077 -22.534485,46.299286c-0.527039,4.384338 -0.701477,8.768646 -0.527039,13.152985z" },
                { d: "m143.663208,897.328064c43.580994,0 78.917786,-35.337646 78.917786,-78.917847l0,-680.62146c0,-43.581055 -35.336792,-78.917847 -78.917786,-78.917847c-43.579285,0 -78.917847,35.336792 -78.917847,78.917847l0,680.62146c0,43.5802 35.338562,78.917847 78.917847,78.917847z" }
            ]
        }, {
            name: tf.styles.SvgGlyphArrowToEndName, W: 956.199, H: 956.199,
            paths: [
                { d: "m636.724365,472.312622c-0.350769,-8.505585 -2.104492,-17.011169 -5.086731,-24.990631c-1.753723,-4.559723 -4.033569,-9.032593 -6.664124,-13.152985c-3.156738,-4.911316 -6.752747,-10.172516 -11.224792,-14.118408l-201.063324,-200.976486c-30.778839,-30.777939 -80.760101,-30.777939 -111.624847,0c-30.777954,30.777954 -30.777954,80.759232 0,111.624863l66.290955,66.290985l-223.688217,0c-43.580185,0 -78.917816,35.337646 -78.917816,78.917816c0,43.581116 35.337631,78.917847 78.917816,78.917847l223.688217,0l-70.587616,70.675293c-30.777954,30.779663 -30.777954,80.760986 0,111.625732c15.432831,15.432861 35.600708,23.149231 55.768585,23.149231s40.423492,-7.717285 55.768616,-23.150085l205.361755,-205.360901c12.101563,-12.890747 20.518555,-28.498077 22.534485,-46.299286c0.527039,-4.384338 0.701477,-8.768646 0.527039,-13.152985z" },
                { d: "m812.535706,58.870922c-43.580994,0 -78.917786,35.33765 -78.917786,78.91782l0,680.621475c0,43.581055 35.336792,78.917847 78.917786,78.917847c43.579285,0 78.917847,-35.336792 78.917847,-78.917847l0,-680.621475c0,-43.58017 -35.338562,-78.91782 -78.917847,-78.91782z" }
            ]
        }, {
        name: tf.styles.SvgGlyphUserLocationName, W: 368.806, H: 368.806,
        paths: [
            { d: "m166.194717,184.403c0,-10.05983 8.148453,-18.208298 18.208282,-18.208298c10.05983,0 18.208298,8.148468 18.208298,18.208298c0,10.05983 -8.148468,18.208282 -18.208298,18.208282c-10.05983,0 -18.208282,-8.148453 -18.208282,-18.208282z" },
            { d: "m217.362122,61.836975l-9.163315,28.699081c-0.906876,2.82412 0.654984,5.846161 3.47908,6.74765c0.542526,0.171837 1.089523,0.257309 1.63205,0.257309c2.276184,0 4.385971,-1.454796 5.110199,-3.736397l9.1633,-28.699081c0.906906,-2.82412 -0.654968,-5.846161 -3.479065,-6.74765c-2.812439,-0.896088 -5.846161,0.66037 -6.742249,3.479088z" },
            { d: "m138.759247,104.568466c0.864594,0 1.739075,-0.209633 2.555084,-0.649574c2.6091,-1.417007 3.575348,-4.675667 2.158371,-7.279366l-14.370697,-26.47686c-1.417,-2.603691 -4.675667,-3.569946 -7.273964,-2.15834c-2.609085,1.417007 -3.575348,4.675667 -2.15834,7.279358l14.370689,26.47686c0.971664,1.793076 2.81871,2.807922 4.718857,2.807922z" },
            { d: "m269.611359,144.127655c0.864594,0 1.739105,-0.209625 2.555115,-0.649582l26.476868,-14.370667c2.6091,-1.417015 3.575348,-4.675682 2.158325,-7.279381c-1.416992,-2.603683 -4.670258,-3.575348 -7.273926,-2.15834l-26.476898,14.370689c-2.60907,1.416992 -3.575348,4.675659 -2.158325,7.279358c0.971649,1.793076 2.813293,2.807922 4.718842,2.807922z" },
            { d: "m306.964539,217.367493l-28.699097,-9.1633c-2.813324,-0.933868 -5.846161,0.654984 -6.742249,3.479095c-0.90686,2.818726 0.654968,5.840744 3.479095,6.742233l28.699097,9.163315c0.542511,0.177246 1.089508,0.257294 1.632019,0.257294c2.276215,0 4.385986,-1.454788 5.110229,-3.736389c0.90686,-2.823212 -0.655884,-5.840759 -3.479095,-6.742249z" },
            { d: "m144.696274,310.44812c0.542511,0.177246 1.089493,0.257324 1.632004,0.257324c2.276245,0 4.385971,-1.454803 5.110229,-3.73642l9.1633,-28.699066c0.906876,-2.818726 -0.654953,-5.840759 -3.479095,-6.742249c-2.818695,-0.933868 -5.846146,0.654968 -6.742218,3.479065l-9.163315,28.699097c-0.906876,2.823212 0.655869,5.846161 3.479095,6.742249z" },
            { d: "m227.486267,264.892517c-2.6091,1.416992 -3.575348,4.670288 -2.15834,7.273956l14.370667,26.476868c0.977066,1.793091 2.818726,2.807922 4.724274,2.807922c0.864578,0 1.739059,-0.209625 2.555099,-0.649597c2.60907,-1.416992 3.575363,-4.670227 2.158356,-7.273956l-14.370697,-26.476868c-1.422394,-2.603668 -4.675644,-3.564545 -7.279358,-2.158325z" },
            { d: "m96.639534,225.334229l-26.47686,14.370667c-2.609085,1.417007 -3.575348,4.670258 -2.158348,7.273972c0.977058,1.793045 2.818718,2.807907 4.724251,2.807907c0.864601,0 1.739098,-0.20961 2.555115,-0.649597l26.476852,-14.370636c2.609093,-1.417023 3.575356,-4.670288 2.158348,-7.273987c-1.417,-2.604584 -4.670265,-3.576233 -7.279358,-2.158325z" },
            { d: "m93.799225,150.38678l-28.693687,-9.1633c-2.844803,-0.90152 -5.846161,0.660339 -6.747643,3.47905c-0.906883,2.824142 0.654976,5.846176 3.473686,6.747665l28.693687,9.1633c0.547913,0.171829 1.094917,0.257324 1.637428,0.257324c2.276207,0 4.380577,-1.454803 5.110214,-3.73642c0.906891,-2.823212 -0.654968,-5.845245 -3.473686,-6.74762z" },
            { d: "m184.959015,147.267548c4.43454,0 8.036011,-3.586121 8.052185,-8.025177l0.376083,-112.664989c0.01619,-4.445351 -3.580734,-8.062988 -8.025192,-8.079182c-0.010803,0 -0.016205,0 -0.027008,0c-4.43454,0 -8.03598,3.586147 -8.052185,8.0252l-0.376068,112.659584c-0.016205,4.445343 3.58075,8.062988 8.025208,8.079178c0.010803,0.005386 0.01619,0.005386 0.026978,0.005386z" },
            { d: "m109.587822,128.559479c1.567245,0 3.119202,-0.681953 4.176346,-1.99189c1.867737,-2.308594 1.508774,-5.68512 -0.794434,-7.552872l-23.410728,-18.950081c-2.303192,-1.873146 -5.695915,-1.50338 -7.547462,0.794418c-1.867752,2.308601 -1.508774,5.68512 0.794418,7.552872l23.411629,18.950081c0.992355,0.805229 2.188934,1.197472 3.370232,1.197472z" },
            { d: "m245.609573,114.967033c1.567261,0 3.119186,-0.681961 4.176315,-1.991898l18.950104,-23.41613c1.867737,-2.3032 1.508759,-5.68512 -0.794434,-7.54747c-2.303192,-1.867752 -5.690521,-1.503372 -7.547485,0.794418l-18.950073,23.41613c-1.867737,2.3032 -1.508759,5.68512 0.794434,7.54747c0.99324,0.810608 2.190704,1.197479 3.37114,1.197479z" },
            { d: "m342.282593,177.287384l-107.291138,-0.376068c-0.005402,0 -0.016205,0 -0.026993,0c-4.434555,0 -8.035995,3.586151 -8.0522,8.025208c-0.016205,4.450745 3.575363,8.062988 8.025208,8.079163l107.291138,0.376068c0.005432,0 0.016205,0 0.027008,0c4.43457,0 8.03598,-3.586121 8.052185,-8.025177c0.016205,-4.444458 -3.575348,-8.062988 -8.025208,-8.079193z" },
            { d: "m183.439453,350.3078c0.010788,0 0.016205,0 0.026993,0c4.434555,0 8.03598,-3.586151 8.05217,-8.025208l0.376068,-112.65416c0.01622,-4.445358 -3.58075,-8.063004 -8.025177,-8.079208c-0.010803,0 -0.01619,0 -0.026993,0c-4.434555,0 -8.035995,3.586151 -8.0522,8.025208l-0.376053,112.654175c-0.01622,4.450775 3.580719,8.062988 8.025192,8.079193z" },
            { d: "m255.036438,242.24382c-1.867737,2.303192 -1.508759,5.685104 0.794434,7.54747l23.411621,18.950073c0.993256,0.799805 2.185364,1.197479 3.371124,1.197479c1.567261,0 3.119202,-0.681976 4.176361,-1.991913c1.867737,-2.303192 1.508759,-5.68512 -0.794434,-7.547455l-23.411621,-18.950104c-2.296906,-1.867737 -5.689636,-1.508743 -7.547485,0.794449z" },
            { d: "m119.009331,255.836273l-18.944687,23.416138c-1.867752,2.308594 -1.508774,5.68512 0.794418,7.547455c0.993256,0.799805 2.185341,1.197479 3.371124,1.197479c1.567253,0 3.119217,-0.681946 4.176338,-1.991882l18.944695,-23.416168c1.867744,-2.308594 1.508766,-5.68512 -0.794418,-7.547455c-2.297806,-1.86235 -5.68512,-1.507874 -7.54747,0.794434z" },
            { d: "m230.412048,104.77269c1.900146,0 3.73642,-1.009445 4.71347,-2.786331l14.484055,-26.412079c1.42778,-2.598297 0.472305,-5.86235 -2.125992,-7.290154s-5.867722,-0.466934 -7.28476,2.125961l-14.484039,26.412079c-1.427795,2.598289 -0.472305,5.86235 2.125977,7.290161c0.81601,0.445335 1.702209,0.660362 2.571289,0.660362z" },
            { d: "m161.021973,90.433495l-9.04007,-28.73687c-0.890671,-2.818718 -3.897415,-4.407562 -6.731445,-3.510574c-2.829498,0.891586 -4.402145,3.908234 -3.510559,6.731453l9.040024,28.73687c0.725143,2.292397 2.83403,3.757988 5.121017,3.757988c0.531738,0 1.073334,-0.080971 1.610428,-0.246513c2.828629,-0.891594 4.401291,-3.908234 3.510605,-6.732353z" },
            { d: "m276.762054,161.268463c0.531738,0 1.073334,-0.080048 1.610474,-0.246506l28.742249,-9.040024c2.829498,-0.891586 4.396759,-3.902847 3.51059,-6.731476c-0.890686,-2.824097 -3.902863,-4.412949 -6.731445,-3.510559l-28.74231,9.039124c-2.829498,0.891602 -4.396759,3.902863 -3.510559,6.731445c0.724243,2.292419 2.834015,3.757996 5.121002,3.757996z" },
            { d: "m264.699982,227.84613c-1.427795,2.592911 -0.472321,5.862366 2.125977,7.28476l26.412079,14.484039c0.81604,0.45076 1.702209,0.66037 2.571289,0.66037c1.900146,0 3.73642,-1.00946 4.71347,-2.791718c1.427795,-2.592896 0.472351,-5.862335 -2.125946,-7.28476l-26.412079,-14.484039c-2.598328,-1.427795 -5.856995,-0.472321 -7.28479,2.131348z" },
            { d: "m133.67511,266.830414l-14.478645,26.417511c-1.427811,2.598297 -0.472336,5.862335 2.125961,7.284729c0.81601,0.450745 1.701309,0.66037 2.571304,0.66037c1.900131,0 3.736389,-1.00943 4.713463,-2.791718l14.478653,-26.41748c1.427765,-2.598297 0.472321,-5.862335 -2.125977,-7.284729c-2.603683,-1.433228 -5.866852,-0.471466 -7.28476,2.131317z" },
            { d: "m216.824997,307.109375c0.725143,2.297791 2.834915,3.757965 5.121017,3.757965c0.531708,0 1.073303,-0.080963 1.610443,-0.24649c2.829498,-0.891571 4.402161,-3.908264 3.510559,-6.731476l-9.040039,-28.736847c-0.891602,-2.829529 -3.892059,-4.402161 -6.731445,-3.51059c-2.829514,0.891602 -4.402161,3.908234 -3.51059,6.731445l9.040054,28.735992z" },
            { d: "m90.428101,207.784927l-28.73597,9.040054c-2.829514,0.890686 -4.402161,3.908249 -3.510574,6.731445c0.725151,2.297821 2.834908,3.758011 5.12101,3.758011c0.531715,0 1.073326,-0.080093 1.610443,-0.246536l28.73687,-9.040024c2.829514,-0.890701 4.402168,-3.908234 3.510574,-6.731461c-0.891586,-2.829514 -3.892036,-4.408447 -6.732353,-3.51149z" },
            { d: "m104.106926,140.970673c1.427803,-2.598297 0.472343,-5.862366 -2.125954,-7.290146l-26.412086,-14.484062c-2.598289,-1.427795 -5.867752,-0.466934 -7.284752,2.125961c-1.427803,2.598297 -0.472336,5.86235 2.125954,7.290154l26.412086,14.484039c0.81601,0.445343 1.702202,0.66037 2.571304,0.66037c1.900131,0 3.736397,-1.009445 4.713448,-2.786316z" },
            { d: "m122.691734,115.379982c1.218185,0 2.437256,-0.412949 3.446701,-1.255951c2.270805,-1.905533 2.571297,-5.287453 0.665771,-7.563667l-19.358543,-23.078743c-1.905533,-2.265411 -5.282051,-2.565903 -7.56366,-0.665771c-2.270805,1.90554 -2.571304,5.28746 -0.665764,7.563667l19.353134,23.078743c1.067932,1.266754 2.587509,1.921722 4.12236,1.921722z" },
            { d: "m258.799835,128.060165c1.21817,0 2.437256,-0.412956 3.446686,-1.255959l23.084167,-19.358551c2.270813,-1.905533 2.571289,-5.287453 0.665771,-7.56366c-1.900146,-2.270805 -5.282074,-2.571304 -7.56369,-0.665764l-23.084137,19.358543c-2.270798,1.905533 -2.571289,5.28746 -0.665741,7.56366c1.062546,1.266754 2.582092,1.92173 4.116943,1.92173z" },
            { d: "m242.668472,254.69278c-2.270813,1.900116 -2.571304,5.287445 -0.66037,7.558258l19.358536,23.078735c1.057129,1.266754 2.576691,1.916351 4.117859,1.916351c1.21817,0 2.437225,-0.412964 3.446686,-1.255981c2.270844,-1.900146 2.57132,-5.287445 0.6604,-7.558258l-19.358551,-23.078735c-1.901031,-2.270844 -5.288361,-2.57132 -7.56456,-0.66037z" },
            { d: "m106.554977,242.002701l-23.078751,19.353134c-2.270805,1.905518 -2.571304,5.292847 -0.665764,7.56366c1.062531,1.266785 2.582092,1.916321 4.12326,1.916321c1.21817,0 2.437248,-0.412933 3.446701,-1.250549l23.078751,-19.353149c2.270798,-1.905502 2.571289,-5.292847 0.665756,-7.563644c-1.911835,-2.265411 -5.288345,-2.561417 -7.569954,-0.665771z" },
            { d: "m133.81456,191.90007c0.005386,0 0.016205,0 0.026993,0c4.43454,0 8.036011,-3.586151 8.052185,-8.025192c0.016205,-4.450745 -3.575363,-8.062988 -8.025208,-8.079193l-107.291145,-0.376038c-0.005398,0 -0.016193,0 -0.026989,0c-4.434555,0 -8.035995,3.586151 -8.052193,8.025192c-0.016193,4.45076 3.575356,8.062988 8.0252,8.079178l107.291157,0.376053z" }
        ]
    }, {
        name: tf.styles.SvgGlyphTriangleDownName, W: 16, H: 16,
        paths: [{ d: "m2.282138,2.282138l11.435724,0l-5.67339,11.435724" }]
    }, {
        name: tf.styles.SvgGlyphTriangleRightName, W: 16, H: 16,
        paths: [{ d: "m2.282138,13.717862l0,-11.435724l11.435724,5.67339" }]
    }, {
        name: tf.styles.SvgGlyphBullsEye2Name, W: 390, H: 390,
        paths: [
            { d: "m340.384766,173.735092l31.219025,0c-4.673218,-39.459625 -22.307343,-75.974045 -50.835632,-104.503242c-28.529175,-28.528301 -65.04274,-46.162409 -104.50325,-50.83563l0,31.21903c64.030197,9.325581 114.794266,60.089661 124.119858,124.119843z" },
            { d: "m173.735092,49.61525l0,-31.21903c-39.459625,4.673222 -75.974045,22.307329 -104.503242,50.83563c-28.528301,28.529198 -46.162409,65.042717 -50.83563,104.503242l31.21903,0c9.325581,-64.030182 60.089661,-114.794262 124.119843,-124.119843z" },
            { d: "m216.264908,340.384766l0,31.219025c39.45871,-4.673218 75.974075,-22.307343 104.50325,-50.835632c28.52829,-28.529175 46.162415,-65.04274 50.835632,-104.50325l-31.219025,0c-9.325592,64.030197 -60.089661,114.794266 -124.119858,124.119858z" },
            { d: "m49.61525,216.264908l-31.21903,0c4.673222,39.45871 22.307329,75.974075 50.83563,104.50325c28.529198,28.52829 65.042717,46.162415 104.503242,50.835632l0,-31.219025c-64.030182,-9.325592 -114.794262,-60.089661 -124.119843,-124.119858z" },
            { d: "m116.634109,173.735092c7.527847,-27.709595 29.391388,-49.573135 57.100983,-57.100983l0,-31.732529c-44.80574,8.638191 -80.19532,44.027771 -88.833511,88.833511l31.732529,0z" },
            { d: "m116.634109,216.264908l-31.732529,0c8.638191,44.80574 44.027771,80.195328 88.833511,88.832596l0,-31.731598c-27.709595,-7.526947 -49.574036,-29.391403 -57.100983,-57.100998z" },
            { d: "m273.365906,216.264908c-7.527863,27.709595 -29.391434,49.57225 -57.100998,57.100998l0,31.731598c44.80574,-8.637268 80.195328,-44.026855 88.833511,-88.832596l-31.732513,0z" },
            { d: "m273.365906,173.735092l31.732513,0c-8.638184,-44.80574 -44.027771,-80.19532 -88.833511,-88.833496l0,31.732513c27.709595,7.526947 49.574051,29.391388 57.100998,57.100983z" },
            { d: "m193.5,159.5l3,0l0,71l-3,0l0,-71z" },
            { d: "m230.5,193.5l0,3l-71,0l0,-3l71,0z" }
        ]
    }, {
        name: tf.styles.SvgGlyphBullsEyeName, W: 390, H: 390,
        paths: [
            { d: "m340.384766,173.735092l31.219025,0c-4.673218,-39.459625 -22.307343,-75.974037 -50.835632,-104.503242c-28.529175,-28.528301 -65.04274,-46.162415 -104.50325,-50.835625l0,31.219021c64.030197,9.325584 114.794266,60.089664 124.119858,124.119846z" },
            { d: "m173.735092,49.615246l0,-31.219021c-39.459625,4.67321 -75.974037,22.307323 -104.503242,50.835625c-28.528301,28.529205 -46.162415,65.042717 -50.835625,104.503242l31.219021,0c9.325584,-64.030182 60.089664,-114.794262 124.119846,-124.119846z" },
            { d: "m216.264908,340.384766l0,31.219025c39.45871,-4.673218 75.974075,-22.307343 104.50325,-50.835632c28.52829,-28.529175 46.162415,-65.04274 50.835632,-104.50325l-31.219025,0c-9.325592,64.030197 -60.089661,114.794266 -124.119858,124.119858z" },
            { d: "m49.615246,216.264908l-31.219021,0c4.67321,39.45871 22.307323,75.974075 50.835625,104.50325c28.529205,28.52829 65.042717,46.162415 104.503242,50.835632l0,-31.219025c-64.030182,-9.325592 -114.794262,-60.089661 -124.119846,-124.119858z" },
            { d: "m116.634109,173.735092c7.527847,-27.709595 29.391388,-49.573135 57.100983,-57.100983l0,-31.732529c-44.80574,8.638191 -80.19532,44.027771 -88.833511,88.833511l31.732529,0z" },
            { d: "m116.634109,216.264908l-31.732529,0c8.638191,44.80574 44.027771,80.195328 88.833511,88.832596l0,-31.731598c-27.709595,-7.526947 -49.574036,-29.391403 -57.100983,-57.100998z" },
            { d: "m273.365906,216.264908c-7.527863,27.709595 -29.391434,49.57225 -57.100998,57.100998l0,31.731598c44.80574,-8.637268 80.195328,-44.026855 88.833511,-88.832596l-31.732513,0z" },
            { d: "m273.365906,173.735092l31.732513,0c-8.638184,-44.80574 -44.027771,-80.19532 -88.833511,-88.833496l0,31.732513c27.709595,7.526947 49.574051,29.391388 57.100998,57.100983z" },
            { d: "m203.622787,153.380371l0,-134.984146l-17.245575,0l0,134.984146c-16.530121,3.418884 -29.577057,16.466721 -32.996841,32.996841l-134.984146,0l0,17.245575l134.984146,0c3.418884,16.530106 16.466721,29.577057 32.996841,32.997742l0,134.983261l17.245575,0l0,-134.984161c16.530106,-3.418884 29.577057,-16.466736 32.997742,-32.998657l134.983261,0l0,-17.245575l-134.984161,0c-3.418884,-16.528305 -16.466736,-29.576141 -32.996841,-32.995026z" }
        ]
    }, {
        name: tf.styles.SvgGlyphEarthName, W: 356.902, H: 356.902,
        paths: [
            { d: "m40.129982,93.390343l-0.176014,-1.852318c-1.568474,2.457771 -3.07336,4.946877 -4.518353,7.479286l4.694366,-5.626968z" },
            { d: "m92.50428,54.721287l0,-2.56374l-5.952278,0l-0.33268,1.225662l-3.62352,0l0,0.310562l0,3.276093l8.185188,0" },
            { d: "m341.73584,141.128342l1.166656,2.184052c-0.203644,-0.931686 -0.428528,-1.862442 -0.652435,-2.783981l-0.514221,0.59993z" },
            { d: "m120.032738,103.000237l3.105621,-0.583344l2.48909,-1.579529l0,-3.265038l-5.594711,0c0,0.502235 0,5.42791 0,5.42791z" },
            { d: "m332.430969,111.747559c-1.209961,-2.71949 -2.515839,-5.41777 -3.887054,-8.062614l-1.049652,1.166679l0,7.264557l3.233704,-0.433128l1.703003,0.064507z" },
            { d: "m92.359596,64.668472c0,0 0.300423,-3.597717 0,-3.597717c-0.305031,0 -3.945145,0.615593 -3.945145,0.615593l-5.80851,1.64312l1.562943,1.842171l8.190712,-0.503166z" },
            { d: "m306.272858,79.621498l3.265961,-4.81324c-2.623657,-3.18026 -5.364349,-6.258224 -8.21286,-9.240356l-0.021179,8.003639l-7.15213,3.582054l0.706818,2.361008l11.413391,0.106895z" },
            { d: "m326.808594,119.093216l-4.346924,-4.727539l-0.8349,-7.575119l-4.443726,2.398788l-2.40802,9.278137l-6.425018,-6.761391l-0.256195,-6.402908l-6.210297,-5.278625l-2.290955,-2.259628l-7.195465,0l2.269806,6.349457l8.672638,4.76992l1.49939,1.590599l-1.863373,0.931679l0.075562,5.021515l-4.229889,1.745407l-3.596832,-0.791611l-2.248566,-3.153534l5.846313,0.316086l1.585052,-2.103882l-12.977203,-8.661629l-0.984253,-3.693558l-5.288727,4.710953l-5.355133,-1.08651l-8.137238,10.461411l-1.594299,4.111023l-5.214111,0.46077l-7.708755,0.04332l-4.604065,-2.126022l-1.350067,-9.052353l1.638519,-4.299019l7.848831,-1.713158l8.543671,1.713158l1.049652,-4.684219l-3.640137,-0.85704l1.249634,-7.279305l8.597137,-1.327034l6.0177,-8.410042l6.209381,-1.028442l5.611298,0.81926l2.055054,0l-1.13443,-7.891212l-6.810211,2.713951l-2.398804,-5.894211l-3.961731,-0.540947l-0.728027,-4.041908l3.233704,-3.479752l7.666351,-2.971069l1.979492,-3.485291c-21.799194,-18.988487 -48.642044,-32.420961 -78.263336,-38.080181c-0.680115,-0.117037 -1.33902,-0.240524 -2.018188,-0.358482c-3.046646,-0.551085 -6.172531,-0.909567 -9.299347,-1.295696c-6.140259,-0.669044 -12.367157,-1.055172 -18.705551,-1.055172c-36.543045,0 -70.329727,11.580164 -97.906105,31.174107l6.969666,-0.053459l3.742401,2.050446l7.050758,1.4883l0.55661,2.740681l11.194038,0.407326l-1.526077,-3.554409l-9.941658,-0.272778l2.345337,-2.189598l-0.819252,-2.591393l-8.994301,0l9.823692,-7.243362l9.395172,0l4.421585,6.017708l7.333679,0.406403l4.405907,-4.245567l3.32402,1.644043l-6.086815,5.877625c0,0 -8.432159,0.134544 -8.014694,0.134544s0.701294,5.733868 0.701294,5.733868l10.219948,-0.272778l1.107712,-2.730545l7.05629,-0.417458l0.824783,-4.089828l-4.133148,-0.691158l1.381393,-3.68343l3.169205,-0.952877l11.060425,0.545559l-6.092361,5.472145l0.985138,4.234512l6.359604,0.952881l-0.428528,-7.634102l6.086823,-3.148003l10.787628,-1.226585l15.622086,6.841568l0,5.878555l4.97818,1.225655l-2.500153,4.636307l-7.049835,0l-2.082703,5.332069l-16.130753,-3.752533l12.666656,-6.664635l-4.82338,-4.058495l-10.910202,1.360207l-0.97406,0.979599l-0.032257,-0.011059l-0.17601,0.230389l-3.14801,3.223576l-5.198456,0.438656l0.417465,2.564667l1.80899,0.733551l-0.063583,0.85704l-4.234512,0.588863l-0.305954,2.424595l-4.047424,0.20919l-0.722488,-4.81324l-7.259033,2.179455l-14.824013,8.586987l1.644043,6.038895l4.148804,2.676186l8.297615,1.129814l0,9.320526l3.839157,-0.615593l3.527695,-7.281143l8.828415,-2.762802l0,-11.183899l4.898026,-3.65118l11.852936,2.76281l-0.829391,7.382519l3.174744,0l8.720596,-4.234512l0.411926,9.695595l6.349457,3.821663l-0.262634,5.733864l-6.086823,2.055054l0.41745,1.895622l7.313416,3.298218l-0.128113,3.961731l-2.130615,0.182465c0,-0.064507 -0.021179,-0.106895 -0.021179,-0.106895l-9.250504,-2.816246l-0.385208,-2.93882l-0.011047,0l2.698273,-1.831116l0,-2.677094l-2.907471,-0.711433l-0.712357,2.467903l-5.107224,0.776863l-0.508682,-0.176933l0,0.251579l-1.761078,0.268173l-1.439453,-2.875229l-1.665253,-0.711441l-3.629959,0l-1.643127,1.327034l0,2.971069l3.105621,1.017387l3.067825,0.42852l-0.690231,0.305031l-2.805191,3.062302l-1.221054,-1.536224l-2.703827,-0.691154l-7.372375,6.852631l0.979614,0.775932l-10.889008,5.942146l-10.24115,10.530518l-0.691139,4.678696l-10.25222,6.664627l-5.096161,5.053772l0.567673,10.113052l-7.061813,-3.249374l0.058975,-5.920929l-19.622505,0l-10.166519,5.090622l-4.405907,8.035889l-1.755554,6.381714l2.863243,6.183578l8.004555,0.952881l12.73027,-8.410034l1.102158,4.169998l-3.880623,7.254425l9.695595,1.621918l0.963936,14.781616l1.215523,0.209198c-0.011063,-0.011078 -0.011063,-0.021194 -0.011063,-0.021194l0.133621,0.043304l11.938637,2.007126l8.432159,-9.636612l10.241142,2.060562l3.58667,4.941345l9.8237,-0.57782l0.262634,-2.864166l5.406708,2.591385l6.08223,9.417313l10.502869,0.154831l3.881546,6.696854l0.552017,8.19165l11.628082,4.373657l14.652603,0.13916l4.293488,6.954895l6.494141,2.055069l-1.231186,5.749527l-7.125397,8.940857l-2.07164,19.786514l-6.435165,5.032578l-9.528809,-0.279205l-3.191315,5.46106l2.372055,10.257751l-10.374771,13.105316l-3.329544,6.0177l-9.883591,4.710968l-6.488617,0.97406l-0.272781,2.73053l4.56073,1.295715l-0.551086,2.944336l-4.08429,3.876038l2.483566,3.083496l4.914612,0.150208l-0.272781,3.758057l-1.305817,3.682526l-0.406418,3.009766l7.270096,6.049011l-0.974091,3.148041l-9.903854,-0.181549l-9.844894,-8.512329l-7.671875,-13.331116l1.081894,-12.869385l-5.809433,-7.666351l2.345337,-12.956055l-3.431839,-0.974976l0,-28.148636c0,0 -9.690063,-7.259033 -10.241158,-7.259033c-0.55661,0 -5.118271,-1.209976 -5.118271,-1.209976l-0.963928,-5.321014l-12.586502,-15.589828l1.236717,-5.600235l0.417465,-9.154663l8.704933,-6.022308l-1.225662,-10.246674l-12.720108,-0.941833l-9.958244,-11.210617l-7.05629,-1.905762l-4.561653,-0.83493l0.55661,-4.100876l-5.80851,-0.819244l0,2.323212l-14.518978,-3.549805l-5.846298,-8.838547l2.029251,-3.62999l-2.398785,-0.021194l-0.691162,-2.302017l1.696568,-0.857056l-7.441494,-10.733246l-1.589672,-9.702057l-3.742405,0l1.252384,9.427429l6.360516,9.700211l-0.691158,3.839172l-5.39566,-0.81926l-6.623154,-11.183914l0,-13.003944l-6.916216,-3.292694l0,-7.923462c-3.672367,8.560257 -6.601044,17.516777 -8.795246,26.741463l2.280827,-0.46077l1.349148,6.413055l2.854034,4.550598l1.894703,2.147186l3.431839,1.327957l-3.244766,3.811523l-6.284954,0.604538l-4.814161,0l0.535418,-5.546799l3.929478,-0.813721l-0.342813,-2.596008l-3.254906,-2.039368c-1.820056,9.617264 -2.815326,19.51561 -2.885365,29.649857c0.481968,90.293152 74.907043,163.584747 166.362297,163.584747c51.999237,0 98.500519,-23.739075 129.036926,-60.785278l-5.471252,0l0,-10.931396l-6.360504,-8.44873l0,-13.169815l-4.839966,-4.753326l-0.41745,-5.482285l6.146729,-11.616089l-11.670502,-20.359756l1.391541,-13.817673l-10.493652,-1.07637l-3.886169,-3.821655l-7.056274,0l-3.596802,3.276108l-12.441803,0l-0.406433,1.097549l-6.938293,0l-15.868149,-17.897354l0.106903,-13.945786l2.633774,-0.952881l0.984222,-5.326538l-3.725815,0l-1.541748,-5.605789l18.395004,-13.11084l0,-9.279068l8.994324,-4.941345l3.640076,0.35849l7.409241,0l5.791931,-3.067841l18.674255,-1.444992l0,9.427444l14.722626,3.693573l2.912079,2.050446l2.698303,0l0,-5.118286l8.491119,-0.813736l8.082886,5.942154l13.277679,0l0.919708,-0.83493c-1.294769,-4.427124 -2.804291,-8.769455 -4.485199,-13.036209l-8.662537,0.145599l0,-0.000008l0,-0.000008zm-240.685104,64.612442l-3.159065,0.428513l0,-7.104202l1.022919,-1.145477c1.349144,2.591385 2.617195,5.219635 3.822578,7.885681l-1.686432,-0.064514zm10.765511,28.802032l0.514221,-0.599915c0.21933,0.920624 0.439583,1.820053 0.658913,2.741608l-1.173134,-2.141693z" },
            { d: "m106.744949,105.751976l2.918541,1.541748l7.060898,-9.721405l-5.503479,0l-3.838249,4.089828" },
            { d: "m120.032738,105.869934l-2.484497,0.198128l-0.823853,3.586662l5.284149,0l2.392334,-2.361l0,-3.18026l-3.838242,0.519753" },
            { d: "m96.889,212.50769l1.162071,2.141693c-0.219322,-0.921555 -0.439583,-1.821915 -0.658905,-2.741608l-0.503166,0.599915z" },
            { d: "m82.964424,177.029968l0,7.104202l3.159065,-0.428513l1.675369,0.053452c-1.194328,-2.666046 -2.478043,-5.284164 -3.822578,-7.885681l-1.011856,1.15654z" },
            { d: "m20.140699,151.578674l0.342815,2.601532l-3.929482,0.808197l-0.536339,5.546783l4.737671,0l6.279428,-0.598999l3.249372,-3.817062l-3.431843,-1.327942l-1.90023,-2.146271l-2.847582,-4.550613l-1.349148,-6.413971l-2.280827,0.46077l-0.385208,0.074661c-0.546478,2.372055 -1.027525,4.759781 -1.467104,7.157654l0.262642,0.165863l3.255827,2.039398l0.000002,0l0.000004,0z" }
        ]
    }, {
        name: tf.styles.SvgGlyphDownloadName, W: 29.978, H: 29.978,
        paths: [
            { d: "m24.494501,18.724583l0,6.215084l-19.011004,0l0,-6.215084l-3.653903,0l0,8.042036c0,1.008316 0.816819,1.826044 1.829675,1.826044l22.659461,0c1.01195,0 1.829676,-0.81682 1.829676,-1.826044l0,-8.042036l-3.653904,0z" },
            { d: "m14.654558,18.108339l-5.231272,-6.32127c0,0 -0.795944,-0.751473 0.067162,-0.751473s2.947808,0 2.947808,0s0,-0.50552 0,-1.285129c0,-2.222653 0,-6.267723 0,-7.916789c0,0 -0.117078,-0.448343 0.55816,-0.448343c0.680682,0 3.662069,0 4.149439,0c0.486462,0 0.475569,0.377552 0.475569,0.377552c0,1.59915 0,5.783985 0,7.934033c0,0.697019 0,1.148993 0,1.148993s1.671757,0 2.720915,0c1.047344,0 0.258661,0.786869 0.258661,0.786869s-4.450758,5.908321 -5.071538,6.528194c-0.446527,0.449251 -0.874904,-0.052637 -0.874904,-0.052637z" }
        ]
    }, {
        name: tf.styles.SvgGlyphMeasuringTapeName, W: 80.853, H: 80.853,
        paths: [{ d: "m76.442612,40.437309c0,-0.127323 -0.054695,-0.231339 -0.068146,-0.353287c-0.024208,-2.757259 -0.234032,-5.544113 -0.716438,-8.319305c-2.197739,-12.695959 -8.09066,-22.629272 -16.184906,-27.25609c-0.36853,-0.216098 -0.800728,-0.330872 -1.248165,-0.330872l-29.184824,0c-1.140566,0 -2.136765,0.763066 -2.428185,1.868661c-0.288727,1.100215 0.197268,2.260507 1.182709,2.820925c5.40423,3.096202 9.761152,9.528916 12.250311,17.702962l-16.678967,0c-0.494961,0 -0.92626,0.179335 -1.319899,0.427713c-1.59697,-0.060974 -3.21546,0.260033 -4.764009,1.035652c-8.132799,4.052952 -12.871703,16.671795 -10.797704,28.722145c1.51896,8.798126 5.70372,15.515091 11.471105,18.440926c1.952948,0.989922 4.018875,1.479507 6.103634,1.479507c0.95047,0 1.90453,-0.106705 2.853205,-0.31205l31.595972,-0.94957c0.364048,-0.009865 0.720924,-0.102219 1.043724,-0.264519c10.163761,-5.087708 16.754292,-19.223713 16.817059,-34.381027c0.026894,-0.111191 0.073524,-0.214306 0.073524,-0.331772zm-48.30722,30.224968c-0.617805,0.308456 -1.232922,0.540688 -1.839968,0.716446l-2.054272,0.058273c-0.326387,0.009865 -0.642015,0.088776 -0.928949,0.210724c-1.040138,-0.102219 -2.066826,-0.407089 -3.081858,-0.921776c-4.274427,-2.164566 -7.560724,-7.698814 -8.793646,-14.808514c-1.659736,-9.651764 2.0471,-20.357109 8.093348,-23.372612c1.446329,-0.719131 2.872932,-0.728096 4.233179,-0.041248c2.482882,1.260719 4.406239,4.563156 5.140612,8.835793c1.105595,6.408501 -1.526133,12.404537 -4.686895,13.979088c-0.674297,0.33894 -1.277756,0.348804 -1.896458,0.034073c-1.027584,-0.520065 -2.30534,-2.105381 -2.806578,-4.994453c-0.612427,-3.551708 0.817762,-7.133907 2.50709,-7.97678c1.245476,-0.618702 1.752094,-2.125107 1.134287,-3.366993c-0.618702,-1.243683 -2.130487,-1.752098 -3.3661,-1.133392c-3.883478,1.928734 -6.179852,7.787579 -5.224897,13.330795c0.703886,4.078056 2.707047,7.222679 5.497484,8.635834c2.034546,1.030273 4.310295,1.020409 6.401333,-0.028698c5.541418,-2.758156 8.792746,-11.252316 7.395735,-19.336693c-0.616909,-3.577717 -1.965502,-6.554661 -3.763327,-8.871658l11.199411,0c0.062767,0.346115 0.154228,0.672504 0.215199,1.025791c2.754574,15.901554 -3.250427,32.961609 -13.374729,38.026001zm29.647507,-0.251076l-21.750534,0.661743c8.598171,-8.36055 13.065388,-24.115047 10.436348,-39.308228c-1.612213,-9.363928 -5.245522,-17.226831 -10.288395,-22.562917l21.353306,0c3.383137,2.104486 6.327801,5.546803 8.645699,9.882203l-14.234642,0c-1.379978,0 -2.511574,1.126219 -2.511574,2.511574c0,1.387148 1.131596,2.51247 2.511574,2.51247l16.47094,0c0.971092,2.642488 1.770927,5.481346 2.286507,8.511196c0.313835,1.758369 0.467171,3.531982 0.564003,5.306496l-14.928665,0c-1.380871,0 -2.51247,1.126217 -2.51247,2.51157c0,1.383568 1.131599,2.511578 2.51247,2.511578l14.899979,0c-0.263618,4.917336 -1.256241,9.627548 -2.875626,13.817688l-16.427002,0c-1.379078,0 -2.51247,1.128014 -2.51247,2.51247c0,1.38356 1.133392,2.512466 2.51247,2.512466l14.014961,0c-2.190563,3.787537 -4.928104,6.862221 -8.166878,8.61969z" }]
    },
    {
        name: tf.styles.SvgGlyphMeasure2Name, W: 145.261, H: 145.261,
        paths: [
            { d: "m31.43428,22.218863l-18.93448,0c-3.440969,0 -3.440969,2.776997 -3.440969,4.676542l0,8.060009l16.350917,0c0.474888,0 0.859154,0.585548 0.859154,1.061306c0,0.475758 -0.386009,1.061306 -0.859154,1.061306l-16.351789,0l0,4.245228l9.46811,0c0.474888,0 0.859154,0.585548 0.859154,1.061306c0,0.474888 -0.386009,1.061306 -0.859154,1.061306l-9.46811,0l0,4.245228l16.351792,0c0.474888,0 0.68314,0.509743 0.68314,0.984627c0,0.475758 -0.208252,1.137985 -0.68314,1.137985l-16.351792,0l0,4.245228l9.46811,0c0.474888,0 0.859154,0.585548 0.859154,1.061306s-0.386009,1.06131 -0.859154,1.06131l-9.46811,0l0,4.245224l16.351792,0c0.474888,0 0.859154,0.585548 0.859154,1.061302c0,0.474892 -0.386009,1.06131 -0.859154,1.06131l-16.351792,0l0,4.246101l9.46811,0c0.474888,0 0.859154,0.585548 0.859154,1.061302c0,0.475761 -0.386009,1.06131 -0.859154,1.06131l-9.46811,0l0,4.245232l16.351792,0c0.474888,0 0.859154,0.585541 0.859154,1.06218c0,0.474884 -0.386009,1.061302 -0.859154,1.061302l-16.351792,0l0,4.246094l9.46811,0c0.474888,0 0.662228,0.587296 0.662228,1.063927c0,0.474884 -0.186468,1.058693 -0.662228,1.058693l-9.46811,0l0,4.246101l16.351792,0c0.474888,0 0.859154,0.585541 0.859154,1.060432c0,0.476631 -0.386009,1.06218 -0.859154,1.06218l-16.351792,0l0,4.245224l9.46811,0c0.474888,0 0.859154,0.586418 0.859154,1.062172s-0.386009,1.06218 -0.859154,1.06218l-9.46811,0l0,4.245232l16.351792,0c0.474888,0 0.859154,0.585548 0.859154,1.06131s-0.386009,1.062172 -0.859154,1.062172l-16.351792,0l0,4.244354l9.46811,0c0.474888,0 0.859154,0.586426 0.859154,1.06218c0,0.474892 -0.386009,1.06218 -0.859154,1.06218l-9.46811,0l0,4.245224l16.351792,0c0.474888,0 0.859154,0.585556 0.859154,1.06218c0,0.474884 -0.386009,1.06044 -0.859154,1.06044l-16.351792,0l0,8.068718c0,1.9039 1.541422,2.546097 3.443583,2.546097l18.93448,0c1.899546,0 5.217653,-0.642197 5.217653,-2.546097l0,-94.672398c0,-1.899546 0,-4.676542 -5.219395,-4.676542z" },
            { d: "m126.037849,112.169395l-1.886475,1.786278c-0.671814,0.671806 -1.761017,0.513222 -2.434555,-0.158585c-0.672699,-0.671814 -0.672699,-1.704369 0,-2.377922l1.991043,-1.991043l-5.081726,-5.540054l-4.802025,4.802895c-0.672691,0.671806 -1.761879,0.671806 -2.435432,0c-0.671814,-0.672684 -0.671814,-1.761879 0,-2.434563l4.908325,-4.909195l-5.081726,-5.538315l-2.554802,2.553062c-0.671814,0.672684 -1.761002,0.672684 -2.433685,0c-0.672691,-0.671806 -0.672691,-1.761002 0,-2.434555l2.658493,-2.65937l-5.081726,-5.540924l-5.468605,5.470345c-0.672684,0.671814 -1.761002,0.671814 -2.435425,0c-0.671814,-0.672676 -0.671814,-1.761871 0,-2.434555l5.574036,-5.574036l-5.904282,-6.438423l-2.399704,2.398834c-0.671806,0.672676 -1.761002,0.672676 -2.433685,0c-0.673561,-0.671814 -0.673561,-1.761009 0,-2.434555l2.500778,-2.502525l-5.904282,-6.439293l-6.210121,6.211868c-0.672684,0.671814 -1.761879,0.671814 -2.435432,0c-0.671814,-0.672684 -0.671814,-1.761871 0,-2.435425l6.317299,-6.317307l-5.081718,-5.540054l-2.242867,2.243729c-0.672676,0.672684 -1.761864,0.672684 -2.435425,0c-0.671806,-0.672684 -0.671806,-1.761871 0,-2.434555l2.34742,-2.34742l-5.081726,-5.540062l-5.157524,5.158409c-0.672691,0.672684 -1.761879,0.672684 -2.434563,0s-0.672684,-1.761871 0,-2.434559l5.264709,-5.264709l-5.905151,-6.438423l-2.086895,2.086891c-0.672684,0.672684 -1.761871,0.672684 -2.434555,0s-0.672684,-1.761875 0,-2.434559l2.192322,-2.193192l-5.081726,-5.540054l-5.003304,5.0033c-0.672684,0.672684 -1.761871,0.672684 -2.434555,0c-0.672684,-0.67181 -0.672684,-1.761002 0,-2.434555l4.676544,-5.106995l-10.867508,-11.494877c-1.309639,-1.373249 -2.339581,-0.950645 -2.339581,0.951519l0,98.111622c0,1.900421 1.479557,2.525177 3.381718,2.525177l89.504414,0c1.902161,0 2.418869,-0.696213 1.15889,-2.119125l-8.905205,-9.820145zm-72.402393,-0.796417l0,-52.887573l51.359241,52.886711l-51.359241,0l0,0.000862z" }
        ]
    }, {
        name: tf.styles.SvgGlyphMeasureName, W: 31.154, H: 31.154,
        paths: [
            { d: "m26.068542,15.236625c0,0 -1.257383,0.254503 -2.836899,0.452053l-0.74749,-3.226662l0.575745,0l0,-5.375692l-1.964828,0l0,-4.229542l-2.09119,0l0,4.229542l-1.965717,0l0,5.375692l0.574854,0l-0.74482,3.222212c-1.576844,-0.196659 -2.836897,-0.446712 -2.836897,-0.446712l0,2.406203c0,0 0.979745,0.195772 2.295858,0.377304l-2.279841,9.841049l0.654943,0.151278l-0.189543,0.862282l0.399551,0.088099l-0.079199,0.364845l0.226917,0.049833l0.080088,-0.364847l0.484978,0.106785l0.185982,-0.850714l0.722573,0.167294l2.388405,-10.151611c0.392431,0.022245 0.783083,0.037374 1.158609,0.037374c0.355946,0 0.722572,-0.013348 1.093647,-0.033815l2.387514,10.148052l0.719904,-0.167294l0.199331,0.911224l0.484978,-0.105894l0.080978,0.363956l0.226025,-0.050724l-0.078306,-0.364845l0.39599,-0.088097l-0.202,-0.923681l0.658503,-0.153059l-2.277172,-9.836599c1.316114,-0.183313 2.29497,-0.381754 2.29497,-0.381754l0,-2.404424l0.003559,0l0,0.000889zm-8.410143,-7.533621l4.7866,0l0,4.140555l-0.102335,0l-1.901648,0l-0.779524,0l-1.901648,0l-0.101446,0l0,-4.140555zm-1.579515,19.993555l-1.285857,-0.297216l2.152589,-9.29912c0.435144,0.053391 0.894318,0.101444 1.357939,0.139709l-2.22467,9.456627zm2.780838,-11.822787c-0.460062,-0.029366 -0.922794,-0.06941 -1.371286,-0.117462l0.761726,-3.294292l1.411331,0l-0.801771,3.411755zm1.223568,0.042713c-0.195772,0 -0.394211,-0.004448 -0.597992,-0.011568l0.566847,-2.406203l0.567736,2.408875c-0.183313,0.006228 -0.362177,0.008897 -0.536591,0.008897zm0.357727,-3.454468l1.41222,0l0.762617,3.298742c-0.449383,0.048941 -0.911226,0.088985 -1.371286,0.117462l-0.803551,-3.416204zm4.870249,14.937325l-1.284081,0.297216l-2.223782,-9.452177c0.463621,-0.037374 0.921906,-0.086317 1.357941,-0.138821l2.149921,9.293781z" },
            { d: "m5.085456,28.928133l6.877789,0l0,-27.213052l-6.877789,0l0,27.213052zm1.196872,-26.017068l4.484935,0l0,1.450485l-2.130344,0l0,0.862282l2.130344,0l0,0.931692l-1.382854,0l0,0.862282l1.382854,0l0,1.28052l-2.130344,0l0,0.861392l2.130344,0l0,0.931692l-1.382854,0l0,0.862282l1.382854,0l0,1.258273l-2.35548,0l0,0.862283l2.35459,0l0,0.932581l-1.607101,0l0,0.861393l1.607991,0l0,1.28052l-2.35548,0l0,0.862282l2.35459,0l0,0.931692l-1.607101,0l0,0.862282l1.607991,0l0,1.181746l-2.35548,0l0,0.862282l2.35459,0l0,0.93169l-1.607101,0l0,0.862282l1.607991,0l0,1.280521l-2.35548,0l0,0.861391l2.35459,0l0,0.932583l-1.607101,0l0,0.862282l1.607991,0l0,1.152378l-4.484935,0l0,-24.821086z" }
        ]
    }, {
        name: tf.styles.SvgGlyphCloseXName, W: 16, H: 16,
        paths: [{ d: "m14.743668,2.536786l-1.280454,-1.280454l-5.463214,5.463214l-5.462371,-5.463214l-1.281297,1.280454l5.463214,5.463214l-5.463214,5.463214l1.280454,1.280454l5.463214,-5.463214l5.46237,5.463214l1.280455,-1.280454l-5.462371,-5.463214" }]
    }, {
        name: tf.styles.SvgGlyphMapLayersName, W: 16, H: 16,
        paths: [{ d: "m8,8l-6,-3l6,-3l6,3l-6,3zm0,1.102l-3.703,-1.852l-2.297,0.75l6,3l6,-3l-2.109,-0.797l-3.891,1.899zm0,3l-3.703,-1.852l-2.297,0.75l6,3l6,-3l-2.109,-0.797l-3.891,1.899z" }]
    }, {
        name: tf.styles.SvgGlyphInfoName, W: 16, H: 16,
        paths: [{ d: "m8,0.792577c-3.980299,0 -7.207423,3.227124 -7.207423,7.207423c0,3.979399 3.227124,7.207423 7.207423,7.207423s7.207423,-3.228024 7.207423,-7.207423c0,-3.980299 -3.227123,-7.207423 -7.207423,-7.207423zm-0.652272,12.30127c-0.840565,0 -1.254992,-0.367579 -1.178413,-0.882009c0.142347,-0.941469 0.366678,-2.764047 0.66939,-5.037989l-0.9703,-0.301811l0.106309,-0.479294l2.64062,-0.301811l0.325234,0.142346l-0.75768,5.399261c-0.041443,0.290099 0.029731,0.450464 0.207213,0.450464c0.135139,0 0.27208,-0.072074 0.544161,-0.272981l0.165771,0.432445c-0.141445,0.177484 -0.715337,0.851377 -1.752305,0.851377zm0.743266,-8.028169c-0.66038,0 -1.218055,-0.623442 -1.202739,-1.239676c0.021623,-0.809934 0.555872,-1.4568 1.469414,-1.4568c0.78651,0 1.276614,0.600919 1.262199,1.195531c-0.021622,0.82525 -0.474789,1.500946 -1.528874,1.500946z" }]
    }, {
        name: tf.styles.SvgGlyphMapDirectionsName, W: 885.1, H: 885.1,
        paths: [
            { d: "m78.585098,268.950256l0,475.153748c0,11.532715 7.332047,21.726929 18.240723,25.39209l204.135086,68.760376l0,-531.751801l-187.056778,-62.948364c-17.346558,-5.901398 -35.319031,7.063812 -35.319031,25.393951z" },
            { d: "m612.304932,487.39093c-7.690613,8.13855 -17.526306,13.859314 -28.165771,16.541809l0,259.48407l186.967346,62.948364c17.346558,5.812012 35.408447,-7.063843 35.408447,-25.393982l0,-475.152802c0,-11.534576 -7.331177,-21.727905 -18.239807,-25.393951l-38.628357,-13.054626c-8.494446,23.695038 -22.174988,50.161987 -40.952148,79.221954c-24.768066,38.359131 -58.119934,80.20639 -96.389709,120.799164z" },
            { d: "m527.539246,487.302368c-37.196808,-39.701263 -70.101593,-81.09967 -95.316711,-119.727051c-19.492523,-29.954102 -33.620178,-56.95755 -42.204041,-80.83139l-58.656403,19.760773l0,531.752686l222.375824,-74.929138l0,-259.931091c-9.92511,-2.949829 -19.045471,-8.405945 -26.198669,-16.094788z" },
            { d: "m570.369141,46.842693c-0.178833,0 -0.357666,0 -0.447083,0c-89.683502,0 -163.719391,71.889896 -166.223022,161.573414c-0.447052,15.558258 1.251831,30.669434 4.82843,45.065308c1.430664,7.689697 3.755463,15.915924 6.974426,24.678619c15.379395,42.293427 39.789795,80.742004 67.240265,116.239868c17.79364,23.069153 54.543365,84.40802 87.179901,84.40802c34.693115,0 74.482971,-68.222961 92.544861,-92.634216c24.410339,-32.993347 47.837158,-68.581512 61.78595,-107.387787c3.219849,-8.941498 5.634033,-17.435944 7.063782,-25.304504c3.218933,-12.875793 4.917847,-26.377502 4.917847,-40.326294c0,-91.650665 -74.214661,-166.044178 -165.865356,-166.312428zm13.77002,249.200397c-4.649658,0.715332 -9.388611,1.162384 -14.217102,1.162384c-5.543701,0 -10.908569,-0.536469 -16.184143,-1.52002c-26.020752,-4.82843 -48.016022,-21.280853 -60.445648,-43.724091c-6.974365,-12.607574 -10.90863,-27.003418 -10.90863,-42.382843c0,-48.373672 39.253326,-87.626984 87.626984,-87.626984c48.374573,0 87.626953,39.253311 87.626953,87.626984c0,15.647675 -4.113098,30.311768 -11.266296,43.008759c-12.874939,22.62204 -35.586426,39.074463 -62.232117,43.455811z" }
        ]
    }, {
        name: tf.styles.SvgGlyphMapPinName, W: 430.114, H: 430.114,
        paths: [{ d: "m336.607635,122.049576c-1.31839,-4.941208 -3.995667,-10.206192 -5.976288,-14.815849c-23.700195,-56.957253 -75.484589,-77.369621 -117.297928,-77.369621c-55.974701,0 -117.624275,37.533478 -125.855011,114.898788l0,15.806137c0,0.659637 0.227341,6.585114 0.550262,9.549149c4.613968,36.870392 33.707451,76.055542 55.435623,112.925949c23.376404,39.502899 47.632874,78.362518 71.664597,117.20578c14.818436,-25.348419 29.583466,-51.03006 44.064346,-75.722321c3.946594,-7.246429 8.527802,-14.488586 12.478699,-21.405212c2.633392,-4.605347 7.664124,-9.210693 9.962494,-13.495728c23.375519,-42.797592 61.00116,-85.925888 61.00116,-128.398849l0,-17.448318c0.000854,-4.604492 -5.706757,-20.737015 -6.027954,-21.729904zm-122.249466,79.346771c-16.45372,0 -34.463516,-8.227295 -43.353043,-30.948364c-1.324417,-3.61676 -1.217636,-10.864944 -1.217636,-11.528885l0,-10.206192c0,-28.965164 24.59404,-42.137093 45.989822,-42.137093c26.340439,0 46.712341,21.073708 46.712341,47.414146c0,26.339569 -21.791061,47.406387 -48.131485,47.406387z" }]
    }, {
        name: tf.styles.SvgGlyphAlarmName, W: 45.773, H: 45.773,
        paths: [
            { d: "m7.230119,14.841127c2.270289,-3.466105 5.811132,-6.022158 9.953398,-7.023654c0.319178,-0.076496 0.582081,-0.30247 0.705179,-0.605821c0.12398,-0.30423 0.094084,-0.648905 -0.080013,-0.927635c-1.325947,-2.113779 -3.671854,-3.5215 -6.351886,-3.5215c-4.143147,0 -7.503739,3.358833 -7.503739,7.501979c0,1.758552 0.60758,3.373781 1.622264,4.651368c0.203113,0.257629 0.517893,0.400071 0.845862,0.385123s0.629561,-0.186407 0.808934,-0.459862z" },
            { d: "m34.316208,2.762518c-2.667727,0 -5.00572,1.394531 -6.334307,3.494242c-0.175854,0.277851 -0.206629,0.625165 -0.082651,0.931153c0.124857,0.306867 0.388641,0.531961 0.711334,0.607579c4.153698,0.977754 7.706852,3.516223 9.996487,6.970897c0.182011,0.274333 0.485359,0.444033 0.81509,0.455463c0.329727,0.01231 0.64275,-0.135408 0.844982,-0.396553c0.9716,-1.26264 1.552799,-2.841817 1.552799,-4.559923c-0.002636,-4.144025 -3.360592,-7.502859 -7.503735,-7.502859z" },
            { d: "m39.474037,25.739748c0,-2.896334 -0.75354,-5.61857 -2.067177,-7.987339c-2.434715,-4.387585 -6.807356,-7.541546 -11.953754,-8.331137c-0.820366,-0.125736 -1.653038,-0.211024 -2.508574,-0.211024c-0.893343,0 -1.763826,0.091444 -2.619362,0.22861c-5.124418,0.822123 -9.475073,3.989274 -11.884289,8.382133c-1.289897,2.352943 -2.025852,5.05056 -2.025852,7.918756c0,4.911634 2.165657,9.317686 5.577245,12.345911l-1.392772,1.961662c-0.599666,0.844986 -0.40095,2.01442 0.444035,2.615849c0.329727,0.233883 0.708695,0.347309 1.084146,0.347309c0.587357,0 1.16592,-0.275211 1.53082,-0.789589l1.391893,-1.960785c2.346787,1.281105 5.036489,2.010902 7.894135,2.010902c2.856766,0 5.546471,-0.729797 7.893257,-2.010902l1.391897,1.960785c0.365776,0.515259 0.943459,0.789589 1.530819,0.789589c0.37545,0 0.753536,-0.113426 1.083267,-0.347309c0.844982,-0.601429 1.044579,-1.770863 0.444912,-2.615849l-1.392773,-1.961662c3.411587,-3.028225 5.578125,-7.434277 5.578125,-12.345911zm-16.528625,11.907152c-6.566431,0 -11.90715,-5.340721 -11.90715,-11.907152c0,-2.046951 0.519653,-3.973444 1.432342,-5.658136c1.737447,-3.204082 4.906356,-5.51218 8.639762,-6.093382c0.599665,-0.093203 1.209003,-0.156511 1.835047,-0.156511c0.589115,0 1.165039,0.057154 1.732172,0.140684c3.765059,0.552185 6.968258,2.860285 8.725935,6.078434c0.923237,1.690845 1.448166,3.62789 1.448166,5.688034c0,6.567308 -5.340723,11.90803 -11.906273,11.90803z" },
            { d: "m29.615599,28.525293l-4.542339,-2.804888c-0.094084,-0.531082 -0.381605,-0.989185 -0.785192,-1.313639l0.207506,-5.699463c0.025501,-0.728043 -0.542511,-1.339138 -1.269672,-1.366396c-0.725403,-0.033413 -1.339136,0.541634 -1.366394,1.269674l-0.208389,5.70562c-0.563616,0.397432 -0.934669,1.051613 -0.934669,1.794601c0,1.214279 0.98391,2.197309 2.198189,2.197309c0.345556,0 0.668251,-0.087048 0.958412,-0.228613l4.35681,2.692343c0.216301,0.131893 0.456345,0.196079 0.69199,0.196079c0.442276,0 0.873121,-0.221577 1.123713,-0.625164c0.383366,-0.621651 0.189926,-1.434099 -0.429962,-1.817465z" }
        ]
    }, {
        name: tf.styles.SvgGlyphParkingName, W: 252.094, H: 252.094,
        paths: [
            { d: "m185.140823,143.323944c-0.90892,0 -1.844482,0.130798 -2.780899,0.389069l-3.522354,0.970551l-5.189423,-12.640686c-2.90921,-7.086403 -11.508514,-12.851494 -19.169754,-12.851494l-56.956078,0c-7.660408,0 -16.260551,5.76593 -19.168922,12.852318l-5.180244,12.617371l-3.438225,-0.947235c-0.936409,-0.25827 -1.871994,-0.389053 -2.780907,-0.389053c-4.56958,0 -7.887009,3.278275 -7.887009,7.79451c0,4.458801 3.254105,8.212769 7.664581,9.339966c-2.41851,6.679016 -4.298004,16.69043 -4.298004,23.267792l0,26.898468c0,5.742584 4.671219,10.413818 10.413818,10.413818l3.818115,0c5.742599,0 10.413818,-4.671234 10.413818,-10.413818l0,-5.031952l77.841194,0l0,5.031952c0,5.742584 4.671204,10.413818 10.413788,10.413818l3.819794,0c5.742599,0 10.413818,-4.671234 10.413818,-10.413818l0,-26.898468c0,-6.570709 -1.876129,-16.568787 -4.290497,-23.247803c4.453796,-1.099701 7.750397,-4.873657 7.750397,-9.359955c-0.000824,-4.51709 -3.317413,-7.795349 -7.887009,-7.795349zm-105.493614,10.496277l8.465179,-20.622681c1.740356,-4.238815 6.913109,-7.707039 11.495186,-7.707039l52.788055,0c4.582062,0 9.754822,3.468224 11.495193,7.707039l8.465164,20.622681c1.740356,4.238861 -0.584839,7.707062 -5.166931,7.707062l-82.374931,0c-4.582077,0 -6.907265,-3.468201 -5.166916,-7.707062zm22.443855,33.533325c0,2.291046 -1.874489,4.165527 -4.165527,4.165527l-17.276932,0c-2.291039,0 -4.165527,-1.874481 -4.165527,-4.165527l0,-6.890625c0,-2.291016 1.874489,-4.165497 4.165527,-4.165497l17.276932,0c2.291039,0 4.165527,1.874481 4.165527,4.165497l0,6.890625zm73.239105,0c0,2.291046 -1.874481,4.165527 -4.165527,4.165527l-17.275269,0c-2.291016,0 -4.165497,-1.874481 -4.165497,-4.165527l0,-6.890625c0,-2.291016 1.874481,-4.165497 4.165497,-4.165497l17.275269,0c2.291046,0 4.165527,1.874481 4.165527,4.165497l0,6.890625z" },
            { d: "m226.434509,80.635277l-95.740433,-56.120472c-1.270493,-0.744797 -2.920876,-1.154678 -4.647072,-1.154678c-1.726196,0 -3.376572,0.409882 -4.647064,1.154678l-95.740444,56.120472c-2.63512,1.544571 -4.62291,5.013618 -4.62291,8.068619l0,133.781685c0,3.444901 2.80257,6.248306 6.248291,6.248306l10.757061,0c3.445717,0 6.248291,-2.803406 6.248291,-6.248306l0,-113.208992c0,-1.14801 0.933907,-2.082748 2.082756,-2.082748l159.346375,0c1.148834,0 2.082764,0.934738 2.082764,2.082748l0,113.208992c0,3.444901 2.802551,6.248306 6.248276,6.248306l10.757889,0c3.44574,0 6.248291,-2.803406 6.248291,-6.248306l0,-133.781685c0.000824,-3.055 -1.986969,-6.524048 -4.62207,-8.068619l0,0z" }
        ]
    }, {
        name: tf.styles.SvgGlyphMessagesName, W: 611.932, H: 611.932,
        paths: [{ d: "m510.886414,229.428406l-110.864441,0l0,-89.889816c0,-23.360428 -19.199036,-42.558655 -42.558655,-42.558655l-258.904648,0c-23.359619,0 -42.558655,19.198227 -42.558655,42.558655l0,155.808914c0,23.360413 19.199036,42.558655 42.558655,42.558655l25.191315,0l31.738541,42.558655c1.775558,2.996124 5.381989,4.216705 8.989227,4.216705s6.603394,-1.775543 8.989227,-4.216705l31.738556,-42.558655l4.771698,0l0,89.889801c0,23.360413 19.199005,42.558655 42.558624,42.558655l152.202484,0l31.738556,42.558655c1.775543,2.996155 5.381989,4.216736 8.989227,4.216736s6.603394,-1.775574 8.989197,-4.216736l31.738586,-42.558655l25.191284,0c23.360474,0 42.558655,-19.199036 42.558655,-42.558655l0,-155.808899c0.056152,-23.415771 -19.086731,-42.558655 -43.057434,-42.558655zm-311.617828,86.282562c-3.60643,0 -6.603378,1.775574 -8.989212,4.216736l-26.356583,34.735474l-26.356567,-34.735474c-1.775543,-2.996155 -5.381973,-4.216736 -8.989227,-4.216736l-31.183578,0c-11.375076,0 -20.364304,-8.989227 -20.364304,-20.364288l0,-155.80809c0,-11.375061 8.989227,-20.364288 20.364304,-20.364288l258.904648,0c11.375061,0 20.363495,8.989227 20.363495,20.364288l0,101.264877l0,54.544037c0,11.375061 -8.989258,20.364288 -20.363495,20.364288l-135.499939,0l-21.529541,-0.000824l0,0zm332.591583,112.084991c0,11.375092 -8.989258,20.364319 -20.363525,20.364319l-31.183533,0c-3.606445,0 -6.603394,1.775543 -8.989258,4.216705l-26.356567,34.735504l-26.356567,-34.735504c-1.775543,-2.996124 -5.381958,-4.216705 -8.989227,-4.216705l-157.02948,0c-11.375061,0 -20.364288,-8.989227 -20.364288,-20.364319l0,-89.889801l125.235626,0c8.378937,0 16.202057,-2.385864 22.750122,-6.603394l83.896759,0c5.992249,0 10.764771,-4.771698 10.764771,-10.764771c0,-5.993103 -4.771729,-10.764771 -10.764771,-10.764771l-65.919128,0c1.775543,-4.216736 2.385834,-8.989227 2.385834,-14.371216l0,-43.168945l110.863617,0c11.375061,0 20.364258,8.989227 20.364258,20.364288l0,155.198608l0.055359,0zm-57.540161,-45.554779c0,5.992279 -4.771667,10.764771 -10.764771,10.764771l-163.021759,0c-5.992249,0 -10.764771,-4.771698 -10.764771,-10.764771s4.771698,-10.764771 10.764771,-10.764771l163.021759,0c5.937744,-0.055328 10.764771,4.771667 10.764771,10.764771zm-166.018707,-121.684509l-162.411469,0c-5.992279,0 -10.764771,-4.771698 -10.764771,-10.764801s4.771683,-10.76474 10.764771,-10.76474l162.411469,0c5.992279,0 10.764771,4.771667 10.764771,10.76474c0.610291,5.993103 -4.771698,10.764801 -10.764771,10.764801zm-173.176254,-73.076614c0,-5.992279 4.771683,-10.764786 10.764771,-10.764786l97.657639,0c5.992279,0 10.764771,4.771683 10.764771,10.764786c0,5.992264 -4.771667,10.764771 -10.764771,10.764771l-97.657623,0c-5.993103,-0.000824 -10.764786,-4.772507 -10.764786,-10.764771z" }]
    }, {
        name: tf.styles.SvgGlyphRoadName, W: 455.416, H: 455.416,
        paths: [
            { d: "m239.589569,78.242989c0.324921,8.700958 0.648163,17.401909 0.973938,26.102867c-6.284241,0 -9.425079,0 -15.708496,0c0.324097,-8.700958 0.648987,-17.401909 0.97226,-26.102867c-12.742554,0 -25.484299,0 -38.226852,0c-25.615936,104.87397 -51.236038,209.745262 -76.851135,314.621025c34.451172,0 68.902344,0 103.352661,0c0.324081,-8.701843 0.648163,-17.402802 0.973083,-26.102844c11.756149,0 23.512283,0 35.267624,0c0.326569,8.700928 0.649811,17.401001 0.973083,26.102844c34.451141,0 68.901459,0 103.352631,0c-25.615906,-104.873962 -51.235168,-209.74614 -76.851105,-314.621025c-12.74173,0 -25.484283,0 -38.227692,0zm-16.193329,65.186195c6.20755,0 12.415131,-0.003586 18.623535,-0.001785c0.901459,24.194366 1.802032,48.390518 2.705139,72.583984c-8.011261,0 -16.021729,0 -24.033813,0c0.904755,-24.192581 1.80452,-48.387833 2.705139,-72.582199zm-6.865753,184.247726c0.900589,-24.193451 1.803696,-48.387817 2.705124,-72.581299c8.981857,0 17.96373,-0.00177 26.944778,-0.00177c0.902252,24.193451 1.804535,48.389618 2.705109,72.583069c-10.783875,0 -21.570282,0 -32.355011,0z" },
            { d: "m302.874146,78.242989c-5.205292,0 -7.808807,0 -13.01416,0c32.459167,104.87397 64.910828,209.747032 97.371704,314.621025c11.727814,0 23.456482,0 35.184296,0c-39.845612,-104.875763 -79.693695,-209.747055 -119.54184,-314.621025z" },
            { d: "m162.54184,78.242989c-39.848114,104.87487 -79.697067,209.745262 -119.54184,314.621025c11.728653,0 23.456482,0 35.185135,0c32.45668,-104.873962 64.912521,-209.74614 97.370865,-314.621017c-5.205338,-0.000008 -7.808838,-0.000008 -13.01416,-0.000008z" }
        ]
    }, {
        name: tf.styles.SvgGlyphBusStopName, W: 395, H: 395,
        paths: [
            { d: "m299.633789,22.857147l-204.26757,0c-39.981285,0 -72.509071,32.526905 -72.509071,72.508179l0,204.259644c0,39.986572 32.527786,72.517883 72.509071,72.517883l204.26757,0c39.982178,0 72.509064,-32.531311 72.509064,-72.517883l0,-204.259644c0,-39.981274 -32.526886,-72.508179 -72.509064,-72.508179zm59.245056,276.767822c0,32.672791 -26.57666,59.253876 -59.245056,59.253876l-204.26757,0c-32.667507,0 -59.245052,-26.581085 -59.245052,-59.253876l0,-204.259644c0,-32.667492 26.577545,-59.24416 59.245052,-59.24416l204.26757,0c32.668396,0 59.245056,26.576668 59.245056,59.24416l0,204.259644z" },
            { d: "m325.843475,251.141434l0,-57.280197c0,0 -4.294891,-33.228119 -6.375549,-49.842621c-1.909149,-13.932526 -8.834717,-35.414032 -75.069016,-35.414032c-66.236069,0 -73.299591,21.485046 -75.21051,35.414032c-2.082443,16.614502 -4.158707,33.229004 -6.237625,49.842621l0,57.281967c-1.465225,1.109741 -2.416687,2.863266 -2.416687,4.841354l0,8.755127c0,3.353149 2.722656,6.076691 6.076691,6.076691l13.057083,0l0,10.567871c0,2.250488 1.822479,4.072052 4.072052,4.072052l13.025269,0c2.245163,0 4.072052,-1.821564 4.072052,-4.072052l0,-10.567871l87.118027,0l0,10.567871c0,2.250488 1.824249,4.072052 4.072052,4.072052l13.025269,0c2.250458,0 4.074707,-1.821564 4.074707,-4.072052l0,-10.567871l13.057068,0c3.353149,0 6.075836,-2.723541 6.075836,-6.076691l0,-8.755127c0.00177,-1.978943 -0.950562,-3.732452 -2.416718,-4.843124zm-107.89743,-127.430893l52.900391,0c2.185059,0 3.949158,1.771164 3.949158,3.952667c0,2.179718 -1.764099,3.950027 -3.949158,3.950027l-52.900391,0c-2.182373,0 -3.946487,-1.770309 -3.946487,-3.950027c0,-2.181503 1.76413,-3.952667 3.946487,-3.952667zm-13.857346,117.128311c-6.746078,0 -12.211731,-5.470078 -12.211731,-12.212616c0,-6.747849 5.465652,-12.212616 12.211731,-12.212616c6.744308,0 12.210846,5.465652 12.210846,12.212616c-0.000015,6.741669 -5.466537,12.212616 -12.210846,12.212616zm80.619553,0c-6.747864,0 -12.213501,-5.470078 -12.213501,-12.212616c0,-6.747849 5.465637,-12.212616 12.213501,-12.212616c6.742523,0 12.210846,5.465652 12.210846,12.212616c0.000885,6.741669 -5.468323,12.212616 -12.210846,12.212616zm11.952637,-52.985306c-2.493652,0 -5.192413,0 -8.053894,0c-0.831207,-3.0065 -1.858734,-5.287933 -3.15686,-7.117477c-3.935883,-5.557632 -9.922333,-6.019211 -15.217346,-6.019211c-5.298553,0 -11.281464,0.460693 -15.213837,6.019211c-1.29808,1.829544 -2.325577,4.110977 -3.156815,7.117477c-21.77774,-0.0009 -44.522873,-0.0009 -59.724319,0.000885c-3.457489,0 -6.093475,-2.717377 -5.882141,-6.074936c0.649933,-10.462646 1.306061,-20.925293 1.962189,-31.387955c0.206924,-3.356674 3.01889,-6.07933 6.27211,-6.07933c25.371414,0 74.443832,0 99.817001,0c3.253235,0 6.063416,2.722656 6.27475,6.07933c0.651703,10.462662 1.305176,20.925308 1.957794,31.387955c0.209564,3.357559 -2.424652,6.074051 -5.878632,6.074051z" },
            { d: "m258.46051,157.061569c-0.349243,1.147781 -0.543793,2.362762 -0.543793,3.623734c0,6.800903 5.514282,12.309875 12.315155,12.309875c6.801819,0 12.317871,-5.508102 12.317871,-12.309875c0,-1.260971 -0.19632,-2.475952 -0.550018,-3.623734l3.628143,-6.220825l-30.791962,0l3.624603,6.220825z" },
            { d: "m106.663605,211.505936c12.924454,-2.946381 22.574478,-14.501114 22.574478,-28.319565c0,-16.047684 -13.009346,-29.057037 -29.054382,-29.057037c-16.045929,0 -29.057045,13.009354 -29.057045,29.057037c0,13.818451 9.650902,25.374054 22.577141,28.319565l0,61.928787l-26.965759,0l0,12.960693l66.887787,0l0,-12.960693l-26.962219,0l0,-61.928787z" }
        ]
    }, {
        name: tf.styles.SvgGlyphBusStop2Name, W: 395, H: 395,
        paths: [
            { d: "m354.270111,263.858307l0,-70.859711c0,0 -5.31308,-41.105591 -7.886993,-61.658936c-2.361755,-17.235527 -10.929199,-43.809692 -92.865784,-43.809692c-81.938797,0 -90.67688,26.578545 -93.040817,43.809692c-2.576141,20.553345 -5.144623,41.106674 -7.7164,61.658936l0,70.861908c-1.812592,1.372833 -2.989609,3.542053 -2.989609,5.989105l0,10.830719c0,4.148102 3.368118,7.517303 7.517303,7.517303l16.152542,0l0,13.073212c0,2.784027 2.254547,5.037445 5.03743,5.037445l16.11319,0c2.777435,0 5.03743,-2.253418 5.03743,-5.037445l0,-13.073212l107.771255,0l0,13.073212c0,2.784027 2.256744,5.037445 5.037445,5.037445l16.11319,0c2.783966,0 5.04071,-2.253418 5.04071,-5.037445l0,-13.073212l16.152527,0c4.148071,0 7.516235,-3.369202 7.516235,-7.517303l0,-10.830719c0.002197,-2.44809 -1.175903,-4.61731 -2.989655,-5.991302zm-133.476883,-157.641182l65.441605,0c2.703064,0 4.885376,2.191048 4.885376,4.889732c0,2.696465 -2.182312,4.886467 -4.885376,4.886467l-65.441605,0c-2.699753,0 -4.882095,-2.190002 -4.882095,-4.886467c0,-2.698685 2.182358,-4.889732 4.882095,-4.889732zm-17.142532,144.896156c-8.345383,0 -15.106796,-6.766876 -15.106796,-15.10788c0,-8.34758 6.761414,-15.10791 15.106796,-15.10791c8.343201,0 15.105698,6.761429 15.105698,15.10791c-0.000015,8.339905 -6.762497,15.10788 -15.105698,15.10788zm99.732178,0c-8.347595,0 -15.108978,-6.766876 -15.108978,-15.10788c0,-8.34758 6.761383,-15.10791 15.108978,-15.10791c8.341003,0 15.105713,6.761429 15.105713,15.10791c0.001099,8.339905 -6.764709,15.10788 -15.105713,15.10788zm14.786285,-65.546631c-3.084839,0 -6.423401,0 -9.963257,0c-1.028259,-3.719269 -2.299377,-6.541565 -3.905243,-8.80484c-4.868988,-6.875198 -12.274658,-7.446198 -18.824951,-7.446198c-6.554718,0 -13.955994,0.569916 -18.820618,7.446198c-1.605835,2.263275 -2.876923,5.085571 -3.905212,8.80484c-26.940643,-0.001129 -55.078003,-0.001129 -73.883286,0.001083c-4.277161,0 -7.538071,-3.361588 -7.276627,-7.515121c0.804016,-12.943054 1.615692,-25.886108 2.427368,-38.829163c0.255981,-4.152451 3.734573,-7.520584 7.759048,-7.520584c31.386276,0 92.092392,0 123.48082,0c4.024475,0 7.500885,3.368134 7.762299,7.520584c0.806213,12.943054 1.614624,25.886108 2.421936,38.829163c0.259247,4.153534 -2.999451,7.514038 -7.272278,7.514038z" },
            { d: "m270.912537,147.474747c-0.432037,1.419876 -0.672699,2.922913 -0.672699,4.482819c0,8.413193 6.821564,15.228195 15.234711,15.228195c8.414368,0 15.238098,-6.813904 15.238098,-15.228195c0,-1.559906 -0.242859,-3.062943 -0.680389,-4.482819l4.488251,-7.695602l-38.091858,0l4.483887,7.695602z" },
            { d: "m83.12883,214.82634c15.988495,-3.644867 27.92627,-17.938919 27.92627,-35.03334c0,-19.852127 -16.093506,-35.945633 -35.942368,-35.945633c-19.849968,0 -35.945648,16.093506 -35.945648,35.945633c0,17.094421 11.93885,31.389526 27.929543,35.03334l0,76.610367l-33.358589,0l0,16.033325l82.74501,0l0,-16.033325l-33.354218,0l0,-76.610367z" }
        ]
    }, {
        name: tf.styles.SvgGlyphBusName, W: 45.437, H: 45.437,
        paths: [{ d: "m38.959923,13.213912c-0.322495,-3.15284 -0.836231,-5.607655 -1.649002,-6.572544c-3.351036,-3.967344 -26.824778,-4.25768 -29.489957,0c-0.651952,1.043123 -1.109187,3.489246 -1.416039,6.57776c-0.990098,0.116482 -1.761139,0.950111 -1.761139,1.970634l0,3.862162c0,0.858835 0.544162,1.582937 1.303904,1.865452c-0.179939,6.083143 -0.033902,12.429682 0.235571,15.585997c0,2.436565 1.636834,2.032352 1.636834,2.032352l1.534259,0l0,2.630405c0,1.043125 1.075286,1.887184 2.400052,1.887184c1.326505,0 2.401791,-0.844059 2.401791,-1.887184l0,-2.630405l17.849571,0l0,2.630405c0,1.043125 1.074417,1.887184 2.400925,1.887184c1.324764,0 2.400047,-0.844059 2.400047,-1.887184l0,-2.630405l0.504181,0c0,0 1.9263,0.264256 2.049736,-0.883183c0,-3.147621 0.198193,-10.123507 0.034771,-16.708221c0.807552,-0.252956 1.396919,-0.997049 1.396919,-1.892397l0,-3.862162c0.000866,-1.044864 -0.807552,-1.8924 -1.832424,-1.97585zm-25.40613,-6.00665l18.024294,0l0,2.726897l-18.024294,0l0,-2.726897zm0.257304,28.222559c-1.415171,0 -2.561736,-1.14743 -2.561736,-2.562599c0,-1.414307 1.146565,-2.560871 2.561736,-2.560871s2.562604,1.146564 2.562604,2.560871c0,1.415169 -1.146564,2.562599 -2.562604,2.562599zm17.670501,0c-1.414301,0 -2.563475,-1.14743 -2.563475,-2.562599c0,-1.414307 1.148308,-2.560871 2.563475,-2.560871s2.561741,1.146564 2.561741,2.560871c0.00087,1.415169 -1.146568,2.562599 -2.561741,2.562599zm3.257156,-11.21357l-24.345623,0l0,-12.769564l24.345623,0l0,12.769564z" }]
    }, {
        name: tf.styles.SvgGlyphLeftArrowName, W: 493.578, H: 493.578,
        paths: [{ d: "m457.26651,228.576828c0,-15.198685 -12.252594,-27.58606 -27.58609,-27.58606l-228.65683,0l97.020416,-97.019516c10.713013,-10.713036 10.713013,-28.189125 0,-39.102592l-26.045654,-26.046513c-10.713013,-10.713034 -28.189133,-10.713034 -39.102585,0l-188.482964,188.482067c-5.356514,5.356506 -8.101299,12.38739 -8.101299,19.484772c0,7.029999 2.744785,14.12825 8.101299,19.484756l188.482933,188.482941c10.713043,10.712189 28.189163,10.712189 39.102615,0l26.045654,-26.046509c10.713013,-10.713013 10.713013,-28.189117 0,-39.10257l-97.020416,-96.685181l228.522064,0c15.199554,0 27.586945,-12.38736 27.586945,-27.586945l0.133911,-36.758652z" }]
    }, {
        name: tf.styles.SvgGlyphRightArrowName, W: 493.578, H: 493.578,
        paths: [{ d: "m36.311493,263.730835c0,15.1987 12.252594,27.58606 27.58609,27.58606l228.65683,0l-97.020416,97.019531c-10.713013,10.713043 -10.713013,28.189117 0,39.1026l26.045654,26.046509c10.713013,10.713043 28.189133,10.713043 39.1026,0l188.482971,-188.482056c5.356506,-5.356506 8.101288,-12.387405 8.101288,-19.484787c0,-7.029999 -2.744781,-14.12825 -8.101288,-19.484756l-188.482971,-188.482941c-10.713028,-10.712189 -28.189148,-10.712189 -39.1026,0l-26.045654,26.046509c-10.713013,10.713013 -10.713013,28.189117 0,39.10257l97.020416,96.685181l-228.522064,0c-15.199554,0 -27.586945,12.38736 -27.586945,27.586945l-0.133911,36.758636z" }]
    }, {
        name: tf.styles.SvgGlyphHomeName, W: 460.298, H: 460.298,
        paths: [
            { d: "m230.148148,129.384476l-143.848549,124.868591c0,0.176208 -0.042053,0.435516 -0.126175,0.788879c-0.082367,0.350616 -0.126183,0.605286 -0.126183,0.786102l0,126.442703c0,4.565308 1.585144,8.521698 4.754555,11.853424c3.168533,3.333588 6.920662,5.010986 11.257233,5.010986l96.063759,0l0,-101.157074l64.051559,0l0,101.160767l96.062866,0c4.335693,0 8.093079,-1.673706 11.257263,-5.014679c3.169373,-3.328064 4.759796,-7.28717 4.759796,-11.853424l0,-126.442703c0,-0.701233 -0.091125,-1.230835 -0.25238,-1.574982l-143.853745,-124.868591z" },
            { d: "m429.03418,225.801834l-54.785156,-47.94342l0,-107.478249c0,-2.457047 -0.750061,-4.477676 -2.255493,-6.05912c-1.493103,-1.579605 -3.412109,-2.3694 -5.750854,-2.3694l-48.032745,0c-2.336121,0 -4.254242,0.789795 -5.756989,2.3694c-1.499298,1.581444 -2.248505,3.602997 -2.248505,6.05912l0,51.367432l-61.04158,-53.740517c-5.331146,-4.566261 -11.669952,-6.848923 -19.00946,-6.848923c-7.338638,0 -13.676575,2.282661 -19.01297,6.848923l-179.881861,157.794754c-1.667511,1.402435 -2.581444,3.290207 -2.751438,5.661469c-0.169117,2.369385 0.413593,4.438904 1.749882,6.193832l15.510576,19.494019c1.336288,1.57962 3.085289,2.545654 5.254021,2.899017c2.002235,0.177124 4.004478,-0.439178 6.006721,-1.843475l173.11982,-152.001366l173.121536,152.000481c1.337158,1.22525 3.085297,1.836975 5.253998,1.836975l0.751831,0c2.165253,-0.346924 3.910736,-1.319397 5.254028,-2.895294l15.512329,-19.491287c1.333679,-1.758591 1.918121,-3.824417 1.744629,-6.196594c-0.170868,-2.364792 -1.088318,-4.252548 -2.752319,-5.657776z" }
        ]
    }, {
        name: tf.styles.SvgGlyphHollowStarName, W: 611.815, H: 611.815,
        paths: [{ d: "m566.952148,243.921387c-1.467346,-4.334747 -5.73468,-12.270111 -19.472168,-14.404205l-153.378998,-22.340393l-66.953827,-135.373337c-6.468842,-12.936798 -14.404205,-15.137466 -20.873016,-15.137466c-12.937653,0 -20.139771,12.936806 -21.606293,15.137466l-66.953827,135.374191l-151.244942,21.606293c-10.069443,1.467377 -18.005669,7.202087 -20.139755,15.137451c-2.867348,8.669495 0.733276,17.271545 9.336182,25.94104l108.032341,104.431732l-25.206924,149.111725c-0.733261,3.601501 -2.867355,15.137451 4.334732,23.07373c5.734711,7.202026 15.871613,8.669434 26.674316,3.60144c0,0 0.733292,0 0.733292,-0.733276l136.107468,-72.021881l136.107452,72.021881c5.067993,2.867371 10.069427,4.334778 14.404175,4.334778c5.734711,0 10.069458,-2.134094 13.670959,-5.734741c2.86731,-2.867371 5.73468,-8.669495 4.334717,-19.472168l-26.007629,-154.181488l110.166443,-107.299072c9.336182,-9.402771 9.336182,-17.271545 7.935303,-23.0737zm-141.909546,116.701813c-2.867371,2.867371 -4.334747,7.202118 -3.601471,11.536865l25.94104,149.778412l-134.706665,-70.554474c-3.601471,-2.134094 -8.669495,-2.134094 -12.270111,0l-134.706635,70.554474l25.94104,-149.778412c0.733261,-4.334717 -0.733276,-8.669464 -3.601471,-11.536835l-109.432304,-105.898254l150.511681,-21.606277c4.334717,-0.733276 7.935333,-3.601486 10.069427,-7.202133l66.953827,-136.107445l66.952942,136.107445c2.134094,3.601471 5.734741,6.468857 10.069489,7.202133l150.511658,21.606277l-108.632446,105.898224z" }]
    }, {
        name: tf.styles.SvgGlyphStarName, W: 126.73, H: 126.73,
        paths: [{ d: "m112.326828,46.830582l-29.217438,-2.762756c-1.841827,-0.167442 -3.43335,-1.339523 -4.185997,-3.097641l-10.464996,-25.367153c-1.674393,-4.185997 -7.619354,-4.185997 -9.293747,0l-10.381279,25.367153c-0.669762,1.758118 -2.344154,2.930199 -4.185997,3.097641l-29.218275,2.762756c-4.353439,0.418606 -6.111557,5.860405 -2.846479,8.790596l22.018353,19.339325c1.423241,1.255791 2.009285,3.097633 1.590679,4.939476l-6.613874,27.124435c-1.004639,4.270546 3.599955,7.785957 7.451075,5.526344l24.362518,-14.316948c1.590679,-0.920921 3.516235,-0.920921 5.106918,0l24.36335,14.316948c3.851112,2.259613 8.455719,-1.172073 7.450233,-5.526344l-6.530151,-27.124435c-0.418594,-1.841843 0.167435,-3.683685 1.590683,-4.939476l22.018349,-19.339325c3.181374,-2.930191 1.339523,-8.37199 -3.013924,-8.790596z" }]
    }, {
        name: tf.styles.SvgGlyphUploadVideoName, W: 32, H: 32,
        paths: [
            { d: "m22.63689,14.389723l0,-7.030955l-4.634211,-4.632549l-15.276462,0l0,26.547564l19.910671,0l0,-0.048946c3.732422,-0.414803 6.635231,-3.574797 6.63689,-7.417557c-0.001659,-3.844419 -2.904469,-7.004407 -6.63689,-7.417555l0.000002,-0.000002zm-4.979328,-9.661653l2.976646,2.975816l-2.976646,0c0,0 0,-2.975816 0,-2.975816zm-13.272121,22.886486l0,-23.230775l11.614559,0l0,4.978498l4.977667,0l0,5.027444c-0.574921,0.063051 -1.129101,0.197448 -1.659222,0.384941l0,-2.09311l-9.955338,0l0,2.488833l-3.318445,-2.488833l0,8.296114l3.318445,-2.488832l0,2.488832l5.026614,0c-0.030695,0.272942 -0.048944,0.548372 -0.048944,0.829611c0,2.346972 1.085131,4.440079 2.779198,5.80728l-12.734533,0l0,-0.000002zm17.421837,-0.097063c-3.153353,-0.007463 -5.704405,-2.558517 -5.711874,-5.710217c0.007469,-3.153353 2.558521,-5.704405 5.711874,-5.711874c3.151695,0.007467 5.702751,2.558521 5.710217,5.711874c-0.007462,3.151695 -2.558517,5.702751 -5.710217,5.710217z" },
            { d: "m18.488834,22.63689l6.63689,0l-3.320107,-3.318445" }
        ]
    }, {
        name: tf.styles.SvgGlyphLogInName, W: 96.943, H: 96.943,
        paths: [
            { d: "m38.658562,20.173479l39.757797,0l0,56.594442l-39.759399,0c-0.88131,0 -1.596565,0.715263 -1.596565,1.596565l0,5.879379c0,0.881302 0.715256,1.596565 1.596565,1.596565l47.234535,0c0.88131,0 1.596573,-0.715263 1.596573,-1.596565l0,-71.544723c0,-0.88131 -0.715263,-1.596573 -1.596573,-1.596573l-47.232933,0c-0.882111,0 -1.596573,0.715263 -1.596573,1.596573l0,5.877778c0,0.882902 0.713661,1.596563 1.596573,1.596563l0,-0.000008l0,0.000002z" },
            { d: "m72.41008,47.187103l-21.49144,-21.489838c-0.598709,-0.599512 -1.658833,-0.598713 -2.257542,0l-5.098648,5.099447c-0.623466,0.623461 -0.623466,1.634085 0,2.257547l9.707142,9.708744l-42.022534,0c-0.881308,0 -1.596571,0.715267 -1.596571,1.596573l0,7.912601c0,0.88131 0.715263,1.596573 1.596571,1.596573l42.024938,0l-9.707157,9.708736c-0.623459,0.623463 -0.623459,1.634098 0,2.257565l5.098648,5.100243c0.299355,0.299355 0.70649,0.467789 1.12878,0.467789c0.423889,0 0.829422,-0.168434 1.128777,-0.467789l21.491432,-21.489845c0.299362,-0.299358 0.467796,-0.706482 0.467796,-1.128777c-0.000793,-0.424683 -0.17083,-0.830215 -0.470192,-1.12957z" }
        ]
    }, {
        name: tf.styles.SvgGlyphLogOutName, W: 96.943, H: 96.943,
        paths: [
            { d: "m58.606525,76.769516l-39.757795,0l0,-56.594435l39.759394,0c0.88131,0 1.596569,-0.715265 1.596569,-1.596569l0,-5.879373c0,-0.881307 -0.71526,-1.59657 -1.596569,-1.59657l-47.234535,0c-0.881308,0 -1.596573,0.715263 -1.596573,1.59657l0,71.544719c0,0.88131 0.715265,1.596573 1.596573,1.596573l47.232937,0c0.882111,0 1.596573,-0.715263 1.596573,-1.596573l0,-5.877777c0,-0.882904 -0.713665,-1.596565 -1.596573,-1.596565z" },
            { d: "m86.695793,47.343121l-21.49144,-21.489838c-0.598709,-0.599512 -1.658833,-0.598713 -2.257542,0l-5.098648,5.099447c-0.623466,0.623459 -0.623466,1.634085 0,2.257547l9.707142,9.708744l-42.022533,0c-0.881308,0 -1.596571,0.715267 -1.596571,1.596573l0,7.912601c0,0.88131 0.715263,1.596573 1.596571,1.596573l42.024937,0l-9.707157,9.708736c-0.623459,0.623459 -0.623459,1.634094 0,2.257561l5.098648,5.100243c0.299355,0.299355 0.70649,0.467789 1.12878,0.467789c0.423889,0 0.829422,-0.168434 1.128777,-0.467789l21.491432,-21.489841c0.299362,-0.299358 0.467796,-0.706482 0.467796,-1.128777c-0.000793,-0.424683 -0.17083,-0.830215 -0.470192,-1.12957z" }
        ]
    }, {
        name: tf.styles.SvgGlyphPlusSignName, W: 533.333, H: 533.333,
        paths: [{ d: "m483.854065,208.749969l-159.271454,0l0,-159.27058c0,-7.996841 -6.482605,-14.479454 -14.478607,-14.479454l-86.875,0c-7.996841,0 -14.479462,6.482613 -14.479462,14.479454l0,159.27058l-159.27058,0c-7.996841,0 -14.479454,6.482635 -14.479454,14.479477l0,86.875015c0,7.995972 6.482613,14.478577 14.479454,14.478577l159.27058,0l0,159.271454c0,7.995972 6.48262,14.478577 14.479462,14.478577l86.875,0c7.996002,0 14.479492,-6.482605 14.479492,-14.478577l0,-159.271454l159.270569,0c7.995911,0 14.479431,-6.482605 14.479431,-14.478577l0,-86.875015c-0.000854,-7.996841 -6.483521,-14.479477 -14.479431,-14.479477z" }]
    }, {
        name: tf.styles.SvgGlyphMagnifyingLensName, W: 16, H: 16,
        paths: [{ d: "m2.262,14.615l3.335,-2.607c0.86,0.713 1.927,1.198 3.119,1.344c3.317,0.404 6.333,-1.955 6.738,-5.273c0.406,-3.319 -1.954,-6.335 -5.273,-6.74c-3.317,-0.405 -6.335,1.956 -6.739,5.273c-0.146,1.193 0.07,2.343 0.556,3.351l-3.332,2.608c-0.188,0.146 -0.222,0.419 -0.075,0.606l1.063,1.363c0.149,0.187 0.422,0.221 0.608,0.075zm2.896,-7.793c0.288,-2.365 2.448,-4.056 4.813,-3.768c2.366,0.289 4.055,2.45 3.768,4.815c-0.289,2.367 -2.449,4.056 -4.813,3.767c-2.366,-0.288 -4.057,-2.448 -3.768,-4.814z" }]
    }, {
        name: tf.styles.SvgGlyphQuestionMarkName, W: 16, H: 16,
        paths: [{ d: "m6.558,9.947c-0.063,-0.424 -0.047,-0.811 0.047,-1.16s0.229,-0.675 0.402,-0.975c0.176,-0.3 0.371,-0.574 0.59,-0.824c0.219,-0.249 0.428,-0.49 0.627,-0.721c0.199,-0.231 0.365,-0.455 0.496,-0.674c0.133,-0.219 0.197,-0.446 0.197,-0.684c0,-0.387 -0.115,-0.681 -0.346,-0.881c-0.232,-0.199 -0.533,-0.299 -0.908,-0.299c-0.35,0 -0.658,0.081 -0.928,0.243s-0.527,0.369 -0.777,0.618l-1.518,-1.386c0.424,-0.512 0.924,-0.924 1.498,-1.236s1.211,-0.468 1.911,-0.468c0.525,0 1.016,0.063 1.471,0.187c0.457,0.125 0.85,0.318 1.182,0.581c0.33,0.262 0.59,0.597 0.777,1.002c0.188,0.406 0.281,0.884 0.281,1.433c0,0.389 -0.07,0.734 -0.207,1.04c-0.137,0.307 -0.309,0.591 -0.516,0.853c-0.205,0.263 -0.424,0.516 -0.654,0.759s-0.444,0.496 -0.639,0.757c-0.191,0.263 -0.346,0.54 -0.457,0.833c-0.113,0.294 -0.15,0.628 -0.113,1.002l-2.416,0zm-0.45,2.829c0,-0.499 0.156,-0.914 0.467,-1.246c0.313,-0.33 0.707,-0.495 1.182,-0.495s0.871,0.165 1.189,0.495c0.318,0.332 0.479,0.747 0.479,1.246c0,0.487 -0.16,0.896 -0.479,1.227c-0.318,0.331 -0.715,0.497 -1.189,0.497s-0.869,-0.166 -1.182,-0.497c-0.31,-0.33 -0.467,-0.739 -0.467,-1.227z" }]
    }, {
        name: tf.styles.SvgGlyphPlaySelectedName, W: 512, H: 512,
        paths: [{ d: "m256,92.481003c44.433014,0 86.179993,17.068001 117.553009,48.063995c31.240997,30.865997 48.446991,71.867996 48.446991,115.453995s-17.205994,84.587982 -48.447998,115.455017c-31.372009,30.993988 -73.119995,48.063995 -117.552002,48.063995s-86.179001,-17.070007 -117.552002,-48.063995c-31.241997,-30.867004 -48.447998,-71.869019 -48.447998,-115.455017s17.206001,-84.587997 48.447998,-115.453003c31.373001,-30.995987 73.119995,-48.064987 117.552002,-48.064987m0,-40.000004c-113.771011,0 -206,91.116993 -206,203.518009c0,112.397995 92.228989,203.520004 206,203.520004c113.772003,0 206,-91.121002 206,-203.520004c0,-112.400009 -92.227997,-203.518009 -206,-203.518009l0,0zm-49.455994,304.680012l0,-197.328018l160.919006,98.666l-160.919006,98.662018z" }]
    }, {
        name: tf.styles.SvgGlyphDirectionName, W: 512, H: 512,
        paths: [
            { d: "m256,92.481003c44.433014,0 86.179993,17.068001 117.553009,48.063995c31.240997,30.865997 48.446991,71.867996 48.446991,115.453995s-17.205994,84.587982 -48.447998,115.454987c-31.372009,30.994019 -73.119995,48.063995 -117.552002,48.063995s-86.179001,-17.069977 -117.552017,-48.063995c-31.241982,-30.866974 -48.447983,-71.868988 -48.447983,-115.454987s17.206001,-84.587997 48.447998,-115.453003c31.373001,-30.995987 73.119995,-48.064987 117.552002,-48.064987m0,-40.000004c-113.770996,0 -206,91.117008 -206,203.517994c0,112.39801 92.229004,203.52002 206,203.52002c113.772003,0 206,-91.121002 206,-203.52002c0,-112.399994 -92.227997,-203.517994 -206,-203.517994l0,0z" },
            { d: "m370.083466,282.923218c-6.344604,6.339935 -10.186737,5.512634 -45.754547,-9.9151c-17.957001,-7.789948 -33.174683,-14.163147 -33.809814,-14.163147c-0.638367,0 -1.161194,21.506592 -1.161194,47.795807l0,47.798981l-33.63327,0l-33.635681,0l0,-48.177338c0,-37.146271 -1.012207,-47.758057 -4.426788,-46.364685c-2.433212,0.996094 -18.586517,7.789886 -35.894592,15.100494c-32.626236,13.775665 -41.374649,13.771027 -44.087418,-0.020874c-1.34729,-6.864563 102.349655,-113.741272 113.922836,-117.417114c41.328461,35.600739 84.587952,78.156128 122.729858,117.355286c0,2.065369 -1.910706,5.669067 -4.24939,8.00769z" }
        ]
    }, {
        name: tf.styles.SvgGlyphCompassName, W: 32, H: 32,
        paths: [
            { d: "m8.88776,8.937267c3.894513,-3.921812 10.253166,-3.944012 14.174973,-0.049506s3.944019,10.25316 0.049505,14.174972s-10.253159,3.944019 -14.174971,0.049507s-3.944013,-10.253167 -0.049507,-14.174973m-2.370751,-2.354249c-5.200529,5.236982 -5.170973,13.699442 0.06601,18.899971s13.699442,5.170973 18.899971,-0.06601s5.170973,-13.699443 -0.06601,-18.899971s-13.699443,-5.170973 -18.899971,0.06601l0,0z" },
            { d: "m15.993603,13.492196c0.942642,-0.002105 1.737152,0.538501 2.167452,1.305994l-2.194059,-8.248177l-2.076434,8.182772c0.435124,-0.726224 1.193476,-1.237406 2.103042,-1.240589z" },
            { d: "m16.44162,17.090729c-1.097321,0.005255 -2.016274,-0.608433 -2.548089,-1.479322l2.574435,9.838581l2.574963,-9.953221c-0.510595,0.932097 -1.462778,1.589986 -2.601309,1.593963z" }
        ]
    }, {
        name: tf.styles.SvgGlyphNoCompassName, W: 32, H: 32,
        paths: [
            { d: "m8.88776,8.937267c3.894513,-3.921812 10.253166,-3.944012 14.174973,-0.049506s3.944019,10.25316 0.049505,14.174972s-10.253159,3.944019 -14.174971,0.049507s-3.944013,-10.253167 -0.049507,-14.174973m-2.370751,-2.354249c-5.200529,5.236982 -5.170973,13.699442 0.06601,18.899971s13.699442,5.170973 18.899971,-0.06601s5.170973,-13.699443 -0.06601,-18.899971s-13.699443,-5.170973 -18.899971,0.06601l0,0z" },
            { fill: "#f00", d: "m15.993603,13.492196c0.942642,-0.002105 1.737152,0.538501 2.167452,1.305994l-2.194059,-8.248177l-2.076434,8.182772c0.435124,-0.726224 1.193476,-1.237406 2.103042,-1.240589z" },
            { fill: "#f00", d: "m16.44162,17.090729c-1.097321,0.005255 -2.016274,-0.608433 -2.548089,-1.479322l2.574435,9.838581l2.574963,-9.953221c-0.510595,0.932097 -1.462778,1.589986 -2.601309,1.593963z" }
        ]
    }, {
        name: tf.styles.SvgGlyphTargetName, W: 390, H: 390,
        paths: [
            { d: "m331.655457,175.011902l29.344543,0c-4.392609,-37.090363 -20.967926,-71.412354 -47.783325,-98.228592c-26.816223,-26.81538 -61.13736,-43.39069 -98.228592,-47.78331l0,29.344551c60.185654,8.765648 107.901718,56.481697 116.667374,116.667351z" },
            { d: "m175.011902,58.344551l0,-29.344551c-37.090363,4.39262 -71.412354,20.96793 -98.228592,47.78331c-26.81538,26.816254 -43.39069,61.137375 -47.78331,98.228592l29.344551,0c8.765648,-60.185654 56.481697,-107.901703 116.667351,-116.667351z" },
            { d: "m214.988098,331.655457l0,29.344543c37.089508,-4.392609 71.412354,-20.967926 98.228577,-47.783325c26.815399,-26.816223 43.390717,-61.13736 47.783325,-98.228592l-29.344543,0c-8.765656,60.185654 -56.48172,107.901718 -116.667343,116.667374l-0.000015,0z" },
            { d: "m58.344551,214.988098l-29.344551,0c4.39262,37.089508 20.96793,71.412354 47.78331,98.228577c26.816254,26.815399 61.137375,43.390717 98.228592,47.783325l0,-29.344543c-60.185654,-8.765656 -107.901703,-56.48172 -116.667351,-116.667343l0,-0.000015z" },
            { d: "m121.339417,175.011902c7.075851,-26.045837 27.626648,-46.596634 53.672501,-53.672493l0,-29.827217c-42.115494,8.119514 -75.380196,41.384216 -83.499718,83.49971l29.827217,0z" },
            { d: "m121.339417,214.988098l-29.827217,0c8.119522,42.115479 41.384224,75.380157 83.499718,83.49884l0,-29.826355c-26.045853,-7.075012 -46.597504,-27.626648 -53.672501,-53.672485z" },
            { d: "m268.660583,214.988098c-7.075867,26.045837 -27.626678,46.595795 -53.672501,53.672485l0,29.826355c42.115494,-8.118683 75.380173,-41.383362 83.49971,-83.49884l-29.827209,0z" },
            { d: "m268.660583,175.011902l29.827209,0c-8.119537,-42.115494 -41.384216,-75.380196 -83.49968,-83.499702l0,29.827217c26.045837,7.074997 46.597458,27.626648 53.67247,53.672501l0,-0.000015z" },
            { d: "m203.105057,155.879333l0,-126.879333l-16.210114,0l0,126.879333c-15.537598,3.213593 -27.801178,15.478012 -31.01561,31.01561l-126.879333,0l0,16.210114l126.879333,0c3.213593,15.537598 15.478012,27.801147 31.01561,31.016449l0,126.878494l16.210114,0l0,-126.879333c15.537598,-3.213593 27.801163,-15.478012 31.016464,-31.017334l126.878479,0l0,-16.210098l-126.879333,0c-3.213593,-15.535889 -15.478012,-27.800308 -31.01561,-31.013916l0,0.000015z" }
        ]
    }, {
        name: tf.styles.SvgGlyphNoTargetName, W: 390, H: 390,
        paths: [
            { d: "m331.655457,175.011902l29.344543,0c-4.392609,-37.090363 -20.967926,-71.412354 -47.783325,-98.228592c-26.816223,-26.81538 -61.13736,-43.39069 -98.228592,-47.78331l0,29.344551c60.185654,8.765648 107.901718,56.481697 116.667374,116.667351z" },
            { d: "m175.011902,58.344551l0,-29.344551c-37.090363,4.39262 -71.412354,20.96793 -98.228592,47.78331c-26.81538,26.816254 -43.39069,61.137375 -47.78331,98.228592l29.344551,0c8.765648,-60.185654 56.481697,-107.901703 116.667351,-116.667351z" },
            { d: "m214.988098,331.655457l0,29.344543c37.089508,-4.392609 71.412354,-20.967926 98.228577,-47.783325c26.815399,-26.816223 43.390717,-61.13736 47.783325,-98.228592l-29.344543,0c-8.765656,60.185654 -56.48172,107.901718 -116.667343,116.667374l-0.000015,0z" },
            { d: "m58.344551,214.988098l-29.344551,0c4.39262,37.089508 20.96793,71.412354 47.78331,98.228577c26.816254,26.815399 61.137375,43.390717 98.228592,47.783325l0,-29.344543c-60.185654,-8.765656 -107.901703,-56.48172 -116.667351,-116.667343l0,-0.000015z" },
            { d: "m121.339417,175.011902c7.075851,-26.045837 27.626648,-46.596634 53.672501,-53.672493l0,-29.827217c-42.115494,8.119514 -75.380196,41.384216 -83.499718,83.49971l29.827217,0z" },
            { d: "m121.339417,214.988098l-29.827217,0c8.119522,42.115479 41.384224,75.380157 83.499718,83.49884l0,-29.826355c-26.045853,-7.075012 -46.597504,-27.626648 -53.672501,-53.672485z" },
            { d: "m268.660583,214.988098c-7.075867,26.045837 -27.626678,46.595795 -53.672501,53.672485l0,29.826355c42.115494,-8.118683 75.380173,-41.383362 83.49971,-83.49884l-29.827209,0z" },
            { d: "m268.660583,175.011902l29.827209,0c-8.119537,-42.115494 -41.384216,-75.380196 -83.49968,-83.499702l0,29.827217c26.045837,7.074997 46.597458,27.626648 53.67247,53.672501l0,-0.000015z" },
            { fill: "#f00", d: "m203.105057,155.879333l0,-126.879333l-16.210114,0l0,126.879333c-15.537598,3.213593 -27.801178,15.478012 -31.01561,31.01561l-126.879333,0l0,16.210114l126.879333,0c3.213593,15.537598 15.478012,27.801147 31.01561,31.016449l0,126.878494l16.210114,0l0,-126.879333c15.537598,-3.213593 27.801163,-15.478012 31.016464,-31.017334l126.878479,0l0,-16.210098l-126.879333,0c-3.213593,-15.535889 -15.478012,-27.800308 -31.01561,-31.013916l0,0.000015z" }
        ]
    }, {
        name: tf.styles.SvgGlyphAutoRepeatName, W: 140.171, H: 140.171,
        paths: [
            { d: "m39.906174,86.319725c-8.734777,-4.047989 -14.207458,-9.832954 -14.207458,-16.258339c0,-10.321568 14.137886,-18.971752 33.246418,-21.433754l0,-11.144604c-25.291977,3.081844 -44.328565,16.49633 -44.328565,32.578358c0,9.273209 6.341588,17.633232 16.543754,23.655396c11.161989,6.823059 16.702665,-4.258286 8.745852,-7.397057zm66.545029,-41.272026c-5.946251,-5.460033 -14.258858,2.851776 -8.590088,7.765484c10.059853,4.063797 16.496292,10.281246 16.496292,17.248203c0,10.327095 -14.140251,18.978073 -33.247192,21.43927l0,11.13987c25.291977,-3.077103 44.328545,-16.490776 44.328545,-32.57914c0,-9.986343 -7.367012,-18.925896 -18.987556,-25.013687zm-42.609745,11.104286l18.037235,-10.800686c2.624069,-1.571751 2.629608,-4.131783 0.014221,-5.714607l-18.204052,-11.017309c-2.618542,-1.580456 -4.731873,-0.386616 -4.719219,2.673092l0.098038,22.164278c0.007908,3.060493 2.146534,4.266987 4.773777,2.695232zm12.525814,27.878883l-18.203262,11.016518c-2.61776,1.582825 -2.612228,4.14286 0.015011,5.715416l18.03487,10.800667c2.624077,1.568604 4.767441,0.36528 4.780891,-2.697594l0.094879,-22.164276c0.009476,-3.058121 -2.106216,-4.250381 -4.722389,-2.670731z" },
            { fill: "#f00", d: "m11.993611,43.781517c0,0 2.609659,-5.64209 2.609659,-5.64209c0,0 113.574113,58.094925 113.574113,58.094925c0,0 -2.12635,5.889297 -2.12635,5.889297c0,0 -114.057422,-58.342133 -114.057422,-58.342133z" }
        ]
    }, {
        name: tf.styles.SvgGlyphNoAutoRepeatName, W: 140.171, H: 140.171,
        paths: [{ d: "m39.906174,86.319725c-8.734777,-4.047989 -14.207458,-9.832954 -14.207458,-16.258339c0,-10.321568 14.137886,-18.971752 33.246418,-21.433754l0,-11.144604c-25.291977,3.081844 -44.328565,16.49633 -44.328565,32.578358c0,9.273209 6.341588,17.633232 16.543754,23.655396c11.161989,6.823059 16.702665,-4.258286 8.745852,-7.397057zm66.545029,-41.272026c-5.946251,-5.460033 -14.258858,2.851776 -8.590088,7.765484c10.059853,4.063797 16.496292,10.281246 16.496292,17.248203c0,10.327095 -14.140251,18.978073 -33.247192,21.43927l0,11.13987c25.291977,-3.077103 44.328545,-16.490776 44.328545,-32.57914c0,-9.986343 -7.367012,-18.925896 -18.987556,-25.013687zm-42.609745,11.104286l18.037235,-10.800686c2.624069,-1.571751 2.629608,-4.131783 0.014221,-5.714607l-18.204052,-11.017309c-2.618542,-1.580456 -4.731873,-0.386616 -4.719219,2.673092l0.098038,22.164278c0.007908,3.060493 2.146534,4.266987 4.773777,2.695232zm12.525814,27.878883l-18.203262,11.016518c-2.61776,1.582825 -2.612228,4.14286 0.015011,5.715416l18.03487,10.800667c2.624077,1.568604 4.767441,0.36528 4.780891,-2.697594l0.094879,-22.164276c0.009476,-3.058121 -2.106216,-4.250381 -4.722389,-2.670731z" }]
    }, {
        name: tf.styles.SvgGlyphPlayName, W: 512, H: 512,
        paths: [{ d: "m121.929863,420.870117c4.552467,2.629425 9.635857,3.945007 14.717476,3.945007c5.081635,0 10.162415,-1.315582 14.717499,-3.945007l238.707916,-137.818573c9.106659,-5.257172 14.717438,-14.974762 14.717438,-25.490814c0,-10.512573 -5.610779,-20.231049 -14.717438,-25.48732l-238.711365,-137.820297c-4.554214,-2.627724 -9.632416,-3.944168 -14.717468,-3.944168c-5.08078,0 -10.161591,1.316444 -14.717491,3.944168c-9.106712,5.257179 -14.716621,14.973877 -14.716621,25.48735l0,275.639725c0.006012,10.516083 5.616814,20.234497 14.720055,25.489929z" }]
    }, {
        name: tf.styles.SvgGlyphPauseName, W: 512, H: 512,
        paths: [
            { d: "m162.590088,58.444733c-30.713196,0 -55.60907,24.895859 -55.60907,55.60907l0,283.892426c0,30.709412 24.895874,55.60907 55.60907,55.60907c30.709473,0 55.605377,-24.895935 55.605377,-55.60907l0,-283.896179c0,-30.709465 -24.895874,-55.605331 -55.605377,-55.605331l0,0l0,0.000015z" },
            { d: "m349.409882,58.444733c-30.709473,0 -55.609039,24.895859 -55.609039,55.60907l0,283.892426c0,30.709412 24.895874,55.60907 55.609039,55.60907c30.713287,0 55.6091,-24.895874 55.6091,-55.60907l0,-283.896179c0,-30.709473 -24.895813,-55.605316 -55.6091,-55.605316l0,-0.000015l0,0.000015z" }
        ]
    }, {
        name: tf.styles.SvgGlyphStopName, W: 512, H: 512,
        paths: [{ d: "m172.584091,411.139801l166.831863,0c36.728516,0 66.502563,-30.869995 66.502563,-68.950317l0,-172.378891c0,-38.080399 -29.774048,-68.950378 -66.502563,-68.950378l-166.831863,0c-36.728531,0 -66.502609,30.86998 -66.502609,68.950378l0,172.378891c-0.002785,38.080322 29.774078,68.950317 66.502609,68.950317z" }]
    }, {
        name: tf.styles.SvgGlyphGearName, W: 268.765, H: 268.765,
        style: "enable-background:new 0 0 268.765 268.765;",
        paths: [{
            style: "fill-rule:evenodd;clip-rule:evenodd;",
            d: "M267.92,119.461c-0.425-3.778-4.83-6.617-8.639-6.617c-12.315,0-23.243-7.231-27.826-18.414c-4.682-11.454-1.663-24.812,7.515-33.231c2.889-2.641,3.24-7.062,0.817-10.133c-6.303-8.004-13.467-15.234-21.289-21.5c-3.063-2.458-7.557-2.116-10.213,0.825c-8.01,8.871-22.398,12.168-33.516,7.529c-11.57-4.867-18.866-16.591-18.152-29.176c0.235-3.953-2.654-7.39-6.595-7.849c-10.038-1.161-20.164-1.197-30.232-0.08c-3.896,0.43-6.785,3.786-6.654,7.689c0.438,12.461-6.946,23.98-18.401,28.672c-10.985,4.487-25.272,1.218-33.266-7.574c-2.642-2.896-7.063-3.252-10.141-0.853c-8.054,6.319-15.379,13.555-21.74,21.493c-2.481,3.086-2.116,7.559,0.802,10.214c9.353,8.47,12.373,21.944,7.514,33.53c-4.639,11.046-16.109,18.165-29.24,18.165c-4.261-0.137-7.296,2.723-7.762,6.597c-1.182,10.096-1.196,20.383-0.058,30.561c0.422,3.794,4.961,6.608,8.812,6.608c11.702-0.299,22.937,6.946,27.65,18.415c4.698,11.454,1.678,24.804-7.514,33.23c-2.875,2.641-3.24,7.055-0.817,10.126c6.244,7.953,13.409,15.19,21.259,21.508c3.079,2.481,7.559,2.131,10.228-0.81c8.04-8.893,22.427-12.184,33.501-7.536c11.599,4.852,18.895,16.575,18.181,29.167c-0.233,3.955,2.67,7.398,6.595,7.85c5.135,0.599,10.301,0.898,15.481,0.898c4.917,0,9.835-0.27,14.752-0.817c3.897-0.43,6.784-3.786,6.653-7.696c-0.451-12.454,6.946-23.973,18.386-28.657c11.059-4.517,25.286-1.211,33.281,7.572c2.657,2.89,7.047,3.239,10.142,0.848c8.039-6.304,15.349-13.534,21.74-21.494c2.48-3.079,2.13-7.559-0.803-10.213c-9.353-8.47-12.388-21.946-7.529-33.524c4.568-10.899,15.612-18.217,27.491-18.217l1.662,0.043c3.853,0.313,7.398-2.655,7.865-6.588C269.044,139.917,269.058,129.639,267.92,119.461z M134.595,179.491c-24.718,0-44.824-20.106-44.824-44.824c0-24.717,20.106-44.824,44.824-44.824c24.717,0,44.823,20.107,44.823,44.824C179.418,159.385,159.312,179.491,134.595,179.491z"
        }]
    }, {
        name: tf.styles.SvgGlyphGear2Name, W: 48.352, H: 48.352,
        paths: [{ d: "m42.532543,20.907301l-4.609421,-0.864265c-0.28017,-0.932331 -0.647404,-1.826674 -1.102489,-2.667988l2.667194,-3.899487c0.246937,-0.360903 0.195488,-0.903839 -0.113972,-1.212506l-3.288483,-3.289277c-0.30946,-0.309458 -0.851604,-0.359319 -1.210922,-0.113178l-3.901861,2.668779c-0.865849,-0.466957 -1.787891,-0.841314 -2.749508,-1.123863l-0.859516,-4.585677c-0.080727,-0.429758 -0.498615,-0.777997 -0.93708,-0.777997l-4.650576,0c-0.437674,0 -0.856352,0.348239 -0.937872,0.777998l-0.869013,4.63079c-0.922041,0.281756 -1.806095,0.648991 -2.638704,1.101702l-3.851208,-2.634747c-0.360902,-0.246933 -0.903839,-0.19628 -1.212505,0.113178l-3.289278,3.289278c-0.309458,0.309458 -0.359318,0.851602 -0.113177,1.212505l2.651366,3.874951c-0.446379,0.832609 -0.808072,1.71587 -1.085081,2.63633l-4.60942,0.863474c-0.428967,0.08152 -0.777206,0.500198 -0.777206,0.937874l0,4.650576c0,0.437672 0.348239,0.85635 0.777206,0.93866l4.606255,0.863476c0.280965,0.940247 0.651365,1.842503 1.108826,2.690147l-2.621292,3.832211c-0.246934,0.360905 -0.19628,0.903839 0.113178,1.211712l3.288484,3.28849c0.30946,0.310246 0.851604,0.359318 1.212505,0.114761l3.830633,-2.622086c0.8239,0.445591 1.698456,0.808075 2.611002,1.088249l0.868223,4.63237c0.08152,0.42976 0.500198,0.776417 0.937872,0.776417l4.651365,0c0.438467,0 0.85556,-0.346657 0.93787,-0.776417l0.86031,-4.586468c0.949745,-0.280174 1.863079,-0.64978 2.721016,-1.108826l3.878908,2.654533c0.360901,0.246933 0.903835,0.196281 1.212505,-0.114761l3.286903,-3.286903c0.311039,-0.310249 0.360107,-0.850811 0.114761,-1.212502l-2.639496,-3.856747c0.466164,-0.857937 0.840523,-1.770481 1.126236,-2.722599l4.605461,-0.863476c0.428177,-0.08231 0.775623,-0.500988 0.775623,-0.938662l0,-4.650576c0.00317,-0.439257 -0.345863,-0.857935 -0.775623,-0.939455zm-18.354574,11.250498c-4.406807,0 -7.980217,-3.573406 -7.980217,-7.982588c0,-4.406017 3.573408,-7.980217 7.980217,-7.980217c4.40839,0 7.982588,3.5742 7.982588,7.980217c0,4.409182 -3.575781,7.982588 -7.982588,7.982588z" }]
    }, {
        name: tf.styles.SvgGlyphTwoGearsName, W: 217.794, H: 217.794,
        style: "enable-background:new 0 0 217.794 217.794;",
        paths: [{ d: "m112.864532,130.463486l-5.187439,-11.524536c4.945206,-3.632652 9.192589,-8.151802 12.511253,-13.309792l11.811638,4.478897c2.258789,0.856743 4.782547,-0.281799 5.637787,-2.541374l4.340942,-11.466774c0.411011,-1.085152 0.374283,-2.28933 -0.10231,-3.347351c-0.476593,-1.058029 -1.352829,-1.883278 -2.438065,-2.294586l-11.811638,-4.478897c0.930428,-6.064629 0.741554,-12.264023 -0.557037,-18.264755l11.51606,-5.191254c1.057236,-0.47694 1.881882,-1.353821 2.292892,-2.43985c0.411011,-1.085155 0.374283,-2.28933 -0.10231,-3.347359l-5.032669,-11.179737c-0.991653,-2.203564 -3.581879,-3.183708 -5.782074,-2.192188l-11.516075,5.191246c-3.629974,-4.948837 -8.145821,-9.199326 -13.300026,-12.520428l4.475609,-11.820328c0.85524,-2.259577 -0.281586,-4.786066 -2.539497,-5.641939l-11.457489,-4.345001c-1.083488,-0.410434 -2.286774,-0.374554 -3.344902,0.10239c-1.057251,0.476943 -1.881889,1.35382 -2.292892,2.439852l-4.474731,11.819452c-6.066299,-0.936384 -12.271637,-0.742981 -18.252228,0.556581l-5.186565,-11.523663c-0.476593,-1.058025 -1.352821,-1.88327 -2.438057,-2.29458c-1.083488,-0.410434 -2.287651,-0.374554 -3.344902,0.102389l-11.172401,5.036352c-2.20195,0.992393 -3.182243,3.582766 -2.190582,5.786333l5.187439,11.524534c-4.945206,3.632652 -9.192574,8.151798 -12.511238,13.309792l-11.811653,-4.478893c-1.083483,-0.410435 -2.286774,-0.373676 -3.344896,0.10239c-1.057253,0.476944 -1.881891,1.353821 -2.292894,2.439854l-4.340938,11.4659c-0.855246,2.259575 0.281584,4.786064 2.5395,5.641937l11.811649,4.478897c-0.930449,6.063751 -0.741566,12.264893 0.557045,18.264763l-11.516947,5.191246c-1.057253,0.476944 -1.88189,1.353813 -2.292897,2.43985c-0.411007,1.085159 -0.374279,2.28933 0.102316,3.347359l5.032651,11.179733c0.475719,1.058029 1.352825,1.88327 2.437183,2.294586c1.085236,0.411308 2.287651,0.375427 3.344902,-0.102394l11.516075,-5.191246c3.629978,4.949715 8.144939,9.199326 13.300018,12.520424l-4.475601,11.820328c-0.855251,2.259567 0.281578,4.786072 2.539494,5.641937l11.458363,4.344131c0.499329,0.189026 1.024895,0.283524 1.548714,0.283524c0.613007,0 1.226021,-0.128632 1.796188,-0.385925c1.057255,-0.476944 1.881893,-1.353806 2.292896,-2.439835l4.474739,-11.819473c6.066292,0.935516 12.272499,0.742996 18.252213,-0.556557l5.186562,11.523659c0.476601,1.058029 1.352829,1.883255 2.438065,2.294571c1.084358,0.411301 2.288528,0.375427 3.344902,-0.102386l11.171524,-5.035477c2.202827,-0.992401 3.183998,-3.582764 2.192337,-5.786331zm-7.245979,-41.593872c-4.340057,11.464149 -15.483604,19.166138 -27.728996,19.166138c-3.581886,0 -7.11393,-0.651093 -10.498177,-1.934029c-7.405132,-2.807404 -13.274662,-8.332954 -16.526867,-15.558868c-3.252205,-7.225044 -3.497936,-15.285828 -0.692596,-22.696396c4.340065,-11.464153 15.483616,-19.166142 27.729008,-19.166142c3.581886,0 7.113922,0.651096 10.498169,1.934029c7.405136,2.807407 13.274666,8.332954 16.526871,15.557995c3.253082,7.225914 3.49881,15.286705 0.692589,22.697273zm97.215477,59.750107c-0.783524,-0.854996 -1.875763,-1.363434 -3.033569,-1.413315l-8.235886,-0.353561c-0.758194,-3.889938 -2.127625,-7.645096 -4.051498,-11.111481l6.073303,-5.578033c1.779572,-1.633865 1.897614,-4.401886 0.264954,-6.1819l-6.030426,-6.575691c-0.783539,-0.854996 -1.875778,-1.363449 -3.03447,-1.41333c-1.156052,-0.042885 -2.289398,0.364052 -3.143768,1.148163l-6.072418,5.578056c-3.28717,-2.214943 -6.908417,-3.901314 -10.715912,-4.989967l0.353287,-8.241936c0.103195,-2.414474 -1.769089,-4.455269 -4.181778,-4.558533l-8.91011,-0.382439c-2.400467,-0.091003 -4.451996,1.770386 -4.555191,4.183983l-0.353287,8.241943c-3.8862,0.758728 -7.638611,2.129181 -11.103333,4.053581l-5.573944,-6.077751c-0.783554,-0.854996 -1.875778,-1.363449 -3.033592,-1.41333c-1.157806,-0.047256 -2.289383,0.364052 -3.143753,1.148163l-6.570877,6.034874c-1.779572,1.633858 -1.897629,4.401886 -0.264969,6.181892l5.573959,6.077744c-2.213318,3.289597 -3.898453,6.912628 -4.986313,10.723785l-8.235016,-0.353546c-2.402206,-0.097137 -4.452866,1.769516 -4.556061,4.183975l-0.382149,8.916672c-0.049843,1.159531 0.362915,2.291077 1.147324,3.146072c0.783539,0.854996 1.875771,1.363449 3.034454,1.41333l8.235023,0.352676c0.758179,3.889938 2.127625,7.645096 4.050613,11.112335l-6.072418,5.578064c-0.85437,0.784119 -1.362457,1.877151 -1.4123,3.035812c-0.04985,1.159546 0.362923,2.291077 1.147331,3.146072l6.030441,6.575714c0.783539,0.85498 1.875763,1.363449 3.034454,1.413315c1.153442,0.046387 2.289398,-0.364044 3.143768,-1.148163l6.072411,-5.578049c3.287186,2.214935 6.908417,3.901306 10.715927,4.989975l-0.353287,8.241928c-0.103195,2.414474 1.768204,4.455276 4.180908,4.558533l8.91011,0.382431c0.062973,0.002625 0.125046,0.003494 0.187134,0.003494c1.093109,0 2.148621,-0.409561 2.956635,-1.151657c0.85437,-0.784103 1.362442,-1.877151 1.412292,-3.035812l0.353287,-8.241928c3.8862,-0.758743 7.638611,-2.129196 11.103317,-4.053589l5.573959,6.077744c0.783539,0.854996 1.875778,1.363449 3.033585,1.41333c1.163055,0.050751 2.290268,-0.364059 3.143768,-1.148163l6.570877,-6.034882c1.779572,-1.63385 1.897629,-4.401886 0.264954,-6.181885l-5.573944,-6.077744c2.213303,-3.289597 3.898438,-6.912628 4.986298,-10.723801l8.235016,0.353546c2.41008,0.092773 4.451996,-1.769501 4.556061,-4.183975l0.382141,-8.916656c0.04985,-1.159561 -0.3629,-2.291092 -1.147324,-3.146088zm-49.251785,25.872223c-11.231873,-0.481308 -19.978455,-10.018433 -19.496613,-21.25856c0.468719,-10.951324 9.408569,-19.530197 20.351852,-19.530197c0.295593,0 0.592911,0.006134 0.891113,0.019257c11.231857,0.482208 19.978439,10.018448 19.496613,21.258575c-0.481857,11.247986 -9.919281,19.987 -21.242966,19.510925z" }]
    }, {
        name: tf.styles.SvgGlyphRefreshName, W: 512, H: 512,
        paths: [{ d: "M92.07,256.41H50l78.344,78.019l77.536-78.019h-39.825c-0.104-61.079,49.192-111.032,110.329-111.387c61.293-0.358,111.27,49.039,111.626,110.331c0.58,98.964-119.057,148.511-188.892,79.686l-51.929,52.687c116.154,114.483,315.773,32.415,314.809-132.804C461.4,152.769,378.105,70.441,275.952,71.037C173.955,71.632,91.725,154.47,92.07,256.41z" }]
    }, {
        name: tf.styles.SvgGlyphUndoName, W: 485.183, H: 485.183,
        style: "enable-background:new 0 0 485.183 485.183;",
        paths: [{ d: "m254.626526,140.272308c-59.080673,0 -111.368027,28.49437 -144.308174,72.367249l-60.318359,-60.331848l0,192.602997l192.603035,0l-65.526276,-65.521515c17.410828,-52.809677 67.063232,-90.967331 125.693787,-90.967331c73.165894,0 132.411682,59.295029 132.411682,132.417252c0.000793,-99.735886 -80.831757,-180.566803 -180.555695,-180.566803z" }]
    }, {
        name: tf.styles.SvgGlyphSortAscendingName, W: 301.219, H: 301.219,
        paths: [
            { d: "m149.624527,240.399307l-111.602127,0c-4.422764,0 -8.0079,3.585129 -8.0079,8.007904l0,8.007889c0,4.42276 3.585136,8.007904 8.0079,8.007904l111.602127,0c4.421967,0 8.007904,-3.585144 8.007904,-8.007904l0,-8.007889c0,-4.42276 -3.585144,-8.007904 -8.007904,-8.007904z" },
            { d: "m38.0224,213.973236l96.564087,0c4.421967,0 8.007904,-3.585144 8.007904,-8.007904l0,-8.007904c0,-4.42276 -3.585938,-8.007904 -8.007904,-8.007904l-96.564087,0c-4.422764,0 -8.0079,3.585144 -8.0079,8.007904l0,8.007904c0,4.42276 3.585136,8.007904 8.0079,8.007904z" },
            { d: "m38.0224,163.523453l81.524445,0c4.421974,0 8.007912,-3.585144 8.007912,-8.007904l0,-8.007904c0,-4.42276 -3.585938,-8.007904 -8.007912,-8.007904l-81.524445,0c-4.422764,0 -8.0079,3.585144 -8.0079,8.007904l0,8.007904c0,4.422775 3.585136,8.007904 8.0079,8.007904z" },
            { d: "m38.0224,107.46814l66.485611,0c4.421951,0 8.007904,-3.585144 8.007904,-8.007904l0,-8.007904c0,-4.422768 -3.585953,-8.007896 -8.007904,-8.007896l-66.485611,0c-4.422764,0 -8.0079,3.585129 -8.0079,8.007896l0,8.007904c0,4.42276 3.585136,8.007904 8.0079,8.007904z" },
            { d: "m38.0224,57.018356l51.445969,0c4.421959,0 8.007904,-3.58514 8.007904,-8.007904l0,-8.007904c0,-4.422764 -3.585945,-8.0079 -8.007904,-8.0079l-51.445969,0c-4.422764,0 -8.0079,3.585136 -8.0079,8.0079l0,8.007904c0,4.422764 3.585136,8.007904 8.0079,8.007904z" },
            { d: "m154.996231,101.547096l5.661591,5.662384c1.50148,1.501472 3.538696,2.345505 5.662369,2.345505c2.123703,0 4.16011,-0.844032 5.662399,-2.345505l27.542374,-27.54158l0,180.548561c0,4.42276 3.585129,8.007904 8.007904,8.007904l8.007904,0c4.421967,0 8.007904,-3.585144 8.007904,-8.007904l0,-180.547775l27.542374,27.541603c1.502258,1.502266 3.538696,2.345497 5.662369,2.345497c2.123718,0 4.160919,-0.844025 5.662415,-2.345497l5.661591,-5.662399c3.127075,-3.127098 3.127075,-8.197693 0,-11.324776l-50.87822,-50.878994c-1.502289,-1.50148 -3.538696,-2.345528 -5.662384,-2.345528c-2.123703,0 -4.16011,0.844048 -5.662384,2.345528l-50.878204,50.878994c-3.12709,3.127083 -3.12709,8.196892 0,11.323982z" }
        ]
    }, {
        name: tf.styles.SvgGlyphSortDescendingName, W: 301.219, H: 301.219,
        paths: [
            { d: "m268.882202,203.675873l-5.66156,-5.662384c-1.501495,-1.50148 -3.538696,-2.34552 -5.662384,-2.34552c-2.123703,0 -4.16011,0.84404 -5.662399,2.34552l-27.542374,27.541565l0,-180.548553c0,-4.42276 -3.585129,-8.007904 -8.007904,-8.007904l-8.007904,0c-4.421967,0 -8.007904,3.585144 -8.007904,8.007904l0,180.547775l-27.542374,-27.541611c-1.502258,-1.502258 -3.538696,-2.34549 -5.662369,-2.34549c-2.123718,0 -4.160919,0.844025 -5.662415,2.34549l-5.661591,5.662415c-3.127075,3.12709 -3.127075,8.197693 0,11.324768l50.87822,50.878998c1.502289,1.501465 3.538696,2.34552 5.662384,2.34552c2.123703,0 4.16011,-0.844055 5.662384,-2.34552l50.878189,-50.878998c3.127106,-3.127075 3.127106,-8.196899 0,-11.323975z" },
            { d: "m38.022415,57.018341l111.602127,0c4.42276,0 8.007904,-3.585114 8.007904,-8.007904l0,-8.007874c0,-4.42276 -3.585144,-8.007904 -8.007904,-8.007904l-111.602127,0c-4.421967,0 -8.007904,3.585144 -8.007904,8.007904l0,8.007874c0,4.42276 3.585144,8.007904 8.007904,8.007904z" },
            { d: "m134.586517,83.444427l-96.564072,0c-4.421997,0 -8.007935,3.585144 -8.007935,8.007904l0,8.007904c0,4.42276 3.585938,8.007904 8.007935,8.007904l96.564072,0c4.42276,0 8.007904,-3.585144 8.007904,-8.007904l0,-8.007904c0,-4.42276 -3.585144,-8.007904 -8.007904,-8.007904z" },
            { d: "m119.546875,133.894211l-81.52446,0c-4.421967,0 -8.007904,3.585144 -8.007904,8.007904l0,8.007904c0,4.42276 3.585938,8.007904 8.007904,8.007904l81.52446,0c4.42276,0 8.007904,-3.585144 8.007904,-8.007904l0,-8.007904c0,-4.422775 -3.585144,-8.007904 -8.007904,-8.007904z" },
            { d: "m104.508026,189.949554l-66.485611,0c-4.421967,0 -8.007904,3.585144 -8.007904,8.007904l0,8.007904c0,4.42276 3.585938,8.007889 8.007904,8.007889l66.485611,0c4.42276,0 8.007904,-3.585129 8.007904,-8.007889l0,-8.007904c0,-4.42276 -3.585144,-8.007904 -8.007904,-8.007904z" },
            { d: "m89.468384,240.399292l-51.445969,0c-4.421967,0 -8.007904,3.585144 -8.007904,8.007935l0,8.007874c0,4.422791 3.585938,8.007935 8.007904,8.007935l51.445969,0c4.42276,0 8.007904,-3.585144 8.007904,-8.007935l0,-8.007874c0,-4.422791 -3.585144,-8.007935 -8.007904,-8.007935z" }
        ]
    }, {
        name: tf.styles.SvgGlyphMaximumVolumeName, W: 301.219, H: 301.219,
        paths: [{ d: "m21.455528,109.688332l0,82.469673l46.948105,0l70.280388,57.715927l0.041748,-197.901718l-70.290283,57.716118l-46.979958,0zm144.216576,-9.483368c-4.104141,-4.063011 -10.695053,-4.063011 -14.778412,0.021095c-4.073715,4.083328 -4.073715,10.694679 0.020554,14.78904l0,-0.021042c9.013901,9.024132 14.570023,21.400856 14.570023,35.156212c0,13.745148 -5.545639,26.080322 -14.548798,35.103806c-4.115494,4.062958 -4.115494,10.674606 -0.021225,14.778854c2.037018,2.036697 4.71048,3.060287 7.384476,3.060287c2.683945,0 5.357742,-1.02359 7.394363,-3.060287c12.763199,-12.742172 20.68045,-30.445496 20.670029,-49.88266c0.010422,-19.478912 -7.937759,-37.203224 -20.69101,-49.945305zm23.970535,-23.959351c-4.104767,-4.084099 -10.695129,-4.084099 -14.758392,0c-4.094208,4.083946 -4.094208,10.705086 0,14.768127c15.144714,15.154945 24.481857,36.001808 24.481857,59.125984c0,23.103195 -9.337143,43.939758 -24.46106,59.105225c-4.094162,4.073395 -4.094162,10.684525 0,14.768448c2.036713,2.037094 4.710953,3.06012 7.394852,3.06012c2.673706,0 5.347382,-1.023026 7.384521,-3.06012c18.883286,-18.893295 30.59166,-45.067719 30.570923,-73.873672c0.010361,-28.826607 -11.698181,-55.021339 -30.612701,-73.894112zm22.758224,-22.758972c-4.104416,-4.083778 -10.704803,-4.06274 -14.768387,0.021049c-4.083572,4.062889 -4.083572,10.684319 0.021042,14.758034l-0.021042,0c20.983154,20.982536 33.923676,49.851196 33.923676,81.874001c0,31.99147 -12.940521,60.870712 -33.902634,81.863739c-4.083755,4.073364 -4.083755,10.68428 0.020706,14.778336c2.026276,2.026825 4.69989,3.039841 7.373642,3.039841s5.357941,-1.023499 7.394928,-3.06015c24.68074,-24.711487 40.012848,-58.93808 39.99202,-96.621765c0.020828,-37.714821 -15.311279,-71.951752 -40.033951,-96.653084z" }]
    }, {
        name: tf.styles.SvgGlyphMediumVolumeName, W: 301.219, H: 301.219,
        paths: [{ d: "m21.455528,109.570831l0,82.591293l47.019302,0l70.385674,57.800995l0.04007,-198.193111l-70.393234,57.800823l-47.051811,0zm144.426079,-9.496384c-4.109863,-4.070122 -10.709396,-4.070122 -14.795074,0.019798c-4.07811,4.089752 -4.07811,10.711502 0.015884,14.811241l0,-0.019798c9.033234,9.037628 14.59549,21.430916 14.59549,35.206825c0,13.765945 -5.55394,26.119141 -14.571304,35.156937c-4.118179,4.067825 -4.118179,10.68927 -0.024185,14.799149c2.042831,2.041031 4.724518,3.06456 7.397903,3.06456c2.68927,0 5.370209,-1.023529 7.405487,-3.06456c12.783997,-12.760254 20.708878,-30.490311 20.700562,-49.956085c0.008316,-19.50766 -7.948318,-37.257828 -20.724762,-50.018066zm24.012802,-23.99482c-4.118179,-4.089752 -10.717712,-4.089752 -14.77919,0c-4.10231,4.08992 -4.10231,10.721649 0,14.789474c15.162506,15.178391 24.514801,36.05481 24.514801,59.213432c0,23.136703 -9.352295,44.004944 -24.498932,59.193314c-4.10231,4.077972 -4.10231,10.699585 0,14.789474c2.042847,2.038757 4.716232,3.064423 7.405472,3.064423c2.681702,0 5.355087,-1.025665 7.397919,-3.064423c18.913269,-18.921265 30.635757,-45.134308 30.611588,-73.982788c0.016632,-28.868576 -11.714951,-55.101578 -30.651657,-74.002907z" }]
    }, {
        name: tf.styles.SvgGlyphMinimumVolumeName, W: 301.219, H: 301.219,
        paths: [
            { d: "m20.998001,109.054123l0,82.093719l49.343155,0l73.866394,57.453156l0.044052,-196.999992l-73.877525,57.453117l-49.376076,0zm151.574982,-9.440422c-4.314087,-4.044304 -11.240814,-4.044304 -15.532837,0.020905c-4.281189,4.065163 -4.281189,10.646355 0.021866,14.721985l0,-0.020844c9.473511,8.982857 15.313354,21.303185 15.313354,34.995918c0,13.682297 -5.828949,25.960983 -15.291382,34.943848c-4.325027,4.044403 -4.325027,10.625565 -0.021973,14.711578c2.140625,2.027405 4.95079,3.046341 7.761017,3.046341c2.821152,0 5.631332,-1.018936 7.771942,-3.046341c13.414246,-12.684204 21.735229,-30.30687 21.724121,-49.655426c0.011108,-19.390167 -8.342667,-37.033676 -21.746109,-49.717964z" }
        ]
    }, {
        name: tf.styles.SvgGlyphMuteVolumeName, W: 301.219, H: 301.219,
        paths: [
            { d: "m20.998001,108.944298l0,83.188042l47.356949,0l70.893066,58.218903l0.042236,-199.625908l-70.903702,58.218964l-47.38855,0z" },
            { d: "m227.115997,176.025162l-24.435715,-24.435684l24.431274,-24.435745l-12.559845,-12.568733l-24.435684,24.435707l-24.435791,-24.435707l-12.559784,12.568733l24.431244,24.435745l-24.435699,24.435684l12.568695,12.56424l24.431335,-24.435684l24.431244,24.435684" }
        ]
    }
    ];
    function getGlyphByName(glyphName) {
        return glyphsByName[glyphName];
    }
    function addGlyph(glyphSpecs) {
        if (tf.js.GetIsValidObject(glyphSpecs) && tf.js.GetIsNonEmptyString(glyphSpecs.name)) {
            var name = glyphSpecs.name;
            if (!tf.js.GetIsValidObject(glyphsByName[name])) { glyphsByName[name] = glyphSpecs; }
            else { tf.GetDebug().LogIfTest("glyphlib: adding duplicate glyph named: " + name); }
        }
    }
    function initialize() {
        glyphsByName = {};
        for (var i in allSpecs) { addGlyph(allSpecs[i]); }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * @public
 * @function
 * @summary - Retrieves the {@link singleton} [SVG Glyph Library]{@link tf.styles.SvgGlyphLib}
 * @returns {tf.styles.SvgGlyphLib} - | {@link tf.styles.SvgGlyphLib} the singleton
*/
tf.ui.GetSvgGlyphLib = function () { if (!tf.g_SvgGlyphLib) { tf.g_SvgGlyphLib = new tf.styles.SvgGlyphLib() } return tf.g_SvgGlyphLib; }
/**
 * CSS Style specification of an [SVG Glyph]{@link tf.ui.SvgGlyph} instance. May be set to a [CSS Style Name]{@link tf.types.CSSStyleName} created
 * with the function [CreateSvgGlyphClasses]{@link tf.styles.Styles#CreateSvgGlyphClasses}, or to a {@link boolean} value, in which case
 * a <b>true</b> value selects the API's default <b>light</b> style settings, otherwise the default <b>dark</b> style settings are used
 * @public
 * @typedef {boolean|tf.types.CSSStyleName} tf.types.SvgGlyphStyle
 */
/**
 * Glyph specification of an [SVG Glyph]{@link tf.ui.SvgGlyph} instance. Can be either a [Custom Glyph Specification]{@link tf.types.SVGGlyphSpecs} 
 * or a [Pre-defined SVG glyph name]{@link tf.types.PredefinedSVGGlyphName}
 * @public
 * @typedef {tf.types.SVGGlyphSpecs|tf.types.PredefinedSVGGlyphName} tf.types.SvgGlyphGlyph
 */
/**
 * An object used in the creation of [SVG Glyph]{@link tf.ui.SvgGlyph} instances
 * @public
 * @typedef {object} tf.types.SvgGlyphBtnSettings
 * @property {tf.types.SvgGlyphStyle} style - the given style
 * @property {tf.types.SvgGlyphGlyph} glyph - the given glyph
 * @property {boolean} noChangeOnHover -  if set to <b>true</b> prevents the glyph from changing style when 
 * hovered by the mouse pointer. Valid only when <b>svgGlyphStyle</b> is {@link boolean}, otherwise ignored, defaults to {@link void}
 */
/**
 * @public
 * @class
 * @summary - SVG Glyph is an [Insertable]{@link tf.dom.Insertable} implementing the <b>'svg'</b> HTML element
 * @param {tf.types.SvgGlyphBtnSettings} settings - creation settings
 * @extends {tf.dom.Insertable}
*/
tf.ui.SvgGlyph = function (settings) {
    var svgNS, styles, theThis, svgLightClass, svgDarkClass, style, svg, g, paths;
    /**
     * @public
     * @function
     * @summary - Retrieves this instance's style
     * @returns {tf.types.SvgGlyphStyle} - | {@link tf.types.SvgGlyphStyle} the style
    */
    this.GetStyle = function () { return style; }
    /**
     * @public
     * @function
     * @summary - Sets this instance's style to the given style
     * @param {tf.types.SvgGlyphStyle} style - the given style
     * @returns {void} - | {@link void} no return value
    */
    this.SetStyle = function (style) { return setStyle(style); }
    /**
     * @public
     * @function
     * @summary - Sets this instance's glyph to the given glyph
     * @param {tf.types.SvgGlyphGlyph} glyph - the given glyph
     * @returns {void} - | {@link void} no return value
    */
    this.ChangeGlyph = function (glyph) { clearPaths(); addPaths(glyph); }
    function clearPaths() { var nPaths = paths.length; if (nPaths) { for (var i in paths) { g.removeChild(paths[i]); } paths = []; } }
    function addPathStr(oneglyph) {
        if (tf.js.GetIsValidObject(oneglyph) && oneglyph.d) {
            var path = document.createElementNS(svgNS, 'path');
            var d = oneglyph.d;
            var style = oneglyph.style;
            var fill = oneglyph.fill;
            path.setAttributeNS(null, 'd', d);
            if (style) { path.setAttributeNS(null, 'style', style); }
            if (fill) { path.setAttributeNS(null, 'fill', fill); }
            paths.push(path);
            g.appendChild(path);
        }
    }
    function addPaths(glyphSet) {
        if (tf.js.GetIsString(glyphSet)) { glyphSet = tf.ui.GetSvgGlyphLib().GetGlyphByName(glyphSet); }
        if (tf.js.GetIsValidObject(glyphSet) && glyphSet.W && glyphSet.H) {
            svg.setAttributeNS(null, 'viewBox', '0 0 ' + glyphSet.W + ' ' + glyphSet.H);
            var paths = glyphSet.paths;
            for (var i in paths) { addPathStr(paths[i]); }
        } else { addPathStr(glyphSet); }
    }
    function setStyle(styleSet) {
        if (tf.js.GetIsNonEmptyString(styleSet)) { svg.setAttributeNS(null, 'class', style = styleSet); }
        else { style = !!styleSet; svg.setAttributeNS(null, 'class', style ? svgLightClass : svgDarkClass); }
    }
    function createSvgAndG() {
        svg = document.createElementNS(svgNS, "svg");
        svg.setAttributeNS(null, 'width', '100%');
        svg.setAttributeNS(null, 'height', '100%');
        svg.style.border = svg.style.caption = svg.style.margin = svg.style.padding = "0px";
        svg.style.display = 'inline-block';
        svg.style.display = 'block'; // setting to block breaks the vertical positioning of "closeXButtons"
        setStyle(settings.style);
        svg.appendChild(g = document.createElementNS(svgNS, 'g'));
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        svgNS = "http://www.w3.org/2000/svg";
        styles = tf.GetStyles();
        paths = [];
        var makeIconBool = tf.js.GetBoolFromValue(settings.noChangeOnHover, false);
        svgLightClass = makeIconBool ? styles.svgGlyphLightNoHoverStyleClass : styles.svgGlyphLightStyleClass;
        svgDarkClass = makeIconBool ? styles.svgGlyphDarkNoHoverStyleClass : styles.svgGlyphDarkStyleClass;
        createSvgAndG();
        addPaths(settings.glyph);
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: svg });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.ui.SvgGlyph, tf.dom.Insertable);
/**
 * An object used in the creation of [SVG Glyph Button]{@link tf.ui.SvgGlyphBtn} instances
 * @public
 * @typedef {object} tf.types.SvgGlyphBtnSettings
 * @property {tf.types.SvgGlyphStyle} style - the given style
 * @property {tf.types.SvgGlyphGlyph} glyph - the given glyph
 * @property {boolean} noChangeOnHover -  if set to <b>true</b> prevents the glyph from changing style when 
 * hovered by the mouse pointer. Valid only when <b>svgGlyphStyle</b> is {@link boolean}, otherwise ignored, defaults to {@link void}
 * @property {HTMLElementSizeOrPxNumber} dim - the button's dimensions
 * @property {tf.types.MultiDOMEventListenerCallBack} onClick - sets a [Click Listener]{@link tf.events.DOMClickListener} for the button
 * @property {string} tooltip - tool tip text
 */
/**
 * @public
 * @class
 * @summary - SVG Glyph Button is an [Insertable]{@link tf.dom.Insertable} containing an [SVG Glyph]{@link tf.ui.SvgGlyph} instance and implementing a user interface button
 * @param {tf.types.SvgGlyphBtnSettings} settings - creation settings
 * @extends {tf.dom.Insertable}
*/
tf.ui.SvgGlyphBtn = function (settings) {
    var theThis, defaultDim, divObj, div, svg, onclickCallBack;
    /**
     * @public
     * @function
     * @summary - Retrieves the style of the associated [SVG Glyph]{@link tf.ui.SvgGlyph} instance
     * @returns {tf.types.SvgGlyphStyle} - | {@link tf.types.SvgGlyphStyle} the style
    */
    this.GetStyle = function () { return svg ? svg.GetStyle() : null; }
    /**
     * @public
     * @function
     * @summary - Sets the style of the associated [SVG Glyph]{@link tf.ui.SvgGlyph} instance to the given style
     * @param {tf.types.SvgGlyphStyle} style - the given style
     * @returns {void} - | {@link void} no return value
    */
    this.SetStyle = function (style) { if (!!svg) { svg.SetStyle(style); } }
    /**
     * @public
     * @function
     * @summary - Changes the glyph of the associated [SVG Glyph]{@link tf.ui.SvgGlyph} instance to the given glyph
     * @param {tf.types.SvgGlyphGlyph} glyph - the given glyph
     * @returns {void} - | {@link void} no return value
    */
    this.ChangeGlyph = function (glyph) { if (!!svg) { svg.ChangeGlyph(glyph); } }
    /**
     * @public
     * @function
     * @summary - Changes the tooltip text of this SVG Glyph Button instance to the given text
     * @param {string} tooltip - the given text
     * @returns {void} - | {@link void} no return value
    */
    this.ChangeToolTip = function (tooltip) { return changeToolTip(tooltip); }
    function changeToolTip(toolTipStr) {
        if (tf.js.GetIsNonEmptyString(toolTipStr)) { div.title = toolTipStr; }
        else { if (div.title !== undefined) { delete div.title; } }
    }
    function onClickHandler(notification) {
        tf.events.StopDOMEvent(notification.event);
        if (!!onclickCallBack) { onclickCallBack.call(null, notification); }
        return false;
    }
    function setSize(dim) {
        dim = tf.js.GetDimFromStrOrPxNumber(dim, defaultDim);
        div.style.width = div.style.height = dim;
    }
    function setCallBack(callBackSet) { onclickCallBack = tf.js.GetFunctionOrNull(callBackSet); }
    function initialize() {
        settings = tf.js.GetIsValidObject(settings) ? settings : {};
        defaultDim = "1em";
        divObj = new tf.dom.Div({ cssClass: tf.GetStyles().divSvgGlyphBtnClass });
        div = divObj.GetHTMLElement();
        setSize(settings.dim);
        setCallBack(settings.onClick);
        new tf.events.DOMClickListener({ target: div, callBack: onClickHandler, optionalScope: theThis, callBackSettings: null });
        svg = new tf.ui.SvgGlyph(settings);
        changeToolTip(settings.tooltip);
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: divObj });
        divObj.AddContent(svg);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.ui.SvgGlyphBtn, tf.dom.Insertable);
/**
 * An object used in the creation of [SVG Glyph Button]{@link tf.ui.SvgGlyphToggleBtn} instances
 * @public
 * @typedef {object} tf.types.SvgGlyphToggleBtnSettings
 * @property {tf.types.SvgGlyphStyle} style - the given style
 * @property {tf.types.SvgGlyphGlyph} glyph - the given glyph
 * @property {tf.types.SvgGlyphGlyph} toggledGlyph - the given toggled glyph
 * @property {boolean} noChangeOnHover -  if set to <b>true</b> prevents the glyph from changing style when 
 * hovered by the mouse pointer. Valid only when <b>svgGlyphStyle</b> is {@link boolean}, otherwise ignored, defaults to {@link void}
 * @property {HTMLElementSizeOrPxNumber} dim - the button's dimensions
 * @property {tf.types.MultiDOMEventListenerCallBack} onClick - sets a [Click Listener]{@link tf.events.DOMClickListener} for the button
 * @property {string} tooltip - tool tip text
 * @property {string} toggledTooltip - toggled tool tip text
 * @property {boolean} isToggled -  sets the initial toggled state of the button
 */
/**
 * @public
 * @class
 * @summary - SVG Glyph Toggle Button is an [Insertable]{@link tf.dom.Insertable} containing an [SVG Glyph Button]{@link tf.ui.SvgGlyphBtn} instance
 * that automatically changes its glyph and tooltip in response to [Click]{@link tf.consts.DOMEventNamesClick} events
 * @param {tf.types.SvgGlyphToggleBtnSettings} settings - creation settings
 * @extends {tf.dom.Insertable}
*/
tf.ui.SvgGlyphToggleBtn = function (settings) {
    var theThis, theButton, isToggled, onclickCallBack, glyph, toolTipStr, toggledGlyph, toggledToolTipStr;
    /**
     * @public
     * @function
     * @summary - Sets the toggled state of this SVG Glyph Toggle Button instance to the given state
     * @param {boolean} isToggled - <b>true</b> for toggled state, <b>false</b> for normal state
     * @returns {void} - | {@link void} no return value
    */
    this.SetIsToggled = function (isToggled) { return setIsToggled(isToggled); }
    /**
     * @public
     * @function
     * @summary - Retrieves the toggled state of this SVG Glyph Toggle Button instance
     * @returns {boolean} - | {@link boolean} <b>true</b> if in toggled state, <b>false</b> if in normal state
    */
    this.GetIsToggled = function () { return getIsToggled(); }
    /**
     * @public
     * @function
     * @summary - Toggles the toggled state of this SVG Glyph Toggle Button instance
     * @returns {void} - | {@link void} no return value
    */
    this.ToggleToggled = function () { return toggleToggled(); }
    /**
     * @public
     * @function
     * @summary - Retrieves the style of the associated [SVG Glyph Button]{@link tf.ui.SvgGlyphBtn} instance
     * @returns {tf.types.SvgGlyphStyle} - | {@link tf.types.SvgGlyphStyle} the style
    */
    this.GetStyle = function () { return theButton.GetStyle(); }
    /**
     * @public
     * @function
     * @summary - Sets the style of the associated [SVG Glyph Button]{@link tf.ui.SvgGlyphBtn} instance to the given style
     * @param {tf.types.SvgGlyphStyle} style - the given style
     * @returns {void} - | {@link void} no return value
    */
    this.SetStyle = function (style) { return theButton.SetStyle(style); }
    function changeImage() {
        if (isToggled) { theButton.ChangeToolTip(toggledToolTipStr); theButton.ChangeGlyph(toggledGlyph); }
        else { theButton.ChangeToolTip(toolTipStr); theButton.ChangeGlyph(glyph); }
    }
    function setIsToggled(isToggledSet) { if ((isToggledSet = !!isToggledSet) != isToggled) { isToggled = isToggledSet; changeImage(); } }
    function getIsToggled() { return isToggled; }
    function toggleToggled() { setIsToggled(!getIsToggled()); }
    function myOnClickCallBack(notification) { toggleToggled(); return (!!onclickCallBack) ? onclickCallBack(notification) : false; }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        isToggled = tf.js.GetBoolFromValue(settings.isToggled, false);
        onclickCallBack = tf.js.GetFunctionOrNull(settings.onClick);
        glyph = settings.glyph;
        toggledGlyph = settings.toggledGlyph;
        toolTipStr = settings.tooltip;
        toggledToolTipStr = settings.toggledTooltip;
        theButton = new tf.ui.SvgGlyphBtn({
            style: settings.style,
            glyph: isToggled ? toggledGlyph : glyph,
            onClick: myOnClickCallBack,
            tooltip: isToggled ? toggledToolTipStr : toolTipStr,
            dim: settings.dim });
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: theButton });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.ui.SvgGlyphToggleBtn, tf.dom.Insertable);
/**
 * An object used in the creation of [Click Open Close]{@link tf.ui.ClickOpenClose} instances
 * @public
 * @typedef {object} tf.types.ClickOpenCloseSettings
 * @property {tf.types.SvgGlyphStyle} style - the given style
 * @property {HTMLElementSizeOrPxNumber} dim - the button's dimensions
 * @property {tf.types.MultiDOMEventListenerCallBack} onClick - sets a [Click Listener]{@link tf.events.DOMClickListener} for the button
 * @property {boolean} isOpen -  sets the initial open state of the button
 * @property {HTMLElementLike} divOpenClose - container whose visibility state will be toggled by the button
 */
/**
 * @public
 * @class
 * @summary - Click Open Close is an [Insertable]{@link tf.dom.Insertable} containing an [SVG Glyph Toggle Button]{@link tf.ui.SvgGlyphToggleBtn} instance
 * that automatically changes its image and tooltip in response to [Click]{@link tf.consts.DOMEventNamesClick} events, and also 
 * controls the visibility state of a given HTML container
 * @param {tf.types.ClickOpenCloseSettings} settings - creation settings
 * @extends {tf.dom.Insertable}
*/
tf.ui.ClickOpenClose = function (settings) {
    var theThis, button, divOpenClose, callBack;
    /**
     * @public
     * @function
     * @summary - Sets a container whose visibility state will be controlled by the button, 
     * and optionally modifies the [Click Listener]{@link tf.events.DOMClickListener} for the button
     * @param {HTMLElementLike} divOpenClose - the HTML container
     * @param {tf.types.MultiDOMEventListenerCallBack} callBack - if defined, sets the new listener, can be set to null to remove a previously set listener
     * @returns {void} - | {@link void} no return value
    */
    this.SetDivOpenClose = function (divOpenClose, callBack) { return setDivOpenClose(divOpenClose, callBack) }
    /**
     * @public
     * @function
     * @summary - Sets the open state of this Click Open Close instance to the given state
     * @param {boolean} isOpen - <b>true</b> for open state, <b>false</b> for close state
     * @returns {void} - | {@link void} no return value
    */
    this.SetIsOpen = function (isOpen) { button.SetIsToggled(isOpen); checkOpenClose(); }
    /**
     * @public
     * @function
     * @summary - Retrieves the open state of this Click Open Close instance
     * @returns {boolean} - | {@link boolean} <b>true</b> if in open state, <b>false</b> if in close state
    */
    this.GetIsOpen = function () { return button.GetIsToggled(); }
    /**
     * @public
     * @function
     * @summary - Toggles the open / close state of this Click Open Close instance
     * @returns {void} - | {@link void} no return value
    */
    this.Toggle = function () { button.Toggle(); checkOpenClose(); }
    function checkOpenClose(notification) {
        if (!!divOpenClose) {
            divOpenClose.style.display = button.GetIsToggled() ? 'block' : 'none';
            if (!!callBack) { callBack.call(null, notification); }
        }
    }
    function setDivOpenClose (divOpenCloseSet, callBackSet) {
        divOpenClose = tf.dom.GetHTMLElementFrom(divOpenCloseSet);
        if (callBackSet !== undefined) { callBack = tf.js.GetFunctionOrNull(callBackSet); }
    }
    function myOnClickCallBack(notification) { checkOpenClose(notification); return false; }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        setDivOpenClose(settings.divOpenClose, settings.onClick);
        button = new tf.ui.SvgGlyphToggleBtn({
            style: settings.style, onClick: myOnClickCallBack, dim: settings.dim, isToggled: settings.isOpen,
            glyph: tf.styles.SvgGlyphTriangleRightName, tooltip: "Open", toggledGlyph: tf.styles.SvgGlyphTriangleDownName, toggledTooltip: "Close"
        });
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: button });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.ui.ClickOpenClose, tf.dom.Insertable);
/**
 * An {@link object} with two [CSS Style Specifications]{@link tf.types.CSSStyleSpecs}, for normal and hover states
 * @public
 * @typedef {object} tf.types.CSSStyleAndHoverSpecifications
 * @property {tf.types.CSSStyleSpecs} style - regular style used by the {@link HTMLElementLike} 
 * @property {tf.types.CSSStyleSpecs} hoverStyle - style used by the {@link HTMLElementLike} when the mouse pointer is hovering over it
*/
/**
 * A string containing the name of a Cascading Style Sheet style created by [CSS Style Creator]{@link tf.styles.CSSStyleCreator} 
 * or one of the pre-defined class names provided by [Styles]{@link tf.styles.Styles}. CSSStyleNames can be assigned to the <b>class</b> attribute of an [HTMLElement]{@link HTMLElement}
 * either directly or using the function [AddCSSClass]{@link tf.dom.AddCSSClass}
 * @public
 * @typedef {string} tf.types.CSSStyleName
 */
/**
 * A single CSS Style statement, a component part of [CSS Style Specs]{@link tf.types.CSSStyleSpecs}. Examples: backgroundColor: "#f0f", or, textAlign: "left"
 * @public
 * @typedef {object} tf.types.CSSStyleStatement
 * @property {string} propertyName - the string value of a camelized <b>propertyName</b> is assigned to the corresponding unCamelized <b>propertyname</b>, if it is a known HTML css style property
*/
/**
 * CSS Style definitions, used by [CSS Style Creator]{@link tf.styles.CSSStyleCreator}, [Sub Styles]{@link tf.styles.SubStyles}, and [Styles]{@link tf.styles.Styles}
 * @public
 * @typedef {object} tf.types.CSSStyleSpecs
 * @property {tf.types.CSSStyleName} styleName - the name of the style being created, a mandatory property
 * @property {tf.types.CSSStyleSpecs|enumerable<tf.types.CSSStyleSpecs>} inherits - an optional property implementing style inheritance
 * @property {...tf.types.CSSStyleStatement} statements - zero or more style statements
 * @example
 * // creates a style specification for background color
 * var backgroundSpecs = { backgroundColor: "#707" };
 * // creates a style specification for text color
 * var textColorSpecs = { color: "#42f831" };
 * // creates a style specification for font size
 * var fontSizeSpecs = { fontSize: "1em" };
 * // creates a style specification combining previously defined specifications and adding a new one
 * var textSpecs = { inherits: [textColorSpecs, fontSizeSpecs], fontWeight: "500" };
 * // creates a style specification combining inherited specifications, and specifying a styleName
 * var containerSpecs = { styleName: "myContainerClass", inherits: [textSpecs, backgroundSpecs], border: "1px solid #000" };
*/
/**
 * @public
 * @class
 * @summary The {@link singleton} instance of this class, obtainable by calling {@link tf.GetStyles}().[GetStyleCreator]{@link tf.styles.Styles#GetStyleCreator}(),
 * implements programmatic / run time creation of global CSS classes and application of custom CSS styles to individual {@link HTMLElementLike} instances
 * @param {tf.styles.Styles} styles - the {@link singleton} [Styles]{@link tf.styles.Styles} instance
 */
tf.styles.CSSStyleCreator = function (styles) {
    var theThis, hasHead, head, allRules, styleSheetForNewStyles, styleSheetForNewStylesRules;
    /**
     * @public
     * @function
     * @summary - Creates a new CSS style based on the given specifications
     * @param {tf.types.CSSStyleSpecs} cssStyleSpecs - the given specifications
     * @returns {void} - | {@link void} no return value
    */
    this.CreateStyle = function (cssStyleSpecs) { return createStyle(cssStyleSpecs); }
    /**
     * @public
     * @function
     * @summary - Creates an arbitrary number of new CSS styles based on the given specifications
     * @param {enumerable<tf.types.CSSStyleSpecs>} cssStyleSpecs - an enumerable of specifications
     * @returns {void} - | {@link void} no return value
    */
    this.CreateStyles = function (cssStyleSpecs) { return createStyles(cssStyleSpecs); }
    /**
     * @public
     * @function
     * @summary - Creates a new CSS style with the given name based on the given raw style string
     * @param {tf.types.CSSStyleName} styleName - the style name
     * @param {string } styleStr - a style specification in CSS file syntax
     * @returns {void} - | {@link void} no return value
    */
    this.CreateRawStyle = function (styleName, styleStr) { return createRawStyle(styleName, styleStr); }
    /**
     * @public
     * @function
     * @summary - Applies the given style specifications to the given element
     * @param {HTMLElementLike} elem - the given element
     * @param {tf.types.CSSStyleSpecs} cssStyleSpecs - the given specifications
     * @returns {void} - | {@link void} no return value
    */
    this.ApplyStyleProperties = function (elem, style) { return applyStyleProperties(elem, style); }
    /**
     * @private
     * @function
     * @summary - Debugging mechanism used internally by the API
     * @returns {void} - | {@link void} no return value
    */
    this.LogStyles = function () { return logStyles(); }
    function unCamelize(name) {
        var newName = '', nChars = typeof name === "string" ? name.length : 0;
        for (var i = 0 ; i < nChars ; ++i) {
            //for (var i in name) {
            var thisChar = name[i]; var thisCharLower = thisChar.toLowerCase();
            newName += thisChar == thisCharLower ? thisChar : "-" + thisCharLower;
        }
        return newName;
    }
    function applyStyleProperties(elem, style) {
        var prop;
        if (elem = tf.dom.GetHTMLElementFrom(elem)) {
            for (var property in style) {
                if (style.hasOwnProperty(property)) {
                    if (property != 'styleName') {
                        if (property == 'inherits') {
                            if (typeof (prop = style[property]) === "object") {
                                if (prop.length) { for (var p in prop) { if (prop.hasOwnProperty(p)) { applyStyleProperties(elem, prop[p]); } } }
                                else { applyStyleProperties(elem, prop) }
                            }
                        }
                        else switch (property) {
                            case "tf-shadow":
                                var shadowData = style[property];
                                if (tf.js.GetIsArrayWithMinLength(shadowData, 4)) {
                                    applyStyleProperties(elem, styles.GetSubStyles().CreateShadowStyle(shadowData[0], shadowData[1], shadowData[2], shadowData[3]));
                                }
                                break;
                            default:
                                elem.style[property] = style[property];
                                break;
                        }
                    }
                }
            }
        }
    }
    function addStyleProperties(style, styleStr) {
        typeof styleStr !== "string" && (styleStr = '');
        var prop;
        for (var property in style) {
            if (style.hasOwnProperty(property)) {
                if (property != 'styleName') {
                    if (property == 'inherits') {
                        if (typeof (prop = style[property]) === "object") {
                            if (prop.length) { for (var p in prop) { if (prop.hasOwnProperty(p)) { styleStr = addStyleProperties(prop[p], styleStr); } } }
                            else { styleStr = addStyleProperties(prop, styleStr) }
                        }
                    }
                    else switch (property) {
                        case "tf-shadow":
                            var shadowData = style[property];
                            if (tf.js.GetIsArrayWithMinLength(shadowData, 4)) {
                                styleStr = addStyleProperties(styles.GetSubStyles().CreateShadowStyle(shadowData[0], shadowData[1], shadowData[2], shadowData[3]), styleStr);
                            }
                            break;
                        default:
                            prop = style[property]; property = unCamelize(property); styleStr += property + ' : ' + prop + '; ';
                            break;
                    }
                }
            }
        }
        return styleStr;
    }
    function createStyles(styleArray) {
        if (tf.js.GetIsValidObject(styleArray)) { for (var i in styleArray) { createStyle(styleArray[i]); } }
    }
    function createStyle(style) {
        if (tf.js.GetIsValidObject(style) && tf.js.GetIsNonEmptyString(style.styleName)) {
            var styleStr = '';
            createRawStyle(style.styleName, addStyleProperties(style, styleStr));
        }
    }
    function getStyleSheetRules(styleSheet) {
        var rules = null;
        if (!!styleSheet) {
            try {
                var mediaType = typeof styleSheet.media;
                rules = mediaType == "string" ? styleSheet.rules : (mediaType == "object" ? styleSheet.cssRules : null);
                if (!rules) {
                    if (!!styleSheet.sheet && !!styleSheet.sheet.cssRules) {
                        rules = styleSheet.sheet.cssRules;
                    }
                }
            } catch (e) { rules = null; }
        }
        return rules;
    }
    function getLastAvailableStyleSheet() {
        var styleSheet = null, rules = null, styleSheets = document.styleSheets, nStyleSheets = !!styleSheets ? styleSheets.length : 0;
        if (nStyleSheets > 0) {
            for (var i = nStyleSheets - 1; i >= 0 && !styleSheet ; --i) {
                var thisStyleSheet = styleSheets[i];
                if (!thisStyleSheet.disabled) {
                    var media = thisStyleSheet.media;
                    var mediaType = typeof media;
                    var mediaText = mediaType == "string" ? media : (mediaType == "object" ? media.mediaText : null);
                    if (mediaText == "" || (mediaText.indexOf("screen") != -1) || (mediaText.indexOf("all") != -1)) {
                        if (!(rules = getStyleSheetRules(styleSheet = thisStyleSheet))) { styleSheet = null; }
                    }
                }
            }
        }
        return { styleSheet: styleSheet, rules: rules };
    }
    function createNewStyleSheet() {
        var styleSheet = null, rules = null;
        if (hasHead) {
            var styleElem;
            if (styleElem = document.createElement("style")) {
                styleElem.type = "text/css"; head[0].appendChild(styleElem);
                if (styleElem.sheet != undefined) {
                    styleSheet = styleElem.sheet;
                }
                else if (styleElem.styleSheet != undefined) {
                    styleSheet = styleElem.styleSheet;
                }
                if (!!styleSheet) {
                    if (!(rules = getStyleSheetRules(styleSheet))) { styleSheet = null; }
                }
            }
        }
        return { styleSheet: styleSheet, rules: rules };
    }
    function getLastOrCreateNewStyleSheet() {
        var lastAvailableStyleSheet = getLastAvailableStyleSheet();
        if (!lastAvailableStyleSheet.styleSheet) { lastAvailableStyleSheet = createNewStyleSheet(); }
        styleSheetForNewStyles = lastAvailableStyleSheet.styleSheet;
        styleSheetForNewStylesRules = lastAvailableStyleSheet.rules;
    }
    function createRawStyle(selector, style) {
        if (typeof selector === "string" && selector.length > 0 && typeof style === "string" && style.length > 0) {
            var lowerCaseSelector = selector.toLowerCase(), existingRule = allRules[lowerCaseSelector];
            if (!!existingRule) {
                try {
                    existingRule.style.cssText = style;
                }
                catch (exception) {
                    //tf.GetDebug().LogIfTest("css exception (change existing rule)" + selector + " " + exception);
                }
            }
            else if (!!styleSheetForNewStylesRules) {
                try {
                    var nRules = styleSheetForNewStylesRules.length;
                    if (typeof styleSheetForNewStyles.insertRule === "function") {
                        styleSheetForNewStyles.insertRule(selector + "{" + style + "}", nRules);
                    }
                    else {
                        styleSheetForNewStyles.addRule(selector, style);
                    }
                    allRules[lowerCaseSelector] = styleSheetForNewStylesRules[nRules];
                }
                catch (exception) {
                    //tf.GetDebug().LogIfTest("css exception (insert new rule)" + selector + " " + exception);
                }
            }
        }
    }
    function loadAllRules() {
        var styleSheets = document.styleSheets, nStyleSheets = !!styleSheets ? styleSheets.length : 0;
        allRules = [];
        if (nStyleSheets > 0) {
            for (var styleSheet in styleSheets) {
                if (styleSheets.hasOwnProperty(styleSheet)) {
                    var thisStyleSheet = styleSheets[styleSheet];
                    if (!thisStyleSheet.disabled) {
                        try {
                            var rules = getStyleSheetRules(thisStyleSheet);
                            if (!!rules) {
                                for (var rule in rules) {
                                    if (rules.hasOwnProperty(rule)) {
                                        var thisRule = rules[rule];
                                        if (thisRule.selectorText) { allRules[thisRule.selectorText.toLowerCase()] = thisRule; }
                                        else {
                                            // @ something
                                        }
                                    }
                                }
                            }
                        }
                        catch (exception) {
                        }
                    }
                }
            }
        }
    }
    function logStyles() {
        var styleSheets = document.styleSheets, nStyleSheets = !!styleSheets ? styleSheets.length : 0;
        if (nStyleSheets > 0) {
            var logStr = '';
            for (var styleSheet in styleSheets) {
                if (styleSheets.hasOwnProperty(styleSheet)) {
                    var thisStyleSheet = styleSheets[styleSheet];
                    if (!thisStyleSheet.disabled) {
                        var rules = getStyleSheetRules(thisStyleSheet);
                        var nRules = rules ? rules.length : 0;
                        for (var rule in rules) {
                            if (rules.hasOwnProperty(rule)) {
                                var thisRule = rules[rule];
                                logStr += thisRule.cssText;
                            }
                        }
                    }
                }
            }
            tf.GetDebug().SaveAsTextFile("stylesheets", logStr);
        }
    }
    function initialize() {
        head = document.getElementsByTagName("head");
        hasHead = head && head.length > 0;
        loadAllRules();
        getLastOrCreateNewStyleSheet();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * An object whose properties specify some of the visual attributes used by the TerraFly API, used in the creation of the [Styles]{@link tf.styles.Styles} {@link singleton}
 * @private
 * @typedef {object} tf.types.APIStyleSpecs
 * @property {string} fontFamily - default font family
 * @property {string} markerFontFamily - default font family for displaying text features on the map
 * @property {number} mapButtonDimEmNumber - dimension of map buttons
 * @property {number} mapButtonMarginEmNumber - margin of map buttons
 * @property {number} mapButtonSpacingEmNumber - spacing of map buttons
 * @property {number} mapScaleLineBkColor - background color of the map scale line
 * @property {colorWithOptionalAlpha} mapScaleLineBkColor - background color of the map scale line
 * @property {number} mapScaleLineBorderRadiusPxNumber - border radius of the map scale line
 * @property {number} mapScaleLinePaddingPxNumber - padding of the map scale line
 * @property {string} mapScaleLineBorder - border of the map scale line, example: "1px solid #07375f"
 * @property {number} mapScaleLineFontSizeEmNumber - font size of the map scale line
 * @property {number} mapScaleLineMarginPxNumber - line margin of the map scale line
 * @property {colorWithOptionalAlpha} mapScaleLineFontColor - text color of the map scale line
 * @property {number} overviewMapWidthPxNumber - width of the overview map, in pixels
 * @property {number} overviewMapHeightPxNumber - height of the overview map, in pixels
 * @property {number} overviewMapBorderWidthPxNumberNumber - border width of the overview map border, in pixels
 * @property {string} overviewMapBoxBorder - border of the overview map inner box, example: "2px dotted rgba(255,255,255,1.0)"
 * @property {string} tfLogoBorderRadius - border radius of the TerraFly logo displayed on the map, example: "10%"
 * @property {HTMLElementSize} tfLogoWidth - width of the TerraFly logo displayed on the map, example: "8em"
 * @property {HTMLElementSize} tfLogoHeight - height of the TerraFly logo displayed on the map, example: "8em"
 * @property {tf.types.opacity01} tfLogoOpacity - opacity of the TerraFly logo displayed on the map, example: 0.8
 * @property {colorWithOptionalAlpha} tfLogoBkColor - background color of the TerraFly logo displayed on the map
 * @property {string}  tfLogoBorder - border of the TerraFly logo displayed on the map, example: "1px solid rgba(128,128,128,0.3)"
 * @property {number} mapControlLineHeightEmNumber - line height of text in map controls
 * @property {colorWithOptionalAlpha} mapControlTextColor - text color of map controls
 * @property {number} maxHeightLogoImageEmNumber - maximum height of logos
 * @property {number} maxWidthLogoImageEmNumber - maximum width of logos
 * @property {number} imageThumbWidthEmNumber - maximum dimension of thumbnail images
 * @property {number} infoPopupContentFontSizeEmNumber - font size for map Info Popups
 * @property {number} locationPopupContentFontSizeEmNumber - font size for map Location Popups
 * @property {number} mapControlFontSizeEmNumber - font size for map buttons
 * @property {string} mapControlFontWeight - font weight for for map buttons, example: "700"
 * @property {number} popupContentFontSizeEmNumber - font size for popup contents
 * @property {number} topFontSizePXNumber - font size for top container, changing this default also impacts any element sizes that are defined in EM units
 * @property {number} markerFontSizePXNumber - default font size for displaying text features on the map
 * @property {number} buttonBorderRadiusPxNumber - button border radius
 * @property {number} buttonMarginTopBottomPxNumber - button vertical margins
 * @property {number} buttonMarginLeftRightPxNumber - button horizontal margins
 * @property {number} textButtonPaddingTopBottomPxNumber - text button vertical padding
 * @property {number} textButtonPaddingLeftRightPxNumber - text button horizontal padding
 * @property {number} paddingPxNumber - padding for padded containers
 * @property {number} popupContainerPaddingPxNumber - padding for padded popup containers
 * @property {number} popupCaptionBorderRadiusPXNumber - border radius for popup captions
 * @property {number} popupCaptionBorderRadiusPXNumber - border radius for popup captions
 * @property {number} popupContentPaddingPXNumber - popup content padding
 * @property {number} popupContentBorderRadiusPXNumber - popup content border radius
 * @property {number} svgButtonBorderRadiusPercentNumber - border radius for svg buttons
 * @property {colorWithOptionalAlpha} lightTextColor - light style text color
 * @property {colorWithOptionalAlpha} darkTextColor - dark style text color
 * @property {colorWithOptionalAlpha} disabledTextColor - color for disabled or grayed out text
 * @property {colorWithOptionalAlpha} borderLightColor - light style container separator color
 * @property {colorWithOptionalAlpha} borderDarkColor - dark style container separator color
 * @property {colorWithOptionalAlpha} defaultButtonBk - default button background color
 * @property {colorWithOptionalAlpha} defaultButtonFill - default button fill color
 * @property {colorWithOptionalAlpha} buttonShapedLinkBkColor - background color for links shaped like buttons
 * @property {colorWithOptionalAlpha} buttonShapedLinkTextColor - text color for links shaped like buttons
 * @property {number} buttonShapedLinkMarginPxNumber - margin for links shaped like buttons
 * @property {string} buttonShapedLinkTextShadow - text shadow for links shaped like buttons, example: "1px 1px 1px #333"
 * @property {string} buttonShapedLinkTextShadowHover - text shadow for links shaped like buttons, example: "1px 1px 1px #ccc"
 * @property {colorWithOptionalAlpha} buttonShapedLinkHoverBkColor - background color for links shaped like buttons
 * @property {colorWithOptionalAlpha} buttonShapedLinkHoverTextColor - text color for links shaped like buttons
 * @property {colorWithOptionalAlpha} mapControlBkColor - map control background color
 * @property {colorWithOptionalAlpha} mapControlHoverBkColor - map control background color on hover
 * @property {colorWithOptionalAlpha} mapControlButtonBkColor- map button background color
 * @property {colorWithOptionalAlpha} mapControlButtonHoverBkColor - map button background color on hover
 * @property {colorWithOptionalAlpha} popupContentBkColor - popup content background color
 * @property {colorWithOptionalAlpha} containerDarkBackgroundColor - dark style container background color
 * @property {colorWithOptionalAlpha} containerDarkSelBackgroundColor - dark style selected container background color
 * @property {colorWithOptionalAlpha} hcfLayoutContainerBkColor - {@link tf.layout.HeaderContentFooter} container default background color
 * @property {colorWithOptionalAlpha} popupCaptionBackgroundColor - popup caption background color
 * @property {colorWithOptionalAlpha} separatorBackgroundColor - layout separator background color
 * @property {colorWithOptionalAlpha} buttonLightBkg - light style button background color
 * @property {colorWithOptionalAlpha} buttonLightFill - light style button fill/text color
 * @property {colorWithOptionalAlpha} buttonDarkBkg - dark style button background color
 * @property {colorWithOptionalAlpha} buttonDarkFill - dark style button fill/text color
 * @property {colorWithOptionalAlpha} lightTextDivBtnColor - light style text button text color
 * @property {colorWithOptionalAlpha} darkTextDivBtnColor - dark style text button text color
 * @property {colorWithOptionalAlpha} textInputBackgroundColor - background color for text input
 * @property {colorWithOptionalAlpha} dLayerSpanBackgroundColor - background color for dLayer text spans
 * @property {colorWithOptionalAlpha} mapPopupTextButtonTextColor - text color of map buttons in popups
 * @property {colorWithOptionalAlpha} mapPopupTextButtonBkColor - background color of map buttons in popups
 * @property {colorWithOptionalAlpha} dLayerSpanBackgroundColor - background color for dLayer text spans
 * @property {colorWithOptionalAlpha} inputFormBkColor - background color for input forms
 * @property {number} inputFormBorderRadiusPxNumber - border radius for input forms
 * @property {number} imgFramePaddingBorderWidthEmNumber - padding used in image frames, for best results coordinate size with <b>imgFrameBorder</b>
 * @property {string} imgFrameBorder - border used in image frames, for best results coordinate size with <b>imgFramePaddingBorderWidthEmNumber</b>
 * @property {string} textShadow -default text shadow style, with light color shadow, example: "1px 1px 1px #eee"
 * @property {string} darkTextShadow - default text shadow style, with dark color shadow, example: "1px 1px 1px #333"
 * @property {string} textShadowSelRadioCheckStyle - text shadow for selected radio button and check box labels, example: "1px 2px 2px #ddd"
 * @property {string} borderSeparatorLineSpecs - used for border separators, example: "1px solid"
 * @property {string} mapZoomInBorderRadius - used for the map's zoom in button, example: "2px 2px 0 0"
 * @property {string} mapZoomOutBorderRadius - used for the map's zoom out button, example: "0 0 2px 2px"
 * @property {number} verticalSeparatorWidthEMNumber - width of vertical layout separators
 * @property {number} horizontalSeparatorHeightEMNumber - height of horizontal layout separators
*/
/**
 * @public
 * @function
 * @summary - Returns the default TerraFly style specifications, used in the creation of the [Styles]{@link tf.styles.Styles} {@link singleton}
 * @returns {tf.types.APIStyleSpecs} - the default specifications
*/
tf.styles.GetDefaultAPIStyleSpecifications = function () {
    var mapButtonDimEmNumber = 2.25;
    var mapControlFontSizeEmNumber = mapButtonDimEmNumber - 0.5;
    var popupContentFontSizeEmNumber = mapButtonDimEmNumber - 0.75;
    var fontFamily = "Arial,Verdana,Geneva,Lucida,Arial,Helvetica,sans-serif";
    //var fontFamily = "'SourceSansPro-regular',Verdana,Geneva,Lucida,Arial,Helvetica,sans-serif";
    var niceDarkColor = "#07375f";
    var niceLightTextColor = "#fff";
    var niceButtonBkColor = "#456DA7";
    var niceButtonFillColor = "#fff";
    var imgFramePaddingBorderWidthEmNumber = 0.15;
    var dLayerSpanBackgroundColor = "#ffd";
    var textShadow = '1px 1px 1px #eee';
    var darkTextShadow = '1px 1px 1px #333';
    var textShadowSelRadioCheck = '1px 2px 2px #ddd';
    var borderSeparatorLineSpecs = "1px solid";
    var textInputBackgroundColor = "#fff";
    var mapZoomInBorderRadius = "2px 2px 0 0";
    var mapZoomOutBorderRadius = "0 0 2px 2px";
    var mapControlLineHeightEmNumber = 0.4;
    var mapControlTextColor = "#00618b";
    var mapScaleLineBkColor = "rgba(255,255,255,0.7)";
    var mapScaleLineBorderRadiusPxNumber = 4;
    var mapScaleLinePaddingPxNumber = 2;
    var mapScaleLineBorder = "1px solid " + mapControlTextColor;
    var mapScaleLineFontSizeEmNumber = 0.9;
    var mapScaleLineMarginPxNumber = 1;
    var mapScaleLineFontColor = mapControlTextColor;
    var mapSubLegendBkColor = "#e4f4ff";
    var tfLogoBorderRadius = "10%";
    var tfLogoWidth = "8em";
    var tfLogoHeight = "8em";
    var tfLogoOpacity = "0.8";
    var tfLogoBkColor = "rgba(255,255,255,0.3)";
    var tfLogoBorder = "1px solid rgba(128,128,128,0.3)";
    var mapControlFontWeight = "700";
    var overviewMapWidthPxNumber = 200;
    var overviewMapHeightPxNumber = 200;
    var overviewMapBorderWidthPxNumberNumber = 2;
    var overviewMapBoxBorder = "2px dotted rgba(255,255,255,1.0)";
    var buttonShapedLinkBkColor = niceButtonBkColor;
    var buttonShapedLinkTextColor = niceButtonFillColor;
    var buttonShapedLinkHoverBkColor = "#0869bf";
    var buttonShapedLinkHoverTextColor = "#fdfff0";
    //var mapPopupTextButtonTextColor = niceButtonBkColor;
    //var mapPopupTextButtonBkColor = "#fff";
    var mapPopupTextButtonTextColor = "#fff";
    var mapPopupTextButtonBkColor = niceButtonBkColor;
    var buttonShapedLinkTextShadow = "1px 1px 1px #333";
    var buttonShapedLinkTextShadowHover = "1px 1px 1px #999";
    var buttonShapedLinkMarginPxNumber = 2;
    var inputFormBkColor = "#fff";
    var inputFormBorderRadiusPxNumber = 6;
    //this.QuietJSDoc = function() { }
    return {
        fontFamily: fontFamily,
        markerFontFamily: fontFamily,
        inputFormBkColor: inputFormBkColor,
        inputFormBorderRadiusPxNumber: inputFormBorderRadiusPxNumber,
        mapZoomInBorderRadius: mapZoomInBorderRadius,
        mapZoomOutBorderRadius: mapZoomOutBorderRadius,
        mapPopupTextButtonTextColor:mapPopupTextButtonTextColor,
        mapPopupTextButtonBkColor:mapPopupTextButtonBkColor,
        textInputBackgroundColor: textInputBackgroundColor,
        borderSeparatorLineSpecs: borderSeparatorLineSpecs,
        textShadow: textShadow,
        darkTextShadow: darkTextShadow,
        textShadowSelRadioCheck: textShadowSelRadioCheck,
        dLayerSpanBackgroundColor: dLayerSpanBackgroundColor,
        overviewMapWidthPxNumber :overviewMapWidthPxNumber,
        overviewMapHeightPxNumber :overviewMapHeightPxNumber,
        overviewMapBorderWidthPxNumberNumber :overviewMapBorderWidthPxNumberNumber,
        overviewMapBoxBorder : overviewMapBoxBorder,
        mapButtonDimEmNumber: mapButtonDimEmNumber,
        mapButtonMarginEmNumber: 0.33,
        mapButtonSpacingEmNumber: 0.75,
        mapScaleLineBkColor: mapScaleLineBkColor,
        mapScaleLineBorderRadiusPxNumber: mapScaleLineBorderRadiusPxNumber,
        mapScaleLinePaddingPxNumber: mapScaleLinePaddingPxNumber,
        mapScaleLineBorder: mapScaleLineBorder,
        mapScaleLineFontSizeEmNumber: mapScaleLineFontSizeEmNumber,
        mapScaleLineMarginPxNumber: mapScaleLineMarginPxNumber,
        mapScaleLineFontColor: mapScaleLineFontColor,
        mapControlFontWeight: mapControlFontWeight,
        mapSubLegendBkColor: mapSubLegendBkColor,
        tfLogoBorderRadius: tfLogoBorderRadius,
        tfLogoWidth: tfLogoWidth,
        tfLogoHeight: tfLogoHeight,
        tfLogoOpacity: tfLogoOpacity,
        tfLogoBkColor: tfLogoBkColor,
        tfLogoBorder: tfLogoBorder,
        mapControlLineHeightEmNumber: mapControlLineHeightEmNumber,
        mapControlTextColor: mapControlTextColor,
        maxHeightLogoImageEmNumber: 4.5,
        maxWidthLogoImageEmNumber: 12,
        imageThumbWidthEmNumber: 8,
        infoPopupContentFontSizeEmNumber: 1.2,
        locationPopupContentFontSizeEmNumber: 1,
        mapControlFontSizeEmNumber: mapControlFontSizeEmNumber,
        popupContentFontSizeEmNumber: popupContentFontSizeEmNumber,
        topFontSizePXNumber: 12,
        markerFontSizePXNumber: 14,
        buttonBorderRadiusPxNumber: 3,
        buttonMarginTopBottomPxNumber: 2,
        buttonMarginLeftRightPxNumber: 6,
        textButtonPaddingTopBottomPxNumber: 2,
        textButtonPaddingLeftRightPxNumber: 5,
        paddingPxNumber: 4,
        popupContainerPaddingPxNumber: 8,
        popupCaptionBorderRadiusPXNumber: 5,
        popupContentPaddingPXNumber: 5,
        popupContentBorderRadiusPXNumber: 10,
        svgButtonBorderRadiusPercentNumber: 20,
        lightTextColor: niceLightTextColor,
        darkTextColor: niceDarkColor,
        disabledTextColor: "#a4a4a4",
        borderLightColor: "#BFBFBF",
        borderDarkColor: niceDarkColor,
        defaultButtonBk: niceButtonBkColor,
        defaultButtonFill: niceButtonFillColor,
        buttonShapedLinkBkColor: buttonShapedLinkBkColor,
        buttonShapedLinkTextColor: buttonShapedLinkTextColor,
        buttonShapedLinkTextShadow: buttonShapedLinkTextShadow,
        buttonShapedLinkHoverBkColor: buttonShapedLinkHoverBkColor,
        buttonShapedLinkHoverTextColor: buttonShapedLinkHoverTextColor,
        buttonShapedLinkTextShadowHover: buttonShapedLinkTextShadowHover,
        buttonShapedLinkMarginPxNumber: buttonShapedLinkMarginPxNumber,
        mapControlBkColor: "rgba(244,244,254,.75)",
        mapControlHoverBkColor: "rgba(244,244,254,0.9)",
        mapControlButtonHoverBkColor: "rgba(255,255,255,1)",
        mapControlButtonBkColor: "rgba(244,244,254,.6)",
        popupContentBkColor: "rgb(219, 232, 241)",
        containerDarkBackgroundColor: niceDarkColor,
        containerDarkSelBackgroundColor: "rgb(25,182,0)",
        hcfLayoutContainerBkColor: niceDarkColor,
        popupCaptionBackgroundColor: "#eeeeee",
        separatorBackgroundColor: "#FF8800",
        buttonLightBkg: niceButtonBkColor,
        buttonLightFill: niceButtonFillColor,
        buttonDarkBkg: niceButtonFillColor,
        buttonDarkFill: niceButtonBkColor,
        lightTextDivBtnColor: niceLightTextColor,
        darkTextDivBtnColor: niceDarkColor,
        imgFramePaddingBorderWidthEmNumber: imgFramePaddingBorderWidthEmNumber,
        imgFrameBorder: imgFramePaddingBorderWidthEmNumber + "em solid " + niceDarkColor,
        verticalSeparatorWidthEMNumber: 0.85,
        horizontalSeparatorHeightEMNumber: 0.85
    };
};
/**
 * @public
 * @function
 * @summary - Returns the default TerraFly style specifications, used in the creation of the [Styles]{@link tf.styles.Styles} {@link singleton}
 * @returns {tf.types.APIStyleSpecs} - the default specifications
*/
tf.styles.GetGraphiteAPIStyleSpecifications = function () {
    var APIStyleSpecs = {
        separatorBackgroundColor: "rgba(0,107,133, 0.8)",
        inputFormBkColor: "rgba(128,128,128,0.5)",
        mapPopupTextButtonTextColor: "rgba(255,255,255,1)",
        mapPopupTextButtonBkColor: "rgba(0,0,0,0.7)",
        mapSubLegendBkColor: "rgba(0,0,0,0.5)",
        buttonShapedLinkBkColor: "rgba(0,0,0,0.5)",
        buttonShapedLinkTextColor: "rgba(255,255,255,1)",
        buttonShapedLinkHoverBkColor: "#fff",
        buttonShapedLinkMarginPxNumber: 1,
        buttonShapedLinkHoverTextColor: "rgba(0,0,0,1)",
        topFontSizePXNumber: 12,
        darkTextColor: "#eef",
        paddingPxNumber: "6",
        popupCaptionBorderRadiusPXNumber: 16,
        popupContentBkColor: "rgba(192, 192, 192, 0.6)",
        popupCaptionBackgroundColor: "rgba(210, 210, 210, 0.6)",
        mapControlButtonBkColor: "rgba(192, 192, 192, 0.7)",
        mapControlButtonHoverBkColor: "rgba(244, 244, 244, 0.7)",
        buttonDarkFill: "rgba(0, 0, 0, 0.7)",
        dLayerSpanBackgroundColor: "rgba(32, 32, 32, 1)",
        textShadow: '1px 1px 1px #000',
        darkTextShadow: '1px 1px 1px #fff',
        textShadowSelRadioCheck: '1px 1px 1px #333',
        borderSeparatorLineSpecs: "1px solid",
        textInputBackgroundColor: "#000",
        mapZoomInBorderRadius: "5px 5px 0 0",
        mapZoomOutBorderRadius: "0 0 5px 5px",
        mapControlFontWeight: "700",
        mapScaleLineBkColor: "rgba(255,255,255,0.5)",
        mapScaleLineBorderRadiusPxNumber: 4,
        mapScaleLinePaddingPxNumber: 2,
        mapScaleLineBorder: "1px solid #07375f",
        mapScaleLineFontSizeEmNumber: 0.9,
        mapScaleLineMarginPxNumber: 4,
        mapScaleLineFontColor: "rgba(0, 0, 0, 0.7)",
        tfLogoBorderRadius: "10%",
        tfLogoWidth: "8em",
        tfLogoHeight: "8em",
        tfLogoOpacity: 0.8,
        tfLogoBkColor: "rgba(255,255,255,0.3)",
        tfLogoBorder: "1px solid rgba(128,128,128,0.3)",
        mapControlLineHeightEmNumber: 0,
        mapControlTextColor: "rgba(0, 0, 0, 1)",
        overviewMapWidthPxNumber: 300,
        overviewMapHeightPxNumber: 200,
        overviewMapBorderWidthPxNumberNumber: 1,
        overviewMapBoxBorder: "2px dotted red"
    };
    return tf.js.ShallowMerge(tf.styles.GetDefaultAPIStyleSpecifications(), APIStyleSpecs);
};
/**
 * @public
 * @class
 * @summary - The {@link singleton} instance of this class, obtainable by calling {@link tf.GetStyles}().[GetSubStyles]{@link tf.styles.Styles#GetSubStyles}(),
 * includes the pre-defined [CSS Style Specifications]{@link tf.types.CSSStyleSpecs} used by the API
 * @param {tf.styles.Styles} styles - the {@link singleton} [Styles]{@link tf.styles.Styles} instance
 * @param {tf.types.APIStyleSpecs} alternativeSpecs - if defined, overrides the default API style specifications
*/
tf.styles.SubStyles = function (styles, alternativeSpecs) {
    var theThis;
    var mapButtonDimEmNumber, mapButtonMarginEmNumber, mapButtonSpacingEmNumber, topLeftButtonEmNumber, topRightButtonEmNumber;
    var maxHeightLogoImageEmNumber, maxWidthLogoImageEmNumber, borderSeparatorLightSpecs, borderSeparatorDarkSpecs, borderSeparatorButtonBkSpecs;
    var textButtonPaddingTopBottomPxNumber, textButtonPaddingLeftRightPxNumber;
    var buttonBorderRadiusPxNumber, buttonMarginTopBottomPxNumber, buttonMarginLeftRightPxNumber;
    var svgButtonBorderRadiusPercentNumber;
    var verticalSeparatorWidthEMNumber, horizontalSeparatorHeightEMNumber;
    var paddingPxNumber, popupCaptionBorderRadiusPXNumber, popupContentPaddingPXNumber, popupContentBorderRadiusPXNumber, dLayerSpanBackgroundColor;
    var textShadow, darkTextShadow, textShadowSelRadioCheck, borderSeparatorLineSpecs, textInputBackgroundColor, mapZoomInBorderRadius, mapZoomOutBorderRadius;
    var mapScaleLineBkColor;
    var mapScaleLineBorderRadiusPxNumber;
    var mapScaleLinePaddingPxNumber;
    var mapScaleLineBorder;
    var mapScaleLineFontSizeEmNumber;
    var mapScaleLineMarginPxNumber;
    var mapScaleLineFontColor, mapControlFontWeight;
    var tfLogoBorderRadius;
    var tfLogoWidth;
    var tfLogoHeight;
    var tfLogoOpacity;
    var tfLogoBkColor;
    var tfLogoBorder;
    var mapControlLineHeightEmNumber;
    var mapControlTextColor;
    var overviewMapWidthPxNumber;
    var overviewMapHeightPxNumber;
    var overviewMapBorderWidthPxNumberNumber;
    var overviewMapBoxBorder;
    var mapPopupTextButtonTextColor, mapPopupTextButtonBkColor;
    var buttonShapedLinkTextShadow, buttonShapedLinkTextShadowHover;
    var buttonShapedLinkMarginPxNumber;
    var inputFormBkColor;
    var inputFormBorderRadiusPxNumber;
    /*this.popupContainerPaddingPxNumber=null;
    this.lightTextColor=null; this.darkTextColor=null; this.disabledTextColor=null; this.borderLightColor=null; this.defaultButtonBk=null; this.defaultButtonFill=null; 
    this.buttonShapedLinkBkColor=null; this.buttonShapedLinkTextColor=null;
    this.buttonShapedLinkHoverBkColor=null; this.buttonShapedLinkHoverTextColor=null;
    this.topFontSizePXNumber=null; this.markerFontSizePXNumber=null;
    this.textButtonHeightDelta=null;
    this.imageThumbWidthEmNumber=null; this.imageThumbSquareHeightEmNumber=null; this.imageThumbRectHeightEmNumber=null;
    this.mapButtonDimEmNumber=null; this.mapButtonMarginEmNumber=null;
    this.mapLocationButtonTopEmNumber=null;
    this.mapControlBkColor=null; this.mapControlHoverBkColor=null; this.mapControlButtonHoverBkColor=null; this.mapControlButtonBkColor=null;
    this.containerDarkBackgroundColor=null; this.containerDarkSelBackgroundColor=null; this.hcfLayoutContainerBkColor=null; this.popupCaptionBackgroundColor=null; this.separatorBackgroundColor=null;
    this.buttonLightBkg=null; this.buttonLightFill=null; this.buttonDarkBkg=null; this.buttonDarkFill=null; this.lightTextDivBtnColor=null; this.darkTextDivBtnColor=null;
    this.imgFramePaddingBorderWidthEmNumber=null; this.imgFrameBorder=null; this.mapSubLegendBkColor = null*/
    /**
     * @public
     * @function
     * @summary - Retrieves the [Styles]{@link tf.styles.Styles} {@link singleton}
     * @returns {tf.styles.Styles} - | {@link tf.styles.Styles} the {@link singleton}
    */
    this.GetStyles = function () { return styles; }
    /**
     * @public
     * @function
     * @summary - Creates HTML Shadow [Style Specifications]{@link tf.types.CSSStyleSpecs} that can be applied
     * with the function [ApplyStyleProperties]{@link tf.style.Styles#ApplyStyleProperties} or used as a building block of
     * another style specification
     * @param {number} offXPxNumber - horizontal offset, in pixels
     * @param {number} offYPxNumber - vertical offset, in pixels
     * @param {number} blurPxNumber - blur radius, in pixels
     * @param {colorWithOptionalAlpha} shadowColorStr - color
     * @returns {tf.types.CSSStyleSpecs} - | {@link tf.types.CSSStyleSpecs} the specifications
    */
    this.CreateShadowStyle = function (offXPxNumber, offYPxNumber, blurPxNumber, shadowColorStr) { return createShadowStyle(offXPxNumber, offYPxNumber, blurPxNumber, shadowColorStr); }
    /**
     * @public
     * @function
     * @summary - Creates custom [Style Specifications]{@link tf.types.CSSStyleSpecs} used by [SVG Glyph Button]{@link tf.ui.SvgGlyphBtn} instances to customize 
     * the <b>glyph</b> and <b>background</b> colors displayed in normal and hover states
     * @param {color} glyphColor - normal glyph color
     * @param {color} backgroundColor - normal background color
     * @param {color} glyphColorHover - glyph color on hover
     * @param {color} backgroundColorHover - background color on hover
     * @returns {tf.types.CSSStyleAndHoverSpecifications} - | {@link tf.types.CSSStyleAndHoverSpecifications} the style specifications
    */
    this.CreateSvgGlyphStyles = function (glyphColor, backgroundColor, glyphColorHover, backgroundColorHover) { return createSvgGlyphStyles(glyphColor, backgroundColor, glyphColorHover, backgroundColorHover); }
    /**
     * @public
     * @function
     * @summary - Creates custom [Style Specifications]{@link tf.types.CSSStyleSpecs} used by [Text Button]{@link tf.ui.TextBtn} instances to customize the <b>text</b> and <b>background</b> colors displayed 
     * in normal and hover states
     * @param {color} textColor - normal text color
     * @param {color} backgroundColor - normal background color
     * @param {color} textColorHover - text color on hover
     * @param {color} backgroundColorHover - background color on hover
     * @returns {tf.types.CSSStyleAndHoverSpecifications} - | {@link tf.types.CSSStyleAndHoverSpecifications} the style specifications
    */
    this.CreateTextDivBtnStyles = function (textColor, backgroundColor, textColorHover, backgroundColorHover) { return createTextDivBtnStyles(textColor, backgroundColor, textColorHover, backgroundColorHover); }
    this.mapControlFontSizeEmNumber = null;
    this.popupContentFontSizeEmNumber = null;
    this.popupContentBkColor = null;
    this.addressBarFontSize = null;
    this.infoPopupContentFontSizeEmNumber = null;
    this.locationPopupContentFontSizeEmNumber = null;
    /*
    this.fontFaceStyleContentStr=null;
    this.popupCaptionBorderRadiusStyle=null; this.popupContentPaddingStyle=null; this.popupContentBorderRadiusStyle=null; this.textShadowStyle=null; this.darkTextShadowStyle=null;
    this.seShadowStyle=null; this.horShadowStyle=null;
    this.textShadowSelRadioCheckStyle=null; this.defaultWidthHeightRadioCheckStyle=null; this.defaultRightPaddingRadioCheckStyle=null;
    this.paddingStyle=null; this.paddingLeftRightStyle=null; this.separatorBkColorStyle=null; this.rightSideContainerBkColorStyle=null; this.hcfLayoutContainerBkColorStyle =null;
    this.popupCaptionBackgroundColorStyle=null; this.divIconCursorStyle=null; this.noBorderMarginPaddingStyle=null; this.verticalSeparatorWidthStyle=null; this.horizontalSeparatorHeightStyle=null;
    this.darkTextColorStyle=null; this.lightTextColorStyle=null; this.disabledTextColorStyle=null; this.defaultButtonBkStyle=null; this.buttonBorderRadiusStyle=null;
    this.appContainerStyle=null; this.mapContainerStyle=null; this.mapSubContainerStyle=null; this.popupMapToolBarBaseStyle=null; this.mapToolBarContainerStyle=null;
    this.topSeparatorLightStyle=null; this.bottomBorderSeparatorLightStyle=null;
    this.bottomBorderSeparatorDarkStyle=null; this.rightBorderSeparatorLightStyle=null; this.rightBorderSeparatorDarkStyle=null;
    this.popupContainerStyle=null; this.popupContentStyle=null; this.spanStyle=null; this.spanCursorPointerStyle=null;
    this.appContainerBaseStyle=null; this.hcfLayoutStyle=null; this.hcfLayoutHeaderStyle=null; this.hcfLayoutFooterStyle=null; this.hcfLayoutContentStyle=null;
    this.buttonShapedLinkStyle=null; this.buttonShapedLinkHoverStyle=null; this.dLayerInfoStyle=null; this.dLayerInfoImgStyle=null; this.dLayerInfoLinkStyle=null; this.dLayerInfoLinkHoverStyle=null; this.dLayerInfoSpanStyle=null;
    this.inputTextPlaceholderStyle=null; this.inputTextStyle=null; this.radioCheckStyle=null; this.radioCheckWithDimStyle=null; this.radioCheckLabelStyle=null; this.radioCheckRemoveDefaultStyle=null; this.radioCheckLabelCheckedStyle=null;
    this.radioLabelStyle=null; this.radioRadioStyle=null; this.radioRadioAndLabelCheckedStyle=null; this.radioRadioAndLabelStyleBefore=null; this.radioRadioAndLabelSelStyleBefore=null;
    this.checkLabelStyle=null; this.checkCheckStyle=null; this.checkCheckAndLabelCheckedStyle=null; this.checkCheckAndLabelStyleBefore=null; this.checkCheckAndLabelSelStyleBefore=null;
    this.mapMeasureOverlayDivStyle=null; this.imgStyleBase=null; this.logoMaxWidthHeightStyle=null; this.imgLogoStyle=null;
    this.imgFullWidthHeightStyle=null; this.imgDefaultFrameStyle=null; this.divWithImgBkkSizeStyle=null;
    this.divWithImgBkStyle=null; this.imgForInfoWindowStyle=null; this.buttonStyleBase=null; this.svgGlyphStyleBase=null; this.svgGlyphLightNoHoverStyle=null; this.svgGlyphLightStyle=null; this.svgGlyphLightStyleHover=null;
    this.svgGlyphDarkNoHoverStyle=null; this.svgGlyphDarkStyle=null; this.svgGlyphDarkStyleHover=null; this.divSvgGlyphStyle=null;
    this.buttonDivMarginTopStyle=null; this.buttonDivMarginBotStyle=null; this.buttonDivTopBotMarginsStyle=null; this.buttonDivMarginLeftStyle=null; this.buttonDivMarginRightStyle=null; this.buttonDivLeftRightMarginsStyle=null;
    this.buttonDivAllMarginsStyle=null; this.divSvgGlyphBtnStyle=null; this.divSvgGlyphIconStyle=null;
    this.textButtonStyleBase=null; this.textDivBtnLightStyle=null; this.textDivBtnLightStyleHover=null; this.textDivBtnDarkStyle=null; this.textDivBtnDarkStyleHover=null;
    this.paddedBlockDivStyle=null; this.paddedInlineBlockDivStyle=null; this.paddedBlockDivWithBorderSeparatorStyle=null; this.paddedInlineBlockDivWithBorderSeparatorStyle=null;
    this.unPaddedBlockDivStyle=null; this.unPaddedInlineBlockDivStyle=null; this.leftSideContainerStyle=null; this.floatLeftSideContainerStyle=null; this.leftRightSideSeparatorStyle=null;
    this.rightSideContainerStyle=null; this.bottomContainerStyle=null; this.topBottomSeparatorStyle=null;
    this.listContentStyle=null; this.inputFormStyle=null; this.mapButtonLeftMarginStyle=null; this.mapButtonRightMarginStyle=null;
    this.mapAddressButtonStyle=null; this.mapZoomStyle=null; this.mapLayersButtonStyle=null; this.mapTypeButtonStyle=null; this.mapMeasureButtonStyle=null;
    this.mapDownloadButtonStyle=null; this.mapSourceButtonStyle=null; this.mapFullScreenButtonStyle=null;
    this.mapViewPortUnSelectableStyle=null; this.mapZoomInBorderRadiusStyle=null; this.mapZoomOutBorderRadiusStyle=null; this.mapZoomSliderStyle=null;
    this.transitionOpacityToVisibleStyle=null; this.transitionOpacityToInvisibleStyle=null;
    this.mapLocationButtonStyle=null; this.mapUserLocationButtonStyle=null; this.mapRotateStyle=null; this.mapRotateHiddenStyle=null;
    this.popupContentBkColorStyle=null; this.mapCompassStyle=null; this.mapButtonTextSpanStyle=null; this.mapScaleLineStyle=null; this.mapScaleLineInnerStyle=null;
    this.mapControlBkColorStyle=null; this.mapControlHoverBkColorStyle=null; this.mapControlButtonHoverBkColorStyle=null; this.mapControlButtonBkColorStyle=null;
    this.mapControlStyle=null; this.mapControlHoverStyle=null;
    this.mapControlButtonLineHeightStyle=null; this.mapControlButtonTextColorStyle=null; this.mapControlButtonWidthHeightStyle=null;
    this.mapControlButtonStyle=null; this.mapControlButtonFocusHoverStyle=null; this.mapControlButtonMozFocusInnerStyle=null;
    this.mapOverviewMapStyle=null; this.mapOverviewMapUnCollapsibleStyle=null; this.mapOverviewMapButtonStyle=null; this.mapOverviewMapMapStyle=null;
    this.mapOverviewMapButtonNotCollapsedStyle=null; this.mapOverviewMapButtonCollapsedStyle=null; this.mapOverviewMapNotCollapsedStyle=null;
    this.mapOverviewMapBoxStyle=null;
    this.mapTFLogoControlStyle=null; this.popupCaptionStyle=null; this.bodyStyle=null;*/
    /**
     * specifies 1px margin
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.margin1PXStyle = null;
    /**
     * specifies opacity 0 and visibility hidden, used in transitions
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.opacityVisibilityHideStyle = null;
    /**
     * specifies opacity 1 and visibility show, used in transitions
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.opacityVisibilityShowStyle = null;
    /**
     * specifies the default visibility transition
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.defaultOpacityVisibilityTransitionStyle = null;
    /**
     * specifies a visibility transition faster than the default
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.fasterOpacityVisibilityTransitionStyle = null;
    /**
     * specifies float left used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.floatLeftStyle = null;
    /**
     * specifies float right used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.floatRightStyle = null;
    /**
     * specifies float none used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.floatNoneStyle = null;
    /**
     * specifies the top container font size, inherited by sub containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.topFontSizeStyle = null;
    /**
     * specifies the default fount style, inherited by sub containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.defaultFontStyle = null;
    /**
     * specifies font size inheritance
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.fontSizeInheritStyle = null;
    /**
     * specifies radio button checked
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.defaultRadioCheckedStyle = null;
    /**
     * specifies radio button unchecked
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.defaultRadioUnCheckedStyle = null;
    /**
     * specifies check box checked
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.defaultCheckCheckedStyle = null;
    /**
     * specifies check box unchecked
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.defaultCheckUnCheckedStyle = null;
    /**
     * specifies default font size and style, inherited by sub containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.defaultFontAndTopSizeStyle = null;
    /**
     * specifies inheritance of font size
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.defaultFontSizeInheritStyle = null;
    /**
     * specifies visibility hidden, used in transitions
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.visibilityHiddenStyle = null;
    /**
     * specifies visibility visible, used in transitions
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.visibilityVisibleStyle = null;
    /**
     * specifies opacity 0 (fully transparent), used in transitions
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.opacityZeroStyle = null;
    /**
     * specifies opacity 1 (fully opaque), used in transitions
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.opacityOneStyle = null;
    /**
     * specifies no border, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.noBorderStyle = null;
    /**
     * specifies no border spacing, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.noBorderSpacingStyle = null;
    /**
     * specifies no margin, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.noMarginStyle = null;
    /**
     * specifies no padding, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.noPaddingStyle = null;
    /**
     * specifies position absolute, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.positionAbsoluteStyle = null;
    /**
     * specifies position relative, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.positionRelativeStyle = null;
    /**
     * specifies transparent background, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.transparentBackgroundStyle = null;
    /**
     * specifies the light background used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.whiteBackgroundStyle = null;
    /**
     * specifies the background used in text input boxes
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.textInputBackgroundStyle = null;
    /**
     * specifies no pointer events, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.noPointerEventsStyle = null;
    /**
     * specifies all pointer events, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.allPointerEventsStyle = null;
    /**
     * specifies a mouse pointer suitable for clickable interface items (usually a hand)
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.cursorPointerStyle = null;
    /**
     * specifies the default mouse pointer (usually the regular arrow pointer)
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.cursorDefaultStyle = null;
    /**
     * specifies that an element's transform will frequently be changed
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.willChangeTransformStyle = null;
    /**
     * specifies no outline, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.noOutlineStyle = null;
    /**
     * specifies 100% width
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.fullWidthStyle = null;
    /**
     * specifies 100% height
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.fullHeightStyle = null;
    /**
     * specifies inherited width
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.inheritWidthStyle = null;
    /**
     * specifies inherited height
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.inheritHeightStyle = null;
    /**
     * specifies auto width
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.autoWidthStyle = null;
    /**
     * specifies auto height
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.autoHeightStyle = null;
    /**
     * specifies auto width and height
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.autoWidthAutoHeightStyle = null;
    /**
     * specifies 100% width and height
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.fullWidthHeightStyle = null;
    /**
     * specifies 100% width and auto height
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.fullWidthAutoHeightStyle = null;
    /**
     * specifies auto width and 100% height
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.autoWidthFullHeightStyle = null;
    /**
     * specifies inherited width and height
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.inheritWidthHeightStyle = null;
    /**
     * specifies inline-block display, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.inlineBlockStyle = null;
    /**
     * specifies block display, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.blockStyle = null;
    /**
     * specifies none display (hides the element), used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.noneDisplayStyle = null;
    /**
     * specifies overflow hidden, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.overflowHiddenStyle = null;
    /**
     * specifies overflow auto, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.overflowAutoStyle = null;
    /**
     * specifies overflow scroll in the vertical direction, used on some containers like vertical lists and tables
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.overflowYScrollStyle = null;
    /**
     * specifies middle vertical align, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.middleVerticalAlignStyle = null;
    /**
     * specifies inherit vertical align, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.inheritVerticalAlignStyle = null;
    /**
     * specifies center text alignment, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.textAlignCenterStyle = null;
    /**
     * specifies left text alignment, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.textAlignLeftStyle = null;
    /**
     * specifies no border radius, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.noBorderRadiusStyle = null;
    /**
     * specifies no border, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.borderNoneStyle = null;
    /**
     * specifies no user selection allowed, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.noSelectStyle = null;
    /**
     * specifies an image is not draggable, used on some images
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.notDraggableStyle = null;
    /**
     * specifies no text decoration, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.noTextDecorationStyle = null;
    /**
     * specifies subcontainer positioning to the left edge of the parent container, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.snapLeftStyle = null;
    /**
     * specifies subcontainer positioning to the right edge of the parent container, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.snapRightStyle = null;
    /**
     * specifies subcontainer positioning to the top edge of the parent container, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.snapTopStyle = null;
    /**
     * specifies subcontainer positioning to the bottom edge of the parent container, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.snapBotStyle = null;
    /**
     * specifies subcontainer positioning to the horizontal center of the parent container, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.snapCenterHorStyle = null;
    /**
     * specifies subcontainer positioning to the vertical center of the parent container, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.snapCenterVerStyle = null;
    /**
     * specifies subcontainer positioning to both the horizontal and vertical center of the parent container, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.snapCenterStyle = null;
    /**
     * specifies subcontainer positioning to the left top corner of the parent container, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.snapLeftTopStyle = null;
    /**
     * specifies subcontainer positioning to the right top corner of the parent container, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.snapRightTopStyle = null;
    /**
     * specifies subcontainer positioning to the left bottom corner of the parent container, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.snapLeftBotStyle = null;
    /**
     * specifies subcontainer positioning to the right top corner of the parent container, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.snapRightBotStyle = null;
    /**
     * specifies popup caption border radius, used with popups
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.popupCaptionBorderRadiusStyle = null;
    /**
     * specifies popup content padding border radius, used with popups
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.popupContentPaddingStyle = null;
    /**
     * specifies popup content border radius, used with popups
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.popupContentBorderRadiusStyle = null;
    /**
     * specifies the default text shadow
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.textShadowStyle = null;
    /**
     * specifies a text shadow darker than the default
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.darkTextShadowStyle = null;
    /**
     * specifies a South East shadow, used by some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.seShadowStyle = null;
    /**
     * specifies a horizontal (East) shadow, used by some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.horShadowStyle = null;
    /**
     * specifies the text shadow used by selected radio buttons and check boxes
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.textShadowSelRadioCheckStyle = null;
    /**
     * specifies the dimensions used by radio button and check box images
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.defaultWidthHeightRadioCheckStyle = null;
    /**
     * specifies the right padding used by radio button and check box images to separate the label from the button/box
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.defaultRightPaddingRadioCheckStyle = null;
    /**
     * specifies padding used by padded containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.paddingStyle = null;
    /**
     * specifies padding used by padded containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.paddingLeftRightStyle = null;
    /**
     * specifies background color for containers used as layout separators
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.separatorBkColorStyle = null;
    /**
     * specifies background color for containers used on the right side of layouts
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.rightSideContainerBkColorStyle = null;
    /**
     * specifies background color for head content footer layout container
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.hcfLayoutContainerBkColorStyle = null;
    /**
     * specifies background color for popup captions
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.popupCaptionBackgroundColorStyle = null;
    /**
     * specifies cursor for non-clickable icons
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.divIconCursorStyle = null;
    /**
     * specifies no border, margin, padding, used on unpadded containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.noBorderMarginPaddingStyle = null;
    /**
     * specifies width for containers used as vertical layout separators
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.verticalSeparatorWidthStyle = null;
    /**
     * specifies height for containers used as horizontal layout separators
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.horizontalSeparatorHeightStyle = null;
    /**
     * specifies text color used in the API's dark style settings
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.darkTextColorStyle = null;
    /**
     * specifies text color used in the API's light style settings
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.lightTextColorStyle = null;
    /**
     * specifies disabled text color
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.disabledTextColorStyle = null;
    /**
     * specifies default button background color
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.defaultButtonBkStyle = null;
    /**
     * specifies default button background color
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.buttonBorderRadiusStyle = null;
    /**
     * specifies application containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.appContainerStyle = null;
    /**
     * specifies map containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.mapContainerStyle = null;
    /**
     * specifies map sub containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.mapSubContainerStyle = null;
    /**
     * specifies map popup and toolbar containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.popupMapToolBarBaseStyle = null;
    /**
     * specifies map toolbar containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.mapToolBarContainerStyle = null;
    /**
     * specifies top separators used in the API's light style settings
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.topSeparatorLightStyle = null;
    /**
     * specifies bottom separators used in the API's light style settings
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.bottomBorderSeparatorLightStyle = null;
    /**
     * specifies bottom separators used in the API's dark style settings
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.bottomBorderSeparatorDarkStyle = null;
    /**
     * specifies right separators used in the API's light style settings
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.rightBorderSeparatorLightStyle = null;
    /**
     * specifies right separators used in the API's dark style settings
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.rightBorderSeparatorDarkStyle = null;
    /**
     * specifies left separators used in the API's light style settings
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.leftBorderSeparatorLightStyle = null;
    /**
     * specifies left separators used in the API's dark style settings
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.leftBorderSeparatorDarkStyle = null;
    /**
     * specifies popup containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.popupContainerStyle = null;
    /**
     * specifies popup content
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.popupContentStyle = null;
    /**
     * specifies spans
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.spanStyle = null;
    /**
     * specifies clickable spans with a pointer cursor
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.spanCursorPointerStyle = null;
    /**
     * specifies application containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.appContainerBaseStyle = null;
    /**
     * specifies header content footer layout containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.hcfLayoutStyle = null;
    /**
     * specifies header containers in header content footer layouts
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.hcfLayoutHeaderStyle = null;
    /**
     * specifies footer containers in header content footer layouts
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.hcfLayoutFooterStyle = null;
    /**
     * specifies content containers in header content footer layouts
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.hcfLayoutContentStyle = null;
    /**
     * specifies button shaped links
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.buttonShapedLinkStyle = null;
    /**
     * specifies button shaped links in hover state
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.buttonShapedLinkHoverStyle = null;
    /**
     * specifies dlayer info popup content
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.dLayerInfoStyle = null;
    /**
     * specifies dlayer info popup image content
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.dLayerInfoImgStyle = null;
    /**
     * specifies dlayer info popup link content
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.dLayerInfoLinkStyle = null;
    /**
     * specifies dlayer info popup link content in hover state
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.dLayerInfoLinkHoverStyle = null;
    /**
     * specifies dlayer info popup span content
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.dLayerInfoSpanStyle = null;
    /**
     * specifies text input placeholders
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.inputTextPlaceholderStyle = null;
    /**
     * specifies the background color for input forms
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.inputFormBkStyle = null;
    /**
     * specifies text input text
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.inputTextStyle = null;
    /**
     * specifies custom radio button part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.radioCheckStyle = null;
    /**
     * specifies custom radio button part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.radioCheckWithDimStyle = null;
    /**
     * specifies custom radio button part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.radioCheckLabelStyle = null;
    /**
     * specifies custom radio button part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.radioCheckRemoveDefaultStyle = null;
    /**
     * specifies custom radio button part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.radioCheckLabelCheckedStyle = null;
    /**
     * specifies custom radio button part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.radioLabelStyle = null;
    /**
     * specifies custom radio button part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.radioRadioStyle = null;
    /**
     * specifies custom radio button part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.radioRadioAndLabelCheckedStyle = null;
    /**
     * specifies custom radio button part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.radioRadioAndLabelStyleBefore = null;
    /**
     * specifies custom radio button part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.radioRadioAndLabelSelStyleBefore = null;
    /**
     * specifies custom check box part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.checkLabelStyle = null;
    /**
     * specifies custom check box part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.checkCheckStyle = null;
    /**
     * specifies custom check box part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.checkCheckAndLabelCheckedStyle = null;
    /**
     * specifies custom check box part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.checkCheckAndLabelStyleBefore = null;
    /**
     * specifies custom check box part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.checkCheckAndLabelSelStyleBefore = null;
    this.mapMeasureOverlayDivStyle = null;
    this.imgStyleBase = null;
    this.logoMaxWidthHeightStyle = null;
    this.imgLogoStyle = null;
    this.imgFullWidthHeightStyle = null;
    this.imgDefaultFrameStyle = null;
    this.divWithImgBkkSizeStyle = null;
    this.divWithImgBkStyle = null;
    this.imgForInfoWindowStyle = null;
    this.buttonStyleBase = null;
    this.svgGlyphStyleBase = null;
    this.svgGlyphLightNoHoverStyle = null;
    this.svgGlyphLightStyle = null;
    this.svgGlyphLightStyleHover = null;
    this.svgGlyphDarkNoHoverStyle = null;
    this.mapSvgGlyphInButtonStyle = null;
    this.mapSvgGlyphInPopupStyle = null;
    this.mapSvgGlyphInPopupHoverStyle = null;
    this.svgGlyphDarkStyle = null;
    this.svgGlyphDarkStyleHover = null;
    this.divSvgGlyphStyle = null;
    this.buttonDivMarginTopStyle = null;
    this.buttonDivMarginBotStyle = null;
    this.buttonDivTopBotMarginsStyle = null;
    this.buttonDivMarginLeftStyle = null;
    this.buttonDivMarginRightStyle = null;
    this.buttonDivLeftRightMarginsStyle = null;
    this.buttonDivAllMarginsStyle = null;
    this.divSvgGlyphBtnStyle = null;
    this.divSvgGlyphIconStyle = null;
    this.textButtonStyleBase = null;
    this.textDivBtnLightStyle = null;
    this.textDivBtnLightStyleHover = null;
    this.textDivBtnDarkStyle = null;
    this.textDivBtnDarkStyleHover = null;
    this.paddedBlockDivStyle = null;
    this.paddedInlineBlockDivStyle = null;
    this.paddedBlockDivWithBorderSeparatorStyle = null;
    this.paddedInlineBlockDivWithBorderSeparatorStyle = null;
    this.unPaddedBlockDivStyle = null;
    this.unPaddedInlineBlockDivStyle = null;
    this.leftSideContainerStyle = null;
    this.floatLeftSideContainerStyle = null;
    this.leftRightSideSeparatorStyle = null;
    this.rightSideContainerStyle = null;
    this.bottomContainerStyle = null;
    this.topBottomSeparatorStyle = null;
    this.listContentStyle = null;
    this.inputFormStyle = null;
    this.mapButtonLeftMarginStyle = null;
    this.mapButtonRightMarginStyle = null;
    this.mapAddressButtonStyle = null;
    this.mapZoomStyle = null;
    this.mapLayersButtonStyle = null;
    this.mapTypeButtonStyle = null;
    this.mapMeasureButtonStyle = null;
    this.mapDownloadButtonStyle = null;
    this.mapSourceButtonStyle = null;
    this.mapFullScreenButtonStyle = null;
    this.mapViewPortUnSelectableStyle = null;
    this.mapZoomInBorderRadiusStyle = null;
    this.mapZoomOutBorderRadiusStyle = null;
    this.mapZoomSliderStyle = null;
    this.transitionOpacityToVisibleStyle = null;
    this.transitionOpacityToInvisibleStyle = null;
    this.mapLocationButtonStyle = null;
    this.mapUserLocationButtonStyle = null;
    this.mapRotateStyle = null;
    this.mapRotateHiddenStyle = null;
    this.popupContentBkColorStyle = null;
    this.mapCompassStyle = null;
    this.mapButtonTextSpanStyle = null;
    this.mapScaleLineStyle = null;
    this.mapScaleLineInnerStyle = null;
    this.mapControlBkColorStyle = null;
    this.mapControlHoverBkColorStyle = null;
    this.mapControlButtonHoverBkColorStyle = null;
    this.mapControlButtonBkColorStyle = null;
    this.mapControlStyle = null;
    this.mapControlHoverStyle = null;
    this.mapControlButtonLineHeightStyle = null;
    this.mapControlButtonTextColorStyle = null;
    this.mapControlButtonWidthHeightStyle = null;
    this.mapControlButtonStyle = null;
    this.mapControlButtonFocusHoverStyle = null;
    this.mapControlButtonMozFocusInnerStyle = null;
    this.mapOverviewMapStyle = null;
    //this.mapOverviewMapUnCollapsibleStyle = null;
    this.mapOverviewMapButtonStyle = null;
    this.mapOverviewMapMapStyle = null;
    this.mapOverviewMapButtonNotCollapsedStyle = null;
    this.mapOverviewMapButtonCollapsedStyle = null;
    this.mapOverviewMapNotCollapsedStyle = null;
    this.mapOverviewMapBoxStyle = null;
    this.mapTFLogoControlStyle = null;
    this.popupCaptionStyle = null;
    this.bodyStyle = null;
    function createConstantStyles() {
        var zeroDim = "0px";
        borderSeparatorLightSpecs = borderSeparatorLineSpecs + " " + theThis.borderLightColor;
        borderSeparatorDarkSpecs = borderSeparatorLineSpecs + " " + theThis.borderDarkColor;
        borderSeparatorButtonBkSpecs = borderSeparatorLineSpecs + " " + theThis.defaultButtonBk;
        theThis.margin1PXStyle = { margin: "1px" };
        theThis.defaultOpacityVisibilityTransitionStyle = { transition: "opacity .15s ease-in-out, visibility 0.15s ease-in-out, margin-top 0s 1s" };
        theThis.fasterOpacityVisibilityTransitionStyle = { transition: "opacity .10s ease-in-out, visibility .10s ease-in-out, margin-top 0s 1s" };
        theThis.floatLeftStyle = { "float": "left" };
        theThis.floatRightStyle = { "float": "right" };
        theThis.floatNoneStyle = { "float": "none" };
        theThis.defaultRadioCheckedStyle = { content: "'\\25cf'" };
        theThis.defaultRadioUnCheckedStyle = { content: "'\\25cb'" };
        theThis.defaultCheckCheckedStyle = { content: "'\\2611'" };
        theThis.defaultCheckUnCheckedStyle = { content: "'\\2610'" };
        theThis.topFontSizeStyle = { fontSize: theThis.topFontSizePXNumber + "px" };
        theThis.defaultFontStyle = { fontFamily: theThis.fontFamily };
        theThis.fontSizeInheritStyle = { fontSize: 'inherit' };
        theThis.defaultFontAndTopSizeStyle = { inherits: [theThis.defaultFontStyle, theThis.topFontSizeStyle] };
        theThis.defaultFontSizeInheritStyle = { inherits: [theThis.defaultFontStyle, theThis.fontSizeInheritStyle] };
        theThis.visibilityHiddenStyle = { visibility: 'hidden' };
        theThis.visibilityVisibleStyle = { visibility: 'visible' };
        theThis.opacityZeroStyle = { opacity: '0' };
        theThis.opacityOneStyle = { opacity: '1' };
        theThis.opacityVisibilityHideStyle = { inherits: [theThis.opacityZeroStyle, theThis.visibilityHiddenStyle], marginTop: "-10000px" };
        theThis.opacityVisibilityShowStyle = { inherits: [theThis.opacityOneStyle, theThis.visibilityVisibleStyle], marginTop: "auto" };
        theThis.noBorderStyle = { border: zeroDim };
        theThis.noBorderSpacingStyle = { borderSpacing: zeroDim };
        theThis.noMarginStyle = { margin: zeroDim };
        theThis.noPaddingStyle = { padding: zeroDim };
        theThis.positionAbsoluteStyle = { position: 'absolute' };
        theThis.positionRelativeStyle = { position: 'relative' };
        theThis.transparentBackgroundStyle = { backgroundColor: 'rgba(0,0,0,0.0)' };
        theThis.whiteBackgroundStyle = { backgroundColor: '#fff' };
        theThis.textInputBackgroundStyle = { background: textInputBackgroundColor };
        theThis.noPointerEventsStyle = { pointerEvents: 'none' };
        theThis.allPointerEventsStyle = { pointerEvents: 'all' };
        theThis.cursorPointerStyle = { cursor: 'pointer' };
        theThis.cursorDefaultStyle = { cursor: 'default' };
        theThis.willChangeTransformStyle = { willChange: "transform" };
        theThis.noOutlineStyle = { outline: 0 };
        theThis.fullWidthStyle = { width: "100%" };
        theThis.fullHeightStyle = { height: "100%" }
        theThis.inheritWidthStyle = { width: "inherit" };
        theThis.inheritHeightStyle = { height: "inherit" };
        theThis.autoWidthStyle = { width: 'auto' };
        theThis.autoHeightStyle = { height: 'auto' };
        theThis.autoWidthAutoHeightStyle = { inherits: [theThis.autoWidthStyle, theThis.autoHeightStyle] }
        theThis.fullWidthHeightStyle = { inherits: [theThis.fullWidthStyle, theThis.fullHeightStyle] }
        theThis.fullWidthAutoHeightStyle = { inherits: [theThis.fullWidthStyle, theThis.autoHeightStyle] };
        theThis.autoWidthFullHeightStyle = { inherits: [theThis.autoWidthStyle, theThis.fullHeightStyle] };
        theThis.inheritWidthHeightStyle = { inherits: [theThis.inheritWidthStyle, theThis.inheritHeightStyle] }
        theThis.inlineBlockStyle = { display: 'inline-block' };
        theThis.blockStyle = { display: 'block' };
        theThis.noneDisplayStyle = { display: 'none' };
        theThis.overflowHiddenStyle = { overflow: 'hidden' };
        theThis.overflowAutoStyle = { overflow: 'auto' };
        theThis.overflowYScrollStyle = { overflowY: 'scroll' };
        theThis.middleVerticalAlignStyle = { verticalAlign: 'middle' };
        theThis.inheritVerticalAlignStyle = { verticalAlign: 'inherit' };
        theThis.textAlignCenterStyle = { textAlign: 'center' };
        theThis.textAlignLeftStyle = { textAlign: 'left' };
        theThis.noBorderRadiusStyle = { borderRadius: "0px" };
        theThis.borderNoneStyle = { border: 'none' };
        theThis.noSelectStyle = {
            "-webkit-touch-callout": "none",
            "-webkit-user-select": "none",
            "-khtml-user-select": "none",
            "-moz-user-select": "none",
            "-ms-user-select": "none",
            "user-select": "none",
            "-webkit-tap-highlight-color": "transparent"
        };
        theThis.notDraggableStyle = { draggable: "false" };
        theThis.noTextDecorationStyle = { textDecoration: 'none' };
        theThis.snapLeftStyle = { left: zeroDim };
        theThis.snapRightStyle = { right: zeroDim };
        theThis.snapTopStyle = { top: zeroDim };
        theThis.snapBotStyle = { bottom: zeroDim };
        theThis.snapCenterHorStyle = { left: "50%", transform: "translate(-50%, 0)" };
        theThis.snapCenterVerStyle = { top: "50%", transform: "translate(0, -50%)" };
        theThis.snapCenterStyle = { left: "50%", top: "50%", transform: "translate(-50%, -50%)" };
        theThis.snapLeftTopStyle = { inherits: [theThis.snapLeftStyle, theThis.snapTopStyle] };
        theThis.snapRightTopStyle = { inherits: [theThis.snapRightStyle, theThis.snapTopStyle] };
        theThis.snapLeftBotStyle = { inherits: [theThis.snapLeftStyle, theThis.snapBotStyle] };
        theThis.snapRightBotStyle = { inherits: [theThis.snapRightStyle, theThis.snapBotStyle] };
        theThis.mapViewPortUnSelectableStyle = { inherits: [theThis.noSelectStyle] };
        theThis.mapZoomSliderStyle = { inherits: [theThis.transparentBackgroundStyle, theThis.opacityZeroStyle, theThis.visibilityHiddenStyle], top: "-100em" };
        theThis.divWithImgBkkSizeStyle = { backgroundSize: "100% 100%" };
    }
    function getMapButtonTopEmNumber(isLeft, indexTopToBottom) {
        var top = !!isLeft ? topLeftButtonEmNumber : topRightButtonEmNumber;
        return top + indexTopToBottom * (mapButtonDimEmNumber + 2 * mapButtonSpacingEmNumber);
    }
    function createMapButtonStyle(isLeft, indexTopToBottom) {
        var inheritStyle = !!isLeft ? theThis.mapButtonLeftMarginStyle : theThis.mapButtonRightMarginStyle;
        var top = getMapButtonTopEmNumber(isLeft, indexTopToBottom);
        return { inherits: [inheritStyle], top: top + "em" };
    }
    function createMapComponentsStyles() {
        theThis.mapZoomInBorderRadiusStyle = { borderRadius: mapZoomInBorderRadius };
        theThis.mapZoomOutBorderRadiusStyle = { borderRadius: mapZoomOutBorderRadius };
        var addressBarTopEmNumber = mapButtonMarginEmNumber;
        var zoomTopEmNumber = addressBarTopEmNumber + mapButtonDimEmNumber + 2 * mapButtonSpacingEmNumber;
        topRightButtonEmNumber = mapButtonMarginEmNumber;
        topLeftButtonEmNumber = zoomTopEmNumber + 2 * mapButtonDimEmNumber + 3 * mapButtonSpacingEmNumber;
        theThis.addressBarFontSize = (mapButtonDimEmNumber / 2 + 0.2) + "em";
        var mapButtonDimEmStr = mapButtonDimEmNumber + "em";
        var mapButtonMarginEmStr = mapButtonMarginEmNumber + "em";
        theThis.mapButtonLeftMarginStyle = { left: mapButtonMarginEmStr };
        theThis.mapButtonRightMarginStyle = { right: mapButtonMarginEmStr };
        theThis.mapAddressButtonStyle = { inherits: [theThis.mapButtonLeftMarginStyle], top: addressBarTopEmNumber + "em" };
        theThis.mapZoomStyle = { inherits: [theThis.mapButtonLeftMarginStyle], top: zoomTopEmNumber + "em", zIndex: 1 };
        theThis.mapLayersButtonStyle = createMapButtonStyle(true, 0);
        theThis.mapTypeButtonStyle = createMapButtonStyle(true, 1);
        theThis.mapMeasureButtonStyle = createMapButtonStyle(true, 2);
        theThis.mapDownloadButtonStyle = createMapButtonStyle(true, 3);
        theThis.mapSourceButtonStyle = createMapButtonStyle(true, 4);
        theThis.mapFullScreenButtonStyle = createMapButtonStyle(false, 0);
        theThis.mapLocationButtonStyle = createMapButtonStyle(false, 1);
        theThis.mapUserLocationButtonStyle = createMapButtonStyle(false, 2);
        theThis.mapRotateStyle = { inherits: [theThis.transitionOpacityToVisibleStyle, theThis.mapButtonRightMarginStyle], top: getMapButtonTopEmNumber(false, 3) + "em" };
        theThis.mapRotateHiddenStyle = { inherits: [theThis.opacityZeroStyle, theThis.visibilityHiddenStyle, theThis.transitionOpacityToInvisibleStyle] };
        theThis.mapLocationButtonTopEmNumber = getMapButtonTopEmNumber(false, 1);
        var mapControlFontSizeStyle = { fontSize: theThis.mapControlFontSizeEmNumber + "em" };
        var mapControlButtonFontWeightStyle = { fontWeight: mapControlFontWeight };
        theThis.mapScaleLineStyle = {
            inherits: [theThis.mapButtonLeftMarginStyle], background: mapScaleLineBkColor, borderRadius: mapScaleLineBorderRadiusPxNumber + "px", bottom: mapButtonMarginEmStr,
            padding: mapScaleLinePaddingPxNumber + "px", position: "absolute", zIndex: 1
        };
        theThis.mapScaleLineInnerStyle = {
            inherits: [mapControlButtonFontWeightStyle],
            border: mapScaleLineBorder, borderTop: "none", color: mapScaleLineFontColor,
            fontSize: mapScaleLineFontSizeEmNumber + "em", textAlign: "center", margin: mapScaleLineMarginPxNumber + "px", willChange: "contents,width"
        };
        theThis.mapControlButtonWidthHeightStyle = { width: mapButtonDimEmStr, height: mapButtonDimEmStr };
        theThis.mapOverviewMapStyle = { inherits: [theThis.mapButtonRightMarginStyle], bottom: mapButtonMarginEmStr, zIndex: 1 };
        var tfLogoTop = (2 * mapButtonMarginEmNumber + zoomTopEmNumber) + "em";
        var tfLogoLeft = (3 * mapButtonMarginEmNumber + 2 * mapButtonDimEmNumber) + "em";
        theThis.mapTFLogoControlStyle = {
            inherits: [theThis.positionAbsoluteStyle, theThis.noPointerEventsStyle],
            borderRadius: tfLogoBorderRadius, top: tfLogoTop, left: tfLogoLeft, width: tfLogoHeight, height: tfLogoWidth, opacity: tfLogoOpacity,
            backgroundColor: tfLogoBkColor,
            border: tfLogoBorder
        };
        theThis.mapCompassStyle = { inherits: [theThis.blockStyle, theThis.willChangeTransformStyle, mapControlFontSizeStyle, mapControlButtonFontWeightStyle] };
        theThis.mapButtonTextSpanStyle = { inherits: [theThis.blockStyle, mapControlFontSizeStyle, mapControlButtonFontWeightStyle, theThis.cursorPointerStyle] };
        theThis.mapControlBkColorStyle = { backgroundColor: theThis.mapControlBkColor };
        theThis.mapControlHoverBkColorStyle = { backgroundColor: theThis.mapControlBkColor };
        theThis.mapControlButtonHoverBkColorStyle = { backgroundColor: theThis.mapControlButtonHoverBkColor };
        theThis.mapControlButtonBkColorStyle = { backgroundColor: theThis.mapControlButtonBkColor };
        theThis.mapControlButtonLineHeightStyle = { lineHeight: mapControlLineHeightEmNumber + "em" };
        theThis.mapControlButtonTextColorStyle = { color: mapControlTextColor };
        theThis.mapControlStyle = { inherits: [theThis.horShadowStyle, theThis.positionAbsoluteStyle, theThis.mapControlBkColorStyle, theThis.cursorPointerStyle], borderRadius: "3px", padding: "1px" };
        theThis.mapControlHoverStyle = { inherits: [theThis.mapControlHoverBkColorStyle] };
        theThis.mapControlButtonFocusHoverStyle = { inherits: [theThis.noTextDecorationStyle, theThis.mapControlButtonHoverBkColorStyle] };
        theThis.mapControlButtonStyle = {
            inherits: [theThis.noPaddingStyle, theThis.blockStyle, theThis.noTextDecorationStyle, theThis.borderNoneStyle, theThis.textAlignCenterStyle, theThis.mapControlButtonBkColorStyle,
            theThis.mapControlButtonWidthHeightStyle, mapControlButtonFontWeightStyle, theThis.margin1PXStyle, theThis.noBorderRadiusStyle, theThis.mapControlButtonLineHeightStyle,
            theThis.mapControlButtonTextColorStyle]
        };
        theThis.mapControlButtonMozFocusInnerStyle = { inherits: [theThis.borderNoneStyle, theThis.noPaddingStyle] };
        var ovewviewMapBorderWidthPxNumber = overviewMapBorderWidthPxNumberNumber + "px";
        //theThis.mapOverviewMapUnCollapsibleStyle = { bottom: "0", left: "0", borderRadius: "0 4px 0 0" };
        //theThis.mapOverviewMapButtonStyle = { inherits: [theThis.inlineBlockStyle] };
        theThis.mapOverviewMapButtonStyle = { inherits: [theThis.mapControlButtonStyle] };
        //theThis.mapOverviewMapMapStyle = { border: "1px solid #000", height: "200px", margin: "2px", width: "200px" };
        theThis.mapOverviewMapMapStyle = { margin: ovewviewMapBorderWidthPxNumber, width: overviewMapWidthPxNumber + "px", height: overviewMapHeightPxNumber + "px" };
        theThis.mapOverviewMapButtonNotCollapsedStyle = { inherits: [theThis.positionAbsoluteStyle], bottom: ovewviewMapBorderWidthPxNumber, left: ovewviewMapBorderWidthPxNumber };
        theThis.mapOverviewMapButtonCollapsedStyle = { inherits: [theThis.noneDisplayStyle] };
        theThis.mapOverviewMapNotCollapsedStyle = { inherits: [theThis.seShadowStyle], backgroundColor: theThis.mapControlBkColor };
        theThis.mapOverviewMapBoxStyle = { border: overviewMapBoxBorder };
    }
    function createDLayerStyles() {
        theThis.dLayerInfoStyle = { inherits: [theThis.noBorderMarginPaddingStyle, theThis.inlineBlockStyle, theThis.textShadowStyle], maxWidth: "17em" };
        theThis.dLayerInfoImgStyle = { inherits: [theThis.fullWidthAutoHeightStyle, theThis.middleVerticalAlignStyle] };
        theThis.dLayerInfoLinkStyle = { inherits: [theThis.buttonShapedLinkStyle] };
        theThis.dLayerInfoLinkHoverStyle = { inherits: [theThis.buttonShapedLinkHoverStyle] };
        theThis.dLayerInfoSpanStyle = { inherits: [theThis.blockStyle, theThis.textShadowStyle], backgroundColor: dLayerSpanBackgroundColor, margin: "0.15em" };
    }
    function createShadowStyle(offXPxNumber, offYPxNumber, blurPxNumber, shadowColorStr) {
        var paramStr = offXPxNumber + "px " + offYPxNumber + "px " + blurPxNumber + "px " + shadowColorStr;
        var dropShadowParamStr = "drop-shadow(" + paramStr + ")";
        return { "-moz-box-shadow": paramStr, "-webkit-filter": dropShadowParamStr, filter: dropShadowParamStr };
    }
    function createRadioCheckStyles() {
        theThis.radioCheckStyle = { inherits: [theThis.noBorderMarginPaddingStyle, theThis.middleVerticalAlignStyle] };
        theThis.radioCheckWithDimStyle = { inherits: [theThis.radioCheckStyle, theThis.defaultRightPaddingRadioCheckStyle] };
        //theThis.radioCheckWithDimStyle = { inherits: [theThis.radioCheckStyle, theThis.defaultWidthHeightRadioCheckStyle, theThis.defaultRightPaddingRadioCheckStyle] };
        theThis.radioCheckLabelStyle = { inherits: [theThis.radioCheckStyle, theThis.blockStyle, theThis.cursorPointerStyle, theThis.textAlignLeftStyle/*, theThis.autoWidthAutoHeightStyle*/, theThis.floatNoneStyle] };
        theThis.radioCheckRemoveDefaultStyle = { inherits: [theThis.radioCheckStyle, theThis.positionAbsoluteStyle, theThis.opacityZeroStyle, theThis.visibilityHiddenStyle] };
        theThis.radioCheckLabelCheckedStyle = { inherits: [theThis.radioCheckStyle, theThis.textShadowSelRadioCheckStyle] };
        theThis.radioLabelStyle = { inherits: [theThis.radioCheckLabelStyle] };
        theThis.radioRadioStyle = { inherits: [theThis.radioCheckRemoveDefaultStyle] };
        theThis.radioRadioAndLabelCheckedStyle = { inherits: [theThis.radioCheckLabelCheckedStyle] };
        theThis.radioRadioAndLabelStyleBefore = { inherits: [theThis.radioCheckWithDimStyle, theThis.defaultRadioUnCheckedStyle] };
        theThis.radioRadioAndLabelSelStyleBefore = { inherits: [theThis.radioCheckWithDimStyle, theThis.defaultRadioCheckedStyle] };
        theThis.checkLabelStyle = { inherits: [theThis.radioCheckLabelStyle] };
        theThis.checkCheckStyle = { inherits: [theThis.radioCheckRemoveDefaultStyle] };
        theThis.checkCheckAndLabelCheckedStyle = { inherits: [theThis.radioCheckLabelCheckedStyle] };
        theThis.checkCheckAndLabelStyleBefore = { inherits: [theThis.radioCheckWithDimStyle, theThis.defaultCheckUnCheckedStyle] };
        theThis.checkCheckAndLabelSelStyleBefore = { inherits: [theThis.radioCheckWithDimStyle, theThis.defaultCheckCheckedStyle] };
    }
    function createSvgGlyphStyles(glyphColor, backgroundColor, glyphColorHover, backgroundColorHover) {
        var style = { inherits: [theThis.svgGlyphStyleBase, theThis.cursorPointerStyle], backgroundColor: backgroundColor, fill: glyphColor };
        var hoverStyle = { backgroundColor: backgroundColorHover, fill: glyphColorHover };
        return { style: style, hoverStyle: hoverStyle };
    }
    function createTextDivBtnStyles(textColor, backgroundColor, textColorHover, backgroundColorHover) {
        var style = { inherits: [theThis.textButtonStyleBase], backgroundColor: backgroundColor, color: textColor };
        var hoverStyle = { backgroundColor: backgroundColorHover, color: textColorHover };
        return { style: style, hoverStyle: hoverStyle };
    }
    function createAppStyles() {
        theThis.popupCaptionBorderRadiusStyle = { borderRadius: popupCaptionBorderRadiusPXNumber + 'px' };
        theThis.popupContentPaddingStyle = { padding: popupContentPaddingPXNumber + "px" }
        theThis.popupContentBorderRadiusStyle = { borderRadius: popupContentBorderRadiusPXNumber + "px" }
        theThis.textShadowStyle = { textShadow: textShadow };
        theThis.darkTextShadowStyle = { textShadow: darkTextShadow };
        theThis.seShadowStyle = createShadowStyle(3, 3, 3, "rgba(0,0,0,0.6)");
        theThis.horShadowStyle = createShadowStyle(0, 1, 4, "rgba(0,0,0,0.6)");
        //theThis.seShadowStyle = { "tf-shadow": [3, 3, 3, "rgba(0,0,0,0.6)"] };
        //theThis.horShadowStyle = { "tf-shadow": [0, 1, 4, "rgba(0,0,0,0.6)"] };
        theThis.textShadowSelRadioCheckStyle = { textShadow: textShadowSelRadioCheck };
        theThis.defaultWidthHeightRadioCheckStyle = { width: "1em", height: "1em" };    // not actually shown, because check or radio image component is hidden and replaced by content before
        theThis.defaultRightPaddingRadioCheckStyle = { paddingRight: "0.2em" };
        theThis.paddingStyle = { padding: paddingPxNumber + "px" };
        theThis.paddingLeftRightStyle = { paddingLeft: paddingPxNumber + "px", paddingRight: paddingPxNumber + "px" };
        theThis.separatorBkColorStyle = { backgroundColor: theThis.separatorBackgroundColor };
        theThis.rightSideContainerBkColorStyle = { backgroundColor: theThis.containerDarkBackgroundColor };
        theThis.hcfLayoutContainerBkColorStyle = { backgroundColor: theThis.hcfLayoutContainerBkColor };
        theThis.popupCaptionBackgroundColorStyle = { backgroundColor: theThis.popupCaptionBackgroundColor };
        theThis.divIconCursorStyle = { inherits: theThis.cursorDefaultStyle };
        theThis.noBorderMarginPaddingStyle = { inherits: [theThis.noBorderStyle, theThis.noBorderSpacingStyle, theThis.noMarginStyle, theThis.noPaddingStyle] };
        theThis.verticalSeparatorWidthStyle = { width: verticalSeparatorWidthEMNumber + "em"};
        theThis.horizontalSeparatorHeightStyle = { height: horizontalSeparatorHeightEMNumber + "em" };
        theThis.darkTextColorStyle = { color: theThis.darkTextColor };
        theThis.lightTextColorStyle = { color: theThis.lightTextColor };
        theThis.disabledTextColorStyle = { color: theThis.disabledTextColor };
        theThis.defaultButtonBkStyle = { backgroundColor: theThis.defaultButtonBk };
        theThis.buttonBorderRadiusStyle = { borderRadius: buttonBorderRadiusPxNumber + "px" };
        theThis.appContainerStyle = {
            inherits: [theThis.fullWidthHeightStyle, theThis.blockStyle, theThis.overflowHiddenStyle, theThis.defaultFontAndTopSizeStyle, theThis.noSelectStyle, theThis.positionRelativeStyle],
            lineHeight: "initial"
        };
        theThis.mapContainerStyle = {
            inherits: [theThis.fullWidthHeightStyle, theThis.blockStyle, theThis.overflowHiddenStyle, theThis.noSelectStyle, theThis.middleVerticalAlignStyle,
                theThis.defaultFontAndTopSizeStyle, theThis.positionRelativeStyle], borderRadius: "inherit",
            lineHeight: "initial"
        };
        theThis.mapSubContainerStyle = {
            inherits: [theThis.fullWidthHeightStyle, theThis.blockStyle, theThis.overflowHiddenStyle, theThis.noSelectStyle, theThis.middleVerticalAlignStyle,
                theThis.fontSizeInheritStyle, theThis.positionRelativeStyle], borderRadius: "inherit",
            lineHeight: "initial"
        };
        theThis.popupMapToolBarBaseStyle = {
            inherits: [theThis.noBorderMarginPaddingStyle, theThis.blockStyle, theThis.positionAbsoluteStyle, theThis.noSelectStyle,
                theThis.darkTextColorStyle, theThis.defaultFontStyle]
        };
        theThis.mapToolBarContainerStyle = {
            inherits: [theThis.popupMapToolBarBaseStyle, theThis.fasterOpacityVisibilityTransitionStyle, theThis.middleVerticalAlignStyle, theThis.popupCaptionBackgroundColorStyle,
                theThis.seShadowStyle, theThis.popupCaptionBorderRadiusStyle]
        };
        theThis.topSeparatorLightStyle = { borderTop: borderSeparatorLightSpecs };
        theThis.bottomBorderSeparatorLightStyle = { borderBottom: borderSeparatorLightSpecs };
        theThis.rightBorderSeparatorLightStyle = { borderRight: borderSeparatorLightSpecs };
        theThis.leftBorderSeparatorLightStyle = { borderLeft: borderSeparatorLightSpecs };
        theThis.topBorderSeparatorDarkStyle = { borderTop: borderSeparatorDarkSpecs };
        theThis.bottomBorderSeparatorDarkStyle = { borderBottom: borderSeparatorDarkSpecs };
        theThis.rightBorderSeparatorDarkStyle = { borderRight: borderSeparatorDarkSpecs };
        theThis.leftBorderSeparatorDarkStyle = { borderLeft: borderSeparatorDarkSpecs };
        theThis.popupContainerStyle = {
            inherits: [theThis.popupMapToolBarBaseStyle, theThis.defaultOpacityVisibilityTransitionStyle, theThis.overflowHiddenStyle,
                theThis.textAlignLeftStyle, theThis.transparentBackgroundStyle, theThis.seShadowStyle, theThis.noPointerEventsStyle],
            padding: theThis.popupContainerPaddingPxNumber + "px"
        };
        theThis.popupContentStyle = {
            inherits: [theThis.noBorderMarginPaddingStyle, theThis.blockStyle, theThis.popupContentBkColorStyle, theThis.borderLightStyle,
                theThis.popupContentBorderRadiusStyle, theThis.popupContentPaddingStyle, theThis.textAlignLeftStyle, theThis.allPointerEventsStyle]
        };
        theThis.spanStyle = { inherits: [theThis.noBorderMarginPaddingStyle, theThis.middleVerticalAlignStyle, theThis.transparentBackgroundStyle, theThis.cursorDefaultStyle] };
        theThis.spanCursorPointerStyle = { inherits: [theThis.spanStyle, theThis.cursorPointerStyle] };
        theThis.appContainerBaseStyle = { inherits: [theThis.unPaddedBlockDivStyle, theThis.lightTextColor, theThis.hcfLayoutContainerBkColorStyle, theThis.overflowHiddenStyle] };
        theThis.hcfLayoutStyle = { inherits: [theThis.appContainerBaseStyle, theThis.fullHeightStyle] };
        theThis.hcfLayoutHeaderStyle = { inherits: [theThis.appContainerBaseStyle, theThis.textAlignCenterStyle, theThis.bottomBorderSeparatorLightStyle], top: "0em" };
        theThis.hcfLayoutFooterStyle = { inherits: [theThis.appContainerBaseStyle, theThis.textAlignCenterStyle, theThis.topSeparatorLightStyle], bottom: "0em" };
        theThis.hcfLayoutContentStyle = { inherits: [theThis.appContainerBaseStyle, theThis.overflowYScrollStyle] };
        theThis.inputTextPlaceholderStyle = { inherits: [theThis.defaultFontSizeInheritStyle, theThis.disabledTextColorStyle] };
        theThis.inputTextStyle = {
            inherits: [theThis.noBorderMarginPaddingStyle, theThis.noOutlineStyle, theThis.defaultFontSizeInheritStyle, theThis.darkTextColorStyle, theThis.seShadowStyle,
            theThis.textShadowStyle, theThis.textInputBackgroundStyle, theThis.paddingLeftRightStyle]
        };
        createRadioCheckStyles();
        theThis.mapMeasureOverlayDivStyle = {
            inherits: [theThis.blockStyle, theThis.cursorDefaultStyle, theThis.noBorderMarginPaddingStyle, theThis.paddingStyle, theThis.textAlignCenterStyle,
            theThis.middleVerticalAlignStyle, theThis.noPointerEventsStyle, theThis.noSelectStyle], fontSize: "1.2em", color: "#128", borderRadius: "0.5em",
            border: "1px solid #3e3e3e", backgroundColor: "rgba(255, 255, 255, 0.6)", textShadow: "2px 3px 3px #ddd"
        };
        theThis.imgStyleBase = { inherits: [theThis.noBorderMarginPaddingStyle, theThis.notDraggableStyle, theThis.noSelectStyle] };
        theThis.logoMaxWidthHeightStyle = { minWidth: (maxWidthLogoImageEmNumber / 2) + "em", maxWidth: maxWidthLogoImageEmNumber + "em", maxHeight: maxHeightLogoImageEmNumber + "em" };
        theThis.imgLogoStyle = { inherits: [theThis.imgStyleBase, theThis.inheritHeightStyle, theThis.autoWidthStyle, theThis.noPointerEventsStyle, theThis.logoMaxWidthHeightStyle, theThis.middleVerticalAlignStyle] };
        theThis.imgFullWidthHeightStyle = { inherits: [theThis.imgStyleBase, theThis.fullWidthHeightStyle] };
        theThis.imgDefaultFrameStyle = {
            inherits: [theThis.whiteBackgroundStyle],
            border: theThis.imgFrameBorder,
            margin: theThis.imgFramePaddingBorderWidthEmNumber + "em",
            color: "#FFFFFF"
        };
        theThis.divWithImgBkStyle = {
            inherits: [theThis.noBorderMarginPaddingStyle, theThis.imgDefaultFrameStyle, theThis.inheritVerticalAlignStyle,
                theThis.divWithImgBkkSizeStyle, theThis.inlineBlockStyle, theThis.middleVerticalAlignStyle],
            width: theThis.imageThumbWidthEmNumber + "em"
        };
        theThis.imgForInfoWindowStyle = { inherits: [theThis.imgDefaultFrameStyle], align: "center", padding: "0px", height: "12em", width: "auto" };
        theThis.buttonStyleBase = {
            inherits: [theThis.noBorderMarginPaddingStyle, theThis.middleVerticalAlignStyle, theThis.textAlignCenterStyle, theThis.buttonBorderRadiusStyle, theThis.cursorPointerStyle]
        };
        theThis.svgGlyphStyleBase = {
            inherits: [theThis.buttonStyleBase, theThis.blockStyle, theThis.transparentBackgroundStyle],
            stroke: "#000", strokeWidth: "0%", strokeLinejoin: "round",
            borderRadius: svgButtonBorderRadiusPercentNumber + "%"
        };
        theThis.svgGlyphLightNoHoverStyle = { inherits: [theThis.svgGlyphStyleBase, theThis.divIconCursorStyle], fill: theThis.buttonLightFill };
        theThis.svgGlyphLightStyle = { inherits: [theThis.svgGlyphLightNoHoverStyle, theThis.cursorPointerStyle], backgroundColor: theThis.buttonLightBkg };
        theThis.svgGlyphLightStyleHover = { backgroundColor: theThis.buttonLightFill, fill: theThis.buttonLightBkg };
        theThis.svgGlyphDarkNoHoverStyle = { inherits: [theThis.svgGlyphStyleBase, theThis.divIconCursorStyle], fill: theThis.buttonDarkFill };
        theThis.mapSvgGlyphInButtonStyle = { inherits: [theThis.svgGlyphStyleBase, theThis.divIconCursorStyle], fill: mapControlTextColor };
        theThis.mapSvgGlyphInPopupStyle = { inherits: [theThis.svgGlyphStyleBase, theThis.divIconCursorStyle], fill: mapControlTextColor };
        theThis.mapSvgGlyphInPopupHoverStyle = { inherits: [theThis.svgGlyphStyleBase, theThis.divIconCursorStyle], backgroundColor: mapControlTextColor, fill: theThis.mapControlButtonHoverBkColor };
        theThis.svgGlyphDarkStyle = { inherits: [theThis.svgGlyphDarkNoHoverStyle, theThis.cursorPointerStyle] };
        theThis.svgGlyphDarkStyleHover = { backgroundColor: theThis.buttonDarkFill, fill: theThis.buttonDarkBkg };
        theThis.divSvgGlyphStyle = { inherits: [theThis.noBorderMarginPaddingStyle, theThis.inlineBlockStyle, theThis.middleVerticalAlignStyle] };
        theThis.buttonDivMarginTopStyle = { marginTop: buttonMarginTopBottomPxNumber + "px" };
        theThis.buttonDivMarginBotStyle = { marginBottom: buttonMarginTopBottomPxNumber + "px" };
        theThis.buttonDivTopBotMarginsStyle = { inherits: [theThis.buttonDivMarginTopStyle, theThis.buttonDivMarginBotStyle] };
        theThis.buttonDivMarginLeftStyle = { marginLeft: buttonMarginLeftRightPxNumber + "px" };
        theThis.buttonDivMarginRightStyle = { marginRight: buttonMarginLeftRightPxNumber + "px" };
        theThis.buttonDivLeftRightMarginsStyle = { inherits: [theThis.buttonDivMarginLeftStyle, theThis.buttonDivMarginRightStyle] };
        theThis.buttonDivAllMarginsStyle = { inherits: [theThis.buttonDivTopBotMarginsStyle, theThis.buttonDivLeftRightMarginsStyle] };
        theThis.divSvgGlyphBtnStyle = { inherits: [theThis.divSvgGlyphStyle] };
        theThis.divSvgGlyphIconStyle = { inherits: [theThis.divSvgGlyphStyle, theThis.divIconCursorStyle] };
        theThis.textButtonStyleBase = {
            inherits: [theThis.buttonStyleBase, theThis.inlineBlockStyle, theThis.autoWidthStyle, theThis.buttonBorderRadiusStyle],
            paddingTop: textButtonPaddingTopBottomPxNumber + "px",
            paddingBottom: textButtonPaddingTopBottomPxNumber + "px",
            paddingLeft: textButtonPaddingLeftRightPxNumber + "px",
            paddingRight: textButtonPaddingLeftRightPxNumber + "px"
        };
        theThis.textDivBtnLightStyle = { inherits: theThis.textButtonStyleBase, color: theThis.lightTextDivBtnColor, backgroundColor: theThis.buttonLightBkg, textShadow: buttonShapedLinkTextShadow };
        theThis.textDivBtnLightStyleHover = { color: theThis.darkTextDivBtnColor, backgroundColor: theThis.buttonLightFill, textShadow: "none" };
        theThis.textDivBtnDarkStyle = { inherits: theThis.textButtonStyleBase, color: theThis.darkTextDivBtnColor, backgroundColor: theThis.buttonDarkBkg };
        theThis.textDivBtnDarkStyleHover = { color: theThis.lightTextDivBtnColor, backgroundColor: theThis.buttonDarkFill };
        theThis.mapTextBtnStyle = { inherits: [theThis.textButtonStyleBase], color: mapPopupTextButtonTextColor, backgroundColor: mapPopupTextButtonBkColor, textShadow: buttonShapedLinkTextShadow };
        theThis.mapTextBtnStyleHover = { inherits: [theThis.darkTextShadowStyle], backgroundColor: mapPopupTextButtonTextColor, color: mapPopupTextButtonBkColor, textShadow: buttonShapedLinkTextShadowHover };
        theThis.buttonShapedLinkStyle = {
            inherits: [theThis.textButtonStyleBase, theThis.noTextDecorationStyle],
            borderTop: borderSeparatorLightSpecs,
            borderLeft: borderSeparatorLightSpecs,
            borderBottom: borderSeparatorButtonBkSpecs,
            borderRight: borderSeparatorButtonBkSpecs,
            color: theThis.buttonShapedLinkTextColor,
            backgroundColor: theThis.buttonShapedLinkBkColor,
            textShadow: buttonShapedLinkTextShadow,
            margin: buttonShapedLinkMarginPxNumber + "px"
        };
        theThis.buttonShapedLinkHoverStyle = {
            borderTop: borderSeparatorButtonBkSpecs,
            borderLeft: borderSeparatorButtonBkSpecs,
            borderBottom: borderSeparatorLightSpecs,
            borderRight: borderSeparatorLightSpecs,
            color: theThis.buttonShapedLinkHoverTextColor,
            backgroundColor: theThis.buttonShapedLinkHoverBkColor,
            textShadow: buttonShapedLinkTextShadowHover
        };
        createDLayerStyles();
        theThis.paddedBlockDivStyle = { inherits: [theThis.noBorderMarginPaddingStyle, theThis.paddingStyle, theThis.blockStyle] };
        theThis.paddedInlineBlockDivStyle = { inherits: [theThis.noBorderMarginPaddingStyle, theThis.paddingStyle, theThis.inlineBlockStyle] };
        theThis.paddedBlockDivWithBorderSeparatorStyle = { inherits: [theThis.paddedBlockDivStyle, theThis.bottomBorderSeparatorLightStyle] };
        theThis.paddedInlineBlockDivWithBorderSeparatorStyle = { inherits: [theThis.paddedInlineBlockDivStyle, theThis.rightBorderSeparatorLightStyle] };
        theThis.unPaddedBlockDivStyle = { inherits: [theThis.noBorderMarginPaddingStyle, theThis.blockStyle] };
        theThis.unPaddedInlineBlockDivStyle = { inherits: [theThis.noBorderMarginPaddingStyle, theThis.inlineBlockStyle] };
        theThis.leftSideContainerStyle = { inherits: [theThis.unPaddedBlockDivStyle, theThis.autoWidthFullHeightStyle, theThis.overflowHiddenStyle] };
        theThis.floatLeftSideContainerStyle = { inherits: [theThis.unPaddedBlockDivStyle, theThis.autoWidthFullHeightStyle, theThis.overflowHiddenStyle, theThis.floatLeftStyle] };
        theThis.leftRightSideSeparatorStyle = {
            inherits: [theThis.unPaddedBlockDivStyle, theThis.fullHeightStyle, theThis.overflowHiddenStyle, theThis.separatorBkColorStyle,
                theThis.middleVerticalAlignStyle, theThis.textAlignCenterStyle, theThis.floatRightStyle, theThis.verticalSeparatorWidthStyle, theThis.positionRelativeStyle,
            theThis.leftBorderSeparatorLightStyle, theThis.rightBorderSeparatorDarkStyle]
        };
        theThis.rightSideContainerStyle = { inherits: [theThis.unPaddedBlockDivStyle, theThis.fullHeightStyle, theThis.overflowHiddenStyle, theThis.floatRightStyle, theThis.rightSideContainerBkColorStyle, theThis.lightTextColorStyle] };
        theThis.bottomContainerStyle = { inherits: [theThis.unPaddedBlockDivStyle, theThis.fullWidthStyle, theThis.overflowHiddenStyle, theThis.whiteBackgroundStyle] };
        theThis.topBottomSeparatorStyle = {
            inherits: [theThis.unPaddedBlockDivStyle, theThis.fullWidthStyle, theThis.overflowHiddenStyle, theThis.separatorBkColorStyle, theThis.middleVerticalAlignStyle, theThis.textAlignCenterStyle, theThis.horizontalSeparatorHeightStyle]
        };
        theThis.listContentStyle = { inherits: [theThis.unPaddedBlockDivStyle, theThis.bottomBorderSeparatorLightStyle, theThis.hcfLayoutContainerBkColorStyle] };
        theThis.inputFormBkStyle = { backgroundColor: theThis.inputFormBkColor };
        theThis.inputFormStyle = { inherits: [theThis.unPaddedBlockDivStyle, theThis.inputFormBkStyle, theThis.darkTextColorStyle, theThis.textAlignCenterStyle], borderRadius: inputFormBorderRadiusPxNumber + "px" };
        var platformURL = tf.platform.GetURL();
        theThis.fontFaceStyleContentStr =
            "font-family: 'SourceSansPro-Regular';" +
            "src: url('" + platformURL + "fonts/SourceSansPro-Regular.eot');" +
            "src: local('?'), url('" + platformURL + "fonts/SourceSansPro-Regular.woff') format('woff'), url('" + platformURL +
            "fonts/SourceSansPro-Regular.ttf') format('truetype'), url('" + platformURL + "fonts/SourceSansPro-Regular.svg') format('svg');" +
            "font-weight: normal;" +
            "font-style: normal;";
        theThis.transitionOpacityToVisibleStyle = { transition: "opacity .25s linear,visibility 0s linear" };
        theThis.transitionOpacityToInvisibleStyle = { transition: "opacity .25s linear,visibility 0s linear .25s" };
        createMapComponentsStyles();
        theThis.popupContentBkColorStyle = { backgroundColor: theThis.popupContentBkColor };
        theThis.popupCaptionStyle = {
            inherits: [theThis.inlineBlockStyle, theThis.noBorderMarginPaddingStyle, theThis.popupCaptionBackgroundColorStyle, theThis.seShadowStyle, theThis.bottomBorderSeparatorLightStyle,
                theThis.rightBorderSeparatorLightStyle, theThis.textShadowStyle, theThis.cursorDefaultStyle, theThis.darkTextColorStyle, theThis.positionRelativeStyle,
                theThis.popupCaptionBorderRadiusStyle, theThis.allPointerEventsStyle],
                fontSize: theThis.mapControlFontSizeEmNumber + "em"
        };
        theThis.bodyStyle = { inherits: [theThis.noBorderMarginPaddingStyle, theThis.fullWidthHeightStyle, theThis.whiteBackgroundStyle, theThis.defaultFontStyle, theThis.topFontSizeStyle] };
    }
    function initLiteralValues(specifications) {
        borderSeparatorLineSpecs = specifications.borderSeparatorLineSpecs;
        textInputBackgroundColor = specifications.textInputBackgroundColor;
        mapPopupTextButtonTextColor = specifications.mapPopupTextButtonTextColor;
        mapPopupTextButtonBkColor = specifications.mapPopupTextButtonBkColor;
        mapScaleLineBkColor = specifications.mapScaleLineBkColor ;
        mapScaleLineBorderRadiusPxNumber = specifications.mapScaleLineBorderRadiusPxNumber ;
        mapScaleLinePaddingPxNumber = specifications.mapScaleLinePaddingPxNumber ;
        mapScaleLineBorder = specifications.mapScaleLineBorder ;
        mapScaleLineFontSizeEmNumber = specifications.mapScaleLineFontSizeEmNumber ;
        mapScaleLineMarginPxNumber = specifications.mapScaleLineMarginPxNumber ;
        mapScaleLineFontColor = specifications.mapScaleLineFontColor;
        mapControlFontWeight = specifications.mapControlFontWeight;
        theThis.mapSubLegendBkColor = specifications.mapSubLegendBkColor;
        tfLogoBorderRadius = specifications.tfLogoBorderRadius ;
        tfLogoWidth = specifications.tfLogoWidth ;
        tfLogoHeight = specifications.tfLogoHeight ;
        tfLogoOpacity = specifications.tfLogoOpacity ;
        tfLogoBkColor = specifications.tfLogoBkColor ;
        tfLogoBorder = specifications.tfLogoBorder ;
        mapControlLineHeightEmNumber = specifications.mapControlLineHeightEmNumber ;
        mapControlTextColor = specifications.mapControlTextColor;
        overviewMapWidthPxNumber = specifications.overviewMapWidthPxNumber;
        overviewMapHeightPxNumber = specifications.overviewMapHeightPxNumber;
        overviewMapBorderWidthPxNumberNumber = specifications.overviewMapBorderWidthPxNumberNumber;
        overviewMapBoxBorder = specifications.overviewMapBoxBorder;
        mapZoomInBorderRadius = specifications.mapZoomInBorderRadius;
        mapZoomOutBorderRadius = specifications.mapZoomOutBorderRadius;
        dLayerSpanBackgroundColor = specifications.dLayerSpanBackgroundColor;
        textShadow = specifications.textShadow;
        darkTextShadow = specifications.darkTextShadow;
        textShadowSelRadioCheck = specifications.textShadowSelRadioCheck;
        mapButtonDimEmNumber = specifications.mapButtonDimEmNumber;
        mapButtonMarginEmNumber = specifications.mapButtonMarginEmNumber;
        mapButtonSpacingEmNumber = specifications.mapButtonSpacingEmNumber;
        maxHeightLogoImageEmNumber = specifications.maxHeightLogoImageEmNumber;
        maxWidthLogoImageEmNumber = specifications.maxWidthLogoImageEmNumber;
        theThis.mapButtonDimEmNumber = mapButtonDimEmNumber;
        theThis.mapButtonMarginEmNumber = mapButtonMarginEmNumber;
        theThis.mapControlBkColor = specifications.mapControlBkColor;
        theThis.mapControlHoverBkColor = specifications.mapControlHoverBkColor;
        theThis.mapControlButtonHoverBkColor = specifications.mapControlButtonHoverBkColor;
        theThis.mapControlButtonBkColor = specifications.mapControlButtonBkColor;
        buttonMarginTopBottomPxNumber = specifications.buttonMarginTopBottomPxNumber;
        buttonMarginLeftRightPxNumber = specifications.buttonMarginLeftRightPxNumber;
        buttonBorderRadiusPxNumber = specifications.buttonBorderRadiusPxNumber;
        textButtonPaddingTopBottomPxNumber = specifications.textButtonPaddingTopBottomPxNumber;
        textButtonPaddingLeftRightPxNumber = specifications.textButtonPaddingLeftRightPxNumber;
        theThis.lightTextColor = specifications.lightTextColor;
        theThis.darkTextColor = specifications.darkTextColor;
        theThis.disabledTextColor = specifications.disabledTextColor;
        theThis.borderLightColor = specifications.borderLightColor;
        theThis.defaultButtonBk = specifications.defaultButtonBk;
        theThis.defaultButtonFill = specifications.defaultButtonFill;
        theThis.buttonShapedLinkBkColor = specifications.buttonShapedLinkBkColor;
        theThis.buttonShapedLinkTextColor = specifications.buttonShapedLinkTextColor;
        theThis.buttonShapedLinkHoverBkColor = specifications.buttonShapedLinkHoverBkColor;
        theThis.buttonShapedLinkHoverTextColor = specifications.buttonShapedLinkHoverTextColor;
        buttonShapedLinkTextShadow = specifications.buttonShapedLinkTextShadow;
        buttonShapedLinkTextShadowHover = specifications.buttonShapedLinkTextShadowHover;
        buttonShapedLinkMarginPxNumber = specifications.buttonShapedLinkMarginPxNumber;
        svgButtonBorderRadiusPercentNumber = specifications.svgButtonBorderRadiusPercentNumber;
        verticalSeparatorWidthEMNumber = specifications.verticalSeparatorWidthEMNumber;
        horizontalSeparatorHeightEMNumber = specifications.horizontalSeparatorHeightEMNumber;
        paddingPxNumber = specifications.paddingPxNumber;
        theThis.popupContainerPaddingPxNumber = specifications.popupContainerPaddingPxNumber;
        popupCaptionBorderRadiusPXNumber = specifications.popupCaptionBorderRadiusPXNumber;
        popupContentPaddingPXNumber = specifications.popupContentPaddingPXNumber;
        popupContentBorderRadiusPXNumber = specifications.popupContentBorderRadiusPXNumber;
        theThis.textButtonHeightDelta = textButtonPaddingTopBottomPxNumber * 2;
        theThis.topFontSizePXNumber = specifications.topFontSizePXNumber;
        theThis.markerFontSizePXNumber = specifications.markerFontSizePXNumber;
        theThis.imageThumbWidthEmNumber = specifications.imageThumbWidthEmNumber;
        theThis.imageThumbSquareHeightEmNumber = theThis.imageThumbWidthEmNumber;
        theThis.imageThumbRectHeightEmNumber = theThis.imageThumbWidthEmNumber * 9 / 16;
        theThis.popupContentBkColor = specifications.popupContentBkColor;
        theThis.mapControlFontSizeEmNumber = specifications.mapControlFontSizeEmNumber;
        theThis.popupContentFontSizeEmNumber = specifications.popupContentFontSizeEmNumber;
        theThis.infoPopupContentFontSizeEmNumber = specifications.infoPopupContentFontSizeEmNumber;
        theThis.locationPopupContentFontSizeEmNumber = specifications.locationPopupContentFontSizeEmNumber;
        theThis.fontFamily = specifications.fontFamily;
        theThis.markerFontFamily = specifications.markerFontFamily;
        theThis.containerDarkBackgroundColor = specifications.containerDarkBackgroundColor;
        theThis.containerDarkSelBackgroundColor = specifications.containerDarkSelBackgroundColor;
        theThis.hcfLayoutContainerBkColor = specifications.hcfLayoutContainerBkColor;
        theThis.popupCaptionBackgroundColor = specifications.popupCaptionBackgroundColor;
        theThis.separatorBackgroundColor = specifications.separatorBackgroundColor;
        theThis.buttonLightBkg = specifications.buttonLightBkg;
        theThis.buttonLightFill = specifications.buttonLightFill;
        theThis.buttonDarkBkg = specifications.buttonDarkBkg;
        theThis.buttonDarkFill = specifications.buttonDarkFill;
        theThis.lightTextDivBtnColor = specifications.lightTextDivBtnColor;
        theThis.darkTextDivBtnColor = specifications.darkTextDivBtnColor;
        theThis.imgFramePaddingBorderWidthEmNumber = specifications.imgFramePaddingBorderWidthEmNumber;
        theThis.imgFrameBorder = specifications.imgFrameBorder;
        theThis.inputFormBkColor = specifications.inputFormBkColor;
        inputFormBorderRadiusPxNumber = specifications.inputFormBorderRadiusPxNumber;
    }
    function initialize() {
        var specs = tf.styles.GetDefaultAPIStyleSpecifications();
        //var specs = tf.styles.GetGraphiteAPIStyleSpecifications();
        if (tf.js.GetIsValidObject(alternativeSpecs)) { specs = tf.js.ShallowMerge(specs, alternativeSpecs); }
        initLiteralValues(specs);
        createConstantStyles();
        createAppStyles();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * @public
 * @class
 * @summary The {@link singleton} instance of this class, obtainable by calling {@link tf.GetStyles}(),
 * includes the pre-defined [CSS Style Names]{@link tf.types.CSSStyleName} used by the API, 
 * style related functions, and access to other style [singletons]{@link singleton}, like
 * the [CSS Style Creator]{@link tf.styles.CSSStyleCreator}, and [Sub Styles]{@link tf.styles.SubStyles},
 * containing pre-defined [CSS Style Specifications]{@link tf.types.CSSStyleSpecs}
 * @param {tf.types.APIStyleSpecs} alternativeSpecs - if defined, overrides the default API style specifications
 */
tf.styles.Styles = function (alternativeSpecs) {
    var theThis, styleCreator, subStyles, hiddenCanvas, supportedTransformProp;
    var dotPrefix = '.';
    var lightClassName = "light", darkClassName = "dark";
    var cssClassPrefix = "tf-";
    var divBaseClass = cssClassPrefix + "div-";
    var imgBaseClass = cssClassPrefix + "img-";
    var spanBaseClass = cssClassPrefix + "span-";
    var linkBaseClass = cssClassPrefix + "link-";
    var inputBaseClass = cssClassPrefix +  + "input-";
    var mapBaseClass = cssClassPrefix + "map-";
    var utilBaseClass = cssClassPrefix + "u-";
    var svgGlyphStyleBaseClass = cssClassPrefix + "glyph-svg-";
    var textDivBtnStyleBaseClass = cssClassPrefix + "btn-div-";
    var borderBaseClass = cssClassPrefix + "border-";
    var svgGlyphStyleNoHoverClass = "nohover-";
    var imgPreSelectorStr = "img.", svgPreSelectorStr = "svg.", divPreSelectorStr = 'div.', linkPreSelectorStr = 'a.';
    var imgPosSelectorStr = " img", spanPosSelectorStr = " span", linkPosSelectorStr = " a", labelPosSelectorStr = " label";
    var buttonPosSelectorStr = " button", inputPosSelectorStr = " input";
    var inputTypeRadioPosSelectorStr = inputPosSelectorStr + '[type="radio"]';
    var inputTypeCheckPosSelectorStr = inputPosSelectorStr + '[type="checkbox"]';
    var focusSelectorStr = ":focus", hoverSelectorStr = ":hover", checkedSelectorStr = ":checked";
    var linkSelectorStr = ":link", visitedSelectorStr = ":visited", activeSelectorStr = ":active";
    var beforeSelectorStr = "::before";
    var blockSuffix = "block-", inlineBlockSuffix = "inlineblock-", paddedSuffix = "padded", unPaddedSuffix = "un" + paddedSuffix;
    /**
     * @public
     * @function
     * @summary - Retrieves the {@link singleton} instance of [CSS Style Creator]{@link tf.styles.CSSStyleCreator}
     * @returns {tf.styles.CSSStyleCreator} - | {@link tf.styles.CSSStyleCreator} the {@link singleton}
    */
    this.GetStyleCreator = function () { return styleCreator; }
    /**
     * @public
     * @function
     * @summary - Retrieves the {@link singleton} instance of [Sub Styles]{@link tf.styles.SubStyles}
     * @returns {tf.styles.SubStyles} - | {@link tf.styles.SubStyles} the {@link singleton}
    */
    this.GetSubStyles = function () { return subStyles; }
    /**
     * @protected
     * @function
     * @summary - Retrieves a pre-created HTML5 canvas for internal use by the API
     * @returns {HTMLElement} - | {@link HTMLElement} the hidden canvas
    */
    this.GetHiddenCanvas = function () { return hiddenCanvas; }
    /**
     * @public
     * @function
     * @summary - Creates custom CSS styles and classes used by [SVG Glyph Button]{@link tf.ui.SvgGlyphBtn} instances to customize 
     * the <b>glyph</b> and <b>background</b> colors displayed in normal and hover states
     * @param {color} glyphColor - normal glyph color
     * @param {color} backgroundColor - normal background color
     * @param {color} glyphColorHover - glyph color on hover
     * @param {color} backgroundColorHover - background color on hover
     * @returns {tf.types.CSSStyleName} - | {@link tf.types.CSSStyleName} a CSS style/class
    */
    this.CreateSvgGlyphClasses = function (glyphColor, backgroundColor, glyphColorHover, backgroundColorHover) {
        return createSvgGlyphClasses(glyphColor, backgroundColor, glyphColorHover, backgroundColorHover);
    }
    /**
     * @public
     * @function
     * @summary - Creates custom CSS styles and classes used by [Text Button]{@link tf.ui.TextBtn} instances to customize the <b>text</b> and <b>background</b> colors displayed 
     * in normal and hover states
     * @param {color} textColor - normal text color
     * @param {color} backgroundColor - normal background color
     * @param {color} textColorHover - text color on hover
     * @param {color} backgroundColorHover - background color on hover
     * @returns {tf.types.CSSStyleName} - | {@link tf.types.CSSStyleName} a CSS style/class
    */
    this.CreateTextDivBtnClasses = function (textColor, backgroundColor, textColorHover, backgroundColorHover) {
        return createTextDivBtnClasses(textColor, backgroundColor, textColorHover, backgroundColorHover);
    }
    /**
     * @public
     * @function
     * @summary - Rotates the given element by the given angle, in degrees, by changing a specific [CSS style statement]{@link tf.types.CSSStyleStatement} of that element
     * @param {HTMLElementLike} elem - the given element
     * @param {number} angle - the given angle in degrees
     * @returns {void} - | {@link void} no return value
    */
    this.RotateByDegree = function (elem, angle) {
        if (!!supportedTransformProp) {
            if (elem = tf.dom.GetHTMLElementFrom(elem)) {
                var degStr = tf.js.GetFloatNumberInRange(angle, -360 * 10, 360 * 10, 0) + "deg";
                var transformStr = "rotate(" + degStr + ")";
                elem.style[supportedTransformProp] = transformStr;
            }
        }
    }
    /**
     * @public
     * @function
     * @summary - Gradually changes the visibility state of the given element to the given state by changing specific [CSS style statements]{@link tf.types.CSSStyleStatement} of that element
     * @param {HTMLElementLike} elem - the given element
     * @param {boolean} bool - <b>true</b> to make the element visible, <b>false</b> to make it invisible
     * @returns {void} - | {@link void} no return value
    */
    this.ChangeOpacityVisibilityClass = function (elem, bool) {
        if (elem = tf.dom.GetHTMLElementFrom(elem)) {
            var classIn, classOut;
            if (!!bool) { classIn = theThis.opacityVisibilityShowClass; classOut = theThis.opacityVisibilityHideClass; }
            else { classOut = theThis.opacityVisibilityShowClass; classIn = theThis.opacityVisibilityHideClass; }
            tf.dom.ReplaceCSSClass(elem, classOut, classIn);
        }
    }
    /**
     * @public
     * @function
     * @summary - Applies the given style specifications to the given element
     * @param {HTMLElementLike} elem - the given element
     * @param {tf.types.CSSStyleSpecs} cssStyleSpecs - the given specifications
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.ApplyStyleProperties = function (elem, cssStyleSpecs) { styleCreator.ApplyStyleProperties(elem, cssStyleSpecs); return elem; }
    /**
     * @public
     * @function
     * @summary - Adds a default bottom border separator to the given element
     * @param {HTMLElementLike} elem - the given element
     * @param {boolean} lightBool - set to <b>true</b> to use the API's default <b>light</b> style settings, otherwise the default <b>dark</b> style settings are used
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.AddBorderBottom = function (elem, lightBool) {
        return theThis.ApplyStyleProperties (elem, !!lightBool ? subStyles.bottomBorderSeparatorLightStyle : subStyles.bottomBorderSeparatorDarkStyle);
    }
    /**
     * @public
     * @function
     * @summary - Adds a default top border separator to the given element
     * @param {HTMLElementLike} elem - the given element
     * @param {boolean} lightBool - set to <b>true</b> to use the API's default <b>light</b> style settings, otherwise the default <b>dark</b> style settings are used
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.AddBorderTop = function (elem, lightBool) {
        return theThis.ApplyStyleProperties(elem, !!lightBool ? subStyles.topSeparatorLightStyle : subStyles.topBorderSeparatorDarkStyle);
    }
    /**
     * @public
     * @function
     * @summary - Retrieves button background color used by the API
     * @param {boolean} selectedBool - set to <b>true</b> to retrieve the selected state color, otherwise the normal state color is returned
     * @returns {color} - | {@link color} the color
    */
    this.GetButtonBGColor = function (selectedBool) { return !!selectedBool ? subStyles.defaultButtonBk : subStyles.defaultButtonFill }
    /**
     * @public
     * @function
     * @summary - Retrieves CSS style/class name used by API border separators, always returns the <b>light</b> style settings class/style
     * @param {boolean} inlineBool - set to <b>true</b> to retrieve a right border separator, otherwise the bottom separator is returned
     * @returns {tf.types.CSSStyleName} - | {@link tf.types.CSSStyleName} the s
    */
    this.GetBorderSeparatorClassName = function (inlineBool) { return !!inlineBool ? this.rightBorderSeparatorLightClass : this.bottomBorderSeparatorLightClass; }
    /**
     * @public
     * @function
     * @summary - Retrieves CSS style/class name used by API in the creation of <b>padded</b> [Div]{@link tf.dom.Div} instances
     * @param {boolean} inlineBool - set to <b>true</b> to retrieve an <b>inline-block</b> style with optional right border separator, otherwise a <b>block</b> div style with optional bottom separator is returned
     * @param {boolean} borderSeparatorBool - set to <b>true</b> to add a border separator, defaults to {@link void}
     * @returns {tf.types.CSSStyleName} - | {@link tf.types.CSSStyleName} the color
    */
    this.GetPaddedDivClassNames = function (inlineBool, borderSeparatorBool) {
        var classNames = '';
        if (!!inlineBool) { classNames = this.paddedInlineBlockDivClass; } else { classNames = this.paddedBlockDivClass; }
        if (!!borderSeparatorBool) { classNames += ' ' + theThis.GetBorderSeparatorClassName(inlineBool); }
        return classNames;
    }
    /**
     * @public
     * @function
     * @summary - Retrieves CSS style/class name used by API in the creation of <b>unpadded</b> [Div]{@link tf.dom.Div} instances
     * @param {boolean} inlineBool - set to <b>true</b> to retrieve an <b>inline-block</b> style with optional right border separator, otherwise a <b>block</b> div style with optional bottom separator is returned
     * @param {boolean} borderSeparatorBool - set to <b>true</b> to add a border separator, defaults to {@link void}
     * @returns {tf.types.CSSStyleName} - | {@link tf.types.CSSStyleName} the color
    */
    this.GetUnPaddedDivClassNames = function (inlineBool, borderSeparatorBool) {
        var classNames = '';
        if (!!inlineBool) { classNames = this.unPaddedInlineBlockDivClass; } else { classNames = this.unPaddedBlockDivClass; }
        if (!!borderSeparatorBool) { classNames += ' ' + theThis.GetBorderSeparatorClassName(inlineBool); }
        return classNames;
    }
    /**
     * @public
     * @function
     * @summary - Retrieves a <b>unicode</b> character suitable for display as a double horizontal arrow
     * @returns {character} - | {@link character} the character
    */
    this.GetUnicodeDoubleHorArrow = function () { return '\u2194'; }
    /**
     * @public
     * @function
     * @summary - Retrieves a <b>unicode</b> character suitable for display as an X that resembles a "close" button
     * @returns {character} - | {@link character} the character
    */
    this.GetUnicodeXClose = function () { return '\u00d7'; }
    /**
     * @public
     * @function
     * @summary - Retrieves CSS style/class name used by API in the creation of [Radio Button Lists]{@link tf.ui.RadioButtonList}
     * @returns {tf.types.CSSStyleName} - | {@link tf.types.CSSStyleName} the color
    */
    this.GetRadioItemClasses = function () { return theThis.radioClass + " " + theThis.radioLabelClass; }
    /**
     * @public
     * @function
     * @summary - Retrieves CSS style/class name used by API in the creation of [Check Box Lists]{@link tf.ui.CheckBoxList}
     * @returns {tf.types.CSSStyleName} - | {@link tf.types.CSSStyleName} the color
    */
    this.GetCheckItemClasses = function () { return theThis.checkClass + " " + theThis.checkLabelClass; }
    /**
     * @public
     * @function
     * @summary - Changes the position style of the given element to 'relative'
     * @param {HTMLElementLike} elem - the given element
     * @returns {void} - | {@link void} no return value
    */
    this.ApplyPositionRelativeStyle = function (elem) { return theThis.ApplyStyleProperties(elem, subStyles.positionRelativeStyle); }
    /**
     * @public
     * @function
     * @summary - Changes the position style of the given element to 'absolute'
     * @param {HTMLElementLike} elem - the given element
     * @returns {void} - | {@link void} no return value
    */
    this.ApplyPositionAbsoluteStyle = function (elem) { return theThis.ApplyStyleProperties(elem, subStyles.positionAbsoluteStyle); }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances with image backgrounds
     * @param {HTMLElementLike} elem - the given element
     * @returns {void} - | {@link void} no return value
    */
    this.ApplyDivWithImgBkStyle = function (elem) { return theThis.ApplyStyleProperties(elem, subStyles.divWithImgBkStyle); }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances containing text
     * @param {HTMLElementLike} elem - the given element
     * @param {boolean} darkTextColorBool - set to <b>true</b> to use the API's default <b>dark</b> text color style settings, otherwise the default <b>light</b> style settings are used
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.ApplyTextColorStyle = function (elem, darkTextColorBool) { return theThis.ApplyStyleProperties(elem, !!darkTextColorBool ? subStyles.darkTextColorStyle : subStyles.lightTextColorStyle); }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances to align items vertically
     * @param {HTMLElementLike} elem - the given element
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.ApplyMiddleVerticalAlignStyle = function (elem) { return theThis.ApplyStyleProperties(elem, subStyles.middleVerticalAlignStyle); }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances to align text on the center
     * @param {HTMLElementLike} elem - the given element
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.ApplyTextAlignCenterStyle = function (elem) { return theThis.ApplyStyleProperties(elem, subStyles.textAlignCenterStyle); }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances to float them
     * @param {HTMLElementLike} elem - the given element
     * @param {boolean} isLeftBool - set to <b>true</b> for float <b>left</b> styles, otherwise float <b>right</b> styles are applied
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.ApplyFloatStyle = function (elem, isLeftBool) { styleCreator.ApplyStyleProperties(tf.dom.GetHTMLElementFrom(elem), !!isLeftBool ? subStyles.floatLeftStyle : subStyles.floatRightStyle); return elem; }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances to achieve opacity transition effects
     * @param {HTMLElementLike} elem - the given element
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.AddDefaultOpacityTransitionStyle = function (elem) { return theThis.ApplyStyleProperties(elem, subStyles.defaultOpacityVisibilityTransitionStyle); }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances to achieve the API's default shadow effect
     * @param {HTMLElementLike} elem - the given element
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.AddDefaultShadowStyle = function (elem) { styleCreator.ApplyStyleProperties(tf.dom.GetHTMLElementFrom(elem), subStyles.seShadowStyle); return elem; }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances to achieve the API's alternative shadow effect
     * @param {HTMLElementLike} elem - the given element
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.AddHorShadowStyle = function (elem) { styleCreator.ApplyStyleProperties(tf.dom.GetHTMLElementFrom(elem), subStyles.horShadowStyle); return elem; }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances to set their horizontal and vertical button margins
     * @param {HTMLElementLike} elem - the given element
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.AddButtonDivMargins = function (elem) { styleCreator.ApplyStyleProperties(tf.dom.GetHTMLElementFrom(elem), subStyles.buttonDivAllMarginsStyle); return elem; }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances to set their vertical button margins
     * @param {HTMLElementLike} elem - the given element
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.AddButtonDivTopBottMargins = function (elem) { styleCreator.ApplyStyleProperties(tf.dom.GetHTMLElementFrom(elem), subStyles.buttonDivTopBotMarginsStyle); return elem; }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances to set their horizontal button margins
     * @param {HTMLElementLike} elem - the given element
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.AddButtonDivLeftRightMargins = function (elem) { styleCreator.ApplyStyleProperties(tf.dom.GetHTMLElementFrom(elem), subStyles.buttonDivLeftRightMarginsStyle); return elem; }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances to set their left button margin
     * @param {HTMLElementLike} elem - the given element
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.AddButtonDivLeftMargin = function (elem) { styleCreator.ApplyStyleProperties(tf.dom.GetHTMLElementFrom(elem), subStyles.buttonDivMarginLeftStyle); return elem; }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances to set their right button margin
     * @param {HTMLElementLike} elem - the given element
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.AddButtonDivRightMargin = function (elem) { styleCreator.ApplyStyleProperties(tf.dom.GetHTMLElementFrom(elem), subStyles.buttonDivMarginRightStyle); return elem; }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances to center them relative to their containers
     * @param {HTMLElementLike} elem - the given element
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.ApplySnapToCenterStyle = function (elem) {
        if (!!elem) {
            var domElement = !!elem.GetHTMLElement ? tf.dom.GetHTMLElementFrom(elem) : elem;
            if (!!domElement) { styleCreator.ApplyStyleProperties(domElement, subStyles.snapCenterStyle); }
        }
        return elem;
    }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances to position them relative to their containers
     * @param {HTMLElementLike} elem - the given element
     * @param {object} options - snap positioning options
     * @param {tf.types.horizontalPositioning} options.horPos - horizontal positioning
     * @param {tf.types.verticalPositioning} options.verPos - vertical positioning
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.ApplySnapStyle = function (elem, options) {
        var domElement = tf.dom.GetHTMLElementFrom(elem);
        if (!!domElement) {
            var snapStyleHor;
            var snapStyleVer;
            var singleSnapStyle;
            switch (options.horPos) {
                case tf.consts.positioningLeft: snapStyleHor = subStyles.snapLeftStyle; break;
                case tf.consts.positioningRight: snapStyleHor = subStyles.snapRightStyle; break;
            }
            switch (options.verPos) {
                case tf.consts.positioningTop: snapStyleVer = subStyles.snapTopStyle; break;
                case tf.consts.positioningBottom: snapStyleVer = subStyles.snapBotStyle; break;
            }
            if (!snapStyleHor) {
                if (!snapStyleVer) { singleSnapStyle = subStyles.snapCenterStyle; }
                else { snapStyleHor = subStyles.snapCenterHorStyle; }
            }
            if (!snapStyleVer) { snapStyleVer = subStyles.snapCenterVerStyle; }
            if (singleSnapStyle) { styleCreator.ApplyStyleProperties(domElement, singleSnapStyle); }
            else {
                styleCreator.ApplyStyleProperties(domElement, snapStyleHor);
                styleCreator.ApplyStyleProperties(domElement, snapStyleVer);
            }
        }
        return elem;
    }
    /**
     * @public
     * @function
     * @summary - Creates an [SVG Glyph Button]{@link tf.ui.SvgGlyphBtn} with an X glyph that can be used as a <b>close</b> button on popups and elsewhere
     * @param {boolean} lightBool - set to <b>true</b> to use the API's default <b>light</b> style settings, otherwise the default <b>dark</b> style settings are used
     * @param {tf.types.MultiDOMEventListenerCallBack} onClickCallBack - callback for [Click]{@link tf.consts.DOMEventNamesClick} events
     * @param {HTMLElementSizeOrPxNumber} dim - button dimension
     * @param {string} toolTipStr - optional tooltip
     * @returns {tf.ui.SvgGlyphBtn} - the instance
    */
    this.CloseXButtonForPopup = function (lightBool, onClickCallBack, dim, toolTipStr) {
        !!dim && (dim = subStyles.mapControlFontSizeEmNumber + "em");
        !!!toolTipStr && (toolTipStr = 'Close');
        var btn = new tf.ui.SvgGlyphBtn({ style: lightBool, glyph: tf.styles.SvgGlyphCloseXName, onClick: onClickCallBack, tooltip: toolTipStr, dim: dim });
        var btnDiv = btn.GetHTMLElement();
        //btnDiv.style.top = "50%";
        //btnDiv.style.transform = "translateY(-25%)";
        //btnDiv.style.transform = "translateY(-50%)";
        styleCreator.ApplyStyleProperties(btnDiv, subStyles.buttonDivMarginLeftStyle);
        return btn;
    }
    /**
     * @public
     * @function
     * @summary - Creates an [Img]{@link tf.dom.Img} instance from the given source, will "100%" width and height styles
     * @param {string} imgSrc - the given source
     * @returns {tf.dom.Img} - | {@link tf.dom.Img} the instance
    */
    this.CreateImageFullWidthHeight = function (imgSrc) { return new tf.dom.Img({ src: imgSrc, cssClass: tf.GetStyles().imgFullWidthHeightClass }); }
    /**
     * @public
     * @function
     * @summary - Creates a [Div]{@link tf.dom.Div} instance with the given text settings
     * @param {boolean} darkTextColorBool - set to <b>true</b> to use the API's default <b>dark</b> text color style settings, otherwise the default <b>light</b> style settings are used
     * @returns {tf.dom.Div} - | {@link tf.dom.Div} the instance
    */
    this.CreateListContentItem = function (darkTextColorBool) {
        var styles = tf.GetStyles();
        return styles.ApplyTextColorStyle(styles.ApplyMiddleVerticalAlignStyle(new tf.dom.Div({ cssClass: styles.paddedInlineBlockDivClass })), darkTextColorBool);
    }
    /**
     * @public
     * @function
     * @summary - Creates a [Div]{@link tf.dom.Div} instance with a background image from the given source
     * @param {string} imgSrc - the given source
     * @param {boolean} rectangularImageBool - set to <b>true</b> to create with 16x9 aspect ratio, otherwise a square is created
     * @returns {tf.dom.Div} - | {@link tf.dom.Div} the instance
    */
    this.CreateListContentItemWithImgBk = function (imgSrc, rectangularImageBool) {
        var styles = tf.GetStyles(), subStyles = styles.GetSubStyles();
        var divObj = styles.ApplyDivWithImgBkStyle(theThis.CreateListContentItem(false)), div = divObj.GetHTMLElement();
        div.style.height = (!!rectangularImageBool ? subStyles.imageThumbRectHeightEmNumber : subStyles.imageThumbSquareHeightEmNumber) + "em";
        div.style.backgroundImage = "url('" + imgSrc + "')";
        return divObj;
    }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on the HTML document body
     * @returns {void} - | {@link void} no return value
    */
    this.AddBodyStyle = function () { return addBodyStyle(); }
    /**
     * used for application containers
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.appContainerClass = divBaseClass + "app";
    /**
     * used for [Map]{@link tf.map.Map} containers
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.mapContainerClass = divBaseClass + "map-container";
    /**
     * used for [Map]{@link tf.map.Map} sub-containers
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapSubContainerClass = divBaseClass + "map";
    /**
     * used for layout sub-containers
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.leftSideContainerClass = divBaseClass + "left";
    /**
     * used for layout sub-containers
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.floatLeftSideContainerClass = divBaseClass + "floatLeft";
    /**
     * used for layout sub-containers
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.leftRightSideSeparatorClass = divBaseClass + "leftright";
    /**
     * used for layout sub-containers
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.rightSideContainerClass = divBaseClass + "right";
    /**
     * used for layout sub-containers
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.bottomContainerClass = divBaseClass + "bot";
    /**
     * used for layout sub-containers
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.topBottomSeparatorClass = divBaseClass + "topbot";
    /**
     * used for layout sub-containers
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.listContentClass = divBaseClass + "listcnt";
    /**
     * default used by {@link tf.dom.TextInput}
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.inputFormClass = divBaseClass + "inputForm";
    /**
     * block display padded div 
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.paddedBlockDivClass = divBaseClass + blockSuffix + paddedSuffix;
    /**
     * inline-block display padded div 
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.paddedInlineBlockDivClass = divBaseClass + inlineBlockSuffix + paddedSuffix;
    /**
     * block display padded div with a bottom border separator
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.paddedBlockDivWithBorderSeparatorClass = divBaseClass + "block-padded-bordersep";
    /**
     * inline-block display padded div with a right border separator
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.paddedInlineBlockDivWithBorderSeparatorClass = divBaseClass + "inline-block-padded-bordersep";
    /**
     * block display unpadded div
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.unPaddedBlockDivClass = divBaseClass + blockSuffix + unPaddedSuffix;
    /**
     * inline-block display unpadded div
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.unPaddedInlineBlockDivClass = divBaseClass + inlineBlockSuffix + unPaddedSuffix;
    /**
     * div with background image
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.divWithImgBkClass = divBaseClass + "imgbk";
    /**
     * div used with map measure
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapMeasureOverlayDivClass = divBaseClass + "mapoverlay";
    /**
     * div used with logos
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.imgLogoStyleClass = imgBaseClass + "logo";
    /**
     * used by {@link tf.dom.Img} with "100%" width and height
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.imgFullWidthHeightClass = imgBaseClass + "fullwh";
    /**
     * used by {@link tf.dom.Img} in map's info window
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.imgForInfoWindowClass = imgBaseClass + "infow";
    /**
     * used by {@link tf.ui.SvgGlyph} light style without hover
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.svgGlyphLightNoHoverStyleClass = svgGlyphStyleBaseClass + svgGlyphStyleNoHoverClass + lightClassName;
    /**
     * used by {@link tf.ui.SvgGlyph} light style
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.svgGlyphLightStyleClass = svgGlyphStyleBaseClass + lightClassName;
    /**
     * used by {@link tf.ui.SvgGlyph} dark style without hover
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.svgGlyphDarkNoHoverStyleClass = svgGlyphStyleBaseClass + svgGlyphStyleNoHoverClass + darkClassName;
    /**
     * used by {@link tf.ui.SvgGlyph} dark style
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.svgGlyphDarkStyleClass = svgGlyphStyleBaseClass + darkClassName;
    /**
     * used by {@link tf.ui.SvgGlyphBtn}
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.divSvgGlyphBtnClass = svgGlyphStyleBaseClass + "svgglyphbtndiv";
    /**
     * used by {@link tf.ui.TextBtn} light style
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.textDivBtnLightStyleClass = textDivBtnStyleBaseClass + lightClassName;
    /**
     * used by {@link tf.ui.TextBtn} dark style
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.textDivBtnDarkStyleClass = textDivBtnStyleBaseClass + darkClassName;
    /**
     * used by {@link tf.ui.TextBtn} map style
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.mapTextBtnClass = textDivBtnStyleBaseClass + "map";
    /**
     * bottom separator light style
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.bottomBorderSeparatorLightClass = borderBaseClass + "botlight";
    /**
     * bottom separator dark style
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.bottomBorderSeparatorDarkClass = borderBaseClass + "botdark";
    /**
     * right separator light style
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.rightBorderSeparatorLightClass = borderBaseClass + "rightlight";
    /**
     * right separator dark style
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.rightBorderSeparatorDarkClass = borderBaseClass + "rightdark";
    /**
     * used by {@link tf.ui.RadioButtonWithLabel}
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.radioClass = "tf-radio";
    /**
     * used by {@link tf.ui.RadioButtonWithLabel}
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.radioLabelClass = this.radioClass + "-label";
    /**
     * used by {@link tf.ui.CheckBoxWithLabel}
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.checkClass = "tf-check";
    /**
     * used by {@link tf.ui.CheckBoxWithLabel}
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.checkLabelClass = this.checkClass + "-label";
    /**
     * used by {@link tf.ui.Popup} captions
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.popupCaptionClass = divBaseClass + "popupcaption";
    /**
     * used by {@link tf.ui.Popup} container
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.popupContainerClass = divBaseClass + "popupcontainer";
    /**
     * used by {@link tf.ui.Popup} content
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.popupContentClass = divBaseClass + "popupcontent";
    /**
     * used by map toolbars
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapToolBarContainerClass = divBaseClass + "maptoolbarcontainer";
    /**
     * used by {@link tf.dom.Span}
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.spanClass = spanBaseClass + "span";
    /**
     * used by {@link tf.dom.Span}
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.spanCursorPointerClass = spanBaseClass + "spanCursorPointer";
    /**
     * used by {@link tf.urlapi.DLayer} in map Info Popups
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.dLayerInfoClass = divBaseClass + "dLayerInfo";
    /**
     * used by {@link tf.layout.HeaderContentFooter} layouts
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.hcfLayoutClass = divBaseClass + "hcfpage";
    /**
     * used by {@link tf.layout.HeaderContentFooter} layouts
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.hcfLayoutHeaderClass = divBaseClass + "hcfhrd";
    /**
     * used by {@link tf.layout.HeaderContentFooter} layouts
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.hcfLayoutFooterClass = divBaseClass + "hcfftr";
    /**
     * used by {@link tf.layout.HeaderContentFooter} layouts
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.hcfLayoutContentClass = divBaseClass + "hcfcnt";
    /**
     * used by {@link tf.dom.Link}
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.buttonShapedLinkClass = linkBaseClass + "buttonshape";
    /**
     * used by {@link tf.dom.TextInput}
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.inputTextClass = inputBaseClass + "input";
    /**
     * used by map controls
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapTFLogoControlClass = mapBaseClass + "tflogo";
    /**
     * used by map controls
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapAddressButtonClass = mapBaseClass + "addressbtn";
    /**
     * used by map controls
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapLayersButtonClass = mapBaseClass + "layersbtn";
    /**
     * used by map controls
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapTypeButtonClass = mapBaseClass + "typebtn";
    /**
     * used by map controls
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapMeasureButtonClass = mapBaseClass + "measurebtn";
    /**
     * used by map controls
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapDownloadButtonClass = mapBaseClass + "downloadbtn";
    /**
     * used by map controls
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapSourceButtonClass = mapBaseClass + "sourcebtn";
    /**
     * used by map controls
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapLocationButtonClass = mapBaseClass + "centerbtn";
    /**
     * used by map controls
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapUserLocationButtonClass = mapBaseClass + "userlocbtn";
    /**
     * used by map controls
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapFullScreenButtonClass = mapBaseClass + "fullscreenbtn";
    /**
     * used for visibility transitions
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.opacityVisibilityShowClass = utilBaseClass + "show";
    /**
     * used for visibility transitions
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.opacityVisibilityHideClass = utilBaseClass + "hide";
    /**
     * used by map controls
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapSvgGlyphInButtonClass = mapBaseClass + "svgglyphinbutton";
    function createSvgGlyphClasses(glyphColor, backgroundColor, glyphColorHover, backgroundColorHover) {
        var className = svgGlyphStyleBaseClass + tf.GetGlobalCounter().GetNext();
        var svgStyles = subStyles.CreateSvgGlyphStyles(glyphColor, backgroundColor, glyphColorHover, backgroundColorHover);
        var styles = [
            { styleName: svgPreSelectorStr + className, inherits: svgStyles.style },
            { styleName: svgPreSelectorStr + className + hoverSelectorStr, inherits: svgStyles.hoverStyle }
        ];
        styleCreator.CreateStyles(styles);
        return className;
    }
    function createTextDivBtnClasses(textColor, backgroundColor, textColorHover, backgroundColorHover) {
        var className = textDivBtnStyleBaseClass + tf.GetGlobalCounter().GetNext();
        var divStyles = subStyles.CreateTextDivBtnStyles(textColor, backgroundColor, textColorHover, backgroundColorHover);
        var styles = [
            { styleName: divPreSelectorStr + className, inherits: divStyles.style },
            { styleName: divPreSelectorStr + className + hoverSelectorStr, inherits: divStyles.hoverStyle }
        ];
        styleCreator.CreateStyles(styles);
        return className;
    }
    function addBodyStyle() { styleCreator.CreateStyle({ styleName: "body", inherits: subStyles.bodyStyle }); }
    function getFirstSupportedElementProp (propArrayOrObject) {
        var propFound = null;
        if (tf.js.GetIsValidObject(propArrayOrObject)) {
            var rootStyle = document.documentElement.style;
            for (var i in propArrayOrObject) { var thisProp = propArrayOrObject[i]; if (thisProp in rootStyle) { propFound = thisProp; break; } }
        }
        return propFound;
    }
    function findSupportedElementProps() {
        supportedTransformProp = getFirstSupportedElementProp(['transform', 'MozTransform', 'WebkitTransform', 'msTransform', 'OTransform']);
    }
    function createHiddenCanvas() {
        hiddenCanvas = document.createElement('canvas');
        var hiddenCanvasStyle = hiddenCanvas.style;
        hiddenCanvasStyle.display = 'none';
        hiddenCanvasStyle.width = "10em";
        hiddenCanvasStyle.height = "10em";
        hiddenCanvasStyle.zIndex = -100;
    }
    function createLiteralStyles() {
        var literalStyles = [];
        for (var literalStyle in literalStyles) { var thisStyle = literalStyles[literalStyle]; if (thisStyle.styleName) { styleCreator.CreateRawStyle(thisStyle.selector, thisStyle.style); } }
    }
    function createStyles() {
        var styles = [
            { styleName: dotPrefix + theThis.appContainerClass, inherits: subStyles.appContainerStyle },
            { styleName: dotPrefix + theThis.mapContainerClass, inherits: subStyles.mapContainerStyle },
            { styleName: dotPrefix + theThis.mapSubContainerClass, inherits: subStyles.mapSubContainerStyle },
            { styleName: dotPrefix + theThis.leftSideContainerClass, inherits: subStyles.leftSideContainerStyle },
            { styleName: dotPrefix + theThis.floatLeftSideContainerClass, inherits: subStyles.floatLeftSideContainerStyle },
            { styleName: dotPrefix + theThis.leftRightSideSeparatorClass, inherits: subStyles.leftRightSideSeparatorStyle },
            { styleName: dotPrefix + theThis.rightSideContainerClass, inherits: subStyles.rightSideContainerStyle },
            { styleName: dotPrefix + theThis.bottomContainerClass, inherits: subStyles.bottomContainerStyle },
            { styleName: dotPrefix + theThis.topBottomSeparatorClass, inherits: subStyles.topBottomSeparatorStyle },
            { styleName: dotPrefix + theThis.listContentClass, inherits: subStyles.listContentStyle },
            { styleName: dotPrefix + theThis.inputFormClass, inherits: subStyles.inputFormStyle },
            { styleName: dotPrefix + theThis.popupContainerClass, inherits: subStyles.popupContainerStyle },
            { styleName: dotPrefix + theThis.popupContentClass, inherits: subStyles.popupContentStyle },
            { styleName: dotPrefix + theThis.mapToolBarContainerClass, inherits: subStyles.mapToolBarContainerStyle },
            { styleName: dotPrefix + theThis.paddedBlockDivClass, inherits: subStyles.paddedBlockDivStyle },
            { styleName: dotPrefix + theThis.paddedInlineBlockDivClass, inherits: subStyles.paddedInlineBlockDivStyle },
            { styleName: dotPrefix + theThis.paddedBlockDivWithBorderSeparatorClass, inherits: subStyles.paddedBlockDivWithBorderSeparatorStyle },
            { styleName: dotPrefix + theThis.paddedInlineBlockDivWithBorderSeparatorClass, inherits: subStyles.paddedInlineBlockDivWithBorderSeparatorStyle },
            { styleName: dotPrefix + theThis.unPaddedBlockDivClass, inherits: subStyles.unPaddedBlockDivStyle },
            { styleName: dotPrefix + theThis.unPaddedInlineBlockDivClass, inherits: subStyles.unPaddedInlineBlockDivStyle },
            { styleName: dotPrefix + theThis.divWithImgBkClass, inherits: subStyles.divWithImgBkStyle },
            { styleName: dotPrefix + theThis.inputTextClass + ":-moz-placeholder", inherits: subStyles.inputTextPlaceholderStyle },
            { styleName: dotPrefix + theThis.inputTextClass + "::-moz-placeholder", inherits: subStyles.inputTextPlaceholderStyle },
            { styleName: dotPrefix + theThis.inputTextClass + ":-ms-input-placeholder", inherits: subStyles.inputTextPlaceholderStyle },
            { styleName: dotPrefix + theThis.inputTextClass + "::-webkit-input-placeholder", inherits: subStyles.inputTextPlaceholderStyle },
            { styleName: dotPrefix + theThis.inputTextClass + "::-ms-clear", inherits: subStyles.noneDisplayStyle },
            { styleName: dotPrefix + theThis.inputTextClass + ", " + dotPrefix + theThis.inputTextClass + inputPosSelectorStr + ", " + dotPrefix + theThis.inputTextClass + inputPosSelectorStr + focusSelectorStr, inherits: subStyles.inputTextStyle },
            { styleName: dotPrefix + theThis.radioLabelClass + labelPosSelectorStr, inherits: subStyles.radioLabelStyle },
            { styleName: dotPrefix + theThis.radioClass + inputTypeRadioPosSelectorStr, inherits: subStyles.radioRadioStyle },
            { styleName: dotPrefix + theThis.radioClass + inputTypeRadioPosSelectorStr + checkedSelectorStr + " +" + labelPosSelectorStr, inherits: subStyles.radioRadioAndLabelCheckedStyle },
            { styleName: dotPrefix + theThis.radioClass + inputTypeRadioPosSelectorStr + ", " + dotPrefix + theThis.radioLabelClass + labelPosSelectorStr + beforeSelectorStr, inherits: subStyles.radioRadioAndLabelStyleBefore },
            { styleName: dotPrefix + theThis.radioClass + inputTypeRadioPosSelectorStr + checkedSelectorStr + " +" + labelPosSelectorStr + beforeSelectorStr, inherits: subStyles.radioRadioAndLabelSelStyleBefore },
            { styleName: dotPrefix + theThis.checkLabelClass + labelPosSelectorStr, inherits: subStyles.checkLabelStyle },
            { styleName: dotPrefix + theThis.checkClass + inputTypeCheckPosSelectorStr, inherits: subStyles.checkCheckStyle },
            { styleName: dotPrefix + theThis.checkClass + inputTypeCheckPosSelectorStr + checkedSelectorStr + " +" + labelPosSelectorStr, inherits: subStyles.checkCheckAndLabelCheckedStyle },
            { styleName: dotPrefix + theThis.checkClass + inputTypeCheckPosSelectorStr + ", " + dotPrefix + theThis.checkLabelClass + labelPosSelectorStr + beforeSelectorStr, inherits: subStyles.checkCheckAndLabelStyleBefore },
            { styleName: dotPrefix + theThis.checkClass + inputTypeCheckPosSelectorStr + checkedSelectorStr + " +" + labelPosSelectorStr + beforeSelectorStr, inherits: subStyles.checkCheckAndLabelSelStyleBefore },
            { styleName: dotPrefix + theThis.mapMeasureOverlayDivClass, inherits: subStyles.mapMeasureOverlayDivStyle },
            { styleName: dotPrefix + theThis.hcfLayoutClass, inherits: subStyles.hcfLayoutStyle },
            { styleName: dotPrefix + theThis.hcfLayoutHeaderClass, inherits: subStyles.hcfLayoutHeaderStyle },
            { styleName: dotPrefix + theThis.hcfLayoutFooterClass, inherits: subStyles.hcfLayoutFooterStyle },
            { styleName: dotPrefix + theThis.hcfLayoutContentClass, inherits: subStyles.hcfLayoutContentStyle },
            { styleName: dotPrefix + theThis.popupCaptionClass, inherits: subStyles.popupCaptionStyle },
            { styleName: dotPrefix + theThis.spanClass, inherits: subStyles.spanStyle },
            { styleName: dotPrefix + theThis.spanCursorPointerClass, inherits: subStyles.spanCursorPointerStyle },
            { styleName: dotPrefix + theThis.dLayerInfoClass, inherits: subStyles.dLayerInfoStyle },
            { styleName: dotPrefix + theThis.dLayerInfoClass + imgPosSelectorStr, inherits: subStyles.dLayerInfoImgStyle },
            { styleName: dotPrefix + theThis.dLayerInfoClass + linkPosSelectorStr, inherits: subStyles.dLayerInfoLinkStyle },
            { styleName: dotPrefix + theThis.dLayerInfoClass + linkPosSelectorStr + linkSelectorStr, inherits: subStyles.dLayerInfoLinkStyle },
            { styleName: dotPrefix + theThis.dLayerInfoClass + linkPosSelectorStr + visitedSelectorStr, inherits: subStyles.dLayerInfoLinkStyle },
            { styleName: dotPrefix + theThis.dLayerInfoClass + linkPosSelectorStr + hoverSelectorStr, inherits: subStyles.dLayerInfoLinkHoverStyle },
            { styleName: dotPrefix + theThis.dLayerInfoClass + linkPosSelectorStr + activeSelectorStr, inherits: subStyles.dLayerInfoLinkStyle },
            { styleName: dotPrefix + theThis.dLayerInfoClass + spanPosSelectorStr, inherits: subStyles.dLayerInfoSpanStyle },
            { styleName: linkPreSelectorStr + theThis.buttonShapedLinkClass, inherits: subStyles.buttonShapedLinkStyle },
            { styleName: linkPreSelectorStr + theThis.buttonShapedLinkClass + hoverSelectorStr, inherits: subStyles.buttonShapedLinkHoverStyle },
            { styleName: imgPreSelectorStr + theThis.imgLogoStyleClass, inherits: subStyles.imgLogoStyle },
            { styleName: imgPreSelectorStr + theThis.imgFullWidthHeightClass, inherits: subStyles.imgFullWidthHeightStyle },
            { styleName: imgPreSelectorStr + theThis.imgForInfoWindowClass, inherits: subStyles.imgForInfoWindowStyle },
            { styleName: svgPreSelectorStr + theThis.svgGlyphLightNoHoverStyleClass, inherits: subStyles.svgGlyphLightNoHoverStyle },
            { styleName: svgPreSelectorStr + theThis.svgGlyphLightStyleClass, inherits: subStyles.svgGlyphLightStyle },
            { styleName: svgPreSelectorStr + theThis.svgGlyphLightStyleClass + hoverSelectorStr, inherits: subStyles.svgGlyphLightStyleHover },
            { styleName: svgPreSelectorStr + theThis.svgGlyphDarkNoHoverStyleClass, inherits: subStyles.svgGlyphDarkNoHoverStyle },
            { styleName: svgPreSelectorStr + theThis.svgGlyphDarkStyleClass, inherits: subStyles.svgGlyphDarkStyle },
            { styleName: svgPreSelectorStr + theThis.svgGlyphDarkStyleClass + hoverSelectorStr, inherits: subStyles.svgGlyphDarkStyleHover },
            { styleName: svgPreSelectorStr + theThis.mapSvgGlyphInPopupClass, inherits: subStyles.mapSvgGlyphInPopupStyle },
            { styleName: svgPreSelectorStr + theThis.mapSvgGlyphInPopupClass + hoverSelectorStr, inherits: subStyles.mapSvgGlyphInPopupHoverStyle },
            { styleName: svgPreSelectorStr + theThis.mapSvgGlyphInButtonClass, inherits: subStyles.mapSvgGlyphInButtonStyle },
            { styleName: dotPrefix + theThis.divSvgGlyphBtnClass, inherits: subStyles.divSvgGlyphBtnStyle },
            { styleName: divPreSelectorStr + theThis.textDivBtnLightStyleClass, inherits: subStyles.textDivBtnLightStyle },
            { styleName: divPreSelectorStr + theThis.textDivBtnLightStyleClass + hoverSelectorStr, inherits: subStyles.textDivBtnLightStyleHover },
            { styleName: divPreSelectorStr + theThis.textDivBtnDarkStyleClass, inherits: subStyles.textDivBtnDarkStyle },
            { styleName: divPreSelectorStr + theThis.textDivBtnDarkStyleClass + hoverSelectorStr, inherits: subStyles.textDivBtnDarkStyleHover },
            { styleName: divPreSelectorStr + theThis.mapTextBtnClass, inherits: subStyles.mapTextBtnStyle },
            { styleName: divPreSelectorStr + theThis.mapTextBtnClass + hoverSelectorStr, inherits: subStyles.mapTextBtnStyleHover },
            { styleName: dotPrefix + theThis.bottomBorderSeparatorLightClass, inherits: subStyles.bottomBorderSeparatorLightStyle },
            { styleName: dotPrefix + theThis.bottomBorderSeparatorDarkClass, inherits: subStyles.bottomBorderSeparatorDarkStyle },
            { styleName: dotPrefix + theThis.rightBorderSeparatorLightClass, inherits: subStyles.rightBorderSeparatorLightStyle },
            { styleName: dotPrefix + theThis.rightBorderSeparatorDarkClass, inherits: subStyles.rightBorderSeparatorDarkStyle },
            { styleName: dotPrefix + theThis.mapTFLogoControlClass, inherits: subStyles.mapTFLogoControlStyle },
            { styleName: dotPrefix + theThis.mapAddressButtonClass, inherits: subStyles.mapAddressButtonStyle },
            { styleName: dotPrefix + theThis.mapLayersButtonClass, inherits: subStyles.mapLayersButtonStyle },
            { styleName: dotPrefix + theThis.mapTypeButtonClass, inherits: subStyles.mapTypeButtonStyle },
            { styleName: dotPrefix + theThis.mapMeasureButtonClass, inherits: subStyles.mapMeasureButtonStyle },
            { styleName: dotPrefix + theThis.mapDownloadButtonClass, inherits: subStyles.mapDownloadButtonStyle },
            { styleName: dotPrefix + theThis.mapSourceButtonClass, inherits: subStyles.mapSourceButtonStyle },
            { styleName: dotPrefix + theThis.mapLocationButtonClass, inherits: subStyles.mapLocationButtonStyle },
            { styleName: dotPrefix + theThis.mapUserLocationButtonClass, inherits: subStyles.mapUserLocationButtonStyle },
            { styleName: dotPrefix + theThis.mapFullScreenButtonClass, inherits: subStyles.mapFullScreenButtonStyle },
            { styleName: ".ol-viewport .ol-unselectable", inherits: subStyles.mapViewPortUnSelectableStyle },
            { styleName: ".ol-zoom", inherits: subStyles.mapZoomStyle },
            { styleName: ".ol-zoom .ol-zoom-in", inherits: subStyles.mapZoomInBorderRadiusStyle },
            { styleName: ".ol-zoom .ol-zoom-out", inherits: subStyles.mapZoomOutBorderRadiusStyle },
            { styleName: ".ol-zoomslider", inherits: subStyles.mapZoomSliderStyle },
            { styleName: ".ol-rotate", inherits: subStyles.mapRotateStyle },
            { styleName: ".ol-rotate.ol-hidden", inherits: subStyles.mapRotateHiddenStyle },
            { styleName: ".ol-compass", inherits: subStyles.mapCompassStyle },
            { styleName: ".ol-scale-line", inherits: subStyles.mapScaleLineStyle },
            { styleName: ".ol-scale-line-inner", inherits: subStyles.mapScaleLineInnerStyle },
            { styleName: ".ol-control", inherits: subStyles.mapControlStyle },
            { styleName: ".ol-control" + hoverSelectorStr, inherits: subStyles.mapControlHoverStyle },
            { styleName: ".ol-control" + buttonPosSelectorStr + focusSelectorStr + ", " + ".ol-control" + buttonPosSelectorStr + hoverSelectorStr, inherits: subStyles.mapControlButtonFocusHoverStyle },
            { styleName: ".ol-control" + buttonPosSelectorStr, inherits: subStyles.mapControlButtonStyle },
            { styleName: ".ol-control" + buttonPosSelectorStr + "::-moz-focus-inner", inherits: subStyles.mapControlButtonMozFocusInnerStyle },
            { styleName: ".ol-overviewmap", inherits: subStyles.mapOverviewMapStyle },
            { styleName: ".ol-overviewmap.ol-uncollapsible", inherits: subStyles.mapOverviewMapUnCollapsibleStyle },
            { styleName: ".ol-overviewmap .ol-overviewmap-map, .ol-overviewmap" + buttonPosSelectorStr, inherits: subStyles.mapControlButtonStyle },
            { styleName: ".ol-overviewmap .ol-overviewmap-map", inherits: subStyles.mapOverviewMapMapStyle },
            { styleName: ".ol-overviewmap:not(.ol-collapsed)" + buttonPosSelectorStr, inherits: subStyles.mapOverviewMapButtonNotCollapsedStyle },
            { styleName: ".ol-overviewmap.ol-collapsed .ol-overviewmap-map, .ol-overviewmap.ol-uncollapsible" + buttonPosSelectorStr, inherits: subStyles.mapOverviewMapButtonCollapsedStyle },
            { styleName: ".ol-overviewmap:not(.ol-collapsed)", inherits: subStyles.mapOverviewMapNotCollapsedStyle },
            { styleName: ".ol-overviewmap-box", inherits: subStyles.mapOverviewMapBoxStyle },
            { styleName: ".ol-button-text-span", inherits: subStyles.mapButtonTextSpanStyle },
            { styleName: dotPrefix + theThis.opacityVisibilityShowClass, inherits: subStyles.opacityVisibilityShowStyle },
            { styleName: dotPrefix + theThis.opacityVisibilityHideClass, inherits: subStyles.opacityVisibilityHideStyle },
            {}
        ];
        styleCreator.CreateStyles(styles);
    }
    function initialize() {
        styleCreator = new tf.styles.CSSStyleCreator(theThis);
        subStyles = new tf.styles.SubStyles(theThis, alternativeSpecs);
        createHiddenCanvas();
        findSupportedElementProps();
        //styleCreator.CreateRawStyle("@font-face", subStyles.fontFaceStyleContentStr);
        createLiteralStyles();
        createStyles();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * @public
 * @class
 * @summary - Counter instances are used to generate unique numbers
*/
tf.js.Counter = function () {
    var counter = 0;
    /**
     * @public
     * @function
     * @summary - Retrieves the next number, returns <b>1</b> the first time it is called
     * @returns {number} - | {@link number} the next number
    */
    this.GetNext = function () { return ++counter; }
};
/**
 * @public
 * @class
 * @summary - The {@link singleton} instance of this class, obtainable by calling {@link tf.units.GetDebug}, aids in debugging
*/
tf.Debug = function () {
    var theThis, isTest;
    this.AddExtent = function(extent, layer, lineColor) {
        var coords = [
            [extent[0], extent[1]],
            [extent[0], extent[3]],
            [extent[2], extent[3]],
            [extent[2], extent[1]],
            [extent[0], extent[1]]
        ];
        var line_color = lineColor !== undefined ? lineColor : "#f00";
        var style = { line: true, line_color: line_color, line_width: 5, zindex: 10 };
        var extentFeature = new tf.map.Feature({ type: "linestring", coordinates: coords, style: style });
        layer.AddMapFeature(extentFeature);
    }
   /**
     * @public
     * @function
     * @summary - Logs the given string to the Browser's console only if using the Test platform of the API
     * @param {string} logString - the given string
     * @returns {void} - | {@link void} no return value
     * @see {@link tf.platform.GetIsTest}
    */
    this.LogIfTest = function (logString) { return logIfTest(logString); }
    /**
     * @public
     * @function
     * @summary - Converts the given object to JSON format and writes it to a file of the given name, works on Firefox and not on all Browsers
     * @param {string} name - the given name
     * @param {object} object - the given object
     * @returns {void} - | {@link void} no return value
    */
    this.FileLog = function (name, object) { if (isTest) { saveTextAsFile(name, "var " + name + " = " + JSON.stringify(object)); } }
    /**
     * @public
     * @function
     * @summary - Writes the given string to a file of the given name, works on Firefox and not on all Browsers
     * @param {string} name - the given name
     * @param {string} textToWrite - the given text
     * @returns {void} - | {@link void} no return value
    */
    this.SaveAsTextFile = function (name, textToWrite) { return saveTextAsFile(name, textToWrite); }
    /**
     * @public
     * @function
     * @summary - Logs any arguments passed to the console
     * @returns {void} - | {@link void} no return value
    */
    this.DebugArguments = function () { for (var a in arguments) { logIfTest(a + ': ' + arguments[a]); } }
    function logIfTest(string) { if (isTest) { console.log(string); } }
    function saveTextAsFile(name, textToWrite) {
        var textFileAsBlob = new Blob([textToWrite], { type: 'text/plain' });
        var downloadLink = document.createElement("a");
        downloadLink.download = name;
        downloadLink.innerHTML = "Download File";
        if (window.webkitURL != null) { downloadLink.href = window.webkitURL.createObjectURL(textFileAsBlob); }
        else {
            downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
            downloadLink.onclick = function (event) { (function () { document.body.removeChild(event.target); })(); };
            downloadLink.style.display = "none";
            document.body.appendChild(downloadLink);
        }
        downloadLink.click();
    }
    function initialize() {
        isTest = tf.platform.GetIsTest();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/*tf.debug.RotationTester = function (settings) {
    var theThis, map, actualAngle, anglePopup, anglesStr, isDeleted, debug;
    this.OnDelete = function () { return onDelete(); }
    function onDelete() { if (!isDeleted) { isDeleted = true; if (anglePopup) { anglePopup.Show(false); anglePopup = null; } } }
    function showActualAngle() { debug.LogIfTest('t: ' + actualAngle); }
    function onChangeAngle(newAngleStr) {
        actualAngle = anglesStr[newAngleStr];
        if (actualAngle !== undefined) {
            //map.SetRotationRad(actualAngle);
            var stepMillis = 1000;
            showActualAngle();
            map.StartAnimation(function (request) {
                var nextStep;
                if (request.step == 0) {
                    nextStep = { duration: stepMillis, easing: tf.units.EaseLinear, rotation: actualAngle, notifyListeners: false };
                }
                else if (nextStep != -1) { setTimeout(showActualAngle, 100); }
                return nextStep;
            }, theThis);
        }
    }
    function onCloseAngles() { if (!isDeleted) { setTimeout(function () { anglePopup.Show(true); }, 100); } }
    function createAnglePopup() {
        var angleNames = [];
        anglesStr = {};
        for (var i = 0 ; i < 360 ; i += 30) {
            var angleRad = tf.units.DegreesToRadians(i), angleStr = '' + i;
            anglesStr[angleStr] = angleRad; angleNames.push(angleStr);
        }
        anglePopup = new tf.ui.RadioOrCheckPopupFromData({
            isRadioList: true, optionalScope: theThis, title: "Angles", data: angleNames, isInline: true, onClick: onChangeAngle,
            onClose: onCloseAngles, container: map.GetMapContainer(), horPos: "center", verPos: "bottom", marginVer: "0.5em", zIndex: 1000
        });
        anglePopup.Show(true);
    }
    function initialize() {
        debug = tf.GetDebug();
        settings = tf.js.GetValidObjectFrom(settings);
        if (map = tf.js.GetMapFrom(settings.map)) { createAnglePopup(); }
        else { isDeleted = true; }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};*/
/**
 * Settings used in the creation of [Route Tracker]{@link tf.map.RouteTracker} instances
 * @private
 * @typedef {object} tf.types.RouteTrackerSettings
 * @property {tf.map.Map} map - the given map instance
 * @property {array<tf.types.mapCoordinates>} lineStringCoords - the given route coordinates, in [GeoJSON linestring format]{@link tf.types.GeoJSONGeometryType}
*/
/**
 * @private
 * @class
 * @summary - Route Tracker instances are created to display and follow a given route on a given [map]{@link tf.map.Map} instance
 * @param {tf.types.RouteTrackerSettings} settings - creation settings
*/
/*
tf.map.RouteTracker = function (settings) {
    var theThis, map, coords, routeFeature, postComposeListener, curIndex, directions, routePointFeature, autoPlay;
    this.GoToIndex = function (index, timeInMillis) { return goToIndex(index, timeInMillis); }
    this.GetCurrentIndex = function () { return curIndex; }
    this.SetAutoPlay = function (bool) { autoPlay = !!bool; }
    this.GetAutoPlay = function () { return autoPlay; }
    this.OnDelete = function () { return onDelete(); }
    function onDelete() {
        if (!!map) {
            if (!!postComposeListener) { postComposeListener.OnDelete(); postComposeListener = null; }
            routeFeature = null;
            routePointFeature = null;
            map.Render();
            map = null;
        }
    }
    function onPostCompose(notification) {
        if (!!map) {
            var show = notification.showFeatureImmediately;
            if (!!routeFeature) { show(routeFeature); }
            if (!!routePointFeature) { show(routePointFeature); }
        }
    }
    function goToIndex(index, timeInMillis) {
        if (!!map) {
            //var stepMillis = 100;
            //var stepMillis = 1000;
            //var stepMillis = 3000;
            var stepMillis = tf.js.GetFloatNumberInRange(timeInMillis, 100, 1000000, 1000);
            index = tf.js.GetIntNumberInRange(index, 0, coords.length - 1, 0);
            curIndex = index;
            map.StartAnimation(function (request) {
                var nextStep;
                if (request.step == 0) {
                    var nextRotation = !!directions ? directions[index] : undefined;
                    if (nextRotation !== undefined) { nextRotation -= Math.PI / 2; }
                    nextStep = { duration: stepMillis, center: coords[index], rotation: nextRotation, easing: tf.units.EaseLinear, notifyListeners: false };
                }
                return nextStep;
            }, theThis);
            if (autoPlay) { setTimeout(function () { if (++index == coords.length) { index = 0; } goToIndex(index, timeInMillis); }, stepMillis + 50); }
        }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (!!(map = tf.js.GetMapFrom(settings.map)) && tf.js.GetLooksLikeLineStringCoords(coords = settings.lineStringCoords)) {
            var routeStyle = settings.routeStyle, pointStyle = settings.pointStyle;
            map.ShowPanel(tf.consts.panelNameMapLocation, false);
            var routeStyle = [{ line: true, line_width: 8, line_color: "#f00", zindex: 1, snaptopixel: false }, {
                line: true, line_width: 2, line_color: "#fff", zindex: 2, line_dash: [16, 4], snaptopixel: false
            }];
            //pointStyle = [{ circle: true, circle_radius: 6, line: true, line_color: "#000", fill: true, fill_color: "#f00", fill_opacity: 30, zindex: 3, snaptopixel: false }];
            if (tf.js.GetIsValidObject(routeStyle)) {
                routeFeature = new tf.map.Feature({ type: "linestring", coordinates: coords, style: routeStyle });
            }
            if (tf.js.GetIsValidObject(pointStyle)) {
                routePointFeature = new tf.map.Feature({ type: "multipoint", coordinates: coords, style: pointStyle });
            }
            directions = tf.js.GetIsArrayWithMinLength(settings.directions, settings.lineStringCoords.length) ? settings.directions : null;
            postComposeListener = map.AddListener(tf.consts.mapPostComposeEvent, onPostCompose);
            curIndex = settings.startIndex !== undefined ? tf.js.GetIntNumberInRange(settings.startIndex, 0, coords.length, 0) : 0;
            if (autoPlay = tf.js.GetBoolFromValue(settings.autoPlay, false)) { goToIndex(curIndex, settings.stepTimeInMillis); }
            else { map.Render(); }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
*/
// tf.events
/**
 * @public
 * @function
 * @summary - Stops propagation of the given {@link DOMEvent}
 * @param {DOMEvent} event - the event
 * @returns {void} - | {@link void} no return value
*/
tf.events.StopDOMEvent = function (event) {
    //tf.GetDebug().LogIfTest('.');
    if (!event) { if (window.event) { event = window.event; } }
    if (!!event && typeof event === "object") {
        //if (event.stopPropagation) { event.stopPropagation(); }
        if (event.cancelBubble !== undefined) { event.cancelBubble = true; }
        if (event.returnValue != null) { event.returnValue = false; }
        if (event.preventDefault) { event.preventDefault(); }
        if (event.cancel != null) { event.cancel = true; }
    }
    return false;
};
/**
 * @public
 * @class
 * @summary Delayed Call Back instances receive an arbitrary number notifications during a maximum given period of time, before delivering only the last one of these notifications to the given callback.
 * Use Delayed Call Back to avoid reacting immediately to each instance of an event that may fire in rapid succession during a short period of time
 * @param {number} callBackDelay - the number of milliseconds during which notifications are delayed
 * @param {function} callBack - the callback
 * @param {object} optionalScope - optional scope used with <b>callBack</b>
 */
tf.events.DelayedCallBack = function (callBackDelay, callBack, optionalScope) {
    var theThis, theDelay, theCallBack, theThisForCallBack, lastNotificationTime, waitingForTimeOut, theNotification;
    /**
     * @public
     * @function
     * @summary - Use this function with an event listener to delay event notifications
     * @returns {void} - | {@link void} no return value
    */
    this.DelayCallBack = function () {
        lastNotificationTime = +new Date(); theNotification = arguments;
        if (waitingForTimeOut == undefined) { waitingForTimeOut = setTimeout(delayCallBack, theDelay); }
    }
    /**
     * @public
     * @function
     * @summary - Use this function to cancel a pending delayed callback
     * @returns {void} - | {@link void} no return value
    */
    this.CancelCallBack = function () {
        if (waitingForTimeOut != undefined) { clearTimeout(waitingForTimeOut); waitingForTimeOut = undefined; }
    }
    /**
     * @public
     * @function
     * @summary - Use this function to execute a pending callback immediatelly
     * @returns {void} - | {@link void} no return value
    */
    this.CallBackNow = function () { theThis.CancelCallBack(); doCallBack(); }
    function doCallBack() { theCallBack.apply(theThisForCallBack, theNotification); }
    function delayCallBack() { if (+new Date() - lastNotificationTime < theDelay) { waitingForTimeOut = setTimeout(delayCallBack, theDelay); } else { waitingForTimeOut = undefined; doCallBack(); } }
    function initialize() {
        theDelay = callBackDelay;
        theCallBack = callBack;
        theThisForCallBack = optionalScope;
        lastNotificationTime = +new Date(1, 1, 2000, 12, 0, 0);
        waitingForTimeOut = undefined;
        theNotification = null;
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Settings used in the creation of [Dom Event Listener]{@link tf.events.DOMEventListener} instances
 * @public
 * @typedef {object} tf.types.DOMEventListenerSettings
 * @property {HTMLElementLike} target - the element whose events will be notified
 * @property {tf.types.DOMEventName} eventName - the name of the event to listen for
 * @property {tf.types.DOMEventListenerCallBack} callBack - to receive event notifications
*/
/**
 * @public
 * @class
 * @summary DOM Event Listener instances are created by calling the API function [AddDomEventListener]{@link tf.events.AddDOMEventListener}
 * @param {DOMEventListenerSettings} settings - creation settings
 */
tf.events.DOMEventListener = function (settings) {
    var theThis, target, eventName, callBack;
    /**
     * @public
     * @function
     * @summary - Use this function to delete the event listener and stop receiving notifications
     * @returns {void} - | {@link void} no return value
    */
    this.OnDelete = function () { if (!!callBack) { tf.events.DelDOMEventListener(target, eventName, callBack); callBack = null; } }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (!!(callBack = tf.js.GetFunctionOrNull(settings.callBack)) &&
            !!tf.dom.GetDOMEventListenerFrom(settings.target) &&
            !!tf.js.GetIsNonEmptyString(settings.eventName)) {
            eventName = settings.eventName;
            target = settings.target;
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Notifications sent by [Multi Dom Event Listener]{@link tf.events.MultiDOMEventListener} instances
 * @public
 * @typedef {object} tf.types.MultiDOMEventListenerNotification
 * @property {tf.events.MultiDOMEventListener} sender - the instance sending the notification
 * @property {DOMEvent} event - the event being notified
 * @property {tf.types.DOMEventName} eventName - the name of the event being notified
 * @property {HTMLElementLike} target - the element whose event is being notified
 * @property {object} callBackSettings - application defined properties, provided in the creation of the {@link tf.events.MultiDOMEventListener} instance
*/
/**
 * A callback function that can be used in the creation of [AddDOMEventListener]{@link tf.events.MultiDOMEventListener} instances
 * @public
 * @callback tf.types.MultiDOMEventListenerCallBack
 * @param {tf.types.MultiDOMEventListenerNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * Settings used in the creation of [Multi Dom Event Listener]{@link tf.events.MultiDOMEventListener} instances
 * @public
 * @typedef {object} tf.types.MultiDOMEventListenerSettings
 * @property {HTMLElementLike} target - the element whose events will be notified
 * @property {enumerable<tf.types.DOMEventName>} eventNames - the names of the events to listen for
 * @property {tf.types.MultiDOMEventListenerCallBack} callBack - to receive event notifications
 * @property {object} optionalScope - optional scope used with <b>callBack</b>
 * @property {object} callBackSettings - application defined properties, provided in the creation of the {@link tf.events.MultiDOMEventListener} instance
 * @property {function} onPreNotify - optional callback that receives, and may alter, each notification object before it is sent to listeners
 * @property {object} preNotifyScope - optional scope used with <b>onPreNotify</b>
*/
/**
 * @public
 * @class
 * @summary Multi DOM Event Listener instances notify one or more [DOMEvents]{@link DOMEvent} to a single callback
 * @param {MultiDOMEventListenerSettings} settings - creation settings
 */
tf.events.MultiDOMEventListener = function (settings) {
    var theThis, target, DOMListeners, callBack, optionalScope, callBackSettings, preNotify, preNotifyScope, lastEvent, lastEventName;
    /**
     * @public
     * @function
     * @summary - Retrieves the element whose events are being monitored
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the element
    */
    this.GetTarget = function () { return target; }
    /**
     * @public
     * @function
     * @summary - Retrieves the last event received and notified
     * @returns {DOMEvent} - | {@link DOMEvent} the element
    */
    this.GetLastEvent = function () { return lastEvent; }
    /**
     * @public
     * @function
     * @summary - Retrieves the name last event received and notified
     * @returns {tf.types.DOMEventName} - | {@link tf.types.DOMEventName} the name of the last event
    */
    this.GetLastEventName = function () { return lastEventName; }
    /**
     * @public
     * @function
     * @summary - Use this function to delete the event listeners associated with this instance and stop receiving notifications
     * @returns {void} - | {@link void} no return value
    */
    this.OnDelete = function () { if (!!DOMListeners) { for (var i in DOMListeners) { DOMListeners[i].OnDelete(); } DOMListeners = null; } }
    function notifyEvent(eventNotification) {
        var retVal = callBack.call(optionalScope, eventNotification);
        return retVal != undefined ? retVal : true;
    }
    function onReceivedEvent(event, eventName) {
        if (!event) { if (window.event) { event = window.event; } }
        switch (eventName) {
            case tf.consts.DOMEventNamesClick:
                //tf.events.StopDOMEvent(event);
                break;
            default:
                break;
        }
        lastEventName = eventName;
        lastEvent = event;
        var eventNotification = { sender: theThis, callBackSettings: callBackSettings, event: event, eventName: eventName, target: target };
        if (!!preNotify) { preNotify.call(preNotifyScope, eventNotification); }
        return notifyEvent(eventNotification);
    }
    function makeEventNotificationCallBack(eventName) { return function (event) { return onReceivedEvent(event, eventName) }; }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (!!tf.dom.GetDOMEventListenerFrom(settings.target) &&
            !!tf.js.GetIsValidObject(settings.eventNames) &&
            !!(callBack = tf.js.GetFunctionOrNull(settings.callBack))) {
            optionalScope = settings.optionalScope;
            target = settings.target;
            callBackSettings = settings.callBackSettings;
            preNotify = tf.js.GetFunctionOrNull(settings.onPreNotify);
            preNotifyScope = settings.preNotifyScope;
            DOMListeners = [];
            for (var i in settings.eventNames) {
                var eventName = settings.eventNames[i];
                if (tf.js.GetIsNonEmptyString(eventName)) {
                    DOMListeners.push(tf.events.AddDOMEventListener(target, eventName, makeEventNotificationCallBack(eventName)));
                }
            }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Notifications sent by {@link tf.events.DOMFullScreenChangeListener} instances
 * @public
 * @typedef {object} tf.types.DOMFullScreenChangeListenerNotification
 * @property {tf.events.DOMFullScreenChangeListener} sender - the instance sending the notification
 * @property {DOMEvent} event - the event being notified
 * @property {object} callBackSettings - application defined properties, provided in the creation of the {@link tf.events.DOMFullScreenChangeListener} instance
*/
/**
 * A callback function that can be used in the creation of instances of [DOM Full Screen Change Listener]{@link tf.events.DOMFullScreenChangeListener}
 * @public
 * @callback tf.types.DOMFullScreenChangeListenerCallBack
 * @param {tf.types.DOMFullScreenChangeListenerNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * Settings used in the creation of [DOM Full Screen Change Listener]{@link tf.events.DOMFullScreenChangeListener} instances
 * @public
 * @typedef {object} tf.types.DOMFullScreenChangeListenerSettings
 * @property {tf.types.DOMFullScreenChangeListenerCallBack} callBack - to receive event notifications
 * @property {object} optionalScope - optional scope used with <b>callBack</b>
 * @property {object} callBackSettings - application defined properties, to be passed to <b>callBack</b> during notifications
*/
/**
 * @public
 * @class
 * @summary DOM Full Screen Change Listener instances report to a given callback when the Browser enters or leaves full screen mode
 * @param {tf.types.DOMFullScreenChangeListenerSettings} settings - creation settings
 */
tf.events.DOMFullScreenChangeListener = function (settings) {
    var theThis, onDelayFullScreen, optionalScope, callBack, callBackSettings, DOMListeners;
    /**
     * @public
     * @function
     * @summary - Checks if fullscreen mode is currently on
     * @returns {bool} - | {@link bool} <b>true</b> if in fullscreen mode, <b>false</b> otherwise
    */
    this.GetIsFullScreen = function () { return tf.browser.GetIsFullScreen(); }
    /**
     * @public
     * @function
     * @summary - Use this function to delete the event listener and stop receiving notifications
     * @returns {void} - | {@link void} no return value
    */
    this.OnDelete = function () { if (!!DOMListeners) { for (var i in DOMListeners) { DOMListeners[i].OnDelete(); } DOMListeners = null; } }
    function onFullScreenChange(evt) {
        callBack.call(optionalScope, { sender: theThis, callBackSettings: callBackSettings, event: evt });
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (!!tf.js.GetFunctionOrNull(settings.callBack)) {
            optionalScope = settings.optionalScope;
            callBack = settings.callBack;
            callBackSettings = settings.callBackSettings;
            onDelayFullScreen = new tf.events.DelayedCallBack(50, onFullScreenChange, theThis);
            DOMListeners = [];
            for (var i in tf.consts.allFullScreenEventNames) {
                DOMListeners.push(tf.events.AddDOMEventListener(document, tf.consts.allFullScreenEventNames[i], onDelayFullScreen.DelayCallBack));
            }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Settings used in the creation of [DOM Click Listener]{@link tf.events.DOMClickListener} instances
 * @public
 * @typedef {object} tf.types.DOMClickListenerSettings
 * @property {HTMLElementLike} target - the element whose click events will be monitored
 * @property {tf.types.MultiDOMEventListenerCallBack} callBack - to receive event notifications
 * @property {object} optionalScope - optional scope used with <b>callBack</b>
 * @property {object} callBackSettings - application defined properties, to be passed to <b>callBack</b> during notifications
*/
/**
 * @public
 * @class
 * @summary DOM Click Listener instances report [click]{@link tf.consts.DOMEventNamesClick} [DOM Events]{@link DOMEvent} to a given callback
 * @param {tf.types.DOMClickListenerSettings} settings - creation settings
 * @extends {tf.events.MultiDOMEventListener}
 */
tf.events.DOMClickListener = function (settings) {
    var theThis;
    function onPreNotify(notification) {
        switch (notification.eventName) {
            case tf.consts.DOMEventNamesClick:
                //tf.events.StopDOMEvent(notification.event);
                break;
            default:
                break;
        }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        var eventNames = [tf.consts.DOMEventNamesClick];
        var settingsUse = tf.js.ShallowMerge(settings, { eventNames: eventNames, onPreNotify: onPreNotify, preNotifyScope: theThis });
        tf.events.MultiDOMEventListener.call(theThis, settingsUse);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Notifications sent by {@link tf.events.DOMHoverListener} instances contain the properties of {@link tf.types.MultiDOMEventListenerNotification} plus:
 * @public
 * @typedef {object} tf.types.DOMHoverListenerNotification
 * @property {boolean} isInHover - <b>true</b> in [MouseOver]{@link tf.consts.DOMEventNamesMouseOver} events, <b>false</b> in [MouseOut]{@link tf.consts.DOMEventNamesMouseOut} events
 * @property {tf.types.pixelCoordinates} mouseCoords - the mouse pointer coordinates associated with the event
*/
/**
 * A callback function that can be used in the creation of instances of [DOM Hover Listener]{@link tf.events.DOMHoverListener}
 * @public
 * @callback tf.types.DOMHoverListenerCallBack
 * @param {tf.types.DOMHoverListenerNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * Settings used in the creation of [DOM Hover Listener]{@link tf.events.DOMHoverListener} instances
 * @public
 * @typedef {object} tf.types.DOMHoverListenerSettings
 * @property {HTMLElementLike} target - the element whose hover events will be monitored
 * @property {tf.types.DOMHoverListenerCallBack} callBack - to receive event notifications
 * @property {object} optionalScope - optional scope used with <b>callBack</b>
 * @property {object} callBackSettings - application defined properties, to be passed to <b>callBack</b> during notifications
*/
/**
 * @public
 * @class
 * @summary DOM Hover Listener instances report [MouseOver]{@link tf.consts.DOMEventNamesMouseOver} and [MouseOut]{@link tf.consts.DOMEventNamesMouseOut} 
 * [DOM Events]{@link DOMEvent} to a given callback
 * @param {tf.types.DOMHoverListenerSettings} settings - creation settings
 * @extends {tf.events.MultiDOMEventListener}
 */
tf.events.DOMHoverListener = function (settings) {
    var theThis, isInHover, lastPos;
    /**
     * @public
     * @function
     * @summary - Checks if the last event received was a [MouseOver]{@link tf.consts.DOMEventNamesMouseOver} event
     * @returns {boolean} - | {@link boolean} <b>true</b> if the last event was a MouseOver event, <b>false</b> otherwise
    */
    this.GetIsInHover = function () { return isInHover; }
    /**
     * @public
     * @function
     * @summary - Retrieves the mouse pointer position in the last event received and notified
     * @returns {tf.types.pixelCoordinates} - | {@link tf.types.pixelCoordinates} the last position
    */
    this.GetLastPos = function () { return lastPos; }
    function onPreNotify(notification) {
        lastPos = notification.mouseCoords = tf.events.GetMouseEventCoords(notification.event);
        switch (notification.eventName) {
            case tf.consts.DOMEventNamesMouseOver:
                isInHover = notification.isInHover = true;
                break;
            case tf.consts.DOMEventNamesMouseOut:
                isInHover = notification.isInHover = false;
                break;
        }
    }
    function initialize() {
        isInHover = false;
        var eventNames = [tf.consts.DOMEventNamesMouseOver, tf.consts.DOMEventNamesMouseOut];
        var settingsUse = tf.js.ShallowMerge(settings, { eventNames: eventNames, onPreNotify: onPreNotify, preNotifyScope: theThis });
        tf.events.MultiDOMEventListener.call(theThis, settingsUse);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.events.DOMHoverListener, tf.events.MultiDOMEventListener);
/**
 * Notifications sent by {@link tf.events.DOMMouseListener} contain the properties of {@link tf.types.MultiDOMEventListenerNotification} plus:
 * @public
 * @typedef {object} tf.types.DOMMouseListenerNotification
 * @property {boolean} isInHover - <b>true</b> if the mouse pointer is currently hovering <b>target</b>, <b>false</b> otherwise
 * @property {boolean} isInDrag - <b>true</b> if the mouse pointer is currently down, <b>false</b> otherwise
 * @property {tf.types.pixelCoordinates} mouseCoords - the mouse pointer coordinates associated with the event
*/
/**
 * A callback function that can be used in the creation of instances of [DOM Mouse Listener]{@link tf.events.DOMMouseListener}
 * @public
 * @callback tf.types.DOMMouseListenerCallBack
 * @param {tf.types.DOMMouseListenerNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * Settings used in the creation of [DOM Mouse Listener]{@link tf.events.DOMMouseListener} instances
 * @public
 * @typedef {object} tf.types.DOMMouseListenerSettings
 * @property {HTMLElementLike} target - the element whose hover events will be monitored
 * @property {tf.types.DOMMouseListenerCallBack} callBack - to receive event notifications
 * @property {object} optionalScope - optional scope used with <b>callBack</b>
 * @property {object} callBackSettings - application defined properties, to be passed to <b>callBack</b> during notifications
*/
/**
 * @public
 * @class
 * @summary DOM Mouse Listener instances report [mouse pointer related events]{@link tf.types.DOMMouseEventName} to a given callback
 * @param {tf.types.DOMMouseListenerSettings} settings - creation settings
 * @extends {tf.events.MultiDOMEventListener}
 */
tf.events.DOMMouseListener = function (settings) {
    var theThis, isInHover, isInDrag, lastPos;
    /**
     * @public
     * @function
     * @summary - Checks if the mouse pointer is currently hovering <b>target</b>
     * @returns {bool} - | {@link bool} <b>true</b> if yes, <b>false</b> otherwise
    */
    this.GetIsInHover = function () { return isInHover; }
    /**
     * @public
     * @function
     * @summary - Checks if the mouse pointer is being dragged<b>target</b>
     * @returns {bool} - | {@link bool} <b>true</b> if yes, <b>false</b> otherwise
    */
    this.GetIsInDrag = function () { return isInDrag; }
    /**
     * @public
     * @function
     * @summary - Retrieves the mouse pointer position in the last event received and notified
     * @returns {tf.types.pixelCoordinates} - | {@link tf.types.pixelCoordinates} the last position
    */
    this.GetLastPos = function () { return lastPos; }
    function onPreNotify(notification) {
        lastPos = notification.mouseCoords = tf.events.GetMouseEventCoords(notification.event);
        switch (notification.eventName) {
            case tf.consts.DOMEventNamesMouseOver:
                isInHover = notification.isInHover = true;
                break;
            case tf.consts.DOMEventNamesMouseOut:
                isInHover = notification.isInHover = false;
                break;
            case tf.consts.DOMEventNamesMouseDown:
                isInDrag = notification.isInDrag = true;
                break;
            case tf.consts.DOMEventNamesMouseUp:
                isInDrag = notification.isInDrag = false;
                break;
        }
    }
    function initialize() {
        isInDrag = isInHover = false;
        lastPos = [0, 0];
        var settingsUse = tf.js.ShallowMerge(settings, { eventNames: tf.consts.allMouseEventNames, onPreNotify: onPreNotify, preNotifyScope: theThis });
        tf.events.MultiDOMEventListener.call(theThis, settingsUse);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.events.DOMMouseListener, tf.events.MultiDOMEventListener);
/**
 * @public
 * @class 
 * @summary The {@link singleton} instance of this class, obtainable by calling {@link tf.GetDocMouseListener},
 * sends notifications of [mouse related events]{@link tf.types.DOMMouseEventName} targetted to the HTML document.
*/
tf.events.DocMouseListener = function () {
    var theThis, mouseListener, callBack, optionalScope, callBackSettings;
    /**
     * @public
     * @function
     * @summary - Starts sending notifications to the given callback, using the optional scope and callback settings 
     * @param {tf.types.MultiDOMEventListenerCallBack} callBack - to receive event notifications
     * @param {object} optionalScope - optional scope used with <b>callBack</b>
     * @param {object} callBackSettings - optional application defined properties passed to <b>callBack</b> on notifications
     * @returns {void} - | {@link void} no return value
    */
    this.SetCapture = function (callBack, optionalScope, callBackSettings) { return setCapture(callBack, optionalScope, callBackSettings); }
    /**
     * @public
     * @function
     * @summary - Stops sending notifications to the callback previously set with the [SetCapture]{@link tf.events.DocMouseListener#SetCapture} function
     * @returns {void} - | {@link void} no return value
    */
    this.ReleaseCapture = function () { return releaseCapture(); }
    /**
     * @public
     * @function
     * @summary - Checks if notifications are currently being sent to a callback
     * @returns {bool} - | {@link bool} <b>true</b> if yes, <b>false</b> otherwise
    */
    this.GetIsCaptured = function () { return !!callBack; }
    function setCapture(callBackSet, optionalScopeSet, callBackSettingsSet) {
        releaseCapture();
        //tf.GetDebug().LogIfTest("docMouse: set capture");
        if (!!(callBack = tf.js.GetFunctionOrNull(callBackSet))) {
            mouseListener = new tf.events.DOMMouseListener({ target: document, callBack: onMouse, optionalScope: theThis, callBackSettings: undefined });
            optionalScope = optionalScopeSet;
            callBackSettings = callBackSettingsSet;
        }
    }
    function releaseCapture() {
        if (!!callBack) {
            //tf.GetDebug().LogIfTest("docMouse: release capture");
            callBack = optionalScope = callBackSettings = undefined;
            mouseListener.OnDelete();
        }
    }
    function onMouse(notification) {
        var retVal = true;
        if (!!callBack) {
            if ((retVal = callBack.call(optionalScope, notification)) === undefined) { retVal = true; }
            else if (retVal) { tf.events.StopDOMEvent(notification.event); }
        }
        return retVal;
    }
    function initialize() {
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * @public
 * @function
 * @summary - Retrieves the target of the DOM Event
 * @param {DOMEvent} ev - the event
 * @returns {HTMLElement} - | {@link HTMLElement} the event target
*/
tf.events.GetEventTarget = function (ev) { if (!!ev) { if (ev.srcElement) { return ev.srcElement; } else if (ev.originalTarget) { return ev.originalTarget; } } return null; }
/**
 * @public
 * @function
 * @summary - Retrieves the Pixel Coordinates associated with the mouse DOM Event
 * @param {DOMEvent} ev - the event
 * @returns {tf.types.pixelCoordinates} - | {@link tf.types.pixelCoordinates} the event's pixel coordinates
*/
tf.events.GetMouseEventCoords = function (ev) {
    if (tf.js.GetIsValidObject(ev)) {
        if (ev.offsetX !== undefined) { return [ev.offsetX, ev.offsetY] }
        else if (ev.layerX != undefined) { return [ev.layerX, ev.layerY]; }
    }
    return [0, 0];
}
/**
 * Notifications sent to DOM Event Listeners
 * @public
 * @typedef {object} tf.types.DOMEventListenerNotification
 * @property {DOMEvent} event - the event being notified
*/
/**
 * A callback function that can be used with the function [AddDOMEventListener]{@link tf.events.AddDOMEventListener}
 * @public
 * @callback tf.types.DOMEventListenerCallBack
 * @param {tf.types.DOMEventListenerNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * @public
 * @function
 * @summary - Directs notifications of the given event name on the given target to the given callback, 
 * returns a [Dom Event Listener]{@link tf.events.DOMEventListener} instance
 * @param {HTMLElementLike} target - the element whose events will be notified
 * @param {tf.types.DOMEventName} eventName - the name of the event to listen for
 * @param {tf.types.DOMEventListenerCallBack} callBack - to receive event notifications
 * @returns {tf.events.DOMEventListener} - | {@link tf.events.DOMEventListener} the listener
*/
tf.events.AddDOMEventListener = function (target, eventName, callBack) {
    var listener = null;
    if (tf.js.GetFunctionOrNull(callBack)) {
        if (target = tf.dom.GetDOMEventListenerFrom(target)) {
            if (tf.js.GetIsNonEmptyString(eventName)) {
                if (target.addEventListener) { target.addEventListener(eventName, callBack, true); }
                else if (target.attachEvent) { target.attachEvent("on" + eventName, callBack); }
                else { target["on" + eventName] = callBack; }
                listener = new tf.events.DOMEventListener({ target: target, eventName: eventName, callBack: callBack });
            }
        }
    }
    return listener;
}
/**
 * @public
 * @function
 * @summary - Stops directing notifications of the given event name on the given target to the given callback
 * @property {HTMLElementLike} target - the element whose events are being notified
 * @property {tf.types.DOMEventName} eventName - the name of the event that is being listen for
 * @property {tf.types.DOMEventListenerCallBack} callBack - to stop receiving event notifications
 * @returns {void} - | {@link void} no return value
*/
tf.events.DelDOMEventListener = function (target, eventName, callBack) {
    if (tf.js.GetFunctionOrNull(callBack)) {
        if (target = tf.dom.GetDOMEventListenerFrom(target)) {
            if (tf.js.GetIsNonEmptyString(eventName)) {
                if (target.removeEventListener) { target.removeEventListener(eventName, callBack, true); }
                else if (target.detachEvent) { target.detachEvent("on" + eventName, callBack); }
                else { target["on" + eventName] = undefined; }
            }
        }
    }
}
/**
 * Settings used in the creation of [EventListener]{@link tf.events.EventListener} instances
 * @private
 * @typedef {object} tf.types.EventListenerSettings
 * @property {string} key - unique identifier
 * @property {function} deleteCallBack - a callback used by the listener to delete itself
*/
/**
 * @public
 * @class
 * @summary Applications do not create instances of this class directly. They are obtained from TerraFly API classes that include <b>AddListener</b> functions
 * @param {tf.types.EventListenerSettings} settings - event listener creation settings
 */
tf.events.EventListener = function (settings) {
    var theThis, onDeleteCallBack, key;
    /**
     * @public
     * @function
     * @summary - Removes this event listener
     * @returns {void} - | {@link void} no return value
    */
    this.OnDelete = function () { if (!!onDeleteCallBack) { var localRef = onDeleteCallBack; onDeleteCallBack = null; localRef(theThis); } }
    /**
     * @private
     * @function
     * @summary - Retrieves the listener's unique identifier
     * @returns {string} - | {@link string} the listener's unique identifier
    */
    this.GetKey = function () { return key; }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        key = settings.key;
        onDeleteCallBack = tf.js.GetFunctionOrNull(settings.deleteCallBack);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Settings used in the creation of [Event Notifier]{@link tf.events.EventNotifier} instances
 * @public
 * @typedef {object} tf.types.EventNotifierSettings
 * @property {string} eventName - the application defined name of the event
*/
/**
 * @public
 * @class
 * @summary Event Notifier instances implement event notifications for a single application defined event name, provided on creation.
 * During their lifetime, Event Notifiers create [Event Listeners]{@link tf.event.EventListener} for given callback functions, 
 * and relay notifications to these callbacks upon request
 * @param {tf.types.EventNotifierSettings} settings - creation settings
 */
tf.events.EventNotifier = function (settings) {
    var theThis, eventName, listeners, keyCount;
    /**
     * @public
     * @function
     * @summary - Retrieves the name of the event provided in the creation of this Notifier instance
     * @returns {string} - | {@link string} the name
    */
    this.GetEventName = function () { return eventName; }
    /**
     * @public
     * @function
     * @summary - Adds the given callback to the list of notification recipients
     * @param {function} callBack - a function capable of receiving notifications sent by this Notifier instance
     * @returns {tf.events.EventListener} - | {@link tf.events.EventListener} an Event Listener
    */
    this.Add = function (callBack) { return add(callBack); }
    /**
     * @public
     * @function
     * @summary - Notifies [Event Listeners]{@link tf.event.EventListener} previously added to an event
     * @param {...*} notificationArgument - any number of arguments to be used in the notifications sent to listeners
     * @returns {void} - | {@link void} no return value
    */
    this.Notify = function () { for (var i in listeners) { listeners[i].callBackFunction.apply(undefined, arguments); } }
    /**
     * @public
     * @function
     * @summary - Removes all [Event Listeners]{@link tf.event.EventListener}
     * @returns {void} - | {@link void} no return value
    */
    this.OnDelete = function () { return onDelete(); }
    function onDelete() { for (var i in listeners) { listeners[i].listener.OnDelete(); } listeners = []; }
    function isListener(theListener) { return !!theListener && theListener instanceof tf.events.EventListener; }
    function deleteCallBack(theListener) {
        if (isListener(theListener)) { var key = tf.js.MakeObjectKey(theListener.GetKey()); if (!!listeners[key]) { delete listeners[key]; } }
    }
    function add(callbackFunction) {
        var listener = null;
        if (!!tf.js.GetFunctionOrNull(callbackFunction)) {
            ++keyCount;
            listeners[tf.js.MakeObjectKey(keyCount)] = { listener: listener = new tf.events.EventListener({ key: keyCount, deleteCallBack: deleteCallBack }), callBackFunction: callbackFunction };
        }
        return listener;
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        eventName = tf.js.GetNonEmptyString(settings.eventName, "");
        listeners = {};
        keyCount = 0;
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Settings used in the creation of [Multi Event Notifier]{@link tf.events.MultiEventNotifier} instances
 * @public
 * @typedef {object} tf.types.MultiEventNotifierSettings
 * @property {enumerable<string>} eventNames - application defined event names for each of which an [Event Notifier]{@link tf.events.EventNotifier} instance is created
*/
/**
 * @public
 * @class
 * @summary Multi Event Notifier instances manage a variable number of [Event Notifiers]{@link tf.event.EventNotifier} 
 * automating listening and notification functionality for an arbitrary number of application defined event names, which may be specified
 * on creation and/or dynamically added and removed.
 * Instances of this class are used throughout the API (by [Maps]{@link tf.map.Map}, [Keyed Feature Lists]{@link tf.map.KeyedFeatureList}, [Keyed Lists]{@link tf.js.KeyedList}, etc.)
 * to implement listening and notification of their respective event names
 * @param {tf.types.MultiEventNotifierSettings} settings - creation settings
 */
tf.events.MultiEventNotifier = function (settings) {
    var theThis, notifiers;
    /**
     * @public
     * @function
     * @summary - Adds the given callback to the [Event Notifier]{@link tf.events.EventNotifier} associated with the given event name
     * @param {string} eventName - one of the event names associated with this Multi Event Notifier instance
     * @param {function} callBack - a function capable of receiving notifications sent by the Event Notifier associated with <b>eventName</b>
     * @returns {tf.events.EventListener} - | {@link tf.events.EventListener} an Event Listener, or {@link void} if <b>eventName</b> is not associated with this instance
    */
    this.AddListener = function (eventName, callBack) { return addListener(eventName, callBack); }
    /**
     * @public
     * @function
     * @summary - Adds one or more listeners for the given event names
     * @param {tf.types.EventNamesAndCallBacks} eventNamesAndCallBacks - the event names and callbacks
     * @returns {tf.types.EventNamesAndListeners} - | {@link tf.types.EventNamesAndListeners} the event names and listeners
    */
    this.AddListeners = function (eventNamesAndCallBacks) { return addListeners(eventNamesAndCallBacks); }
    /**
     * @public
     * @function
     * @summary - Notifies [Event Listeners]{@link tf.event.EventListener} previously added to the given event name
     * @param {string} eventName - one of the event names associated with this Multi Event Notifier instance
     * @param {...*} notificationArgument - any number of arguments to be used in the notifications sent to listeners
     * @returns {void} - | {@link void} no return value
    */
    this.Notify = function (eventName) {
        if (!!eventName && notifiers[eventName]) { notifiers[eventName].Notify.apply(null, Array.prototype.slice.call(arguments, 1)); }
    }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Event Notifier]{@link tf.event.EventNotifier} instance associated with the given event name, if any
     * @param {string} eventName - one of the event names associated with this Multi Event Notifier instance
     * @returns {tf.events.EventNofifier} - | {@link tf.events.EventNofifier} the Event Notifier, or {@link void} if <b>eventName</b> is not associated with this instance
    */
    this.GetNotifier = function (eventName) { return getNotifier(eventName); }
    /**
     * @public
     * @function
     * @summary - Adds an [Event Notifier]{@link tf.event.EventNotifier} instance associated with the given event name
     * @param {string} eventName - an application defined event name
     * @returns {tf.events.EventNofifier} - | {@link tf.events.EventNofifier} the Event Notifier
    */
    this.AddNotifier = function (eventName) { return addNotifier(eventName); }
    /**
     * @public
     * @function
     * @summary - Deletes the [Event Notifier]{@link tf.event.EventNotifier} instance associated with the given event name, if any
     * @param {string} eventName - an application defined event name
     * @returns {void} - | {@link void} no return value
    */
    this.DelNotifier = function (eventName) { return delNotifier(eventName); }
    /**
     * @public
     * @function
     * @summary - Removes all [Event Notifiers]{@link tf.event.EventNotifier}
     * @returns {void} - | {@link void} no return value
    */
    this.OnDelete = function () { return onDelete(); }
    function getNotifier(eventName) { return !!eventName ? notifiers[eventName] : null; }
    function addListener(eventName, callBackFunction) {
        var listener = null;
        if (!!eventName && !!callBackFunction) { if (!!notifiers[eventName]) { listener = notifiers[eventName].Add(callBackFunction); } }
        return listener;
    }
    function addListeners(eventNamesAndCallBacks) {
        var listeners = {};
        if (tf.js.GetIsValidObject(eventNamesAndCallBacks)) {
            for (var thisEventName in eventNamesAndCallBacks) {
                var listenerSet = getNotifier(thisEventName);
                if (!!listenerSet) {
                    var thisCallBack = tf.js.GetFunctionOrNull(eventNamesAndCallBacks[thisEventName]);
                    if (!!thisCallBack) { listeners[thisEventName] = listenerSet.Add(thisCallBack); }
                }
            }
        }
        return listeners;
    }
    function delNotifier(eventName) {
        if (!!eventName && !!notifiers[eventName]) { notifiers[eventName].OnDelete(); delete notifiers[eventName]; }
    }
    function addNotifier(eventName) {
        if (!!eventName) {
            if (!!notifiers[eventName]) {
                tf.GetDebug().LogIfTest('tf.events.MultiEventNotifier: adding duplicate listener for event name: ' + eventName);
            }
            else { notifiers[eventName] = new tf.events.EventNotifier({ eventName: eventName }); }
        }
    }
    function onDelete() { for (var i in notifiers) { delNotifier(i); } }
    function createListenerSets(eventNames) {
        notifiers = {}; if (!!eventNames && typeof eventNames === "object") { for (var i in eventNames) { addNotifier(eventNames[i]); } }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        createListenerSets(settings.eventNames);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * @public
 * @function
 * @summary - Deletes one or more listeners for the given event names
 * @param {tf.types.EventNamesAndListeners} eventNamesAndListeners - the event names and listeners
 * @returns {void} - | {@link void} no return value
*/
tf.events.DeleteListeners = function (eventNamesAndListeners) {
    if (tf.js.GetIsValidObject(eventNamesAndListeners)) {
        for (var i in eventNamesAndListeners) {
            var listener = eventNamesAndListeners[i];
            if (tf.js.GetIsInstanceOf(listener, tf.events.EventListener)) {
                listener.OnDelete();
                delete eventNamesAndListeners[i];
            }
        }
    }
}
/**
 * A JavaScript {@link object} whose single property name is an API event name and its value is a callBack function to receive notifications of that event
 * @public
 * @typedef {tf.types.EventNameAndCallBack} tf.types.EventNameAndCallBack
 * @property {string} callBack - an event name and callBack pair, the event name is the property name
 * @example
 * // Declares an association between the onMapMoveEnd callBack and the name of the tf.consts.mapMoveEndEvent event
 * var eventNameAndCallBack = {} ; eventNameAndCallBack[tf.consts.mapMoveEndEvent] = onMapMoveEnd;
 * @see {@link tf.types.EventNamesAndCallBacks}
 */
/**
 * An {@link enumerable} of {@link tf.types.EventNameAndCallBack} items that can be created as a group
 * @public
 * @typedef {tf.types.EventNamesAndCallBacks} tf.types.EventNamesAndCallBacks
 * @example
 * // Add listeners to 3 map events
 * var eventNamesAndCallBacks = {} ;
 * eventNamesAndCallBacks[tf.consts.mapMoveEndEvent] = onMapMoveEnd;
 * eventNamesAndCallBacks[tf.consts.mapMouseMoveEvent] = onMapMouseMoveOrClick;
 * eventNamesAndCallBacks[tf.consts.mapClickEvent] = onMapMouseMoveOrClick;
 * var eventNamesAndListeners = [map]{@link tf.map.Map}.[AddListeners]{@link tf.map.Map#AddListeners}(eventNamesAndCallBacks);
 * // When the listeners are no longer needed, dispose of them as a group
 * [tf.events.DeleteListeners]{@link tf.events.DeleteListeners}(eventNamesAndListeners);
 * @see [map]{@link tf.map.Map}[AddListeners]{@link tf.map.Map#AddListeners}
 * @see [DeleteListeners]{@link tf.events.DeleteListeners}
 */
/**
 * A JavaScript {@link object} whose single property name is an API event name and its value is an instance of [EventListener]{@link tf.events.EventListener}. 
 * Applications do not create these objects direction, they are obtained by calling API functions that create and return them.
 * @public
 * @typedef {tf.types.EventNameAndListener} tf.types.EventNameAndListener
 * @property {string} theEventListener - an event name and listener par
 * @see {@link tf.types.EventNamesAndCallBacks}
 */
/**
 * An {@link enumerable} of {@link tf.types.EventNameAndListener} items that can be disposed of as a group
 * @public
 * @typedef {tf.types.EventNamesAndListeners} tf.types.EventNamesAndListeners
 * @see [map]{@link tf.map.Map}[AddListeners]{@link tf.map.Map#AddListeners}
 * @see [DeleteListeners]{@link tf.events.DeleteListeners}
 */
/**
 * A {@link string} that uniquely identifies a JavaScript {@link object} within a collection of JavaScript [objects]{@link object}
 * @public
 * @typedef {string} tf.types.Key
 */
/**
 * A callback function that can be passed in the creation of [Keyed List]{@link tf.js.KeyedList} instances to selectively prevent data items from being added to that list.<br>
 * This callback can also be used selectively alter the contents of data retrieved from remote services before it is incorporated into a [Keyed Item]{@link tf.js.KeyedItem}
 * @public
 * @callback tf.types.FilterAddItem
 * @param {object} itemData - the candidate data object, which this callback is allowed to alter
 * @returns {boolean} - | {@link boolean} <b>true</b> if the item data can be added to the list, <b>false</b> otherwise
 */
/**
 * An object passed to {@link tf.types.NeedsUpdateItemData} callbacks containing the current data object associated with a [Keyed Item]{@link tf.js.KeyedItem} and a new data item to replace it
 * @public
 * @typedef {object} tf.types.NeedsUpdateItemDataObject
 * @property {object} itemData - the data object currently associated with the keyed item instance
 * @property {object} itemDataSet - the candidate new data object
 */
/**
 * A callback function that can be passed in the creation of [Keyed Item]{@link tf.js.KeyedItem} instances to determine if the instance's data needs 
 * to be updated from a new data object. Use this callback to compare freshly retrieved data from a remote service with the data currently stored
 * in the instance, and prevent unnecessary update notifications if the data has not changed
 * @public
 * @callback tf.types.NeedsUpdateItemData
 * @param {tf.types.NeedsUpdateItemDataObject} updateObj - contains the data object currently associated with the keyed item instance and the candidate new data object
 * @returns {boolean} - | {@link boolean} <b>true</b> if an update is needed, <b>false</b> otherwise
 */
/**
 * A callback function that must be provided in the creation of [Keyed List]{@link tf.js.KeyedList} instances to extract [Keys]{@link tf.types.Key} from the type of [data objects]{@link object} 
 * that are associated with the [Keyed Items]{@link tf.js.KeyedItem} in the list
 * @public
 * @callback tf.types.GetKeyFromData
 * @param {object} data - an object of the type stored by the [Keyed Items]{@link tf.js.KeyedItem} in the list
 * @returns {tf.types.Key} - | {@link tf.types.Key} the key extracted from <b>data</b>, or {@link void} if a key could not be extracted
 */
/**
 * Settings used in the creation of [Keyed Item]{@link tf.js.KeyedItem} instances
 * @public
 * @typedef {object} tf.types.KeyedItemSettings
 * @property {tf.js.KeyedList} list - the associated [Keyed List]{@link tf.js.KeyedList} instance
 * @property {tf.types.Key} key - the key
 * @property {object} itemData - the data
 * @property {tf.types.NeedsUpdateItemData} needsUpdateItemData - a callback that determines if the item's data needs to be updated from a new data object
*/
/**
 * @public
 * @class
 * @summary Each Keyed Item instance implements a standard key/value pair data structure, and belongs to a single [Keyed List]{@link tf.js.KeyedList} instance.
 * Keyed Items are created by calling the [AddOrGetItem]{@link tf.js.KeyedList#AddOrGetItem} function of a Keyed List
 * @param {tf.types.KeyedItemSettings} settings - keyed item creation settings
 */
tf.js.KeyedItem = function (settings) {
    var theThis, list, lastTimeUpdated, itemData, key, needsUpdateDataMethod;
    /**
     * @public
     * @function
     * @summary - Retrieves the [Keyed list]{@link tf.js.KeyedList} instance associated with this keyed item instance
     * @returns {tf.js.KeyedList} - | {@link tf.js.KeyedList} the list instance
    */
    this.GetList = function () { return list; }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Key]{@link tf.types.Key} associated with this keyed item instance
     * @returns {tf.types.Key} - | {@link tf.types.Key} the key
    */
    this.GetKey = function () { return key; }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Data object]{@link object} associated with this keyed item instance
     * @returns {tf.types.Key} - | {@link tf.types.Key} the key
    */
    this.GetData = function () { return itemData; }
    /**
     * @public
     * @function
     * @summary - Retrieves the last time the data associated with this keyed item instance was updated
     * @returns {Date} - | {@link Date} the date
    */
    this.GetLastTimeUpdated = function () { return lastTimeUpdated; }
    /**
     * @public
     * @function
     * @summary - Notifies registered listeners of the [Items Updated Event]{@link tf.consts.keyedListUpdatedItemsEvent} of the associated 
     * [KeyedList]{@link tf.js.KeyedList} that this Keyed Item instance has been updated. 
     * Use this function instead of [Update]{@link tf.js.KeyedItem#Update] when the data associated with a Keyed Item instance is retrieved with 
     * the [GetData]{@link tf.js.KeyedItem#GetData] function and then directly modified in place
     * @returns {void} - | {@link void} no return value
    */
    this.NotifyUpdated = function () { notifyUpdated(); }
    /**
     * @public
     * @function
     * @summary - Replaces the data object associated with this Keyed Item instance with the given new data object, provided
     * that <b>itemDataSet</b> is a valid object and that the [Key]{@link tf.types.Key} extracted from it matches this instance's Key.
     * Registered listeners of the [Items Updated Event]{@link tf.consts.keyedListUpdatedItemsEvent} of the associated 
     * [KeyedList]{@link tf.js.KeyedList} are notified if the update occurs
     * @param {object} itemDataSet - the new data
     * @returns {boolean} - | {@link boolean} <b>true</b> if an update was performed, <b>false</b> otherwise
    */
    this.Update = function (itemDataSet) { return update(itemDataSet, false); }
    /**
     * @private
     * @function
     * @summary - Marks this instance for deletion
     * @returns {void} - | {@link void} no return value
    */
    this.OnDelete = function () { return onDelete(); }
    /**
     * @private
     * @function
     * @summary - Updates the data object associated with this keyed item from the given data object. This function bypasses the associated [KeyedList]{@link tf.js.KeyedList} notification
     * and is meant to be used internally by the API
     * @param {object} itemDataSet - the new data
     * @returns {boolean} - | {@link boolean} <b>true</b> if an update was performed, <b>false</b> otherwise
    */
    this.privateUpdate = function (itemDataSet) { return update(itemDataSet, true); }
    function doUpdate(itemDataSet) {
        var wasUpdated = false;
        lastTimeUpdated = new Date();
        if (tf.js.GetIsValidObject(itemDataSet)) {
            if (wasUpdated = ((!itemData) || (!needsUpdateDataMethod) || (needsUpdateDataMethod({ sender: theThis, itemData: itemData, itemDataSet: itemDataSet })))) {
                itemData = itemDataSet;
            }
        }
        return wasUpdated;
    }
    function notifyUpdated() {
        if (!!list && !!key) {
            list.NotifyItemUpdated(theThis);
        }
    }
    function update(itemDataSet, isUpdateFromList) {
        var updated ;
        if (!!list && !!key && list.GetKeyFromData(itemDataSet) == key) {
            if (isUpdateFromList) { updated = doUpdate(itemDataSet); }
            else { itemData = null; updated = doUpdate(itemDataSet); list.NotifyItemUpdated(theThis); }
        }
        return updated;
    }
    function onDelete() { }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        list = tf.js.GetIsInstanceOf(settings.list, tf.js.KeyedList) ? settings.list : null;
        key = settings.key;
        needsUpdateDataMethod = tf.js.GetFunctionOrNull(settings.needsUpdateItemData);
        doUpdate(settings.itemData);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Notifications sent by {@link tf.js.KeyedList} instances. Properties are available in notifications that require them
 * @public
 * @typedef {object} tf.types.KeyedListEventNotification
 * @property {tf.map.KeyedList} sender - the instance sending the notification
 * @property {tf.types.keyedListEventName} eventName - the name of the event
 * @property {enumerable<tf.js.KeyedItem>} items - the associated keyed items
 * @property {enumerable<tf.types.Key>} keyes - the associated keys
*/
/**
 * A callback function that can be passed to the function {@link tf.js.KeyedList#AddListener} to start receiving keyed list event notifications
 * @public
 * @callback tf.types.KeyedListEventCallBack
 * @param {tf.types.KeyedListEventNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * Settings used in the creation of [Keyed IteList]{@link tf.js.KeyedList} instances
 * @public
 * @typedef {object} tf.types.KeyedListSettings
 * @property {string} name - the name associated with the Keyed List instance
 * @property {tf.types.GetKeyFromData | enumerable<tf.types.GetKeyFromData>} getKeyFromItemData - a mandatory callback capable of extracting a [Key]{@link tf.types.Key} from 
 * the type of data stored by the [Keyed Items]{@link tf.js.KeyedItem} in this Keyed List.
 * <br>To create nested Keyed Lists of depth <b>N</b> use an {@link enumerable}
 * containing <b>N</b> instances of {@link tf.types.GetKeyFromData}; each {@link tf.types.GetKeyFromData} is used in the creation of a nested Keyed List, beginning with the topmost list
 * @property {tf.types.FilterAddItem} filterAddItem - an optional callback to selectivelly prevent data items from being added to this Keyed List instance
 * @property {tf.types.NeedsUpdateItemData} needsUpdateItemData - an optional callback that determines if an item's data needs to be updated from a new data object
 * @property {boolean} keepNotUpdated - if set to <b>true</b> prevents the Keyed List from removing items that were not updated from a new data set, defaults to {@link void}
 * @property {tf.types.Key} key - <b>applications do not define this property directly.</b> It is only meaningful for Keyed List instances that are items in another Keyed List, and it is 
 * automatically defined by the parent Keyed List during the creation of nested Keyed Lists
*/
/**
 * @public
 * @class
 * @summary - Each Keyed List instance implements a standard collection of key/value pairs with unique keys.<br>
 * - Keyed Lists dispatch notifications to registered [Event Listeners]{@link tf.events.EventListener} when standard list operations (Add, Update, and Delete) are performed on it.<br>
 * - Keyed Lists may be used to store key/value pairs retrieved from a remote service.<br>
 * - One or more [Keyed Feature Lists]{@link tf.map.KeyedFeatureList} can be associated with a Keyed List to automate the creation, update, and deletion of [Keyed Features]{@link tf.map.KeyedFeature} 
 * specified by the the list's [Keyed Items]{@link tf.js.KeyedItem}<br>
 * - Keyed Lists are created to either store instances of [Keyed Items]{@link tf.js.KeyedItem} or to store sub-instances of Keyed Lists, which are all updated from the same data set, 
 * and can be nested to arbitraty depths.<br>
 * - Nested Keyed Lists may be used to automatically maintain and query binary relationships (of cardinalities 1:n, n:1, or n:m) between [Keyed Items]{@link tf.js.KeyedItem} stored in other Keyed Lists.<br>
 * - The creation of nested Keyed List instances is automatically performed during the creation of the topmost Keyed List instance, based on the number and order of 
 * [Key extraction callbacks]{@link tf.types.GetKeyFromData} that are specified for it.
 * @param {tf.types.KeyedListSettings} settings - keyed list creation settings
*/
tf.js.KeyedList = function (settings) {
    var theThis, lastTimeUpdated, makePrivateKey, list, keyList, itemCount, name, keepNotUpdated, needsUpdateItemData;
    var allEventDispatchers, filterAddItemCallBack, getKeyFromDataFunction, settingsGetKeyFromData, isListOfLists, key, cachedItemDatas;
    /**
     * @public
     * @function
     * @summary - Retrieves the name of this keyed list
     * @returns {string} - | {@link string} the name
    */
    this.GetName = function () { return name; }
    /**
     * @public
     * @function
     * @summary - Checks if the items in this Keyed List instance are also Keyed Lists
     * @returns {boolean} - | {@link boolean} <b>true</b> if items are also Keyed Lists, <b>false</b> otherwise
    */
    this.GetIsListOfLists = function () { return isListOfLists; }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Key]{@link tf.types.Key} associated with this Keyed List instance. This Key is only meaningful if this Keyed List instance is an item of another Keyed List instance
     * @returns {tf.types.Key} - | {@link tf.types.Key} the key
    */
    this.GetKey = function () { return key; }
    /**
     * @public
     * @function
     * @summary - Assuming that a [Key]{@link tf.types.Key} is extracted from the given [itemData]{@link object}, this function performs one of the following actions:<br>
     * -- if this Keyed List instance contains a [Keyed Item]{@link tf.js.KeyedItem} with a matching Key, this function returns that item, and itemData is otherwise ignored<br>
     * -- if this Keyed List instance does not contain a [Keyed Item]{@link tf.js.KeyedItem} with a matching Key, this function creates a new one using 
     * Key and itemData, adds it to the list, and returns the newly created item
     * @param {object} itemData - a custom, application defined, JavaScript object from which a [Key]{@link tf.types.Key} can extracted using the {@link tf.types.GetKeyFromData} callback
     * provided on the creation settings of this Keyed List instance
     * @returns {tf.js.KeyedItem} - | {@link tf.js.KeyedItem} a Keyed Item instance - either pre-existing or newly created with <b>itemData</b>, or {@link void} if a Key cannot be extracted from <b>itemData</b>
    */
    this.AddOrGetItem = function (itemData) { return addOrGetItem(itemData, true).item; }
    /**
     * @public
     * @function
     * @summary - Removes the given [Keyed Item]{@link tf.js.KeyedItem} from this Keyed List instance
     * @param {tf.js.KeyedItem} keyedItem - the Keyed Item to be removed
     * @returns {boolean} - | {@link boolean} <b>true</b> if the item was removed, <b>false</b> if the the list does not contain the item
    */
    this.RemoveItem = function (keyedItem) { return removeItem(keyedItem, true); }
    /**
     * @public
     * @function
     * @summary - Removes the [Keyed Item]{@link tf.js.KeyedItem} matching the given [Key]{@link {tf.types.Key} from this Keyed List instance
     * @param {tf.types.Key} itemKey - the given Key
     * @returns {boolean} - | {@link boolean} <b>true</b> if the item was removed, <b>false</b> if the the list does not contain an item matching <b>itemKey</b>
    */
    this.RemoveItemByKey = function (itemKey) { return removeItemByKey(itemKey, true); }
    /**
     * @public
     * @function
     * @summary - Removes all [Keyed Items]{@link tf.js.KeyedItem} from this Keyed List instance
     * @returns {void} - | {@link void} no return value
    */
    this.RemoveAllItems = function () { return removeAll(true); }
    /**
     * @public
     * @function
     * @summary - Checks if this Keyed List instance contains a [Keyed Item]{@link tf.js.KeyedItem} matching the given [Key]{@link {tf.types.Key}
     * @param {tf.types.Key} itemKey - the given Key
     * @returns {boolean} - | {@link boolean} <b>true</b> if the list contains a matching item for <b>itemKey</b>, <b>false</b> otherwise
    */
    this.HasKey = function (itemKey) { return hasKey(itemKey); }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Keyed Item]{@link tf.js.KeyedItem} matching the given [Key]{@link {tf.types.Key}, if any
     * @param {tf.types.Key} itemKey - the given Key
     * @returns {tf.js.KeyedItem} - | {@link tf.js.KeyedItem} the Keyed Item instance matching <b>itemKey</b>, or {@link void} if no matching item is found
    */
    this.GetItem = function (itemKey) { return getItem(itemKey); }
    /**
     * @public
     * @function
     * @summary - Retrieves the number of [Keyed Items]{@link tf.js.KeyedItem} currently in this Keyed List instance
     * @returns {number} - | {@link number} the number of items
    */
    this.GetItemCount = function () { return itemCount; }
    /**
     * @public
     * @function
     * @summary - Retrieves an enumerable containing all the Keyed Items in this Keyed List instance. Applications should not alter the contents of these items, only retrieve information from them
     * @returns {enumerable<tf.js.KeyedItem>} - | {@link enumerable}<{@link tf.js.KeyedItem}> all the items
    */
    this.GetKeyedItemList = function () { return tf.js.ShallowMerge(list); }
    /**
     * @public
     * @function
     * @summary - Retrieves an enumerable containing all the Keys in this Keyed List instance. Applications should not alter the contents of these keys, only retrieve information from them
     * @returns {enumerable<tf.types.Key>} - | {@link enumerable}<{@link tf.types.Key}> all the keyes
    */
    this.GetKeyList = function () { return tf.js.ShallowMerge(keyList); }
    /**
     * @public
     * @function
     * @summary - Extracts a [Key]{@link tf.types.Key} from the given [itemData]{@link object}
     * @param {object} itemData - a custom, application defined, JavaScript object from which a [Key]{@link tf.types.Key} can extracted using the {@link tf.types.GetKeyFromData} callback
     * provided on the creation settings of this Keyed List instance
     * @returns {tf.types.Key} - | {@link tf.types.Key} the extracted Key, or {@link void} if a Key cannot be extracted from <b>itemData</b>
    */
    this.GetKeyFromData = function (data) { return getKeyFromDataFunction(data); }
    /**
     * @public
     * @function
     * @summary - Retrieves the last time this Keyed List instance was [updated from a new list]{@link tf.js.KeyedList#UpdateFromNewData}
     * @returns {Date} - | {@link Date} the date
    */
    this.GetLastTimeUpdated = function () { return lastTimeUpdated; }
    /**
     * @public
     * @function
     * @summary - Updates this Keyed List instance with the contents of the given <b>newData</b>. Removes from the list any [Keyed Items]{@link tf.js.KeyedItem} whose
     * keys are not present in <b>newData</b>, unless the property [keepNotUpdated]{@link tf.types.KeyedListSettings} was set to <b>true</b> during the creation of this Keyed List instance.
     * Notifies listeners of any events that occur during the update.
     * @param {enumerable<object>} newData - an enumerable containing custom, application defined, JavaScript objects from which [Keys]{@link tf.types.Key} can extracted using the {@link tf.types.GetKeyFromData} callback
     * provided on the creation settings of this Keyed List instance
     * @returns {void} - | {@link void} no return value
    */
    this.UpdateFromNewData = function (newData) { return updateFromNewData(newData); }
    /**
     * @public
     * @function
     * @summary - Adds a listener for the given event name
     * @param {tf.types.keyedListEventName} eventName - the name of the event
     * @param {tf.types.KeyedListEventCallBack} callBack - the callback for event notifications
     * @returns {tf.events.EventListener} - | {@link tf.events.EventListener} the event listener
    */
    this.AddListener = function (eventName, callbackFunction) { return allEventDispatchers.AddListener(eventName, callbackFunction); }
    /**
     * @public
     * @function
     * @summary - Adds one or more listeners for the given event names
     * @param {tf.types.EventNamesAndCallBacks} eventNamesAndCallBacks - the event names and callbacks
     * @returns {tf.types.EventNamesAndListeners} - | {@link tf.types.EventNamesAndListeners} the event names and listeners
    */
    this.AddListeners = function (eventNamesAndCallBacks) { return allEventDispatchers.AddListeners(eventNamesAndCallBacks); }
    /**
     * @public
     * @function
     * @summary - Sends the given <b>callBack</b> a [Items Added Event]{@link tf.consts.keyedListAddedItemsEvent} with all keyed items currently in this list
     * @param {tf.types.KeyedListEventCallBack} callBack - the callback
     * @returns {void} - | {@link void} no return value
    */
    this.NotifyItemsAdded = function (callBack) {
        if (tf.js.GetFunctionOrNull(callBack)) {
            if (itemCount > 0) {
                callBack(makeEventNotification(tf.consts.keyedListAddedItemsEvent, list, keyList));
            }
        }
    }
    /**
     * @public
     * @function
     * @summary - Notifies listeners of the [Items Updated Event]{@link tf.consts.keyedListUpdatedItemsEvent} with all keyed items currently in this list
     * @param {tf.types.KeyedListEventCallBack} callBack - the callback
     * @returns {void} - | {@link void} no return value
    */
    this.NotifyItemsUpdated = function () { if (itemCount > 0) { notifyListItemUpdate(list, keyList); } }
    /**
     * @private
     * @function
     * @summary - This function is used internally by the API to implement Keyed Item / List Update notifications
     * @param {tf.js.KeyedItem} keyedItem - the item
     * @returns {void} - | {@link void} no return value
    */
    this.NotifyItemUpdated = function (keyedItem) { if (hasItem(keyedItem)) { notifyListItemUpdate([keyedItem], [keyedItem.GetKey()]); } }
    /**
     * @private
     * @function
     * @summary - Adds the given given [itemData]{@link object} to the update cache for later update by the function {@link tf.js.KeyedList#UpdateFromItemDataCache}.
     * This function is used internally by the API to implement Keyed List nesting
     * @param {object} itemData - a custom, application defined, JavaScript object from which a [Key]{@link tf.types.Key} can extracted using the {@link tf.types.GetKeyFromData} callback
     * provided on the creation settings of this Keyed List instance
     * @returns {void} - | {@link void} no return value
    */
    this.AddItemDataToUpdateCache = function (itemData) { return addItemDataToUpdateCache(itemData); }
    /**
     * @private
     * @function
     * @summary - Updates this Keyed List instance from the contents added to its update by the function {@link tf.js.KeyedList#AddItemDataToUpdateCache}.
     * This function is used internally by the API to implement Keyed List nesting
     * @returns {void} - | {@link void} no return value
    */
    this.UpdateFromItemDataCache = function (itemData) { return updateFromItemDataCache(); }
    /**
     * @private
     * @function
     * @summary - Marks this instance for deletion
     * @returns {void} - | {@link void} no return value
    */
    this.OnDelete = function () { return onDelete(); }
    function onDelete() { notifyListEvent(tf.consts.keyedListDeleteEvent, list, keyList); removeAll(false); allEventDispatchers.OnDelete(); }
    function makeEventNotification(eventName, items, keys) { return { sender: theThis, eventName: eventName, items: items, keys: keys }; }
    function notifyListEvent(eventName, items, keys) { return allEventDispatchers.Notify(eventName, makeEventNotification(eventName, items, keys)); }
    function notifyListItemAdd(items, keys) { notifyListEvent(tf.consts.keyedListAddedItemsEvent, items, keys); }
    function notifyListItemUpdate(items, keys) { notifyListEvent(tf.consts.keyedListUpdatedItemsEvent, items, keys); }
    function notifyListItemDelete(items, keys) { notifyListEvent(tf.consts.keyedListDeletedItemsEvent, items, keys); }
    function removeItemByKey(itemKey, notify) { var item = getItem(itemKey); return !!item ? removeItem(item, notify) : false; }
    function hasKey(theKey) { return !!list[tf.js.MakeObjectKey (theKey)]; }
    function hasItem(theItem) { return !!theItem && (isListOfLists ? theItem instanceof tf.js.KeyedList : theItem instanceof tf.js.KeyedItem) && hasKey(theItem.GetKey()); }
    function getItem(theKey) { return hasKey(theKey) ? list[tf.js.MakeObjectKey (theKey)] : null; }
    function removeAll(doNotify) { for (var i in list) { removeItem(list[i], doNotify); } }
    function removeItems(items, keys) { if (!!items) { notifyListItemDelete(items, keys); for (var i in items) { removeItem(items[i], false); } } }
    function removeItem(theItem, notify) {
        if (hasItem(theItem)) {
            var itemKey = theItem.GetKey();
            var privateKey = makePrivateKey(itemKey);
            if (!!notify) { notifyListItemDelete([theItem], [itemKey]); }
            theItem.OnDelete();
            delete keyList[privateKey];
            delete list[privateKey];
            --itemCount;
            return true;
        }
        return false;
    }
    function getNotUpdated() {
        var items = [], keys = [];
        for (var i in list) { var theItem = list[i]; if (theItem.GetLastTimeUpdated() < lastTimeUpdated) { items.push(theItem); keys.push(theItem.GetKey()); } }
        return { foundSome: !!items.length, items: items, keys: keys };
    }
    function addOrGetItem(itemData, notify) {
        var item = null;
        var itemKey = getKeyFromDataFunction(itemData);
        var isExisting = false;
        if (!!itemKey) {
            if (!(isExisting = !!(item = getItem(itemKey)))) {
                if (!filterAddItemCallBack || filterAddItemCallBack(itemData)) {
                    if (isListOfLists) {
                        item = new tf.js.KeyedList({
                            key: itemKey,
                            getKeyFromItemData: settingsGetKeyFromData,
                            needsUpdateItemData: needsUpdateItemData
                        });
                    }
                    else {
                        item = new tf.js.KeyedItem({
                            list: theThis,
                            key: itemKey,
                            itemData: itemData,
                            needsUpdateItemData: needsUpdateItemData
                        });
                    }
                    var privateKey = makePrivateKey(itemKey);
                    keyList[privateKey] = itemKey;
                    list[privateKey] = item;
                    ++itemCount;
                    if (!!notify) { notifyListItemAdd([item], [itemKey]); }
                }
            }
        }
        return { isExisting: isExisting, item: item, key: itemKey };
    }
    function addItemDataToUpdateCache (itemData) { if (!!itemData) { if (!cachedItemDatas) { cachedItemDatas = [] } cachedItemDatas.push(itemData); } }
    function updateFromItemDataCache() { var updated = false; if (!!cachedItemDatas) { updated = updateFromNewData(cachedItemDatas); cachedItemDatas = null; } return updated; }
    function updateFromNewData(newData) {
        var addedItems = [], addedKeys = [];
        var updatedItems = [], updatedKeys = [];
        var addedSome = false, updatedSome = false, deletedSome = false;
        lastTimeUpdated = new Date();
        if (!!newData) {
            var newListUse = tf.js.GetIsArray(newData) ? newData : [newData];
            var seenKeys = {}, seenUpdatedKeys = {}, listsToUpdate = {};
            for (var i in newListUse) {
                var itemData = newListUse[i];
                var addedOrGotten = addOrGetItem(itemData, false);
                var isExistingItem = addedOrGotten.isExisting;
                var item = addedOrGotten.item;
                var key = addedOrGotten.key;
                if (isExistingItem) {
                    if (isListOfLists) {
                        item.AddItemDataToUpdateCache(itemData);
                        if (!seenKeys[key]) { if (!listsToUpdate[key]) { listsToUpdate[key] = item; } }
                    }
                    else {
                        if (item.privateUpdate(itemData)) {
                            if (!seenKeys[key]) { if (!seenUpdatedKeys[key]) { seenUpdatedKeys[key] = key; updatedItems.push(item); updatedKeys.push(key); } }
                        }
                    }
                }
                else if (!!item) {
                    if (isListOfLists) { item.AddItemDataToUpdateCache(itemData); }
                    seenKeys[key] = item;
                    addedItems.push(item); addedKeys.push(key);
                }
            }
            if (addedSome = addedItems.length > 0) {
                if (isListOfLists) { for (var i in addedItems) { addedItems[i].UpdateFromItemDataCache(); } }
                notifyListItemAdd(addedItems, addedKeys);
            }
            if (isListOfLists) {
                for (var i in listsToUpdate) {
                    var listItem = listsToUpdate[i];
                    if (listItem.UpdateFromItemDataCache()) {
                        updatedKeys.push(i); updatedItems.push(listItem);
                    }
                }
            }
            if (updatedSome = updatedItems.length > 0) { notifyListItemUpdate(updatedItems, updatedKeys); }
        }
        if (!keepNotUpdated) {
            var notUpdated = getNotUpdated();
            if (deletedSome = notUpdated.foundSome) {
                removeItems(notUpdated.items, notUpdated.keys);
            }
        }
        return addedSome || updatedSome || deletedSome;
    }
    function getNullKey() { return null; }
    function setKeyFromDataCallBack() {
        getKeyFromDataFunction = undefined;
        isListOfLists = false;
        settingsGetKeyFromData = settings.getKeyFromItemData;
        if (!!settingsGetKeyFromData) {
            if (typeof settingsGetKeyFromData === "function") {
                getKeyFromDataFunction = tf.js.GetFunctionOrNull(settingsGetKeyFromData);
            }
            else if (tf.js.GetIsNonEmptyArray(settingsGetKeyFromData)) {
                getKeyFromDataFunction = tf.js.GetFunctionOrNull(settingsGetKeyFromData[0]);
                settingsGetKeyFromData = settingsGetKeyFromData.slice(1);
                if (!(isListOfLists = settingsGetKeyFromData.length > 0)) {
                    settingsGetKeyFromData = null;
                }
            }
        }
        
        if (!getKeyFromDataFunction) { getKeyFromDataFunction = getNullKey; }
    }
    function initialize() {
        allEventDispatchers = new tf.events.MultiEventNotifier({ eventNames: tf.consts.allKeyedListEventNames });
        makePrivateKey = tf.js.MakeObjectKey;
        list = {}; keyList = {}; itemCount = 0;
        settings = tf.js.GetValidObjectFrom(settings);
        name = settings.name;
        needsUpdateItemData = tf.js.GetFunctionOrNull(settings.needsUpdateItemData);
        keepNotUpdated = tf.js.GetBoolFromValue(settings.keepNotUpdated, false);
        filterAddItemCallBack = tf.js.GetFunctionOrNull(settings.filterAddItem);
        key = settings.key;
        setKeyFromDataCallBack();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * A callback function that must be provided in the creation of [Keyed Lists Periodic Refresh]{@link tf.js.KeyedListsPeriodicRefresh} instances to 
 * preprocess the data returned by the remote service into an {@link enumerable} used to update the [Keyed List]{@link tf.js.KeyedList} instances 
 * managed by the Periodic Refresh via their [UpdateFromNewData]{@link tf.js.KeyedList#UpdateFromNewData} functions.
 * @public
 * @callback tf.types.PreProcessServiceData
 * @param {object} data - an object returned from the remote service
 * @returns {enumerable<object>} - | {@link enumerable}<{@link object}> the parameter to be passed to [UpdateFromNewData]{@link tf.js.KeyedList#UpdateFromNewData}
 */
/**
 * Notifications sent by [Keyed Lists Periodic Refresh]{@link tf.js.KeyedListsPeriodicRefresh} instances. Properties are available in notifications that require them
 * @public
 * @typedef {object} tf.types.KeyedListsPeriodicRefreshNotification
 * @property {tf.js.KeyedListsPeriodicRefresh} sender - the instance sending the notification
*/
/**
 * A callback function that receives notifications from a [Keyed Lists Periodic Refresh]{@link tf.js.KeyedListsPeriodicRefresh} instance
 * @public
 * @callback tf.types.KeyedListsPeriodicRefreshCallBack
 * @param {tf.types.KeyedListsPeriodicRefreshNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * Settings used in the creation of [Keyed Lists Periodic Refresh]{@link tf.js.KeyedListsPeriodicRefresh} instances
 * @public
 * @typedef {object} tf.types.KeyedListsPeriodicRefreshSettings
 * @property {enumerable<tf.js.KeyedList | tf.types.KeyedListSettings>} keyedLists - a non-empty enumerable whose elements can be a mix of pre-existing [Keyed Lists]{@link tf.js.KeyedList} 
 * instances or settings used in the creation of new lists
 * @property {tf.types.PreProcessServiceData} preProcessServiceData - a mandatory callback that transforms raw data returned from a service into data digestible by [Keyed List]{@link tf.js.KeyedList} instances
 * @property {string | tf.types.GetUrlFunction} serviceURL - a mandatory url to access, either the url string itself or a function that returns an url string
 * @property {number} refreshMillis - The desired number of milliseconds between periodic refreshes
 * @property {boolean} useRedirect - if set to <b>true</b> requests are sent using a redirect proxy, to avoid cross domain violations
 * @property {boolean} refreshOnCreate - if set to <b>true</b> the first request is sent immediately upon creation of this instance
 * @property {tf.types.KeyedListsPeriodicRefreshCallBack} onCreated - a callback notified upon completion of the first refresh operation 
 * @property {tf.types.KeyedListsPeriodicRefreshCallBack} refreshCallback - a callback notified upon completion of the each refresh operation
 * @property {boolean} retryOnFail - if set to <b>true</b> requests are re-sent immediately upon failure, defaults to {@link void}
*/
/**
 * @public
 * @class
 * @summary Instances of Keyed Lists Periodic Refresh retrieve data from remote services to update one or more [Keyed List]{@link tf.js.KeyedList} instances, using 
 * their respective [UpdateFromNewData]{@link tf.js.KeyedList#UpdateFromNewData} functions. Instances can work with pre-existing Keyed Lists or create new ones
 * @param {tf.types.KeyedListsPeriodicRefreshSettings} settings - Keyed Lists Periodic Refresh creation settings
*/
tf.js.KeyedListsPeriodicRefresh = function (settings) {
    var defaultRefreshTimeOutMillis = 1000 * 60 * 10;
    var theThis, periodicJSONGet, keyedListsByName, keyedLists, refreshMillis, newData;
    var refreshCallback, onCreatedCallback, refreshListeners, refreshCount, isDeleted;
    /**
     * @public
     * @function
     * @summary - Retrieves by name one of the [Keyed Lists]{@link tf.js.KeyedList} associated with this instance
     * @param {string} listName - the name of the list
     * @returns {tf.js.KeyedList} - | {@link tf.js.KeyedList} the list, if a list named <b>listName</b> is found
    */
    this.GetKeyedList = function (listName) { return getKeyedList(listName); }
    /**
     * @public
     * @function
     * @summary - Triggers an immediate refresh
     * @returns {void} - | {@link void} no return value
    */
    this.RefreshNow = function () { return refreshNow(); }
    /**
     * @public
     * @function
     * @summary - Retrieves the number of refresh operations performed by this instance
     * @returns {number} - | {@link number} the number of refreshes
    */
    this.GetRefreshCount = function () { return refreshCount; }
    /**
     * @public
     * @function
     * @summary - Checks if a refresh operation is in progress (a request was sent, but a response has not been received)
     * @returns {boolean} - | {@link boolean } <b>true</b> if a refresh is in progress, <b>false</b> otherwise
    */
    this.GetIsRefreshing = function () { return periodicJSONGet.GetIsRefreshing(); }
    /**
     * @public
     * @function
     * @summary - Adds a listener for list refresh events
     * @param {tf.types.KeyedListsPeriodicRefreshCallBack} callBack - the callback for event notifications
     * @returns {tf.events.EventListener} - | {@link tf.events.EventListener} the event listener
    */
    this.AddOnRefreshListener = function (callBack) { return addListener(refreshListeners, callBack); }
    /**
     * @private
     * @function
     * @summary - Marks this instance for deletion
     * @returns {void} - | {@link void} no return value
    */
    this.OnDelete = function () { return onDelete(); }
    function getKeyedList(listName) { return keyedListsByName[listName]; }
    function onDelete() {
        isDeleted = true;
        if (periodicJSONGet) { periodicJSONGet.OnDelete(); periodicJSONGet = null; }
        refreshListeners = deleteListener(refreshListeners);
        for (var i in keyedLists) { keyedLists[i].OnDelete(); } keyedLists = null; keyedListsByName = {};
    }
    function deleteListener(theListener) { if (!!theListener) { theListener.OnDelete(); } return null; }
    function refreshNow() { if (periodicJSONGet) { periodicJSONGet.RefreshNow(); } }
    function onNotifyRefresh() { return refreshListeners.Notify({ sender: theThis }); }
    function updateFromNewData(data) {
        ++refreshCount;
        if (!refreshMillis) { periodicJSONGet.Cancel(); }
        var notify = true;
        if (!data) {
            if (settings.retryOnFail) {
                notify = false;
                tf.GetDebug().LogIfTest("KeyedListsPeriodicRefresh: retrying JSON download");
                setTimeout(refreshNow, 1000);
                //refreshNow();
            }
        }
        if (notify) {
            var newData = settings.preProcessServiceData(data);
            for (var i in keyedLists) { keyedLists[i].UpdateFromNewData(newData); }
        }
    }
    function notifyRefresh() { if (!!refreshCallback) { refreshCallback({ sender: theThis }); } onNotifyRefresh(); }
    function onListLoaded(notification) { if (!isDeleted) { updateFromNewData(notification.data); notifyRefresh(); } }
    function onListLoadedFirstTime(notification) {
        if (!isDeleted) {
            periodicJSONGet.ChangeCallBack(onListLoaded);
            updateFromNewData(notification.data);
            if (!!onCreatedCallback) { var occb = onCreatedCallback; onCreatedCallback = null; occb({ sender: theThis }); }
            notifyRefresh();
        }
    }
    function createPeriodicRefresh() {
        var autoRefresh = ((refreshMillis = tf.js.GetNonNegativeIntFrom(settings.refreshMillis)) > 0);
        periodicJSONGet = new tf.ajax.PeriodicJSONGet({
            url: settings.serviceURL,
            refreshMillis: refreshMillis ? refreshMillis : defaultRefreshTimeOutMillis,
            autoRefresh: autoRefresh,
            onRefresh: onListLoadedFirstTime,
            optionalScope: theThis,
            useRedirect: settings.useRedirect
        });
        if (tf.js.GetBoolFromValue(settings.refreshOnCreate, true)) { periodicJSONGet.RefreshNow(); }
    }
    function initialize() {
        keyedLists = [];
        keyedListsByName = {};
        if (!!settings && typeof settings === "object" && !!settings.keyedLists && tf.js.GetIsArray(settings.keyedLists)) {
            isDeleted = false;
            refreshListeners = new tf.events.EventNotifier();
            refreshCallback = tf.js.GetFunctionOrNull(settings.refreshCallback);
            onCreatedCallback = tf.js.GetFunctionOrNull(settings.onCreated);
            for (var i in settings.keyedLists) {
                var keyedList = settings.keyedLists[i];
                if (!!keyedList) {
                    if (!(keyedList instanceof tf.js.KeyedList)) { keyedList = tf.js.GetIsValidObject(keyedList) ? new tf.js.KeyedList(keyedList) : null; }
                    if (!!keyedList) { keyedLists.push(keyedList); keyedListsByName[keyedList.GetName()] = keyedList; }
                }
            }
            if (keyedLists.length) { createPeriodicRefresh(); }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Notifications sent by {@link tf.map.KeyedFeatureList} instances. Properties are available in notifications that require them
 * @public
 * @typedef {object} tf.types.KeyedFeatureListEventNotification
 * @property {tf.map.KeyedFeatureList} sender - the instance sending the notification
 * @property {tf.types.keyedFeatureListEventName} eventName - the name of the event
 * @property {enumerable<tf.map.KeyedFeature>} items - the associated keyed features
 * @property {enumerable<tf.types.Key>} keyes - the associated keys
*/
/**
 * A callback function that can be passed to the function {@link tf.map.KeyedFeatureList#AddListener} to start receiving keyed feature list event notifications
 * @public
 * @callback tf.types.KeyedFeatureListEventCallBack
 * @param {tf.types.KeyedFeatureListEventNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * Settings used in the creation of [Keyed Feature List]{@link tf.map.KeyedFeatureList} instances
 * @public
 * @typedef {object} tf.types.KeyedFeatureListSettings
 * @property {tf.js.KeyedList} keyedList - the associated [Keyed List]{@link tf.js.KeyedList} instance
 * @property {string} layerName - the name of [Feature Layers]{@link tf.map.FeatureLayer} allowed to display the [Keyed Features]{@link tf.map.KeyedFeature} in this list. 
 * Defaults to the name of the associated [Keyed List]{@link tf.js.KeyedList} instance. Applications may define this property to override the default settings
 * @property {tf.types.PropertyName} propertyName - The name of the [Keyed Item]{@link tf.js.KeyedItem} property to be associated with [Keyed Features]{@link tf.map.KeyedFeature} in this list
 * Defaults to {@link tf.consts.KeyedFeatureProperty}. Applications must uniquely define this property if more than one [Keyed Feature List]{@link tf.map.KeyedFeatureList} will be associated with
 * the given <b>[keyedList]{@link tf.js.KeyedList}</b>
 * @property {tf.types.GetGeoJSONGeometryCallBack} getGeometryFromData - a callback capable of retrieving [GeoJSON Geometry]{@link tf.types.GeoJSONGeometry} from a keyed item's data,
 defaults to {@link tf.js.GetGeoJSONGeometryFrom}
 * @property {tf.types.NamedFeatureStyleSettings} featureStyleSettings - feature style settings
*/
/**
 * @public
 * @class
 * @summary Each instance of this class is associated with a single [Keyed List]{@link tf.js.KeyedList} instance and is responsible automating the creation, update,
 * and deletion of the [Keyed Features]{@link tf.map.KeyedFeature} corresponding to the [Keyed Items]{@link tf.js.KeyedItem} that are added, updated, and deleted from that list.
 * @param {tf.types.KeyedFeatureListSettings} settings - keyed feature list creation settings
 */
tf.map.KeyedFeatureList = function (settings) {
    var theThis, keyedList, keyedListName, featureStyleSettings, listMonitor, getGeometryFromData, layerName, propertyName, allEventDispatchers;
    /**
     * @public
     * @function
     * @summary - Adds a listener for the given event name
     * @param {tf.types.keyedFeatureListEventName} eventName - the name of the event
     * @param {tf.types.KeyedFeatureListEventCallBack} callBack - the callback for event notifications
     * @returns {tf.events.EventListener} - | {@link tf.events.EventListener} the event listener
    */
    this.AddListener = function (eventName, callbackFunction) { return allEventDispatchers.AddListener(eventName, callbackFunction); }
    /**
     * @public
     * @function
     * @summary - Adds one or more listeners for the given event names
     * @param {tf.types.EventNamesAndCallBacks} eventNamesAndCallBacks - the event names and callbacks
     * @returns {tf.types.EventNamesAndListeners} - | {@link tf.types.EventNamesAndListeners} the event names and listeners
    */
    this.AddListeners = function (eventNamesAndCallBacks) { return allEventDispatchers.AddListeners(eventNamesAndCallBacks); }
    /**
     * @public
     * @function
     * @summary - Sends the given <b>callBack</b> a [Features Added Event]{@link tf.consts.keyedFeaturesAddedEvent} with all keyed features currently in this keyed feature list
     * @param {tf.types.KeyedFeatureListEventCallBack} callBack - the callback
     * @returns {void} - | {@link void} no return value
    */
    this.NotifyFeaturesAdded = function (callBack) { if (tf.js.GetFunctionOrNull(callBack)) { return notifyFeaturesAdded(); } }
    /**
     * @public
     * @function
     * @summary - Shows or hides all keyed features in this keyed feature list on the given map instance
     * @param {tf.map.Map} map - the map instance
     * @param {boolean} showOrHideBool - <b>true</b> to show the features, <b>false</b> to hide them
     * @param {string} styleName - optional feature style name
     * @returns {void} - | {@link void} no return value
    */
    this.ShowAllOnMap = function (map, showOrHideBool, styleName) { return showAllOnMap(map, showOrHideBool, styleName); }
    /**
     * @public
     * @function
     * @summary - Shows or hides some keyed features in this keyed feature list on the given map instance
     * @param {tf.map.Map} map - the map instance
     * @param {enumerable} keyList - an enumerable containing the keys of the features to be shown or hidden
     * @param {boolean} showOrHideBool - <b>true</b> to show the features, <b>false</b> to hide them
     * @param {string} styleName - optional feature style name
     * @returns {void} - | {@link void} no return value
    */
    this.ShowSomeOnMap = function (map, keyList, showOrHideBool, styleName) { return showSomeOnMap(map, keyList, showOrHideBool, styleName); }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Keyed List]{@link tf.js.KeyedList} instance associated with this keyed feature list
     * @returns {tf.js.KeyedList} - | {@link tf.js.KeyedList} the keyed list instance
    */
    this.GetKeyedList = function () { return keyedList; }
    /**
     * @public
     * @function
     * @summary - Retrieves the name of the [Keyed List]{@link tf.js.KeyedList} instance associated with this keyed feature list
     * @returns {string} - | {@link string} the name
    */
    this.GetKeyedListName = function () { return keyedListName; }
    /**
     * @public
     * @function
     * @summary - Retrieves the name of [Feature Layers]{@link tf.map.FeatureLayer} allowed to display the [Keyed Features]{@link tf.map.KeyedFeature} in this keyed feature list
     * @returns {string} - | {@link string} the name
    */
    this.GetLayerName = function () { return layerName; }
    /**
     * @public
     * @function
     * @summary - Retrieves the name of the [Keyed Item]{@link tf.js.KeyedItem} property that is associated with [Keyed Features]{@link tf.map.KeyedFeature} in this keyed list
     * @returns {tf.types.PropertyName} - | {@link tf.types.PropertyName} the name
    */
    this.GetPropertyName = function () { return propertyName; }
    /**
     * method tf.map.KeyedFeatureList.GetPointFeaturesCloseTo - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
     * @param {?} coords - parameter description?
     * @param {?} radiusInMeters - parameter description?
     * @param {?} sortBool - parameter description?
    */
    this.GetPointFeaturesCloseTo = function (coords, radiusInMeters, sortBool) { return getPointFeaturesCloseTo(coords, radiusInMeters, sortBool); }
    /**
     * @public
     * @function
     * @summary - Forces the re-creation of one or more of the keyed feature's named styles whose keyes are given
     * @param {enumerable} keyList - an enumerable containing the keys of the features whose styles are to be refreshed
     * @param {string | enumerable<string>} styleNameOrNames - the name of the style to refresh, or an enumerable of style names to refresh
     * @returns {void} - | {@link void} no return value
    */
    this.RefreshStyle = function (keyList, styleNameOrNames) { return refreshStyle(keyList, styleNameOrNames); }
    /**
     * @public
     * @function
     * @summary - Retrieves an {@link enumerable} of [Keyed Features]{@link tf.map.KeyedFeature} whose keyes are given
     * @param {enumerable} keyList - an enumerable containing the keys of the features to be retrieved
     * @returns {enumerable<tf.map.KeyedFeature>} - | {@link enumerable}<{@link tf.map.KeyedFeature}> the keyed features
    */
    this.GetFeatures = function (keyList) { return getFeatures(keyList); }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Keyed Feature]{@link tf.map.KeyedFeature} whose key is given, if one exists
     * @param {tf.types.Key} itemKey - the key
     * @returns {tf.map.KeyedFeature} - | {@link tf.map.KeyedFeature} the keyed feature or {@link void}
    */
    this.GetFeature = function (itemKey) { return getFeature(itemKey); }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Keyed Feature]{@link tf.map.KeyedFeature} associated with the given [Keyed Item]{@link tf.js.KeyedItem}, if one exists
     * @param {tf.js.KeyedItem} keyedItem - the keyed item
     * @returns {tf.map.KeyedFeature} - | {@link tf.map.KeyedFeature} the keyed feature or {@link void}
    */
    this.GetFeatureFromItem = function (keyedItem) { return getFeatureFromItem(keyedItem); }
    /**
     * @private
     * @function
     * @summary - Marks this instance for deletion
     * @returns {void} - | {@link void} no return value
    */
    this.OnDelete = function () { return onDelete(); }
    function compareDistances(obj1, obj2) { return obj1.distance < obj2.distance ? -1 : obj1.distance > obj2.distance ? 1 : 0; }
    function getPointFeaturesCloseTo(coords, radiusInMeters, sortBool) {
        var pointFeatureKeys = [];
        if (!!coords) {
            var keyedItemList = getKeyedItemList();
            if (!!keyedItemList) {
                var coordsUse = tf.js.GetMapCoordsFrom(coords);
                var radius = tf.js.GetFloatNumber(radiusInMeters, 1000);
                sortBool = !!sortBool;
                for (var i in keyedItemList) {
                    var keyedItem = keyedItemList[i];
                    var itemKey = keyedItem.GetKey();
                    var feature = getFeature(itemKey).GetMapFeature();
                    if (feature.GetIsPoint()) {
                        var featureCoords = feature.GetGeom().GetPointCoords();
                        if (!!featureCoords) {
                            var featureDistance = tf.units.GetDistanceInMetersBetweenMapCoords(featureCoords, coordsUse);
                            if (featureDistance <= radius) {
                                if (sortBool) {
                                    pointFeatureKeys.push({ itemKey: itemKey, distance: featureDistance });
                                }
                                else {
                                    pointFeatureKeys.push(itemKey);
                                }
                            }
                        }
                    }
                }
                if (sortBool && !!pointFeatureKeys.length) {
                    pointFeatureKeys.sort(compareDistances);
                    var itemKeys = [], itemDistances = [];
                    for (var i in pointFeatureKeys) {
                        itemKeys.push(pointFeatureKeys[i].itemKey);
                        itemDistances.push(pointFeatureKeys[i].distance);
                    }
                    pointFeatureKeys.sortedKeyesAndDistances = { itemKeys: itemKeys, itemDistances: itemDistances };
                }
            }
        }
        return pointFeatureKeys;
    }
    function showAllOnMap(map, showOrHideBool, styleNameForShow) {
        if (tf.js.GetIsMap(map)) { map.ShowAllKeyedFeatures(theThis, showOrHideBool, styleNameForShow); }
    }
    function showSomeOnMap(map, keyList, showOrHideBool, styleNameForShow) {
        if (tf.js.GetIsMap(map)) { map.ShowSomeKeyedFeatures(theThis, keyList, showOrHideBool, styleNameForShow); }
    }
    function refreshStyle(keyList, styleNameOrNames) {
        keyList = null;
        if (!tf.js.GetIsValidObject(keyList)) { keyList = keyedList.GetKeyList(); }
        for (var i in keyList) {
            var feature = getFeature(keyList[i]);
            if (!!feature) { feature.RefreshStyle(styleNameOrNames); }
        }
    }
    function onCreated(theList) {
        var onCreated = tf.js.GetFunctionOrNull(settings.onCreated);
        if (!!onCreated) { onCreated(theThis); }
    }
    function onDelete() {
        deleteAllFeatures();
        if (!!monitor) { monitor.OnDelete(); monitor = null; }
        coreList = backendList = timedRefreshList = keyedList = null;
    }
    function getFeatures(keyList) {
        var features = [];
        if (!keyList) { keyList = keyedList.GetKeyList(); }
        for (var i in keyList) {
            var key = keyList[i];
            var feature = getFeature(key);
            if (!!feature) { features.push(feature); }
        }
        return features;
    }
    function getFeature(itemKey) { return !!keyedList ? getFeatureFromItem(keyedList.GetItem(itemKey)) : null; }
    function getFeatureFromItem(keyedItem) { return tf.js.GetObjProperty(keyedItem, propertyName); }
    function setFeatureToItem(keyedItem, feature) { return tf.js.SetObjProperty(keyedItem, propertyName, feature); }
    function deleteFeatureFromItem(keyedItem) { var feature = getFeatureFromItem(keyedItem); if (!!feature) { feature.OnDelete(); setFeatureToItem(keyedItem, null); } }
    function createFeatureForItem(keyedItem) {
        setFeatureToItem(keyedItem, new tf.map.KeyedFeature({
            featureList: theThis,
            keyedItem: keyedItem,
            getGeometryFromData: getGeometryFromData,
            styleSettings: featureStyleSettings
        }));
    }
    function getKeyedItemList() { return !!keyedList ? keyedList.GetKeyedItemList() : []; }
    function getKeyList() { return !!keyedList ? keyedList.GetKeyList() : []; }
    function deleteAllFeatures() {
        var keyedItemList = getKeyedItemList();
        var keyList = getKeyList();
        allFeatures.Notify(featuresDeletedListener, keyedItemList, keyList);
        for (var i in keyedItemList) { deleteFeatureFromItem(keyedItemList[i]); }
    }
    function onListDeleted(monitor) { deleteAllFeatures(); }
    function doNotification(eventName, notification) {
        allEventDispatchers.Notify(eventName, tf.js.ShallowMerge(notification, { sender: theThis, eventName: eventName }));
    }
    function doNotifyFeaturesAdded(items, keys) {
        doNotification(tf.consts.keyedFeaturesAddedEvent, { items: items, keys: keys });
    }
    function notifyFeaturesAdded() { if (!!keyedList) { doNotifyFeaturesAdded(keyedList.GetKeyedItemList(), keyedList.GetKeyList()); } }
    function onListItemsAdded(notification) {
        var items = notification.items;
        if (!tf.js.GetIsArray(items)) {
            var localItems = [];
            for (var i in items) { localItems.push(items[i]); }
            items = localItems;
        }
        for (var i = items.length - 1 ; i >= 0; --i) { createFeatureForItem(items[i]); }
        //for (var i in items) { createFeatureForItem(items[i]); }
        doNotifyFeaturesAdded(items, notification.keys);
    }
    function onListItemsUpdated(notification) {
        var items = notification.items;
        for (var i in items) { var itemFeature = getFeatureFromItem(items[i]); if (!!itemFeature) { itemFeature.UpdateFromItem(); } }
        doNotification(tf.consts.keyedFeaturesUpdatedEvent, { items: items, keys: notification.keys });
    }
    function onListItemsDeleted(notification) {
        var items = notification.items;
        doNotification(tf.consts.keyedFeaturesDeletedEvent, { items: items, keys: notification.keys });
        for (var i in items) { deleteFeatureFromItem(items[i]); }
    }
    function initialize() {
        allEventDispatchers = new tf.events.MultiEventNotifier({ eventNames: tf.consts.allKeyedFeaturesEventNames });
        if (typeof settings === "object") {
            keyedList = settings.keyedList;
            if (!!keyedList && keyedList instanceof tf.js.KeyedList) {
                featureStyleSettings = tf.js.ShallowMerge(settings.featureStyleSettings);
                if (typeof featureStyleSettings.styles === "object") {
                    for (var style in featureStyleSettings.styles) {
                        var theStyle = featureStyleSettings.styles[style];
                        if (typeof theStyle === "object") {
                            theStyle.style = tf.map.GetOrCreateFeatureStyle(theStyle.style);
                            if (!!theStyle.hoverStyle) { theStyle.hoverStyle = tf.map.GetOrCreateFeatureStyle(theStyle.hoverStyle); }
                        }
                    }
                }
                else {
                    featureStyleSettings.style = tf.map.GetOrCreateFeatureStyle(featureStyleSettings.style, null);
                    if (!!featureStyleSettings.hoverStyle) {
                        featureStyleSettings.hoverStyle = tf.map.GetOrCreateFeatureStyle(featureStyleSettings.hoverStyle, null);
                    }
                }
                layerName = tf.js.GetNonEmptyString(settings.layerName, keyedListName = keyedList.GetName());
                propertyName = tf.js.GetNonEmptyString(settings.propertyName, tf.consts.KeyedFeatureProperty);
                getGeometryFromData = tf.js.GetGeoJSONGeometryFunctionFrom(settings.getGeometryFromData);
                var listeners = {};
                listeners[tf.consts.keyedListDeleteEvent] = onListDeleted;
                listeners[tf.consts.keyedListAddedItemsEvent] = onListItemsAdded;
                listeners[tf.consts.keyedListUpdatedItemsEvent] = onListItemsUpdated;
                listeners[tf.consts.keyedListDeletedItemsEvent] = onListItemsDeleted;
                listMonitor = keyedList.AddListeners(listeners);
                keyedList.NotifyItemsAdded(onListItemsAdded);
            }
        }
        setTimeout(onCreated, 10);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Settings used in the creation of [Keyed Feature]{@link tf.map.KeyedFeature} instances
 * @public
 * @typedef {object} tf.types.KeyedFeatureSettings
 * @property {tf.map.KeyedFeatureList} featureList - the associated [Keyed Feature List]{@link tf.map.KeyedFeatureList} instance
 * @property {tf.js.KeyedItem} keyedItem - the associated [Keyed Item]{@link tf.js.KeyedItem} instance
 * @property {tf.types.GetGeoJSONGeometryCallBack} getGeometryFromData - a callback capable of retrieving [GeoJSON Geometry]{@link tf.types.GeoJSONGeometry} from the keyed item's data
 * @property {tf.types.NamedFeatureStyleSettings} styleSettings - style settings
*/
/**
 * @public
 * @class
 * @summary Keyed Map Features can be displayed in one or more [Feature Layers]{@link tf.map.FeatureLayer} of different [Maps]{@link tf.map.Map}.
 * Each instance of this class manages one instance of [Map Feature with Named Styles]{@link tf.map.FeatureWithNamedStyles} and is
 * uniquely associated with an instance of [Keyed Item]{@link tf.js.KeyedItem}.
 * Applications do not create Keyed Features directly, they are automatically created and deleted by their associated [Keyed Feature Lists]{@link tf.map.KeyedFeatureList}
 * @param {tf.types.KeyedFeatureSettings} settings - keyed feature creation settings
 */
tf.map.KeyedFeature = function (settings) {
    var theThis, debug, featureList, keyedItem, keyedItemKey, keyedListName, layerName, propertyName, mapFeature, styleSettings;
    var markerSettings, getGeometryFromData, isDeleted;
    /**
     * @public
     * @function
     * @summary - Retrieves the [Keyed Feature List]{@link tf.map.KeyedFeatureList} instance associated with this keyed feature instance
     * @returns {tf.map.KeyedFeatureList} - | {@link tf.map.KeyedFeatureList} the list instance
    */
    this.GetFeatureList = function () { return featureList; }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Keyed Item]{@link tf.js.KeyedItem} instance associated with this keyed feature instance
     * @returns {tf.js.KeyedItem} - | {@link tf.js.KeyedItem} the item instance
    */
    this.GetKeyedItem = function () { return keyedItem; }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Key]{@link tf.types.Key} of the [Keyed Item]{@link tf.js.KeyedItem} instance associated with this keyed feature instance
     * @returns {tf.types.Key} - | {@link tf.types.Key} the key
    */
    this.GetKeyedItemKey = function () { return keyedItemKey; }
    /**
     * @public
     * @function
     * @summary - Retrieves the name of the [Keyed List]{@link tf.js.KeyedList} containing the [Keyed Item]{@link tf.js.KeyedItem} instance associated with this keyed feature instance
     * @returns {string} - | {@link string} the name
    */
    this.GetKeyedListName = function () { return keyedListName; }
    /**
     * @public
     * @function
     * @summary - Retrieves the name of the [Feature Layer]{@link tf.map.FeatureLayer] instance where this keyed feature instance can be displayed
     * @returns {string} - | {@link string} the name
    */
    this.GetLayerName = function () { return layerName; }
    /**
     * @public
     * @function
     * @summary - Retrieves the name of the [Keyed Item]{@link tf.js.KeyedItem} instance property associated with this keyed feature instance
     * @returns {tf.types.PropertyName} - | {@link tf.types.PropertyName} the name
    */
    this.GetPropertyName = function () { return propertyName; }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Key]{@link tf.types.Key} associated with this keyed feature instance
     * @returns {tf.types.Key} - | {@link tf.types.Key} the key
    */
    this.GetFeatureKey = function () { return keyedListName + ':' + propertyName + ':' + keyedItemKey; }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Map Feature]{@link tf.map.Feature} associated with the given style name
     * @param {string} styleName - the name of the style
     * @returns {tf.map.Feature} - | {@link tf.map.Feature} the map feature
    */
    this.GetMapFeature = function (styleName) { return mapFeature ? mapFeature.GetMapFeature(styleName) : null; }
    /**
     * @public
     * @function
     * @summary - Forces the re-creation of one or more of the feature's named styles
     * @param {string | enumerable<string>} styleNameOrNames - the name of the style to refresh, or an enumerable of style names to refresh
     * @returns {void} - | {@link void} no return value
    */
    this.RefreshStyle = function (styleNameOrNames) { if (mapFeature) { mapFeature.RefreshStyle(styleNameOrNames); } }
    /**
     * @public
     * @function
     * @summary - Checks if the type of geometry associated with this feature is "point"
     * @returns {boolean} - | {@link boolean} <b>true</b> if the geometry type is "point", <b>false</b> otherwise
    */
    this.GetIsPoint = function () { return mapFeature ? mapFeature.GetIsPoint() : false; }
    /**
     * @public
     * @function
     * @summary - Changes the map coordinates of a "point" feature
     * @param {tf.types.mapCoordinates} pointCoords - the feature coordinates
     * @returns {void} - | {@link void} no return value
    */
    this.SetPointCoords = function (pointCoords) { return mapFeature ?  mapFeature.SetPointCoords(pointCoords) : false; }
    /**
     * @public
     * @function
     * @summary - Retrieves the current coordinates of a "point" feature
     * @returns {tf.types.mapCoordinates} - | {@link tf.types.mapCoordinates} the coordinates
    */
    this.GetPointCoords = function () { return mapFeature ? mapFeature.GetPointCoords() : [0,0]; }
    /**
     * @public
     * @function
     * @summary - Updates the map feature from its associated [Keyed Item]{@link tf.js.KeyedItem} instance, currently only the coordinates of point features are updated
     * @returns {void} - | {@link void} no return value
    */
    this.UpdateFromItem = function () { return updateFromItem(); }
    /**
     * @private
     * @function
     * @summary - Marks this instance for deletion
     * @returns {void} - | {@link void} no return value
    */
    this.OnDelete = function () { return onDelete(); }
    /**
     * @private
     * @function
     * @summary - Checks if this instance has been marker for deletion
     * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
    */
    this.IsDeleted = function () { return isDeleted; }
    function onDelete() {
        //if (!!debug) { debug.LogIfTest('deleting feature ' + makeFeatureDesc()); }
        mapFeature = null;
        keyedItem = null;
        isDeleted = true;
    }
    function makeFeatureDesc() { return '"' + layerName + ' ' + keyedItem.GetKey() + '"'; }
    function updateFromItem() {
        var updated = false;
        if (!isDeleted) {
            var itemData = keyedItem.GetData();
            if (!!itemData) {
                var nowCoords = mapFeature.GetPointCoords();
                if (!!nowCoords) {
                    var geometry = getGeometryFromData(itemData);
                    if (!!geometry) {
                        if (nowCoords[0] != geometry.coordinates[0] || nowCoords[1] != geometry.coordinates[1]) {
                            mapFeature.SetPointCoords(geometry.coordinates);
                            updated = true;
                        }
                    }
                }
            }
        }
        return updated;
    }
    function resolveFeatureStyles (settings) {
        if (tf.js.GetIsValidObject(settings)) {
            if (tf.js.GetIsValidObject(settings.styles)) {
                for (var style in settings.styles) {
                    var theStyle = settings.styles[style];
                    if (tf.js.GetIsValidObject(theStyle)) {
                        theStyle.style = tf.map.GetOrCreateFeatureStyle(theStyle.style);
                        if (!!theStyle.hoverStyle) { theStyle.hoverStyle = tf.map.GetOrCreateFeatureStyle(theStyle.hoverStyle); }
                    }
                }
            }
            else {
                settings.style = tf.map.GetOrCreateFeatureStyle(settings.style);
                if (!!settings.hoverStyle) { settings.hoverStyle = tf.map.GetOrCreateFeatureStyle(settings.hoverStyle); }
            }
        }
        else { settings = {}; }
        return settings;
    }
    function createFromItem() {
        var itemData = keyedItem.GetData();
        mapFeature = null;
        if (!!itemData) {
            var geometry = getGeometryFromData(itemData);
            if (!!geometry) {
                styleSettings = resolveFeatureStyles(styleSettings);
                var mapFeatureGeom = new tf.map.FeatureGeom({ type: geometry.type, coordinates: geometry.coordinates, simplifyTolerance: styleSettings.simplifyTolerance });
                mapFeature = new tf.map.FeatureWithNamedStyles({ keyedFeature: theThis, geom: mapFeatureGeom, styleSettings: styleSettings });
            }
        }
        return mapFeature != null;
    }
    function initialize() {
        //debug = tf.GetDebug();
        isDeleted = false;
        featureList = settings.featureList;
        keyedItem = settings.keyedItem;
        keyedItemKey = keyedItem.GetKey();
        styleSettings = settings.styleSettings;
        if (!tf.js.GetIsValidObject(styleSettings)) { styleSettings = tf.helpers.CopyDefaultMapFeatureStyleSettings(); }
        if ((featureList instanceof tf.map.KeyedFeatureList) && (keyedItem instanceof tf.js.KeyedItem)) {
            if (!!(getGeometryFromData = tf.js.GetFunctionOrNull(settings.getGeometryFromData))) {
                isDeleted = false;
                keyedListName = keyedItem.GetList().GetName();
                layerName = featureList.GetLayerName();
                propertyName = featureList.GetPropertyName();
                if (!createFromItem()) { onDelete(); }
            }
            else {
                featureList = keyedItem = styleSettings = null;
                isDeleted = true;
            }
        }
        else {
            featureList = keyedItem = styleSettings = null;
            isDeleted = true;
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Settings used in the creation of [Map Feature]{@link tf.map.Feature} instances
 * @public
 * @typedef {object} tf.types.MapFeatureSettings
 * @property {tf.map.FeatureGeom} geom - a geometry instance to be associated with the map feature, if this property is not defined, then <b>type</b> and <b>coordinates</b> are mandatory
 * @property {tf.types.GeoJSONGeometryType} type - the map feature type, mandatory if <b>geom</b> is not defined
 * @property {tf.types.GeoJSONGeometryCoordinates} coordinates - the map feature coordinates, mandatory if <b>geom</b> is not defined
 * @property {tf.types.MapFeatureStyleLike} style - the map feature style
 * @property {tf.types.MapFeatureStyleLike} hoverStyle - the style assumed by the map feature when the mouse pointer is hovering over it
 * @property {tf.map.KeyedFeature} keyedFeature - the keyed feature instance associated with this map feature, if any
 * @property {tf.map.FeatureWithNamedStyles} mapFeatureWithNamedStyles - the map feature with named styles instance associated with this map feature, if any
 * @property {string} styleName - the style name, used by map features that are associated with instances of {@link tf.map.MapFeatureWithNamedStyles}
*/
tf.map.nextFeatureId = 0;
/**
 * @public
 * @class
 * @summary Map Features can be displayed in one or more [Feature Layers]{@link tf.map.FeatureLayer} of the same or different [Maps]{@link tf.map.Map} using a single geometry and set of styles 
 * @param {tf.types.MapFeatureSettings} settings - map feature creation settings
 */
tf.map.Feature = function (settings) {
    var theThis, mapFeatureStyle, mapFeatureNormalStyle, mapFeatureHoverStyle, mapFeatureGeom;
    var APIFeature, keyedFeature, mapFeatureWithNamedStyles, styleName;
    var onRollOverListener, onClickListener, onDoubleClickListener, onHoverInOutListener;
    var isInHover, alwaysInHover, processInHover, id;
    /**
     * @public
     * @function
     * @summary - Changes the geometry of a feature
     * @param {tf.map.FeatureGeom} geom - the new geometry
     * @returns {void} - | {@link void} no return value
    */
    this.SetGeom = function (geom) {
        if (tf.js.GetIsInstanceOf(geom, map.Feature.Geom) && ((!mapFeatureGeom) || (mapFeatureGeom.GetType() == geom.GetType()))) { mapFeatureGeom = geom; refreshGeom(); return true; } return false;
    }
    /**
     * @public
     * @function
     * @summary - Retrieves the geometry instance associated with this feature
     * @returns {tf.map.FeatureGeom} - | {@link tf.map.FeatureGeom} the geometry
    */
    this.GetGeom = function () { return mapFeatureGeom; }
    /**
     * @public
     * @function
     * @summary - Retrieves the style instance associated with this feature
     * @returns {tf.map.FeatureStyle} - | {@link tf.map.FeatureStyle} the style
    */
    this.GetStyle = function () { return mapFeatureStyle; }
    /**
     * @public
     * @function
     * @summary - Forces the re-creation of the feature geometry
     * @returns {void} - | {@link void} no return value
    */
    this.RefreshGeom = function () { return refreshGeom(); }
    /**
     * @public
     * @function
     * @summary - Forces the re-creation of the feature style
     * @returns {void} - | {@link void} no return value
    */
    this.RefreshStyle = function () { return refreshStyle(); }
    /**
     * @public
     * @function
     * @summary - Changes the features's style
     * @param {tf.types.MapFeatureStyleLike} strStyleOrObj - map feature style settings
     * @returns {void} - | {@link void} no return value
    */
    this.ChangeStyle = function (strStyleOrObj) { return changeStyle(strStyleOrObj); }
    /**
     * @public
     * @function
     * @summary - Checks if the type of geometry associated with this feature is "point"
     * @returns {boolean} - | {@link boolean} <b>true</b> if the geometry type is "point", <b>false</b> otherwise
    */
     this.GetIsPoint = function () { return !!mapFeatureGeom ? mapFeatureGeom.GetIsPoint() : false; }
    /**
     * @public
     * @function
     * @summary - Changes the map coordinates of a "point" feature
     * @param {tf.types.mapCoordinates} pointCoords - the feature coordinates
     * @returns {void} - | {@link void} no return value
    */
     this.SetPointCoords = function (pointCoords) { if (mapFeatureGeom.SetPointCoords(pointCoords)) { refreshGeom(); return true; } return false; }
    /**
     * @public
     * @function
     * @summary - Retrieves the current coordinates of a "point" feature
     * @returns {tf.types.mapCoordinates} - | {@link tf.types.mapCoordinates} the coordinates
    */
     this.GetPointCoords = function () { return mapFeatureGeom.GetPointCoords(); }
    /**
     * @public
     * @function
     * @summary - Sets a listener for {@link tf.consts.mapFeatureHoverInOutEvent} map events associated with this feature, replacing the previous listener, if any
     * @param {tf.types.MapEventCallBack} callBack - the callback for event notifications
     * @returns {void} - | {@link void} no return value
    */
     this.SetOnHoverInOutListener = function (callBack) { onHoverInOutListener = tf.js.GetFunctionOrNull(callBack); }
    /**
     * @public
     * @function
     * @summary - Sets a listener for {@link tf.consts.mapFeatureMouseMoveEvent} map events associated with this feature, replacing the previous listener, if any
     * @param {tf.types.MapEventCallBack} callBack - the callback for event notifications
     * @returns {void} - | {@link void} no return value
    */
     this.SetOnMouseMoveListener = function (callbackFunction) { onRollOverListener = tf.js.GetFunctionOrNull(callbackFunction); }
    /**
     * @public
     * @function
     * @summary - Sets a listener for {@link tf.consts.mapFeatureClickEvent} map events associated with this feature, replacing the previous listener, if any
     * @param {tf.types.MapEventCallBack} callBack - the callback for event notifications
     * @returns {void} - | {@link void} no return value
    */
     this.SetOnClickListener = function (callbackFunction) { onClickListener = tf.js.GetFunctionOrNull(callbackFunction); }
    /**
     * @public
     * @function
     * @summary - Sets a listener for {@link tf.consts.mapFeatureDblClickEvent} map events associated with this feature, replacing the previous listener, if any
     * @param {tf.types.MapEventCallBack} callBack - the callback for event notifications
     * @returns {void} - | {@link void} no return value
    */
     this.SetOnDoubleClickListener = function (callbackFunction) { onDoubleClickListener = tf.js.GetFunctionOrNull(callbackFunction); }
    /**
     * @public
     * @function
     * @summary - Checks if the feature is currently being hovered over
     * @returns {boolean} - | {@link boolean} <b>true</b> if the feature is being hovered over, <b>false</b> otherwise
    */
     this.GetIsInHover = function () { return isInHover; }
     this.GetIsAlwaysInHover = function () { return alwaysInHover; }
     this.SetIsAlwaysInHover = function (bool) { if (alwaysInHover != (bool = !!bool)) { alwaysInHover = bool; setHoverNonHoverStyle() }; }
     this.GetProcessInHover = function () { return processInHover; }
     this.SetProcessInHover = function (bool) { if (processInHover != (bool = !!bool)) { processInHover = bool; setHoverNonHoverStyle() }; }
    /**
     * @public
     * @function
     * @summary - Retrieves the keyed feature instance associated with this map feature, if any
     * @returns {tf.map.KeyedFeature} - | {@link tf.map.KeyedFeature} the keyed feature
    */
     this.GetKeyedFeature = function () { return keyedFeature; }
    /**
     * @public
     * @function
     * @summary - Retrieves the map feature with named styles instance associated with this map feature, if any
     * @returns {tf.map.FeatureWithNamedStyles} - | {@link tf.map.FeatureWithNamedStyles} the map feature with named styles instance
    */
     this.GetMapFeatureWithNamedStyles = function () { return mapFeatureWithNamedStyles; }
    /**
     * @public
     * @function
     * @summary - Receives {@link tf.consts.mapFeatureHoverInOutEvent} event notifications from maps, notifies a listener, if one is set
     * @param {tf.types.MapEventNotification} notification - the notification
     * @returns {void} - | {@link void} no return value
    */
     this.onHoverInOut = function (notification) { return onHoverInOut(notification); }
    /**
     * @public
     * @function
     * @summary - Receives {@link tf.consts.mapFeatureMouseMoveEvent} event notifications from maps, notifies a listener, if one is set
     * @param {tf.types.MapEventNotification} notification - the notification
     * @returns {void} - | {@link void} no return value
    */
     this.onMouseMove = function (notification) { return notifyListener(onRollOverListener, notification); }
    /**
     * @public
     * @function
     * @summary - Receives {@link tf.consts.mapFeatureClickEvent} event notifications from maps, notifies a listener, if one is set
     * @param {tf.types.MapEventNotification} notification - the notification
     * @returns {void} - | {@link void} no return value
    */
     this.onClick = function (notification) { return notifyListener(onClickListener, notification); }
    /**
     * @public
     * @function
     * @summary - Receives {@link tf.consts.mapFeatureDblClickEvent} event notifications from maps, notifies a listener, if one is set
     * @param {tf.types.MapEventNotification} notification - the notification
     * @returns {void} - | {@link void} no return value
    */
     this.onDoubleClick = function (notification) { return notifyListener(onDoubleClickListener, notification); }
    /**
     * @private
     * @function
     * @summary - Returns underlying map engine object associated with this feature's geometry
     * @returns {ol.Feature} - | the map engine object
    */
     this.getAPIFeature = function () { return APIFeature; }
    /**
     * @private
     * @function
     * @summary - Returns underlying map engine object associated with this feature's style
     * @returns {ol.Style} - | the map engine object
    */
     this.getAPIStyle = function () { return getAPIStyle(); }
    /**
     * @private
     * @function
     * @summary - Returns the style name set when this instance was created
     * @returns {string} - | {@link string} the style name
    */
     this.getStyleName = function () { return styleName; }
     function notifyListener(theListener, notification) { if (!!theListener) { theListener(notification); } }
     function setHoverNonHoverStyle() {
         var useHover = (!!processInHover && !!isInHover) || alwaysInHover;
         mapFeatureStyle = !!useHover ? mapFeatureHoverStyle : mapFeatureNormalStyle;
         refreshStyle();
     }
    function onHoverInOut(notification) {
        isInHover = notification.isInHover;
        if (!!mapFeatureHoverStyle) { setHoverNonHoverStyle(); }
        notifyListener(onHoverInOutListener, notification);
    }
    function styleFunction (feature, resolution) {
        var APIStyle;
        if (feature instanceof ol.feature) {
            var mapFeature = feature.getProperties().mapFeature;
            if (mapFeature) { APIStyle = null; }
        }
        return APIStyle;
    }
    function doGetAPIStyle(fromFeatureStyle) {
        var APIStyle = null;
        if (fromFeatureStyle instanceof tf.map.FeatureStyle) { APIStyle = fromFeatureStyle.getAPIStyle(); }
        else if (typeof fromFeatureStyle === "function") {
            var obj = !!keyedFeature ? keyedFeature : theThis;
            var style = tf.map.GetOrCreateFeatureStyle(fromFeatureStyle(obj));
            APIStyle = style instanceof (tf.map.FeatureStyle) ? style.getAPIStyle() : null ;
        }
        return APIStyle;
    }
    function getAPIStyle() { return doGetAPIStyle(mapFeatureStyle); }
    function refreshGeom() {
        if (!!APIFeature) {
            //APIFeature.setGeometry(null);
            APIFeature.setGeometry(mapFeatureGeom.getAPIGeom());
        }
    }
    function refreshStyle() {
        if (!!APIFeature) {
            //APIFeature.setStyle(null);
            //APIFeature.setStyle(mapFeatureStyle.getAPIStyle());
            APIFeature.setStyle(getAPIStyle());
        }
    }
    function refreshFeature() { refreshGeom(); refreshStyle(); }
    function changeStyle(strStyleOrObj) {
        if (strStyleOrObj instanceof tf.map.FeatureStyle) {
            mapFeatureStyle = strStyleOrObj;
            refreshStyle();
        }
        else if (mapFeatureStyle instanceof tf.map.FeatureStyle) {
            mapFeatureStyle.UpdateAttributesFrom(strStyleOrObj);
            refreshStyle();
        }
    }
    function updateAPIFeature() {
        APIFeature = new ol.Feature({ mapFeature: theThis });
        APIFeature.setId(id);
        refreshFeature();
    }
    function initialize() {
        isInHover = false;
        processInHover = true;
        id = ++tf.map.nextFeatureId;
        keyedFeature = settings.keyedFeature instanceof tf.map.KeyedFeature ? settings.keyedFeature : null;
        mapFeatureWithNamedStyles = settings.mapFeatureWithNamedStyles instanceof tf.map.FeatureWithNamedStyles ? settings.mapFeatureWithNamedStyles : null;
        mapFeatureNormalStyle = mapFeatureStyle = tf.map.GetOrCreateFeatureStyle(settings.style);
        mapFeatureHoverStyle = !!settings.hoverStyle ? tf.map.GetOrCreateFeatureStyle(settings.hoverStyle) : null;
        mapFeatureGeom = settings.geom instanceof tf.map.FeatureGeom ? settings.geom : new tf.map.FeatureGeom({ type: settings.type, coordinates: settings.coordinates });
        styleName = tf.js.GetNonEmptyString(settings.styleName, "");
        updateAPIFeature();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Settings used in the creation of [Map Feature]{@link tf.map.Feature} instances
 * @public
 * @typedef {object} tf.types.MapFeatureWithNamedStylesSettings
 * @property {tf.map.FeatureGeom} geom - a geometry instance to be associated with the map feature, if this property is not defined, then <b>type</b> and <b>coordinates</b> are mandatory
 * @property {tf.types.GeoJSONGeometryType} type - the map feature type, mandatory if <b>geom</b> is not defined
 * @property {tf.types.GeoJSONGeometryCoordinates} coordinates - the map feature coordinates, mandatory if <b>geom</b> is not defined
 * @property {tf.types.NamedFeatureStyleSettings} styleSettings - style settings
 * @property {tf.map.KeyedFeature} keyedFeature - the keyed feature instance associated with this map feature, if any
*/
/**
 * @public
 * @class
 * @summary Map Features with Named Styles can be displayed in one or more [Feature Layers]{@link tf.map.FeatureLayer} of the same or different [Maps]{@link tf.map.Map}. 
 * Each instance of this class manages one or more instances of [Map Feature]{@link tf.map.Feature}, all sharing the same geometry instance, and each with a different set of named styles 
 * @param {tf.types.MapFeatureWithNamedStylesSettings} settings - map feature creation settings
 */
tf.map.FeatureWithNamedStyles = function (settings) {
    var theThis, keyedFeature, mapFeatures, mapFeatureGeom;
    /**
     * @public
     * @function
     * @summary - Retrieves the geometry instance associated with this feature
     * @returns {tf.map.FeatureGeom} - | {@link tf.map.FeatureGeom} the geometry
    */
    this.GetGeom = function () { return mapFeatureGeom; }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Map Feature]{@link tf.map.Feature} associated with the given style name
     * @param {string} styleName - the name of the style
     * @returns {tf.map.Feature} - | {@link tf.map.Feature} the map feature
    */
    this.GetMapFeature = function (styleName) { return getMapFeature(styleName); }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Map Feature Style]{@link tf.map.FeatureStyle} associated with the given style name
     * @param {string} styleName - the name of the style
     * @returns {tf.map.FeatureStyle} - | {@link tf.map.FeatureStyle} the map feature style
    */
    this.GetStyle = function (styleName) { return getMapFeatureStyle(styleName).GetStyle(); }
    /**
     * @public
     * @function
     * @summary - Forces the re-creation of one or more of the feature's named styles
     * @param {string | enumerable<string>} styleNameOrNames - the name of the style to refresh, or an enumerable of style names to refresh
     * @returns {void} - | {@link void} no return value
    */
    this.RefreshStyle = function (styleNameOrNames) { return refreshStyle(styleNameOrNames); }
    /**
     * @public
     * @function
     * @summary - Checks if the type of geometry associated with this map feature is "point"
     * @returns {boolean} - | {@link boolean} <b>true</b> if the geometry type is "point", <b>false</b> otherwise
    */
    this.GetIsPoint = function () { return !!mapFeatureGeom ? mapFeatureGeom.GetIsPoint() : false; }
    /**
     * @public
     * @function
     * @summary - Changes the map coordinates of a "point" feature
     * @param {tf.types.mapCoordinates} pointCoords - the feature coordinates
     * @returns {void} - | {@link void} no return value
    */
    this.SetPointCoords = function (pointCoords) { return setPointCoords(pointCoords); }
    /**
     * @public
     * @function
     * @summary - Retrieves the current coordinates of a "point" feature
     * @returns {tf.types.mapCoordinates} - | {@link tf.types.mapCoordinates} the coordinates
    */
    this.GetPointCoords = function () { return !!mapFeatureGeom ? mapFeatureGeom.GetPointCoords() : [0,0]; }
    /**
     * @public
     * @function
     * @summary - Retrieves the keyed feature instance associated with this map feature, if any
     * @returns {tf.map.KeyedFeature} - | {@link tf.map.KeyedFeature} the keyed feature
    */
    this.GetKeyedFeature = function () { return keyedFeature; }
    /**
     * @private
     * @function
     * @summary - Returns underlying map engine object associated with feature of the given style name
     * @param {string} styleName - the name of the style
     * @returns {ol.Feature} - | the map engine object
    */
    this.getAPIFeature = function (styleName) { return getMapFeature(styleName).getAPIFeature(); }
    /**
     * @private
     * @function
     * @summary - Returns underlying map engine object associated with feature of the given style name
     * @param {string} styleName - the name of the style
     * @returns {ol.Style} - | the map engine object
    */
    this.getAPIStyle = function (styleName) { return getMapFeature(styleName).getAPIStyle(); }
    function getMapFeature(styleName) {
        if (!styleName || !tf.js.GetIsNonEmptyString (styleName) || !mapFeatures[styleName]) {
            styleName = tf.consts.defaultMapFeatureStyleName;
        }
        return mapFeatures[styleName];
    }
    function setPointCoords(pointCoords) {
        if (!!mapFeatureGeom) {
            if (mapFeatureGeom.SetPointCoords(pointCoords)) {
                for (var i in mapFeatures) { mapFeatures[i].RefreshGeom(); }
            }
        }
    }
    function getMapFeatureStyle(styleName) { var mapFeature = getMapFeature(styleName); return mapFeature ? mapFeature.GetStyle() : null; }
    function doRefreshStyle(styleName) { var mapFeature = getMapFeature(styleName); return mapFeature ? mapFeature.RefreshStyle() : false; }
    function refreshStyle(styleNameOrNames) {
        var refreshed = false;
        //if (!!styleNameOrNames) {
            if (tf.js.GetIsArray(styleNameOrNames)) {
                for (var i in styleNameOrNames) { refreshed = doRefreshStyle(styleNameOrNames[i]) || refreshed; }
            }
            else { refreshed = doRefreshStyle(styleNameOrNames) ; }
        //}
        return refreshed;
    }
    function initialize() {
        keyedFeature = settings.keyedFeature instanceof tf.map.KeyedFeature ? settings.keyedFeature : null;
        mapFeatureGeom = settings.geom instanceof tf.map.FeatureGeom ? settings.geom : new tf.map.FeatureGeom({ type: settings.type, coordinates: settings.coordinates });
        var propagateSettings = tf.js.ShallowMerge(settings, { geom: mapFeatureGeom, mapFeatureWithNamedStyles: theThis });
        settings = tf.js.GetValidObjectFrom(settings);
        var styleSettings = tf.js.GetValidObjectFrom(settings.styleSettings);
        if (tf.js.GetIsValidObject(styleSettings.styles)) {
            var firstFeature = null;
            var styles = styleSettings.styles;
            mapFeatures = {};
            for (var styleName in styles) {
                var theStyle = styles[styleName];
                if (typeof theStyle === "object") {
                    propagateSettings.style = tf.map.GetOrCreateFeatureStyle (theStyle.style);
                    propagateSettings.hoverStyle = tf.map.GetOrCreateFeatureStyle(theStyle.hoverStyle);
                    propagateSettings.styleName = styleName;
                    var thisFeature = new tf.map.Feature(propagateSettings);
                    mapFeatures[styleName] = thisFeature;
                    if (!firstFeature) { firstFeature = thisFeature; }
                }
            }
            if (!!firstFeature) {
                if (mapFeatures[tf.consts.defaultMapFeatureStyleName] === undefined) {
                    mapFeatures[tf.consts.defaultMapFeatureStyleName] = firstFeature;
                }
            }
            else {
                mapFeatures = null;
            }
        }
        else {
            propagateSettings.style = styleSettings.style;
            propagateSettings.hoverStyle = styleSettings.hoverStyle;
        }
        if (!mapFeatures) {
            propagateSettings.styleName = tf.consts.defaultMapFeatureStyleName;
            mapFeatures = {};
            mapFeatures[tf.consts.defaultMapFeatureStyleName] = new tf.map.Feature(propagateSettings);
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * An icon anchor are horizontal and vertical offset factors of the icon's width and height, respectivelly and in that order, used to displace 
 * the icon from the feature's point coordinates: [0.5, 0.5] places the icon centered at the point coordinates, [0.5, 1.0] places the icon centered horizontally and
 * above the map coordinates, [0.0, 0.0] places the icon to the left and below the map coordinates, etc.
 * @public
 * @typedef {array<number,number>} tf.types.iconAnchor
*/
/**
 * A callback function that, upon request, returns an instance of [Map Feature Style]{@link tf.map.FeatureStyle} to be used with the given map feature
 * @public
 * @callback tf.types.MapFeatureStyleFunction
 * @param {tf.map.Feature|tf.map.KeyedFeature} mapFeature - the feature for which a style is requested
 * @returns {tf.map.FeatureStyle} - | {@link tf.map.FeatureStyle} the instance
 */
/**
 * A type accepted by many API functions and is either an instance of [Map Feature Style]{@link tf.map.FeatureStyle}, 
 * a [Map Feature Style Settings]{@link tf.types.MapFeatureStyleSettings} object, an array of [Map Feature Style Settings]{@link tf.types.MapFeatureStyleSettings},
 * of a function that returns an instance of [Map Feature Style]{@link tf.map.FeatureStyle}
 * @public
 * @typedef {tf.types.MapFeatureStyleSettings|array<tf.types.MapFeatureStyleSettings>|tf.types.MapFeatureStyleFunction} tf.types.MapFeatureStyleLike
*/
/**
 * An {@link object} with a Map feature style property and a Map feature style hover property
 * @public
 * @typedef {object} tf.types.MapFeatureStyleAndHoverStyle
 * @property {tf.types.MapFeatureStyleLike} style - a map feature style
 * @property {tf.types.MapFeatureStyleLike} hoverStyle - a style assumed by a map feature when the mouse pointer is hovering over it
*/
/**
 * An {@link object} whose property name specifies the style name and whose property value is a [Map Feature Style and Hover Style]{@link tf.types.MapFeatureStyleAndHoverStyle}
 * @public
 * @typedef {object} tf.types.NamedMapFeatureStyleAndHoverStyles
*/
/**
 * An {@link object} used in the creation of [Keyed Features]{@link tf.map.KeyedFeature} and [Map Features with Named Styles]{@link tf.map.FeatureWithNamedStyles}.
 * Specifies either a single default style/hoverStyle pair using the properties <b>style</b> and <b>hoverStyle</b>, or an enumerable of named style/hoverStyle pairs
 * @public
 * @typedef {object} tf.types.NamedFeatureStyleSettings
 * @property {enmumerable<tf.types.NamedMapFeatureStyleAndHoverStyles>} styles - an enumerable of named styles, if not defined <b>style</b> and <b>hoverStyle</b> are mandatory, 
 * and used to create a feature with the default style name ({@link tf.consts.defaultMapFeatureStyleName}). When defined, if none of the named styles is
 * named {@link tf.consts.defaultMapFeatureStyleName}, the first style is used as the default style.
 * @property {tf.types.MapFeatureStyleLike} style - the map feature style, mandatory if <b>styles</b> is not defined
 * @property {tf.types.MapFeatureStyleLike} hoverStyle - the style assumed by the map feature when the mouse pointer is hovering over it, mandatory if <b>styles</b> is not defined
*/
/**
 * @private
 * @function
 * @summary - Returns the given parameter if it is an instance of {@link tf.map.FeatureStyle} or a {@link function}, otherwise 
 * creates and returns a new instance of {@link tf.map.FeatureStyle} initialized with the given parameter. Used internally by the API
 * @param {tf.types.MapFeatureStyleLike} fromFeatureStyleSettingsObjectOrFunction - the given parameter
 * @returns {tf.types.MapFeatureStyleLike} - | {@link tf.types.MapFeatureStyleLike} the instance
*/
tf.map.GetOrCreateFeatureStyle = function (fromFeatureStyleSettingsObjectOrFunction) {
    var featureStyle, featureStyleSettings;
    if (!!fromFeatureStyleSettingsObjectOrFunction) {
        if ((fromFeatureStyleSettingsObjectOrFunction instanceof tf.map.FeatureStyle) || tf.js.GetFunctionOrNull(fromFeatureStyleSettingsObjectOrFunction)) {
            featureStyle = fromFeatureStyleSettingsObjectOrFunction;
        }
        else if (tf.js.GetIsValidObject(fromFeatureStyleSettingsObjectOrFunction)) { featureStyleSettings = fromFeatureStyleSettingsObjectOrFunction; }
    }
    if (!featureStyle) { featureStyle = new tf.map.FeatureStyle(featureStyleSettings); }
    return featureStyle;
}
/**
 * An object whose properties specify the visual attributes used to display [Map Features]{@link tf.map.Feature} on the [Map]{@link tf.map.Map}.
 * @public
 * @typedef {object} tf.types.MapFeatureStyleSettings
 *
 * @property {boolean} circle - Used with [point geometries]{@link tf.types.GeoJSONGeometryType} to display a circle at the point coordinates. Mutually exclusive
 * with other <b>point</b> styles. Uses the properties <b>circle_radius</b>, and the properties related to <b>line</b>, and <b>fill</b>
 *
 * @property {boolean} icon - Used with [point geometries]{@link tf.types.GeoJSONGeometryType} to display an image at the point coordinates. Mutually exclusive
 * with other <b>point</b> styles. Uses the property <b>icon_anchor</b> and either <b>icon_url</b>, or both <b>icon_img</b> and <b>icon_size</b>
 *
 * @property {boolean} marker - Used with [point geometries]{@link tf.types.GeoJSONGeometryType} to display a text bubble (a marker) pointing to the feature's coordinates. Mutually exclusive
 * with other <b>point</b> styles. Uses the properties <b>label</b> (the text), <b>font</b>, <b>font_height</b>, <b>font_color</b>, <b>font_opacity</b>, <b>border_color</b>, <b>border_opacity</b>,
 * <b>border_width</b>, <b>marker_color</b>, <b>marker_opacity</b>, and properties related to <b>line</b> (for optinal text stroke)
 *
 * @property {boolean} shape - Used with [point geometries]{@link tf.types.GeoJSONGeometryType} to display the shape of a regular polygon or a star at the point coordinates. Mutually exclusive
 * with other <b>point</b> styles. Controls shape settings with the properties <b>shape_points</b> and either the property <b>shape_radius</b>, or both <b>shape_radius1</b> and <b>shape_radius2</b>.
 * Uses the properties related with <b>line</b> and <b>fill</b>
 *
 * @property {boolean} text - Used with [point geometries]{@link tf.types.GeoJSONGeometryType} to display text at or near the point coordinates. Mutually exclusive
 * with other <b>point</b> styles. Uses the properties <b>label</b> (the text), <b>font</b>, <b>text_offsetx</b>, <b>text_offsety</b>, <b>text_align</b>, <b>text_baseline</b>,
 * and the properties related with <b>line</b> and <b>fill</b> for text stroke and fill respectivelly
 *
 * @property {boolean} round_rect - Used with [point geometries]{@link tf.types.GeoJSONGeometryType} to display a rectangle with rounded corners at or near the point coordinates. Mutually exclusive
 * with other <b>point</b> styles. Uses the properties <b>round_rect_width</b>, <b>round_rect_height</b>, <b>round_rect_radius</b>, and the properties related with <b>line</b> 
 * and <b>fill</b>
 *
 * @property {boolean} fill - Used with <b>fill_color</b> and <b>fill_opacity</b> to determine how shapes, circles, texts, and round_rects are filled
 *
 * @property {boolean} line - Used with <b>line_color</b>, <b>line_dash</b>, <b>line_opacity</b>, and <b>line_width</b> to determine how lines in shapes, circles, markers, round_rects,
 * and geometries other than <b>point</b> are drawn
 *
 * @property {number} border_width - In pixels, used with <b>marker<b>
 *
 * @property {number} circle_radius - In pixels, used with <b>circle</b>
 *
 * @property {tf.types.opacity0100} fill_alpha - <b>deprecated</b> Use <b>fill_opacity</b> instead
 *
 * @property {hexColor} fill_color - Used with <b>fill</b>
 *
 * @property {tf.types.opacity0100} fill_opacity - Opacity component for <b>fill_color</b>, used <b>fill</b>
 *
 * @property {tf.types.opacity0100} font_alpha - <b>deprecated</b> Use <b>font_opacity</b> instead
 *
 * @property {hexColor} font_color - Used only in conjunction with both the <b>font</b> property and the <b>marker</b> property
 *
 * @property {tf.types.opacity0100} font_opacity - Opacity component for <b>font_color</b>, used <b>font</b>
 *
 * @property {number} font_height - In pixels, used with <b>font</b> in conjunction with <b>marker</b>
 *
 * @property {string} font - Used with <b>font</b>, may include font size information, except when used in conjunction with <b>marker</b>
 *
 * @property {tf.types.iconAnchor} icon_anchor - Used with <b>icon</b>
 *
 * @property {HTMLElement} icon_img - An HTML img that has been preloaded, used with <b>icon</b>, requires <b>icon_size</b>, and is and mutually exclusive with <b>icon_url</b>
 *
 * @property {tf.types.pixelCoordinates} icon_size - The size of <b>icon_img</b> in pixels, required when using <b>icon_img</b>
 *
 * @property {string} icon_url - The location of an image file used with <b>icon</b> and mutually exclusive with <b>icon_img</b>
 *
 * @property {string} label - Text content used with <b>marker</b> and <b>text</b>
 *
 * @property {tf.types.opacity0100} line_alpha - <b>deprecated</b> Use <b>line_opacity</b> instead
 *
 * @property {string} line_cap - Used with <b>line</b>, one of "butt", "round", or "square", Defaults to "round"
 *
 * @property {hexColor} line_color - Used with <b>line</b>
 *
 * @property {array<number,number>} line_dash - Used with <b>line</b> to create a dashed line style instead of a solid style
 *
 * @property {string} line_join - Used with <b>line</b>, one of "bevel", "round", or "miter", Defaults to "round"
 *
 * @property {tf.types.opacity0100} line_opacity - Opacity component for <b>line_color</b>
 *
 * @property {number} line_width - Used with <b>line</b>
 *
 * @property {tf.types.opacity0100} marker_alpha - <b>deprecated</b> Use <b>marker_opacity</b> instead
 *
 * @property {number} marker_arrowlength - Used with <b>marker</b> to set the length of the callout arrow
 *
 * @property {hexColor} marker_color - The background color of the text bubble, used with <b>marker</b>
 *
 * @property {tf.types.opacity0100} marker_opacity - Opacity component for <b>marker_color</b>
 *
 * @property {tf.types.horizontalPositioning} marker_horpos - Horizontal positioning for <b>marker</b>, defaults to {@link tf.consts.positioningCenter}
 *
 * @property {tf.types.verticalPositioning} marker_verpos - Vertical positioning for <b>marker</b>, defaults to {@link tf.consts.positioningTop}
 *
 * @property {tf.types.opacity01} opacity - Controls the overall opacity of <b>icon</b>, <b>marker</b>, and <b>round_rect</b> styles
 *
 * @property {boolean} rotate_with_map - Used with [point geometries]{@link tf.types.GeoJSONGeometryType}, if set to <b>true</b> rotates the map feature style with the map, defaults to {@link void}
 *
 * @property {number} rotation_rad - Controls the rotational angle of <b>point</b> styles
 *
 * @property {number} round_rect_width - Used with <b>round_rect</b>
 *
 * @property {number} round_rect_height - Used with <b>round_rect</b>
 *
 * @property {number} round_rect_radius - Used with <b>round_rect</b>
 *
 * @property {number} scale - Controls the scale of <b>icon</b>, <b>marker</b>, and <b>round_rect</b> styles, defaults to 1
 *
 * @property {number} shape_radius - Controls the radius of the <b>shape</b> polygon, mutually exclusive with <b>shape_radius1</b> and <b>shape_radius2</b>
 *
 * @property {number} shape_radius1 - Controls the outer radius of the <b>shape</b> star, mutually exclusive with </b>shape_radius</b>, may be used with <b>shape_radius2</b>
 *
 * @property {number} shape_radius2 - Controls the inner radius of the <b>shape</b> star, mutually exclusive with </b>shape_radius</b>, may be used in addition to <b>shape_radius1</b>
 *
 * @property {number} shape_points - Controls the number of points (vertices) of the <b>shape</b> polygon or star
 *
 * @property {boolean} snaptopixel - Used by all <b>point</b> styles, if set <b>true</b> rounds coordinates to the closest pixel, producing crisper results, if <b>false</b> 
 * produces smoother results for animation. Defaults to <b>true</b>
 *
 * @property {number} text_offsetx - Horizontal offset, in pixels, used with <b>text</b>
 *
 * @property {number} text_offsety - Vertical offset, in pixels, used with <b>text</b>
 *
 * @property {string} text_align - HTML Canvas text align, one of 'left', 'right', 'center', 'end', 'start', defaults to 'start'
 *
 * @property {string} text_baseline - HTML Canvas text baseline, one of:  'bottom', 'top', 'middle', 'alphabetic', 'hanging', 'ideographic', defaults to 'alphabetic'
 *
 * @property {number} zindex - Controls the order in which sub styles are rendered, defaults to 0, used by all styles
 *
 * @see [Map Feature Style]{@link tf.map.FeatureStyle}
 * @see [Map Feature Sub Style]{@link tf.map.FeatureSubStyle}
 * @see {@link tf.map.Feature}
 */
/**
 * @public
 * @class
 * @summary Map Feature Sub Style instances describe the visual attributes used to display [Map Features]{@link tf.map.Feature} on the [Map]{@link tf.map.Map}.
 * @param {tf.types.MapFeatureStyleSettings} settings - creation settings
 */
tf.map.FeatureSubStyle = function (settings) {
    var theThis, debug, attrGetters, thisInstanceSettings, APISubStyle;
    /**
     * @public
     * @function
     * @summary - Changes the attributes of this Feature Sub Style instance based on the given settings
     * @param {tf.types.MapFeatureStyleSettings} styleSettings - the given settings
     * @returns {void} - | {@link void} no return value
    */
    this.UpdateAttributesFrom = function (styleSettings) { return updateAttributesFrom(styleSettings); }
    /**
     * @private
     * @function
     * @summary - Returns underlying map engine object associated with this sub style
     * @returns {ol.style} - | the map engine object
    */
    this.GetAPISubStyle = function () { return APISubStyle; }
/**
 * method tf.map.FeatureSubStyle.SetAttribute - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} attrName - parameter description?
 * @param {?} attrVal - parameter description?
*/
    //this.SetAttribute = function (attrName, attrVal) { return setAttribute(attrName, attrVal, false); }
/**
 * method tf.map.FeatureSubStyle.GetAttribute - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} attrName - parameter description?
*/
    //this.GetAttribute = function (attrName) { return getAttribute(attrName); }
    function createStarSubStyle() {
        return new ol.style.RegularShape({
            opacity: thisInstanceSettings.opacity,
            rotation: thisInstanceSettings.rotation_rad,
            //scale: thisInstanceSettings.scale,
            radius1: thisInstanceSettings.font_height,
            radius2: thisInstanceSettings.font_height / 2,
            stroke: new ol.style.Stroke({
                color: tf.js.GetRGBAColor(thisInstanceSettings.border_color, thisInstanceSettings.border_color, thisInstanceSettings.border_opacity),
                width: thisInstanceSettings.border_width
            }),
            fill: new ol.style.Fill({
                color: tf.js.GetRGBAColor(thisInstanceSettings.marker_color, thisInstanceSettings.marker_color, thisInstanceSettings.marker_opacity)
            }),
            points: 5
        });
    }
    function createTextCanvasSubStyle() {
        //var triW = thisInstanceSettings.font_height / 2;
        var options = {
            label: !!thisInstanceSettings.label ? thisInstanceSettings.label : '',
            font_height: thisInstanceSettings.font_height,
            font: thisInstanceSettings.font,
            arrow_length: thisInstanceSettings.marker_arrowlength,
            line_color: thisInstanceSettings.line_color,
            line_opacity: thisInstanceSettings.line_opacity,
            line_width: thisInstanceSettings.line_width,
            font_color: thisInstanceSettings.font_color,
            font_opacity: thisInstanceSettings.font_opacity,
            border_line_color: thisInstanceSettings.border_color,
            border_line_opacity: thisInstanceSettings.border_opacity,
            border_line_width: thisInstanceSettings.border_width,
            fill_color: thisInstanceSettings.marker_color,
            fill_opacity: thisInstanceSettings.marker_opacity,
            horpos: thisInstanceSettings.marker_horpos,
            verpos: thisInstanceSettings.marker_verpos
        };
        var memImage = tf.canvas.CreateMemoryImage({ drawFunction: tf.canvas.DrawTextMarkerImage, drawSettings: options });
        var textImageSubStyle = null;
        try {
            textImageSubStyle = new ol.style.Icon({
                opacity: thisInstanceSettings.opacity,
                rotation: thisInstanceSettings.rotation_rad,
                scale: thisInstanceSettings.scale,
                //src: memImage.image,
                img: memImage.image,
                imgSize: [memImage.image.width, memImage.image.height],
                anchor: memImage.anchor
            });
        }
        catch (e) { textImageSubStyle = null; }
        return textImageSubStyle;
    }
    function createRoundRectSubStyle() {
        var memImage = tf.canvas.CreateMemoryImage({
            canvas: null,
            drawFunction: tf.canvas.DrawRoundRect,
            drawSettings: {
                width: thisInstanceSettings.round_rect_width,
                height: thisInstanceSettings.round_rect_height,
                radius: thisInstanceSettings.round_rect_radius,
                fill: thisInstanceSettings.fill,
                fill_color: tf.js.GetRGBAColor(thisInstanceSettings.fill_color, thisInstanceSettings.fill_color, thisInstanceSettings.fill_opacity),
                line: thisInstanceSettings.line,
                line_color: tf.js.GetRGBAColor(thisInstanceSettings.line_color, thisInstanceSettings.line_color, thisInstanceSettings.line_opacity),
                line_width: thisInstanceSettings.line_width,
                line_dash: thisInstanceSettings.line_dash
            }
        });
        var styleSettings = {
            //src: memImage.image,
            img: memImage.image,
            imgSize: [memImage.image.width, memImage.image.height],
            anchor: thisInstanceSettings.icon_anchor
        };
        //var styleSettings = { src: tf.GetStyles().GetHiddenCanvas(), anchor: thisInstanceSettings.icon_anchor };
        return new ol.style.Icon(completeSubStyleSettings(styleSettings, true, true, false));
    }
    function createStrokeSubStyle() {
        return new ol.style.Stroke({
            color: tf.js.GetRGBAColor(thisInstanceSettings.line_color, thisInstanceSettings.line_color, thisInstanceSettings.line_opacity),
            width: thisInstanceSettings.line_width,
            lineDash: thisInstanceSettings.line_dash,
            lineCap: thisInstanceSettings.line_cap,
            lineJoin: thisInstanceSettings.line_join
        });
    }
    function createFillSubStyle() {
        return new ol.style.Fill({ color: tf.js.GetRGBAColor(thisInstanceSettings.fill_color, thisInstanceSettings.fill_color, thisInstanceSettings.fill_opacity) });
    }
    function completeSubStyleSettings(styleSettings, styleUsesOpacity, styleUsesScale, styleUsesDraw) {
        if (!!styleUsesOpacity) {
            styleSettings.opacity = thisInstanceSettings.opacity;
            styleSettings.snapToPixel = thisInstanceSettings.snaptopixel;
        }
        if (thisInstanceSettings.rotate_with_map) { styleSettings.rotateWithView = true; }
        styleSettings.rotation = thisInstanceSettings.rotation_rad;
        if (!!styleUsesScale) { styleSettings.scale = thisInstanceSettings.scale; }
        if (!!styleUsesDraw) {
            if (thisInstanceSettings.line) { styleSettings.stroke = createStrokeSubStyle() };
            if (thisInstanceSettings.fill) { styleSettings.fill = createFillSubStyle() };
        }
        return styleSettings;
    }
    function createCircleSubStyle() {
        var styleSettings = { radius: thisInstanceSettings.circle_radius };
        return new ol.style.Circle(completeSubStyleSettings(styleSettings, true, false, true));
    }
    function createRegularShapeSubStyle() {
        var styleSettings = { radius: thisInstanceSettings.shape_radius, radius1: thisInstanceSettings.shape_radius1, radius2: thisInstanceSettings.shape_radius2, points: thisInstanceSettings.shape_points };
        return new ol.style.RegularShape(completeSubStyleSettings(styleSettings, true, false, true));
    }
    function createIconSubStyle() {
        var styleSettings = {
            crossOrigin: "",
            src: thisInstanceSettings.icon_url, anchor: thisInstanceSettings.icon_anchor, img: thisInstanceSettings.icon_img, imgSize: thisInstanceSettings.icon_size, offset: thisInstanceSettings.icon_offset
        };
        return new ol.style.Icon(completeSubStyleSettings(styleSettings, true, true, false));
    }
    function createTextSubStyle() {
        var styleSettings = {
            text: !!thisInstanceSettings.label ? thisInstanceSettings.label : '',
            font: thisInstanceSettings.font,
            offsetX: thisInstanceSettings.text_offsetx,
            offsetY: thisInstanceSettings.text_offsety,
            textAlign: thisInstanceSettings.text_align,
            textBaseline: thisInstanceSettings.text_baseline
        };
        return new ol.style.Text(completeSubStyleSettings(styleSettings, false, false, true));
    }
    function createMarkerStyle() {
        var styleSettings = {};
        var label = typeof thisInstanceSettings.label === "string" ? thisInstanceSettings.label : "";
        var labelLen = label.length;
        var hasLabel = labelLen > 0 && (label.charAt(0) != '.');
        //hasLabel = false;
        if (hasLabel) { styleSettings.image = createTextCanvasSubStyle(); } else { styleSettings.image = createStarSubStyle(); }
        return styleSettings;
    }
    function createAPISubStyle() {
        var styleSettings = {};
        if (thisInstanceSettings.marker) {
            styleSettings = createMarkerStyle();
        }
        else if (thisInstanceSettings.icon) {
            styleSettings.image = createIconSubStyle();
        }
        else if (thisInstanceSettings.circle) {
            styleSettings.image = createCircleSubStyle();
        }
        else if (thisInstanceSettings.shape) {
            styleSettings.image = createRegularShapeSubStyle();
        }
        else if (thisInstanceSettings.round_rect) {
            styleSettings.image = createRoundRectSubStyle();
        }
        else if (thisInstanceSettings.text) {
            styleSettings.text = createTextSubStyle();
        }
        else {
            if (thisInstanceSettings.line) { styleSettings.stroke = createStrokeSubStyle() };
            if (thisInstanceSettings.fill) { styleSettings.fill = createFillSubStyle() };
        }
        styleSettings.zIndex = thisInstanceSettings.zindex;
        return new ol.style.Style(styleSettings);
    }
    function get01NumberFromValue0100 (fromValue0100, defaultValue01) {
        return ((fromValue0100 = tf.js.GetFloatNumber(fromValue0100, -1)) == -1) ? defaultValue01 : tf.js.GetFloatNumberInRange(fromValue0100 / 100, 0, 1, defaultValue01);
    }
    function setAttribute(attrName, attrVal, dontUpdateAPISubStyleBool) {
        var didSet = false;
        if (!!attrName && typeof attrName === "string" && attrName.length) {
            var attrGetter = attrGetters[attrName.toLowerCase()];
            if (typeof attrGetter === "function") {
                var newVal = attrGetter(attrVal, thisInstanceSettings[attrName]);
                if (!!debug) {
                    debug.LogIfTest('requested [' + attrName + '] = ' + attrVal);
                    debug.LogIfTest('+assigned [' + attrName + '] = ' + newVal);
                }
                didSet = true;
                thisInstanceSettings[attrName] = newVal;
                if (!dontUpdateAPISubStyleBool) { updateAPISubStyle(); }
            }
        }
        return didSet;
    }
    function getAttribute(attrName) { return thisInstanceSettings[attrName]; }
    function updateAPISubStyle() { APISubStyle = createAPISubStyle(); }
    function updateAttributesFrom(newSettings) {
        var didSet = false;
        if (typeof newSettings === "string") { newSettings = newSettings.length ? tf.js.ParseLegacyFormatString(newSettings) : null; }
        if (!!newSettings && typeof newSettings === "object") {
            for (var attr in newSettings) {
                if (setAttribute(attr, newSettings[attr], true)) { didSet = true; }
            }
            if (didSet) {
                updateAPISubStyle();
            }
        }
        return didSet;
    }
    function getValue01(value, defaultValue) { return tf.js.GetFloatNumberInRange(value, 0, 1, defaultValue); }
    function getAlpha(value, defaultValue) {
        return get01NumberFromValue0100(value, defaultValue);
    }
    function getColor(value, defaultValue) { return tf.js.GetHexColorStr(value, defaultValue); }
    function getTwoElementNumberArray(value, defaultValue) {
        var returnValue = defaultValue;
        if (!!value) {
            if (typeof value === "string") {
                var values = value.split(',');
                var nValues = values.length;
                if (nValues == 2) {
                    for (var i in values) {
                        var defaultV = !!defaultValue ? defaultValue[i] : undefined;
                        values[i] = tf.js.GetFloatNumber(values[i], defaultV);
                    }
                    returnValue = values;
                }
            }
            else if (typeof value === "object" && value.length == 2) {
                for (var i in value) {
                    var defaultV = !!defaultValue ? defaultValue[i] : undefined;
                    value[i] = tf.js.GetFloatNumber(value[i], defaultV);
                }
                returnValue = value;
            }
        }
        return returnValue;
    }
    function getRadius(value, defaultValue) { return value === undefined || value == null ? undefined : Math.abs(tf.js.GetFloatNumber(value, defaultValue)); }
    function getStringOrUndefined(value, defaultValue) { return !!value ? tf.js.GetNonEmptyString(value, defaultValue) : undefined; }
    function getImgObject(value, defaultValue) { if (!(value = tf.dom.GetHTMLElementFrom((value)))) { value = defaultValue; } return value; }
    function get_border_opacity(value, defaultValue) { return getAlpha(value, defaultValue); }
    function get_border_color(value, defaultValue) { return getColor(value, defaultValue) }
    function get_border_width(value, defaultValue) { return tf.js.GetNonNegativeIntFrom(value, defaultValue); }
    function get_circle(value, defaultValue) { return tf.js.GetBoolFromValue(value, defaultValue); }
    function get_circle_radius(value, defaultValue) { return getRadius(value, defaultValue); }
    function get_fill(value, defaultValue) { return tf.js.GetBoolFromValue(value, defaultValue); }
    function get_fill_opacity(value, defaultValue) { return getAlpha(value, defaultValue); }
    function get_fill_color(value, defaultValue) { return getColor(value, defaultValue); }
    function get_font_opacity(value, defaultValue) { return getAlpha(value, defaultValue); }
    function get_font_color(value, defaultValue) { return getColor(value, defaultValue); }
    function get_font_height(value, defaultValue) { return tf.js.GetIntNumberInRange(value, 8, 120, defaultValue); }
    function get_font(value, defaultValue) { return tf.js.GetNonEmptyString(value, defaultValue); }
    function get_icon(value, defaultValue) { return tf.js.GetBoolFromValue(value, defaultValue); }
    function get_icon_anchor(value, defaultValue) { return getTwoElementNumberArray(value, defaultValue); }
    function get_icon_offset(value, defaultValue) { return getTwoElementNumberArray(value, defaultValue); }
    function get_icon_size(value, defaultValue) { return getTwoElementNumberArray(value, defaultValue); }
    function get_icon_img(value, defaultValue) { return getImgObject(value, defaultValue); }
    function get_icon_url(value, defaultValue) { return tf.js.GetNonEmptyString(value, defaultValue); }
    function get_label(value, defaultValue) { return tf.js.GetNonEmptyString(value, defaultValue); }
    function get_line_cap(value, defaultValue) { return tf.js.GetNonEmptyString(value, defaultValue); }
    function get_line_join(value, defaultValue) { return tf.js.GetNonEmptyString(value, defaultValue); }
    function get_line(value, defaultValue) { return tf.js.GetBoolFromValue(value, defaultValue); }
    function get_line_opacity(value, defaultValue) { return getAlpha(value, defaultValue); }
    function get_line_color(value, defaultValue) { return getColor(value, defaultValue); }
    function get_line_dash(value, defaultValue) { return getTwoElementNumberArray(value, defaultValue); }
    //function get_line_width(value, defaultValue) { return tf.js.GetNonNegativeIntFrom(value, defaultValue); }
    function get_line_width(value, defaultValue) { return tf.js.GetFloatNumber(value, defaultValue); }
    function get_marker(value, defaultValue) { return tf.js.GetBoolFromValue(value, defaultValue); }
    function get_marker_opacity(value, defaultValue) { return getAlpha(value, defaultValue); }
    function get_marker_arrowlength(value, defaultValue) { return tf.js.GetFloatNumber(value, defaultValue); }
    function get_marker_color(value, defaultValue) { return getColor(value, defaultValue); }
    function get_opacity(value, defaultValue) { return getValue01(value, defaultValue); }
    function get_rotate_with_view(value, defaultValue) { return tf.js.GetBoolFromValue(value, defaultValue); }
    function get_rotation_rad(value, defaultValue) { return tf.js.GetFloatNumber(value, defaultValue); }
    function get_scale(value, defaultValue) { return value !== undefined ? tf.js.GetFloatNumber(value, defaultValue) : value; }
    function get_shape(value, defaultValue) { return tf.js.GetBoolFromValue(value, defaultValue); }
    function get_shape_radius(value, defaultValue) { return getRadius(value, defaultValue); }
    function get_shape_radius1(value, defaultValue) { return getRadius(value, defaultValue); }
    function get_shape_radius2(value, defaultValue) { return getRadius(value, defaultValue); }
    function get_shape_points(value, defaultValue) { return tf.js.GetNonNegativeIntFrom(value, defaultValue); }
    function get_snaptopixel(value, defaultValue) { return tf.js.GetBoolFromValue(value, defaultValue); }
    function get_round_rect(value, defaultValue) { return tf.js.GetBoolFromValue(value, defaultValue); }
    function get_round_rect_width(value, defaultValue) { return tf.js.GetFloatNumber(value, defaultValue); }
    function get_round_rect_height(value, defaultValue) { return tf.js.GetFloatNumber(value, defaultValue); }
    function get_round_rect_radius(value, defaultValue) { return tf.js.GetFloatNumber(value, defaultValue); }
    function get_text(value, defaultValue) { return tf.js.GetBoolFromValue(value, defaultValue); }
    function get_marker_horpos(value, defaultValue) { return getStringOrUndefined(value, defaultValue); }
    function get_marker_verpos(value, defaultValue) { return getStringOrUndefined(value, defaultValue); }
    function get_text_align(value, defaultValue) { return getStringOrUndefined(value, defaultValue); }
    function get_text_baseline(value, defaultValue) { return getStringOrUndefined(value, defaultValue); }
    function get_text_offsetx(value, defaultValue) { return tf.js.GetFloatNumber(value, defaultValue); }
    function get_text_offsety(value, defaultValue) { return tf.js.GetFloatNumber(value, defaultValue); }
    function get_zindex(value, defaultValue) { return tf.js.GetNonNegativeIntFrom(value, defaultValue); }
    function initialize() {
        //debug = tf.GetDebug();
        var subStyles = tf.GetStyles().GetSubStyles();
        settings = tf.js.GetValidObjectFrom(settings);
        attrGetters = {
            border_alpha: get_border_opacity,
            border_color: get_border_color,
            border_opacity: get_border_opacity,
            border_width: get_border_width,
            circle: get_circle,
            circle_radius: get_circle_radius,
            fill: get_fill,
            fill_alpha: get_fill_opacity,
            fill_color: get_fill_color,
            fill_opacity: get_fill_opacity,
            font_alpha: get_font_opacity,
            font_color: get_font_color,
            font_opacity: get_font_opacity,
            font_height: get_font_height,
            font: get_font,
            icon: get_icon,
            icon_anchor: get_icon_anchor,
            icon_offset: get_icon_offset,
            icon_img: get_icon_img,
            icon_size: get_icon_size,
            icon_url: get_icon_url,
            label: get_label,
            marker: get_marker,
            marker_alpha: get_marker_opacity,
            marker_arrowlength: get_marker_arrowlength,
            marker_color: get_marker_color,
            marker_opacity: get_marker_opacity,
            marker_horpos: get_marker_horpos,
            marker_verpos: get_marker_verpos,
            opacity: get_opacity,
            line: get_line,
            line_alpha: get_line_opacity,
            line_cap: get_line_cap,
            line_color: get_line_color,
            line_dash: get_line_dash,
            line_join: get_line_join,
            line_opacity: get_line_opacity,
            line_width: get_line_width,
            rotate_with_map: get_rotate_with_view,
            rotation_rad: get_rotation_rad,
            round_rect: get_round_rect,
            round_rect_width: get_round_rect_width,
            round_rect_height: get_round_rect_height,
            round_rect_radius: get_round_rect_radius,
            scale: get_scale,
            shape: get_shape,
            shape_radius: get_shape_radius,
            shape_radius1: get_shape_radius1,
            shape_radius2: get_shape_radius2,
            shape_points: get_shape_points,
            snaptopixel: get_snaptopixel,
            text: get_text,
            text_align: get_text_align,
            text_baseline: get_text_baseline,
            text_offsetx: get_text_offsety,
            text_offsety: get_text_offsety,
            zindex: get_zindex
        };
        var defaultMapFeatureStyleSettings = {
            border_opacity: 1,
            border_color: "#000",
            border_width: 2,
            circle: false,
            circle_radius: 20,
            fill: false,
            fill_opacity: 1,
            fill_color: "#fff",
            font_opacity: 1,
            font_color: subStyles.darkTextColor,
            font_height: subStyles.markerFontSizePXNumber,
            font: subStyles.markerFontFamily,
            icon: false,
            icon_anchor: [0.5, 0.5],
            icon_img: undefined,
            icon_offset: [0, 0],
            icon_url: undefined,
            icon_size: undefined,
            label: '',
            line: false,
            line_opacity: 1,
            line_cap: "round",
            line_join: "round",
            line_color: "#000",
            line_dash: [20, 0],
            line_width: 1,
            marker: false,
            marker_opacity: 1,
            marker_arrowlength: 12,
            marker_color: "#3399FF",
            marker_horpos : tf.consts.positioningCenter,
            marker_verpos : tf.consts.positioningTop,
            opacity: 1,
            rotate_with_map: false,
            rotation_rad: 0,
            round_rect: false,
            round_rect_width: 10,
            round_rect_height: 10,
            round_rect_radius: 0,
            scale: 1.0,
            shape: false,
            shape_radius: undefined,
            shape_radius1: undefined,
            shape_radius2: undefined,
            shape_points: 4,
            snaptopixel: true,
            text: false,
            text_offsetx: 0,
            text_offsety: 0,
            text_align: undefined,
            text_baseline: undefined,
            zindex: 1
        };
        thisInstanceSettings = tf.js.ShallowMerge(defaultMapFeatureStyleSettings);
        updateAttributesFrom(settings);
        updateAPISubStyle();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * @public
 * @class
 * @summary Map Feature Style instances contain one or more [Map Feature Sub Style]{@link tf.map.FeatureSubStyle} instances
 * that together describe the visual attributes used to display [Map Features]{@link tf.map.Feature} on the [Map]{@link tf.map.Map}.
 * @param {tf.types.MapFeatureStyleSettings|array<tf.types.MapFeatureStyleSettings>} settings - creation settings, use a single 
 * settings object to create a single SubStyle, or an {@link array} of settings objects, one for each SubStyle to be created
 */
tf.map.FeatureStyle = function (settings) {
    var theThis, debug, APIStyle, subStyles;
    /**
     * @public
     * @function
     * @summary - Retrieves the number of [Feature Sub Style]{@link tf.map.FeatureSubStyle} instances associated with this Feature Style instance
     * @returns {number} - | {@link number} the number of instances
    */
    this.GetCount = function () { return !!subStyles ? subStyles.length : 0; }
    /**
     * @public
     * @function
     * @summary - Retrieves a [Feature Sub Style]{@link tf.map.FeatureSubStyle} instance associated with this Feature Style instance by the given index
     * @param {number} index - the given index
     * @returns {tf.map.FeatureSubStyle} - | {@link tf.map.FeatureSubStyle} the instance, or {@link void} if <b>index</b> is invalid
    */
    this.Get = function (index) { return index >= 0 && index < theThis.GetCount() ?  subStyles[index] : null; }
    /**
     * @public
     * @function
     * @summary - Changes the attributes of all [Feature Sub Style]{@link tf.map.FeatureSubStyle} instances of this Feature Style instance based on the given settings
     * @param {tf.types.MapFeatureStyleSettings} styleSettings - the given settings
     * @returns {void} - | {@link void} no return value
    */
    this.UpdateAttributesFrom = function (styleSettings) { return updateAttributesFrom(styleSettings); }
    /**
     * @private
     * @function
     * @summary - Returns underlying map engine object associated with this sub style
     * @returns {ol.style} - | the map engine object
    */
    this.getAPIStyle = function () { return APIStyle; }
/**
 * method tf.map.FeatureStyle.GetSubStyles - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    //this.GetSubStyles = function () { return subStyles; }
/**
 * method tf.map.FeatureStyle.SetAttribute - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} attrName - parameter description?
 * @param {?} attrVal - parameter description?
*/
    //this.SetAttribute = function (attrName, attrVal) { return subStyles[0].SetAttribute(attrName, attrVal, false); }
/**
 * method tf.map.FeatureStyle.GetAttribute - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} attrName - parameter description?
*/
    //this.GetAttribute = function (attrName) { return subStyles[0].GetAttribute(attrName); }
    function updateAttributesFrom(newSettings) {
        var updated = false;
        if (!!newSettings) {
            if (tf.js.GetIsNonEmptyArray(newSettings)) {
                var maxIndex = subStyles.length < newSettings.length ? subStyles.length : newSettings.length;
                for (var index = 0 ; index < maxIndex ; index++) {
                    if (subStyles[index].UpdateAttributesFrom(newSettings[i])) {
                        updated = true;
                    }
                }
            }
            else {
                updated = subStyles[0].UpdateAttributesFrom(newSettings);
            }
        }
        if (updated) { updateAPIStyle(); }
        return updated;
    }
    function createAPIStyle() { var apiStyle = []; for (var subStyle in subStyles) { apiStyle.push(subStyles[subStyle].GetAPISubStyle()); } return apiStyle; }
    function updateAPIStyle() { APIStyle = createAPIStyle(); }
    function getMapFeatureSubStyleFrom(theStyle) {
        return theStyle instanceof tf.map.FeatureSubStyle ? theStyle : new tf.map.FeatureSubStyle(theStyle) ;
    }
    function initialize() {
        subStyles = [];
        if (tf.js.GetIsNonEmptyArray(settings)) {
            var nStyles = settings.length;
            subStyles.push(getMapFeatureSubStyleFrom(settings[0]));
            for (var i = 1 ; i < nStyles ; i++) {
                subStyles.push(getMapFeatureSubStyleFrom(settings[i]));
            }
        }
        if (!subStyles.length) { subStyles.push(getMapFeatureSubStyleFrom(settings)); }
        updateAPIStyle();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/*tf.js.SetLegacyCoordsTo = function (coords) {
    if (tf.js.GetIsArrayWithLength(coords, 2)) {
        coords.lon = coords.Lon = coords.Longitude = coords.longitude = coords[0];
        coords.lat = coords.Lat = coords.Latitude = coords.latitude = coords[1];
    }
}*/
/**
 * @public
 * @class
 * @summary Map Feature Geometries support [GeoJSON Geometries]{@link tf.types.GeoJSONGeometry} and can be shared among different [Map Features]{@link tf.map.Feature}
 * @param {tf.types.GeoJSONGeometry} settings - creation settings
 */
tf.map.FeatureGeom = function (settings) {
    var theThis, coordinates, geomCreateFunction, type, isPoint, APIGeom, simplifyTolerance;
    /**
     * @public
     * @function
     * @summary - Retrieves the type of this geometry instance
     * @returns {tf.types.GeoJSONGeometryType} - | {@link tf.types.GeoJSONGeometryType} the type
    */
    this.GetType = function () { return type; }
    /**
     * @public
     * @function
     * @summary - Checks if the type this geometry instance is "point"
     * @returns {boolean} - | {@link boolean} <b>true</b> if the geometry type is "point", <b>false</b> otherwise
    */
    this.GetIsPoint = function () { return isPoint; }
    /**
     * @public
     * @function
     * @summary - Changes the map coordinates of a "point" geometry
     * @param {tf.types.mapCoordinates} pointCoords - the coordinates
     * @returns {void} - | {@link void} no return value
    */
    this.SetPointCoords = function (pointCoords) {
        if (isPoint) {
            var coordsUse = tf.js.GetMapCoordsFrom(pointCoords);
            coordinates[0] = coordsUse[0]; coordinates[1] = coordsUse[1]; /*tf.js.SetLegacyCoordsTo(coordinates);*/ updateGeom(); return true;
        } return false;
    }
    /**
     * @public
     * @function
     * @summary - Retrieves the current coordinates of a "point" geometry
     * @returns {tf.types.mapCoordinates} - | {@link tf.types.mapCoordinates} the coordinates
    */
    this.GetPointCoords = function () { return isPoint ? coordinates : [0,0]; }
    /**
     * @public
     * @function
     * @summary - Retrieves the map extent of this geometry instance
     * @returns {tf.types.mapExtent} - | {@link tf.types.mapExtent} the extent
    */
    this.GetExtent = function () { return getExtent(); }
    this.GetLength = function () { return getLength(); }
    /**
     * @private
     * @function
     * @summary - Returns underlying map engine object associated with this geometry
     * @returns {ol.geom} - | the map engine object
    */
    this.getAPIGeom = function () { return APIGeom; }
    function getLength() {
        var length = 0;
        if (!!APIGeom) { length = APIGeom.getLength(); }
        return length;
    }
    function getExtent() {
        var extent = [0,0,0,0];
        if (!!APIGeom) { extent = ol.extent.applyTransform(APIGeom.getExtent(), ol.proj.getTransform(tf.consts.olSystem, tf.consts.tmSystem)); }
        return extent;
    }
    function createPointGeom() { isPoint = true; return new ol.geom.Point(coordinates); }
    function createPolygonGeom() { return new ol.geom.Polygon(coordinates); }
    function createMultiLineStringGeom() { return new ol.geom.MultiLineString(coordinates); }
    function createLineStringGeom() { return new ol.geom.LineString(coordinates); }
    function createMultiPointGeom() { return new ol.geom.MultiPoint(coordinates); }
    function createMultiPolygonGeom() { return new ol.geom.MultiPolygon(coordinates); }
    function updateGeom() {
        APIGeom = null;
        if (!!(APIGeom = geomCreateFunction())) {
            APIGeom.transform(tf.consts.tmSystem, tf.consts.olSystem);
            if (simplifyTolerance !== undefined) { APIGeom = APIGeom.simplify(simplifyTolerance); }
        }
    }
    function initialize() {
        var geomCreateFunctions = {
            point: createPointGeom,
            polygon: createPolygonGeom,
            linestring: createLineStringGeom,
            multilinestring: createMultiLineStringGeom,
            multipoint: createMultiPointGeom,
            multipolygon: createMultiPolygonGeom
        };
        if (!tf.js.GetIsValidObject(settings)) { settings = { type: "point", coordinates: [0, 0] }; }
        type = settings.type;
        if (!tf.js.GetIsNonEmptyString(type) || geomCreateFunctions[type = type.toLowerCase()] === undefined || !tf.js.GetIsNonEmptyArray(settings.coordinates)) {
            type = "point"; settings.coordinates = [0, 0];
        }
        geomCreateFunction = geomCreateFunctions[type];
        if (isPoint = (type === "point")) { coordinates = tf.js.GetIsArrayWithMinLength(settings.coordinates, 2) ? settings.coordinates.slice(0) : [0,0]; }
        else { coordinates = settings.coordinates; }
        simplifyTolerance = settings.simplifyTolerance;
        if (tf.js.GetIsNonEmptyArray(coordinates)) { updateGeom(); }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.map.SecondsCounterFeature = function (settings) {
    var theThis, map, layer, canvas, ctx, startTime, mapFeature, preComposeListener, totalTime, nSeconds, onEndCallBack, getPositionCallBack, baseZIndex;
    this.OnDelete = function () { return onDelete(); }
    this.GetMapFeature = function () { return mapFeature; }
    this.GetTime01 = function () { return getTime01(); }
    function getTime01() { var time01 = (Date.now() - startTime) / totalTime; return time01; }
    function getFeatureStyle() {
        var style = {};
        if (!!canvas) {
            var twoPI = Math.PI * 2, PIOver2 = Math.PI / 2;
            var dim = 44;//48;//40;//60;
            var dim2 = dim / 2;
            var strokeMin = 1.5;
            var strokeW = 2;//3;
            var time01 = getTime01();
            var angle = time01 * twoPI;
            var blueColor = "rgba(0, 0, 255, 1)";
            var seconds = (nSeconds - (nSeconds * time01));
            var nDecs = seconds < 10 ? 1 : 0;
            var secondsFixed = seconds.toFixed(nDecs) + '';
            var lineDashOffset = Math.floor(time01 * nSeconds * 10);
            var hColor = (1 - time01) * 120;
            var hslColor = "hsl(" + hColor + ", 100%, 50%)";
            var showProgress;
            if (! (showProgress = time01 <= 0.8)) {
                var decimal = Math.floor(time01 * 100) % 10;
                showProgress = (decimal % 2 == 1);
            }
            ctx.translate(0.5, 0.5);
            ctx.canvas.width = dim;
            ctx.canvas.height = dim;
            ctx.clearRect(0, 0, dim, dim);
            ctx.lineDashOffset = 0;
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.shadowColor = "#000";
            ctx.beginPath();
            ctx.lineWidth = strokeMin;
            ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
            ctx.strokeStyle = blueColor;
            ctx.setLineDash([4, 2, 8, 2]);
            ctx.lineDashOffset = lineDashOffset;
            ctx.arc(dim2, dim2, dim2 - strokeW, 0, twoPI, true);
            ctx.stroke();
            ctx.shadowBlur = 0;
            ctx.fill();
            ctx.closePath();
            if (showProgress) {
                ctx.beginPath();
                ctx.setLineDash([]);
                ctx.lineWidth = strokeW + 2 + 1;
                ctx.strokeStyle = hslColor;
                ctx.arc(dim2, dim2, dim2 - 2 * strokeW, -PIOver2 + angle, -PIOver2, true);
                ctx.stroke();
                ctx.closePath();
            }
            ctx.beginPath();
            ctx.lineWidth = strokeMin;
            ctx.setLineDash([8, 2, 1, 2]);
            ctx.lineDashOffset = -lineDashOffset * 2;
            ctx.strokeStyle = blueColor;
            ctx.arc(dim2, dim2, dim2 - 3 * strokeW, 0, twoPI, true);
            ctx.shadowBlur = 4;
            /*ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
            ctx.fill();*/
            ctx.stroke();
            ctx.closePath();
            ctx.shadowColor = "#bebebe";
            var fontStr = "bold " + (Math.floor(dim2) - strokeW * 3) + "px Arial";
            ctx.shadowBlur = 0;
            ctx.font = fontStr;
            ctx.textAlign = "center";
            ctx.textBaseline = 'middle';
            ctx.fillStyle = hslColor;
            ctx.setLineDash([]);
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 2;
            ctx.strokeText(secondsFixed, dim2, dim2);
            ctx.fillText(secondsFixed, dim2, dim2);
            var zIndex = time01 < 0.33 ? 1 : time01 < 0.67 ? 2 : 3;
            style = { zindex: zIndex + baseZIndex, icon: true, icon_img: canvas, icon_size: [dim, dim] };
            if (!!mapFeature) {
                if (mapFeature.GetIsInHover() && showProgress) {
                    var strokeWFrame = 3;
                    ctx.beginPath();
                    ctx.lineWidth = strokeWFrame;
                    ctx.setLineDash([9, 3]);
                    ctx.strokeStyle = "#c00";
                    ctx.strokeRect(strokeWFrame / 2, strokeWFrame / 2, dim - strokeWFrame / 2 - 2, dim - strokeWFrame / 2 - 2);
                    ctx.closePath();
                }
                if (!!getPositionCallBack) {
                    var newPos = getPositionCallBack({ time01: time01, sender: theThis });
                    if (newPos !== undefined) { mapFeature.SetPointCoords(newPos); }
                }
            }
        }
        return style;
    }
    function onDelete() {
        if (!!canvas) {
            if (preComposeListener) { preComposeListener.OnDelete(); preComposeListener = null; }
            canvas = null;
            ctx = null;
            if (!!layer && !!mapFeature) { layer.DelMapFeature(mapFeature); layer = null; }
            if (!!onEndCallBack) { onEndCallBack(theThis); }
            mapFeature = null;
        }
    }
    function onPreCompose (notification) {
        if (getTime01() <= 1) { if (!!mapFeature) { mapFeature.RefreshStyle(); } notification.continueAnimation(); } else { onDelete(); }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (!!(map = tf.js.GetMapFrom(settings.map))) {
            layer = settings.layer;
            canvas = document.createElement('canvas');
            ctx = canvas.getContext("2d");
            baseZIndex = settings.baseZIndex !== undefined ? settings.baseZIndex : 1;
            nSeconds = Math.round(tf.js.GetFloatNumberInRange(settings.nSeconds, 1, 100000, 5));
            totalTime = 1000 * nSeconds;
            onEndCallBack = tf.js.GetFunctionOrNull(settings.onEnd);
            getPositionCallBack = tf.js.GetFunctionOrNull(settings.getPosition);
            startTime = Date.now();
            preComposeListener = map.AddListener(tf.consts.mapPreComposeEvent, onPreCompose);
            mapFeature = new tf.map.Feature({ type: "point", coordinates: settings.center, style: getFeatureStyle });
            mapFeature.secondsCounter = theThis;
            if (!!layer) { layer.AddMapFeature(mapFeature); }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.map.AtlasAnimationFeature = function (settings) {
    var theThis, map, layer, startTime, mapFeature, preComposeListener, timeFromStart, totalTime, frameSettings, scale, nLoop, lastNLoop, onLoopCallBack,
        opacityCallBack, opacity, scaleCallBack, rotationCallBack, iconStyle, getPositionCallBack, baseZIndex;
    this.OnDelete = function () { return onDelete(); }
    this.GetMapFeature = function () { return mapFeature; }
    this.SetScale = function (scale) { return setScale(scale); }
    this.GetTime01 = function () { return getTime01(); }
    this.GetTimeFromStart = function () { return timeFromStart; }
    this.GetNLoop = function () { return nLoop; }
    this.GetSettings = function () { return settings; }
    function onDelete() {
        if (!!mapFeature) {
            if (preComposeListener) { preComposeListener.OnDelete(); preComposeListener = null; }
            if (!!layer && !!mapFeature) { layer.DelMapFeature(mapFeature); layer = null; }
            mapFeature = null;
        }
    }
    function getTime01() {
        timeFromStart = Date.now() - startTime;
        nLoop = Math.floor(timeFromStart / totalTime);
        var timeThisLoop = timeFromStart - nLoop * totalTime;
        var time01 = timeThisLoop / totalTime;
        return time01;
    }
    function getFeatureStyle() {
        var style = {};
        if (!!mapFeature) {
            var time01 = getTime01();
            if (nLoop != lastNLoop) {
                lastNLoop = nLoop;
                if (!!onLoopCallBack) { onLoopCallBack(theThis); }
            }
            if (!!mapFeature) {
                var iFrame = Math.floor(frameSettings.nFrames * time01);
                var xIndexFrame = iFrame % frameSettings.nFramesPerRow;
                var yIndexFrame = Math.floor(iFrame / frameSettings.nFramesPerRow);
                var frameX = frameSettings.ptLTFirstFrame[0] + xIndexFrame * frameSettings.sizeAdvance[0];
                var frameY = frameSettings.ptLTFirstFrame[1] + yIndexFrame * frameSettings.sizeAdvance[1];
                var notification = { time01: time01, nLoop: nLoop, scale: scale, sender: theThis };
                var opacityUse = !!opacityCallBack ? opacityCallBack(notification) : opacity;
                var scaleUse = !!scaleCallBack ? scaleCallBack(notification) : scale;
                var rotationUse = !!rotationCallBack ? rotationCallBack(notification) : undefined;
                if (!!mapFeature) {
                    var useIcon;
                    if (!!iconStyle) {
                        var wScreen = frameSettings.sizeFrame[0] * scaleUse;
                        var minDim = 8;
                        if (!(useIcon = wScreen < minDim)) {
                            var hScreen = frameSettings.sizeFrame[1] * scaleUse;
                            useIcon = hScreen < minDim;
                        }
                    }
                    if (useIcon) { style = iconStyle; }
                    else {
                        //console.log(frameSettings.sizeFrame);
                        style = {
                            rotation_rad: rotationUse,
                            rotate_with_map: frameSettings.rotateWithMap,
                            zindex: baseZIndex,
                            icon: true,
                            icon_img: settings.atlas,
                            icon_size: frameSettings.sizeFrame,
                            icon_offset: [frameX, frameY],
                            opacity: opacityUse,
                            scale: scaleUse
                        };
                    }
                }
            }
            if (!!mapFeature && !!getPositionCallBack) {
                var newPos = getPositionCallBack({ time01: time01, nLoop: nLoop, sender: theThis });
                if (newPos !== undefined) { mapFeature.SetPointCoords(newPos); }
            }
        }
        return style;
    }
    function setScale(scaleSet) {
        scale = tf.js.GetFloatNumberInRange(scaleSet, 0.0001, 999999, 1);
    }
    function onPreCompose(notification) { if (!!mapFeature) { mapFeature.RefreshStyle(); notification.continueAnimation(); } }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsValidObject(frameSettings = settings.frameSettings)) {
            if (!!(map = tf.js.GetMapFrom(settings.map))) {
                layer = settings.layer;
                setScale(settings.scale);
                totalTime = frameSettings.frameDuration * frameSettings.nFrames;
                lastNLoop = nLoop = 0;
                baseZIndex = settings.baseZIndex !== undefined ? settings.baseZIndex : 1;
                iconStyle = tf.js.GetIsValidObject(settings.iconStyle) ? settings.iconStyle : null;
                onLoopCallBack = tf.js.GetFunctionOrNull(settings.onLoop);
                startTime = Date.now();
                timeFromStart = 0;
                if (!(opacityCallBack = tf.js.GetFunctionOrNull(settings.opacity))) {
                    opacity = tf.js.GetIntNumberInRange(settings.opacity, 0, 1, 1);
                }
                scaleCallBack = tf.js.GetFunctionOrNull(settings.scaleCallBack);
                rotationCallBack = tf.js.GetFunctionOrNull(settings.rotationCallBack);
                getPositionCallBack = tf.js.GetFunctionOrNull(settings.getPosition);
                preComposeListener = map.AddListener(tf.consts.mapPreComposeEvent, onPreCompose);
                mapFeature = new tf.map.Feature({ type: "point", coordinates: settings.center, style: getFeatureStyle });
                if (!!layer) { layer.AddMapFeature(mapFeature); }
            }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Settings used in the creation of [Map HTML Overlay]{@link tf.map.HTMLOverlay} instances
 * @public
 * @typedef {object} tf.types.MapOverlaySettings
 * @property {tf.map.Map} map - the map that will display the overlay
 * @property {HTMLElementLike} content - optional content (content can be set after creation)
 * @property {boolean} isVisible - set to <b>false</b> to create an invisible overlay, defaults to <b>true</b>
 * @property {tf.types.mapCoordinates} position - the map coordinates where the overlay is displayed, defaults to [ {@link tf.consts.defaultLongitude}, {@link tf.consts.defaultLatitude}]
 * @property {tf.types.pixelCoordinates} offset - optional pixel offset
 * @property {boolean} autoPan - set to <b>false</b> to prevent the map from panning to the overlay position, defaults to <b>true</b>
 * @property {tf.types.horizontalPositioning} horPos - optional horizontal positioning, defaults to {@link tf.consts.positioningCenter}
 * @property {tf.types.verticalPositioning} verPos - optional vertical positioning, defaults to {@link tf.consts.positioningTop}
*/
/**
 * @public
 * @class
 * @summary Create instances of this class to display HTML Overlays on the [TerraFly HTerraMap]{@link tf.map.Map}
 * @param {tf.types.MapOverlaySettings} settings - map overlay creation settings
 */
tf.map.HTMLOverlay = function (settings) {
    var theThis, styles, isVisible, tMap, div, APIOverlay, pointCoords;
    this.GetContainerDiv = function () { return div; }
    this.GetOverlayHTMLElement = function () { return !!APIOverlay ? APIOverlay.getElement() : undefined; }
    this.SetStyle = function (cssstyle) {
        if (!!div) {
            styles.ApplyStyleProperties(div, cssstyle);
        }
    }
    /**
     * @public
     * @function
     * @summary - Shows or hides the overlay
     * @param {boolean} bool - Set to <b>true</b> to show, <b>false</b> to hide
     * @returns {void} - | {@link void} no return value
    */
    this.SetVisible = function (bool) { return setVisible(bool); }
    /**
     * @public
     * @function
     * @summary - Determines if the overlay is visible
     * @returns {boolean} - | {@link boolean} <b>true</b> if visible, <b>false</b> otherwise
    */
    this.GetIsVisible = function () { return isVisible; }
    /**
     * @public
     * @function
     * @summary - Sets the overlay position on the map
     * @param {tf.types.mapCoordinates} pointCoords - the position
     * @returns {void} - | {@link void} no return value
    */
    this.SetPointCoords = function (pointCoords) { return setPointCoords(pointCoords); }
    /**
     * @public
     * @function
     * @summary - Gets the overlay position on the map
     * @returns {tf.types.mapCoordinates} - | {@link tf.types.mapCoordinates} the position
    */
    this.GetPointCoords = function () { return pointCoords.slice(0); }
    /**
     * @public
     * @function
     * @summary - Sets how the overlay is positioned around its coordinates
     * @param {tf.types.horizontalPositioning} horPos - horizontal positioning
     * @param {tf.types.verticalPositioning} verPos - vertical positioning
     * @returns {void} - | {@link void} no return value
    */
    this.SetPositioning = function (horPos, verPos) {
        if (!!APIOverlay) {
            var horPosUse = tf.js.GetNonEmptyString(horPos, tf.consts.positioningCenter);
            var verPosUse = tf.js.GetNonEmptyString(verPos, tf.consts.positioningTop);
            APIOverlay.setPositioning(verPosUse + '-' + horPosUse);
        } 
    }
    /**
     * @public
     * @function
     * @summary - Sets the overlay pixel offset
     * @param {tf.types.pixelCoordinates} offset - pixel offset
     * @returns {void} - | {@link void} no return value
    */
    this.SetOffset = function (offset) { if (!!APIOverlay && tf.js.GetIsArrayWithLength(offset, 2)) { APIOverlay.setOffset(offset); } }
    /**
     * @public
     * @function
     * @summary - Gets the overlay pixel offset
     * @returns {tf.types.pixelCoordinates} - | {@link tf.types.pixelCoordinates} the pixel offset
    */
    this.GetOffset = function () { return !!APIOverlay ? APIOverlay.getOffset() : undefined; }
    /**
     * @public
     * @function
     * @summary - Sets the overlay content
     * @param {HTMLElementLike} content - the content
     * @returns {void} - | {@link void} no return value
    */
    this.SetContent = function (content) { return setContent(content); }
    /**
     * @private
     * @function
     * @summary - Gets the underlying map engine object
     * @returns {ol.Overlay} - | the underlying map engine object
    */
    this.getAPIOverlay = function () { return APIOverlay; }
    function setContent(content) { if (!!content && !!div) { div.ReplaceContent(content); } }
    function setPointCoords(newPointCoords) {
        if (!!APIOverlay && !!newPointCoords && typeof newPointCoords === "object") { return APIOverlay.setPosition(tf.units.TM2OL(pointCoords = newPointCoords.slice(0))); }
    }
    function setVisible(bool) {
        if (isVisible != (bool = !!bool)) {
            isVisible = bool;
            if (!!tMap) {
                if (isVisible) { tMap.addHTMLOverlay(theThis); } else { tMap.removeHTMLOverlay(theThis); APIOverlay.setMap(undefined); }
            }
        }
    }
    function initialize() {
        styles = tf.GetStyles();
        isVisible = false;
        var defaultPosition = [tf.consts.defaultLongitude, tf.consts.defaultLatitude];
        var defaultSettings = {
            map: undefined,
            content: undefined,
            isVisible: true,
            position: defaultPosition,
            offset: [0, 0],
            horPos: tf.consts.positioningCenter,
            verPos: tf.consts.positioningTop,
            stopEvent: true,
            insertFirst: true,
            autoPanMargin: 20,
            autoPan: false
        };
        var settingsUse = tf.js.ShallowMerge(defaultSettings, settings);
        if (!!(tMap = tf.js.GetMapFrom(settingsUse.map))) {
            var content = settingsUse.content;
            var isVisible = settingsUse.isVisible;
            settingsUse.positioning = settingsUse.verPos + '-' + settingsUse.horPos;
            delete settingsUse.horPos;
            delete settingsUse.verPos;
            delete settingsUse.isVisible;
            delete settingsUse.content;
            delete settingsUse.map;
            if (tf.js.GetIsArray(settingsUse.position)) { settingsUse.position = defaultPosition; }
            settingsUse.position = tf.units.TM2OL(pointCoords = settingsUse.position);
            settingsUse.element = (div = new tf.dom.Div({ cssClass: styles.GetUnPaddedDivClassNames(false, false) })).GetHTMLElement();
            if (!!content) { div.AddContent(settings.content); }
            APIOverlay = new ol.Overlay(settingsUse);
            setVisible(isVisible);
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Settings used in the creation of [Map HTML Control]{@link tf.map.HTMLControl} instances
 * @public
 * @typedef {object} tf.types.MapControlSettings
 * @property {tf.map.Map} map - the map that will display the control
 * @property {HTMLElementLike} content - optional content (content can be set after creation)
 * @property {boolean} isVisible - set to <b>false</b> to create an invisible control, defaults to <b>true</b>
 * @property {tf.types.CSSStyleSpecs} cssStyle - optional style to be applied to the control
*/
/**
 * @public
 * @class
 * @summary Create instances of this class to display HTML Controls on the [TerraFly HTerraMap]{@link tf.map.Map}
 * @param {tf.types.MapControlSettings} settings - map control creation settings
 */
tf.map.HTMLControl = function (settings) {
    var theThis, styles, isVisible, tMap, div, APIControl;
    /**
     * @public
     * @function
     * @summary - Shows or hides the control
     * @param {boolean} bool - Set to <b>true</b> to show, <b>false</b> to hide
     * @returns {void} - | {@link void} no return value
    */
    this.SetVisible = function (bool) { return setVisible(bool); }
    /**
     * @public
     * @function
     * @summary - Determines if the control is visible
     * @returns {boolean} - | {@link boolean} <b>true</b> if visible, <b>false</b> otherwise
    */
    this.GetIsVisible = function () { return isVisible; }
    /**
     * @public
     * @function
     * @summary - Sets the control content
     * @param {HTMLElementLike} content - the content
     * @returns {void} - | {@link void} no return value
    */
    this.SetContent = function (content) { return setContent(content); }
    /**
     * @private
     * @function
     * @summary - Gets the underlying map engine object
     * @returns {ol.control.Control} - | the underlying map engine object
    */
    this.getAPIControl = function () { return APIControl; }
    function setContent(content) { if (!!content && !!div) { div.ReplaceContent(content); } }
    function setVisible(bool) {
        if (isVisible != (bool = !!bool)) {
            isVisible = bool;
            if (!!tMap) {
                if (isVisible) { tMap.addHTMLControl(theThis); } else { tMap.removeHTMLControl(theThis); APIControl.setMap(undefined); }
            }
        }
    }
    function initialize() {
        styles = tf.GetStyles();
        isVisible = false;
        var defaultPosition = [tf.consts.defaultLongitude, tf.consts.defaultLatitude];
        var defaultSettings = {
            map: undefined,
            content: undefined,
            isVisible: true
        };
        var settingsUse = tf.js.ShallowMerge(defaultSettings, settings);
        if (!!(tMap = tf.js.GetMapFrom(settingsUse.map))) {
            var content = settingsUse.content;
            var isVisible = settingsUse.isVisible;
            delete settingsUse.isVisible;
            delete settingsUse.content;
            delete settingsUse.map;
            settingsUse.target = tMap.GetControlContainer();
            settingsUse.element = (div = new tf.dom.Div({ cssClass: styles.GetUnPaddedDivClassNames(false, false) })).GetHTMLElement();
            if (!!settings.cssStyle) { styles.ApplyStyleProperties(div, settings.cssStyle); }
            if (!!content) { div.AddContent(settings.content); }
            APIControl = new ol.control.Control(settingsUse);
            if (isVisible) {
                setVisible(isVisible);
            }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.map.MapOverlay = function (settings) {
    var theThis, styles, subStyles, map, mapBubble, myMap, bubbleDim, content, borderRadius;
    this.GetHTMLOverlay = function () { return mapBubble; }
    this.GetOverlayMap = function () { return myMap; }
    this.GetMapContainer = function () { return content; }
    function prepareBubbleContent(coords) {
        content = new tf.dom.Div(null, styles.GetUnPaddedDivClassNames(false, false));
        var baseContainerStyles = { inherits: [subStyles.defaultShadowStyle, subStyles.buttonStyleBase, subStyles.paddedBlockDivStyle, subStyles.cursorDefaultStyle, subStyles.noSelectStyle] };
        var containerStyles = {
            inherits: [baseContainerStyles],
            backgroundColor: "#000", fontFamily: "Arial", fontSize: "1.2em", color: "#fc0",
            border: "2px dashed #fc0", borderRadius: borderRadius, padding: "0px",
            maxWidth: "20em", width: bubbleDim + "px", height: bubbleDim + "px",
            position: "relative", overflow: "hidden"
        };
        mapBubble.SetStyle(containerStyles);
        var contentStyle = {
            borderRadius: borderRadius,
            width: (bubbleDim) + "px", height: (bubbleDim) + "px",
            position: "relative", overflow: "hidden"
        };
        styles.ApplyStyleProperties(content, contentStyle);
        myMap = map.CreateMapWithSameLayers(content);
        return content;
    }
    function initialize() {
        var defaultSettings = {};
        settings = tf.js.ShallowMerge(defaultSettings, settings);
        if (!!(map = tf.js.GetMapFrom(settings.map))) {
            var coords = settings.coords !== undefined ? settings.coords : map.GetCenter();
            styles = tf.GetStyles();
            subStyles = styles.GetSubStyles();
            bubbleDim = tf.js.GetIntNumberInRange(settings.bubbleDim, 100, 1000, 200);
            borderRadius = tf.js.GetNonEmptyString(settings.borderRadius, "50%");
            mapBubble = new tf.map.HTMLOverlay({ map: map, autoPan: settings.autoPan, autoPanMargin: settings.autoPanMargin, stopEvent: false, isVisible: settings.isVisible });
            mapBubble.SetPositioning(tf.consts.positioningCenter, tf.consts.positioningCenter);
            mapBubble.SetOffset([0, 0]);
            mapBubble.SetContent(prepareBubbleContent(coords));
            mapBubble.SetPointCoords(coords);
            myMap.OnResize();
            setTimeout(myMap.OnResize, 250);
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * A callback function that renders animations during [Map]{@link tf.map.Map} [Post Compose]{@link tf.consts.mapPostComposeEvent} events
 * @public
 * @callback tf.types.PostComposeAnimatorCallBack
 * @param {tf.map.Map} map - Map instance where animation will take place
 * @param {tf.types.MapShowFeatureImmediately} mapShowFeatureImmediately - A callback used to display map features
 * @param {number} elapsed01 - A number between <b>0</b> and <b>1</b> equal to the ratio (animation elapsed time) / (animation duration)
 * @returns {void} - | {@link void} no return value
 */
/**
 * @public
 * @class
 * @summary - Post Compose Animator instances automatically manage listening to [Post Compose]{@link tf.consts.mapPostComposeEvent} events
 * on the given [Map]{@link tf.map.Map} instance, and for the given duration of time call the given callback to perform an animation
 * @param {object} settings - creation settings
 * @param {tf.map.Map} settings.map - Map instance where animation will take place
 * @param {tf.types.PostComposeAnimatorCallBack} settings.animationFunction - callback that renders the animation
 * @param {number} settings.duration - the duration of the animation in  milliseconds
*/
tf.map.PostComposeAnimator = function (settings) {
    var theThis, listener, startTime, theMap, duration, animationFunction;
    /**
     * @public
     * @function
     * @summary - Starts the animation
     * @returns {void} - | {@link void} no return value
    */
    this.Start = function () { if (startTime === undefined) { if (!!theMap) { startTime = new Date().getTime(); renderMap(); } } }
    /**
     * @public
     * @function
     * @summary - Stops the animation, if it is ongoing
     * @returns {void} - | {@link void} no return value
    */
    this.Stop = function () { return stop(); }
    /**
     * @public
     * @function
     * @summary - Determines if the animation is ongoing
     * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
    */
    this.IsAnimating = function () { return startTime !== undefined && !listener; }
    function renderMap() { theMap.Render(); }
    function stop() { if (!!listener) { listener.OnDelete(); listener = null; setTimeout(renderMap, 10); } }
    function animate(notification) {
        if (startTime !== undefined) {
            var elapsed = new Date().getTime() - startTime;
            if (elapsed > duration) { stop(); }
            else {
                animationFunction(notification.sender, notification.showFeatureImmediately, tf.js.GetFloatNumberInRange(elapsed / duration, 0, 1, 1));
                notification.continueAnimation();
            }
        }
    }
    function initialize() {
        theMap = tf.js.GetMapFrom(settings.map);
        if (tf.js.GetIsMap(theMap) &&
            (!!(animationFunction = tf.js.GetFunctionOrNull(settings.animationFunction)))) {
            duration = tf.js.GetFloatNumberInRange(settings.duration, 1000, 10000, 100);
            listener = theMap.AddListener(tf.consts.mapPostComposeEvent, animate);
        } else { theMap = null; animationFunction = null; }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * A callback function that produces a [Feature Style Settings]{@link tf.types.MapFeatureStyleSettings} object
 * for the given animation elapsed time ratio. Used by [Geometries Style Animator]{@link tf.map.GeometriesStyleAnimator}
 * @public
 * @callback tf.types.GeometriesStyleAnimatorCallBack
 * @param {number} elapsed01 - A number between <b>0</b> and <b>1</b> equal to the ratio (animation elapsed time) / (animation duration)
 * @returns {tf.types.MapFeatureStyleSettings} - | {@link tf.types.MapFeatureStyleSettings} the style settings to be used at <b>elapsed01</b>
 */
/**
 * @public
 * @class
 * @summary - Geometries Style Animator instances repeatedly refresh the style of one or more given geometries, 
 * using the given style generator callback and for the given time duration, to display style animations on 
 * the on the given [Map]{@link tf.map.Map} instance
 * @param {object} settings - creation settings
 * @param {tf.map.Map} settings.map - Map instance where animation will take place
 * @param {tf.types.GeometriesStyleAnimatorCallBack} settings.getStyle - callback that produces style settings
 * @param {number} settings.duration - the duration of the animation in  milliseconds
*/
tf.map.GeometriesStyleAnimator = function (settings) {
    var theThis, geometries, getStyleMethod, animator;
    /**
     * @public
     * @function
     * @summary - Starts the animation
     * @returns {void} - | {@link void} no return value
    */
    this.Start = function () { if (!!animator) { animator.Start(); } }
    /**
     * @public
     * @function
     * @summary - Stops the animation, if it is ongoing
     * @returns {void} - | {@link void} no return value
    */
    this.Stop = function () { if (!!animator) { animator.Stop(); } }
    /**
     * @public
     * @function
     * @summary - Determines if the animation is ongoing
     * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
    */
    this.IsAnimating = function () { return !!animator ? animator.IsAnimating() : false; }
    function getDefaultStyle(elapsed01) {
        var radius = 4 + Math.pow(elapsed01, 1 / 2) * 16;
        var opacity = 1 - Math.pow(elapsed01, 3);
        var line_width = (2 - elapsed01);
        var defaultStyle = {
            circle: true,
            circle_radius: radius,
            snapToPixel: false,
            line: true,
            line_width: line_width,
            line_color: tf.js.GetRandomHexColorStr(),//"#f00",
            line_alpha: opacity * 100
        };
        return defaultStyle;
    }
    function animate(theMap, showFeatureImmediately, elapsed01) {
        var animatedStyle = getStyleMethod(elapsed01);
        for (var i in geometries) {
            var geom = geometries[i];
            var animatedFeature = new tf.map.Feature({ geom: geom, style: animatedStyle });
            showFeatureImmediately(animatedFeature);
        }
    }
    function initialize() {
        if (!(getStyleMethod = tf.js.GetFunctionOrNull(settings.getStyle))) { getStyleMethod = getDefaultStyle; }
        if (!!(geometries = settings.geometries) && (typeof geometries === "object")) {
            animator = new tf.map.PostComposeAnimator({ map: settings.map, duration: settings.duration, animationFunction: animate });
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * @public
 * @class
 * @summary - Points Style Animator instances repeatedly display an arbitrary number of [Point Geometries]{@link tf.types.GeoJSONGeometryType} 
 * obtained from the given providers on the given [Maps]{@link tf.map.Map}, using styles obtained from the given style generator callback,
 * producing an animation with the given duration
 * @param {object} settings - creation settings
 * @param {enumerable<tf.map.Map>} settings.maps - an arbitrary number of Map instances where animation will take place
 * @param {enumerable<object>} settings.pointProviders - an arbitrary number of objects, each containing a function named <b>GetPointCoords</b> returning
 * [Map Coordinates]{@link tf.types.mapCoordinates}
 * @param {tf.types.GeometriesStyleAnimatorCallBack} settings.getStyle - callback that produces style settings
 * @param {number} settings.duration - the duration of the animation in  milliseconds
*/
tf.map.PointsStyleAnimator = function (settings) {
    var theThis, pointListGeometry, getStyleMethod;
    /**
     * @private
     * @function
     * @summary - Retrieves the single [Map Feature Geometry]{@link tf.map.FeatureGeom} instance containing all map coordinates whose style is being animated
     * @returns {tf.map.FeatureGeom} - | {@link tf.map.FeatureGeom} the instance
    */
    this.GetPointListGeometry = function () { return pointListGeometry; }
    function createGeometry(pointProviders) {
        var coordinates = [];
        for (var i in pointProviders) {
            var pp = pointProviders[i];
            if (tf.js.GetIsValidObject(pp)) {
                var coords;
                if (tf.js.GetFunctionOrNull(pp.GetPointCoords)) {
                    coords = pp.GetPointCoords();
                }
                else if (tf.js.GetIsArrayWithMinLength(pp, 2)) {
                    coords = pp;
                }
                if (!!coords) { coordinates.push(coords); }
            }
        }
        if (!!coordinates.length) { pointListGeometry = new tf.map.FeatureGeom({ type: "multipoint", coordinates: coordinates }); }
        return !!pointListGeometry;
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        var settingsMaps = settings.maps;
        var pointProviders = settings.pointProviders;
        if (tf.js.GetIsValidObject(settingsMaps) && tf.js.GetIsValidObject(pointProviders)) {
            var hasGeometriesAndMaps = false;
            var animators = [];
            for (var i in settingsMaps) {
                var map = tf.js.GetMapFrom(settingsMaps[i]);
                if (!!map) {
                    if (!hasGeometriesAndMaps) { if (!(hasGeometriesAndMaps = createGeometry(pointProviders))) { break; } }
                    animators.push(new tf.map.GeometriesStyleAnimator({ map: map, geometries: [pointListGeometry], getStyle: settings.getStyle, duration: settings.duration }));
                }
            }
            if (hasGeometriesAndMaps) { for (var i in animators) { animators[i].Start(); } }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * class tf.ui.VolumeControl - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} initialLightBool - parameter description?
 * @param {?} buttonHeight - parameter description?
 * @param {?} initPos01 - parameter description?
 * @param {?} initialIsMute - parameter description?
 * @param {?} volChangeCallBack - parameter description?
*/
tf.ui.VolumeControl = function (initialLightBool, buttonHeight, initPos01, initialIsMute, volChangeCallBack) {
    var onTouchDevice = tf.browser.HasTouch();
    var svgGlyphLib = tf.ui.GetSvgGlyphLib();
    var muteGlyph = svgGlyphLib.GetGlyphByName(tf.styles.SvgGlyphMuteVolumeName);
    var volMinGlyph = svgGlyphLib.GetGlyphByName(tf.styles.SvgGlyphMinimumVolumeName);
    var volMedGlyph = svgGlyphLib.GetGlyphByName(tf.styles.SvgGlyphMediumVolumeName);
    var volMaxGlyph = svgGlyphLib.GetGlyphByName(tf.styles.SvgGlyphMaximumVolumeName);
    var theThis, divObj, divElem, volButton, volSlider, volSliderElem = null;
    var widthVolSlider = 64;
    var pos01 = null;
    var pos01BeforeMute = null;
    var isMute = false;
    var hoverListener;
/**
 * method tf.ui.VolumeControl.Repaint - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.Repaint = function () { volSlider.Repaint(); }
    function getCurVolGlyph() {
        return isMute ? muteGlyph : (pos01 > 0.66 ? volMaxGlyph : (pos01 > 0.33 ? volMedGlyph : volMinGlyph));
    }
    function getCurVolToolTip() { return isMute ? "unmute" : "mute"; }
    function updateVolButton() {
        volButton.ChangeGlyph(getCurVolGlyph());
        volButton.ChangeToolTip(getCurVolToolTip());
        if (!!volChangeCallBack) { volChangeCallBack(theThis, pos01); }
    }
    function setMutePos01() { pos01BeforeMute = pos01; pos01 = 0; }
    function setUnMutePos01() { pos01 = pos01BeforeMute; }
    function setPosByMute() { if (isMute) { setMutePos01() } else { setUnMutePos01(); } }
    function onClickVolume() {
        isMute = !isMute;
        setPosByMute();
        volSlider.SetPos01(pos01);
        updateVolButton();
    }
    function onVolHover(notification) {
        if (!onTouchDevice) {
            var inHover = notification.isInHover;
            volSliderElem.style.display = inHover ? "inline-block" : "none";
            if (inHover) { volSlider.Repaint(); }
        }
    }
    function onClickVolSlide(theSlide, slidePos01) {
        if (isMute) { isMute = false; }
        pos01 = volSlider.GetPos01();
        updateVolButton();
    }
    function initialize() {
        var styles = tf.GetStyles();
        isMute = !!initialIsMute;
        typeof volChangeCallBack !== "function" && (volChangeCallBack = null);
        pos01 = tf.js.GetFloatNumber(initPos01, 0.5);
        divObj = new tf.dom.Div({ cssClass: styles.unPaddedInlineBlockDivClass });
        divElem = divObj.GetHTMLElement();
        var divVolsObj = new tf.dom.Div({ cssClass: styles.unPaddedInlineBlockDivClass });
        var divVolsElem = divObj.GetHTMLElement();
        volButton = new tf.ui.SvgGlyphBtn({ style: initialLightBool, glyph: getCurVolGlyph(), onClick: onClickVolume, tooltip: getCurVolToolTip(), dim: buttonHeight });
        divVolsObj.AddContent(volButton);
        volSlider = new tf.ui.CanvasSlider(pos01, undefined, false);
        volSliderElem = volSlider.GetHTMLElement();
        volSlider.SetOnClickListener(onClickVolSlide, theThis);
        volSliderElem.style.width = widthVolSlider + "px";
        volSliderElem.style.display = onTouchDevice ? "inline-block" : "none";
        hoverListener = new tf.events.DOMHoverListener({ target: divVolsElem, callBack: onVolHover, optionalScope: theThis, callBackSettings: null });
        divVolsObj.AddContent(volSlider);
        divObj.AddContent(divVolsObj);
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: divElem });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
}
tf.js.InheritFrom(tf.ui.VolumeControl, tf.dom.Insertable);
/**
 * class tf.ui.VideoPopup - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} container - parameter description?
 * @param {?} backgroundColorSet - parameter description?
 * @param {?} backgroundImgSet - parameter description?
*/
tf.ui.VideoPopup = function (container, backgroundColorSet, backgroundImgSet) {
    var theThis, styles, subStyles, onTouchDevice, wPadding, widthWindowRatio, heightWindowRatio, videoRatio;
    var defaultBackgroundColor, backgroundColor, backgroundImg;
    var divContainerElem, popup, divPopupTitle, videoElem, posSlideObj, posSlideElem, volControlObj, currentTimeElem;
    var hoverTimeElem, totalTimeElem, toolBarObj, toolBarElem, videoAllContentObj, videoAllContentElem;
    var playPauseButtonObj, stopButtonObj, autoRepeatButtonObj, videoLength, videoPos, slideHover;
    var isStopped, autoRepeat, miniVideo, miniVideoPos01, miniVideoPos, miniVideoBorderDim;
    var miniVideoColorNormal, miniVideoColorLate, miniVideoBorderCaughtUp, miniVideoBorderLate;
    var minivideoShowing, videoW, videoH, addedContents, lightBool, buttonDim, hasVideo;
    var onCloseCallBack, onCloseThis, miniVideoDisplaying, lastMouse01;
    var onMiniVideoChangeCallBack, onThisMiniVideoChangeCallBack;
    var onTimeUpdateThis, onTimeUpdateCallBack;
    /**
     * method tf.ui.VideoPopup.Stop - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
    */
    this.Stop = function () { return onStop(); }
    /**
     * method tf.ui.VideoPopup.GetLeftTopOnContainer - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
    */
    this.GetLeftTopOnContainer = function () { return getLeftTopOnContainer(); }
    function getLeftTopOnContainer() { return popup.GetLeftTopOnContainer(); }
    /**
     * method tf.ui.VideoPopup.ChangeTitle - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
     * @param {?} titleStr - parameter description?
    */
    this.ChangeTitle = function (titleStr) { popup.ChangeTitle(titleStr); }
    /**
     * method tf.ui.VideoPopup.ChangeSpeed - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
     * @param {?} speed - parameter description?
    */
    this.ChangeSpeed = function (speed) { return changeSpeed(speed); }
    /**
     * method tf.ui.VideoPopup.SetPos01 - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
     * @param {?} pos01Set - parameter description?
    */
    this.SetPos01 = function (pos01Set) { setSlidePos01(pos01Set); changeVideoPosFromSlide(); }
    /**
     * method tf.ui.VideoPopup.GetPos01 - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
    */
    this.GetPos01 = function () { return posSlideObj.GetPos01(); }
    /**
     * method tf.ui.VideoPopup.GetPos - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
    */
    this.GetPos = function () { return videoPos; }
    /**
     * method tf.ui.VideoPopup.GetToolBarButtonDim - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
    */
    this.GetToolBarButtonDim = function () { return buttonDim; }
    /**
     * method tf.ui.VideoPopup.GetIsButtonLight - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
    */
    this.GetIsButtonLight = function () { return lightBool; }
    /**
     * method tf.ui.VideoPopup.AddToolBarButton - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
     * @param {?} toolBarButton - parameter description?
    */
    this.AddToolBarButton = function (toolBarButton) { return addToolBarButton(toolBarButton); }
    /**
     * method tf.ui.VideoPopup.AddContent - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
     * @param {?} elem - parameter description?
    */
    this.AddContent = function (elem) { return addContent(elem); }
    /**
     * method tf.ui.VideoPopup.SetOnClickTitle - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
     * @param {?} callBack - parameter description?
     * @param {?} optionalScope - parameter description?
    */
    this.SetOnClickTitle = function (callBack, optionalScope) { if (popup) { popup.SetOnClickTitle(callBack, optionalScope); } }
    /**
     * method tf.ui.VideoPopup.SetZIndex - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
     * @param {?} zIndex - parameter description?
    */
    this.SetZIndex = function (zIndex) { popup && popup.SetZIndex(zIndex); }
    /**
     * method tf.ui.VideoPopup.GetZIndex - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
    */
    this.GetZIndex = function () { return popup ? popup.GetZIndex() : 0; }
    /**
     * method tf.ui.VideoPopup.SetOnClose - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
     * @param {?} callBack - parameter description?
     * @param {?} optionalScope - parameter description?
    */
    this.SetOnClose = function (callBack, optionalScope) { onCloseCallBack = tf.js.GetFunctionOrNull(callBack); onCloseThis = optionalScope; }
    /**
     * method tf.ui.VideoPopup.ShowMiniVideo - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
     * @param {?} showBool - parameter description?
     * @param {?} time01 - parameter description?
    */
    this.ShowMiniVideo = function (showBool, time01) { return showMiniVideo(showBool, time01); }
    /**
     * method tf.ui.VideoPopup.GetIsMiniVideoShowing - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
    */
    this.GetIsMiniVideoShowing = function () { return minivideoShowing; }
    /**
     * method tf.ui.VideoPopup.SetOnMiniVideoChangeCallBack - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
     * @param {?} callBack - parameter description?
     * @param {?} optionalScope - parameter description?
    */
    this.SetOnMiniVideoChangeCallBack = function (callBack, optionalScope) { onMiniVideoChangeCallBack = tf.js.GetFunctionOrNull(callBack); onThisMiniVideoChangeCallBack = optionalScope; }
    /**
     * method tf.ui.VideoPopup.SetOnTimeUpdate - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
     * @param {?} callBack - parameter description?
     * @param {?} optionalScope - parameter description?
    */
    this.SetOnTimeUpdate = function (callBack, optionalScope) { onTimeUpdateCallBack = tf.js.GetFunctionOrNull(callBack); onTimeUpdateThis = optionalScope; }
    /**
     * method tf.ui.VideoPopup.SetTitle - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
     * @param {?} titleStr - parameter description?
    */
    this.SetTitle = function (titleStr) { popup && popup.ChangeTitle(titleStr); }
    /**
     * method tf.ui.VideoPopup.Show - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
     * @param {?} bool - parameter description?
    */
    this.Show = function (bool) { if (popup) { popup.Show(bool); } }
    /**
     * method tf.ui.VideoPopup.IsShowing - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
    */
    this.IsShowing = function () { return popup ? popup.IsShowing() : false; }
    /**
     * method tf.ui.VideoPopup.Toggle - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
    */
    this.Toggle = function () { this.Show(!this.IsShowing()); }
    /**
     * method tf.ui.VideoPopup.SetVideoURL - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
     * @param {?} theVideoURL - parameter description?
    */
    this.SetVideoURL = function (theVideoURL) { hasVideo = false; isStopped = true; if (miniVideo) { miniVideo.src = theVideoURL; } videoElem.src = theVideoURL; }
    /**
     * method tf.ui.VideoPopup.OnContainerResize - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
    */
    this.OnContainerResize = function () { onContainerResize(); }
    function myOnCloseCallBack() { onStop(); if (!!onCloseCallBack) { onCloseCallBack.call(onCloseThis); } }
    function setContent(content) { if (popup) { return popup.SetContent(content); } }
    function positionMiniVideo() {
        if (miniVideo) {
            var miniVideoW = videoW / 3;
            var miniVideoH = videoH / 3;
            miniVideo.style.width = miniVideoW + "px";
            miniVideo.style.height = miniVideoH + "px";
            var topPos = videoH - miniVideoH - 4 * miniVideoBorderDim;
            miniVideo.style.top = topPos + "px";
            var leftPos = miniVideoPos01 * videoW - miniVideoW / 2 + miniVideoBorderDim;
            if (leftPos < miniVideoBorderDim) { leftPos = miniVideoBorderDim; } else if (leftPos + 2 * miniVideoBorderDim + miniVideoW > videoW) { leftPos = videoW - miniVideoW - 2 * miniVideoBorderDim; }
            miniVideo.style.left = leftPos + "px";
        }
    }
    function resizeElems() {
        if (videoElem) {
            var containerWidth = divContainerElem.offsetWidth;
            var containerHeight = divContainerElem.offsetHeight;
            var maxW = widthWindowRatio * containerWidth;
            var maxH = heightWindowRatio * containerHeight;
            var hForMaxW = maxW / videoRatio;
            if (hForMaxW > maxH) { maxW = maxH * videoRatio; } else { maxH = maxW / videoRatio; }
            videoW = Math.round(maxW);
            videoH = Math.round(maxH);
            videoElem.style.width = videoW + "px";
            videoElem.style.height = videoH + "px";
            posSlideElem.style.width = videoW + "px";
            posSlideObj.Repaint();
            volControlObj.Repaint();
            positionMiniVideo();
            var nAddedContents = addedContents.length;
            for (var i = 0 ; i < nAddedContents ; ++i) {
                var contentObj = addedContents[i], contentElem = tf.dom.GetHTMLElementFrom(contentObj);
                if (contentElem) { contentElem.style.width = (videoW + "px"); }
            }
            //tf.GetDebug().LogIfTest ("videoW: " + videoW + " videoH: " + videoH);
        }
    }
    function onContainerResize() { resizeElems(); popup.OnContainerResize(); }
    function onPlay() { isStopped = false; if (videoElem.paused) { videoElem.play(); } else { videoElem.pause(); } }
    function onStop() { if (videoElem) { isStopped = true; videoElem.pause(); setSlidePos01(0); changeVideoPosFromSlide(); playPauseButtonObj.SetIsToggled(true); checkMiniVideoOnHover(); } }
    function updateVideoPosInterface() {
        var timeStamp = tf.js.ConvertToHHMMSSBrief(videoPos);
        currentTimeElem.textContent = timeStamp;
        //popup.ChangeTitle(timeStamp);
        if (onTimeUpdateCallBack) { onTimeUpdateCallBack.call(onTimeUpdateThis, theThis, posSlideObj.GetPos01(), videoPos); }
    }
    function changeVideoPosFromSlide() {
        var pos01 = posSlideObj.GetPos01();
        if (hasVideo) {
            videoPos = videoElem.currentTime = pos01 * videoLength;
            updateVideoPosInterface();
            //tf.GetDebug().LogIfTest("changed to: " + pos01);
        }
    }
    function setSlidePos01(pos01Set) { posSlideObj.SetPos01(pos01Set, true); }
    function setSlidePos01IfNotStopped(pos01Set) { if (!isStopped) { setSlidePos01(pos01Set); changeVideoPosFromSlide(); } }
    function onTimeUpdate() {
        videoPos = videoElem.currentTime;
        if (videoLength) {
            setSlidePos01(videoPos / videoLength);
            updateVideoPosInterface();
        }
    }
    function onLoadedMetadata() {
        videoLength = videoElem.duration; totalTimeElem.textContent = tf.js.ConvertToHHMMSSBrief(videoLength);
        hasVideo = true;
        isStopped = false;
        changeVideoPosFromSlide();
        popup.OnContainerResize();
        videoElem.play();
    }
    function setMiniVideoTime01(time01) { miniVideoPos01 = time01; miniVideo.currentTime = miniVideoPos = time01 * videoLength; }
    function notifyMiniVideoChange(mouse01) {
        if (mouse01 != undefined || !miniVideoDisplaying) {
            if (onMiniVideoChangeCallBack) {
                onMiniVideoChangeCallBack.call(onThisMiniVideoChangeCallBack, theThis, miniVideoDisplaying, mouse01);
            }
        }
    }
    function setMiniVideoStyleShow(showBool) {
        if (!!miniVideo) {
            if (showBool) { minivideoShowing = true; miniVideo.style.display = 'block'; hoverTimeElem.style.display = 'inline'; }
            else { minivideoShowing = false; miniVideo.style.display = 'none'; hoverTimeElem.style.display = 'none'; }
        }
    }
    function showMiniVideo(showBool, time01) {
        if (miniVideo) {
            if ((showBool = !!showBool) != miniVideoDisplaying) { setMiniVideoStyleShow(miniVideoDisplaying = showBool); }
            if (miniVideoDisplaying) { setMiniVideoTime01(time01); }
        }
    }
    function checkMiniVideoOnHover(mouse01) {
        var miniVideoWasDisplaying = miniVideoDisplaying;
        miniVideoDisplaying = false;
        if (!onTouchDevice) {
            if (posSlideObj.GetIsInHover() && !posSlideObj.GetIsInDrag()) {
                miniVideoDisplaying = true;
                if (miniVideoWasDisplaying) { if (mouse01 != lastMouse01) { notifyMiniVideoChange(mouse01); } }
                else { setMiniVideoStyleShow(true); notifyMiniVideoChange(mouse01); }
            }
            else { if (miniVideoWasDisplaying) { setMiniVideoStyleShow(false); notifyMiniVideoChange(mouse01); } }
        }
        miniVideoWasDisplaying = miniVideoDisplaying;
        lastMouse01 = mouse01;
        return miniVideoDisplaying;
    }
    function onHoverOverSlide(theSlide, hover01) { if (theSlide == posSlideObj) { if (!theSlide.GetIsInHover()) { checkMiniVideoOnHover(); } } }
    function onMouseMoveOverSlide(theSlide, mouse01) {
        if (miniVideo) {
            if (theSlide == posSlideObj && theSlide.GetIsInHover() && !theSlide.GetIsInDrag()) {
                if (checkMiniVideoOnHover(mouse01)) {
                    miniVideo.style.border = miniVideoBorderLate;
                    hoverTimeElem.style.color = miniVideoColorLate;
                    posSlideObj.SetMouseFillColor(miniVideoColorLate);
                    setMiniVideoTime01(mouse01);
                }
            }
        }
    }
    function onClickVideoSlide(theSlide, pos01) {
        checkMiniVideoOnHover();
        //var posVideo = pos01 * videoLength; videoElem.currentTime = posVideo;
        changeVideoPosFromSlide();
    }
    function onMiniVideoTimeUpdate() {
        if (miniVideo) {
            miniVideo.style.border = miniVideoBorderCaughtUp;
            hoverTimeElem.style.color = miniVideoColorNormal;
            hoverTimeElem.textContent = ' [ ' + tf.js.ConvertToHHMMSSBrief(miniVideoPos) + ' ]';
            posSlideObj.SetMouseFillColor(miniVideoColorNormal);
            positionMiniVideo();
        }
    }
    function createMiniVideo() {
        if (!onTouchDevice) {
            miniVideo = document.createElement('video');
            miniVideo.style.display = 'none';
            miniVideo.style.position = 'absolute';
            miniVideo.style.border = miniVideoBorderCaughtUp;
            miniVideo.style.zIndex = 2;
            miniVideo.style.backgroundColor = backgroundColor;
            miniVideo.poster = backgroundImg;
            tf.events.AddDOMEventListener(miniVideo, "timeupdate", onMiniVideoTimeUpdate);
        }
    }
    function onEndedVideo() { if (autoRepeat) { isStopped = false; setSlidePos01(0); changeVideoPosFromSlide(); videoElem.play(); } else { onStop(); } }
    function createVideoElem() {
        videoElem = document.createElement('video');
        videoElem.style.backgroundColor = backgroundColor;
        videoElem.poster = backgroundImg;
        videoElem.style.position = 'relative';
        videoElem.autoplay = false;
        var listeners = { "loadedmetadata": onLoadedMetadata, "timeupdate": onTimeUpdate, "ended": onEndedVideo };
        for (var i in listeners) { tf.events.AddDOMEventListener(videoElem, i, listeners[i]); }
    }
    function onVolChange(theVolControl, vol01) { if (theVolControl === volControlObj) { videoElem.volume = vol01; } }
    function createVolControl(vol01, lightBool, buttonDim) { volControlObj = new tf.ui.VolumeControl(lightBool, buttonDim, vol01, false, onVolChange); }
    function onToggleAutoRepeat() { autoRepeat = !autoRepeat; }
    function createToolBar() {
        var vol01 = 0.5;
        toolBarObj = new tf.dom.Div({ cssClass: styles.paddedBlockDivClass });
        toolBarElem = toolBarObj.GetHTMLElement();
        toolBarElem.style.textAlign = 'left';
        autoRepeatButtonObj = new tf.ui.SvgGlyphToggleBtn({
            style: lightBool, onClick: onToggleAutoRepeat, dim: buttonDim, isToggled: !autoRepeat,
            glyph: tf.styles.SvgGlyphAutoRepeatName, tooltip: "Auto-repeat", toggledGlyph: tf.styles.SvgGlyphNoAutoRepeatName, toggledTooltip: "Auto-repeat"
        });
        createVolControl(vol01, lightBool, buttonDim);
        toolBarObj.AddContent(playPauseButtonObj = new tf.ui.SvgGlyphToggleBtn({
            style: lightBool, onClick: onPlay, dim: buttonDim, isToggled: false,
            glyph: tf.styles.SvgGlyphPauseName, tooltip: "Pause", toggledGlyph: tf.styles.SvgGlyphPlayName, toggledTooltip: "Play"
        }));
        toolBarObj.AddContent(stopButtonObj =
            new tf.ui.SvgGlyphBtn({ style: lightBool, glyph: tf.styles.SvgGlyphStopName, onClick: onStop, toolitp: "Stop", dim: buttonDim }));
        toolBarObj.AddContent(autoRepeatButtonObj);
        toolBarObj.AddContent(volControlObj);
        currentTimeElem = document.createElement('span');
        toolBarObj.AddContent(currentTimeElem);
        var slashElem = document.createElement('span');
        slashElem.textContent = " / ";
        toolBarObj.AddContent(slashElem);
        totalTimeElem = document.createElement('span');
        toolBarObj.AddContent(totalTimeElem);
        hoverTimeElem = document.createElement('span');
        hoverTimeElem.style.display = 'none';
        toolBarObj.AddContent(hoverTimeElem);
    }
    function addToolBarButton(toolBarButtonObj) {
        var toolBarButtonElem = tf.dom.GetHTMLElementFrom(toolBarButtonObj);
        if (toolBarButtonElem) {
            var divObj = new tf.dom.Div({ cssClass: styles.unPaddedBlockDivClass });
            var divElem = divObj.GetHTMLElement();
            divElem.style["float"] = "right";
            divElem.style.display = 'inline-block';
            divObj.AddContent(toolBarButtonObj);
            toolBarObj.AddContent(divObj);
        }
    }
    function createPosSlide() {
        posSlideObj = new tf.ui.CanvasSlider(0, undefined, true);
        posSlideElem = posSlideObj.GetHTMLElement();
        posSlideObj.SetOnClickListener(onClickVideoSlide, theThis);
        posSlideObj.SetOnHoverListener(onHoverOverSlide, theThis);
        posSlideObj.SetOnMouseMoveListener(onMouseMoveOverSlide, theThis);
    }
    function createPopup() {
        popup = new tf.ui.Popup({
            container: container, titleStr: "Video", marginHor: 8, marginVer: 8, maxHeight: "50%", maxWidth: "100%", horPos: "right", verPos: "bottom",
            fontSize: tf.GetStyles().GetSubStyles().locationPopupContentFontSizeEmNumber + "em", textAlign: "right"
        });
        divPopupTitle = popup.GetTitleContainer();
        popup.SetTitleToolTip("Video");
        popup.SetOnClose(myOnCloseCallBack, theThis);
    }
    function createAllContent() {
        videoAllContentObj = new tf.dom.Div({ cssClass: styles.unPaddedBlockDivClass });
        styles.ApplyPositionRelativeStyle(videoAllContentObj);
        videoAllContentElem = videoAllContentObj.GetHTMLElement();
    }
    function addContent(elem) { if (tf.dom.GetHTMLElementFrom(elem)) { addedContents.push(elem); videoAllContentObj.AddContent(elem); } }
    function initialize() {
        styles = tf.GetStyles();
        subStyles = styles.GetSubStyles();
        onTouchDevice = tf.browser.HasTouch();
        hasVideo = false;
        wPadding = 24;
        widthWindowRatio = 0.8;
        heightWindowRatio = 0.3;
        //heightWindowRatio = 0.6;
        videoRatio = 16 / 9;
        defaultBackgroundColor = "#000";
        backgroundColor = !!backgroundColorSet ? backgroundColorSet : defaultBackgroundColor;
        backgroundImg = !!backgroundImgSet ? backgroundImgSet : tf.platform.GetPoweredByTerraFlyLogoImgStr();
        videoPos = 0;
        isStopped = false;
        autoRepeat = true;
        miniVideoBorderDim = 2;
        miniVideoColorNormal = subStyles.darkTextColor;
        miniVideoColorLate = subStyles.disabledTextColor;
        //miniVideoColorLate = "#f68";
        miniVideoBorderCaughtUp = miniVideoBorderDim + "px solid " + miniVideoColorNormal;
        miniVideoBorderLate = miniVideoBorderDim + "px solid " + miniVideoColorLate;
        minivideoShowing = false;
        videoW = 0;
        videoH = 0;
        addedContents = [];
        lightBool = false;
        buttonDim = "2em";
        divContainerElem = tf.dom.GetHTMLElementFrom(container);
        createPopup();
        createAllContent();
        createVideoElem();
        createMiniVideo();
        createPosSlide();
        createToolBar();
        if (miniVideo) { videoAllContentObj.AddContent(miniVideo); }
        videoAllContentObj.AddContent(videoElem);
        videoAllContentObj.AddContent(posSlideObj);
        videoAllContentObj.AddContent(toolBarObj);
        setContent(videoAllContentObj);
        resizeElems();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * class tf.ui.VideoTrackPlayer - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} tMap - parameter description?
 * @param {?} backgroundColorSet - parameter description?
 * @param {?} backgroundImgSet - parameter description?
 * @param {?} onCloseCallBack - parameter description?
 * @param {?} onCloseCallBackThis - parameter description?
*/
tf.ui.VideoTrackPlayer = function (tMap, backgroundColorSet, backgroundImgSet, onCloseCallBack, onCloseCallBackThis) {
    var theThis, debug, styles, onTouchDevice;
    var iconScale, zIndexStartMapFeature, zIndexendMapFeature, zIndexPoly, zIndexPolyDash, zIndexcurPosMapFeature, zIndexHoverMarker;
    var polyColor, polyLineWidth, dashLineColor, dashLineWidth, dashStyle;
    var mapRollOverListener, mapResizedListener;
    var tLayer, startMapFeature, endMapFeature, curPosMapFeature, hoverPosMapFeature, tPoly, tPolyDash, hoverPosMapFeatureVisible;
    var videoPopup, trackingOnMap, rotatingMap, isPlaying;
    var dLayersOpacityBeforePlay, usingGeocodingBeforePlay, hadAddressBarBeforePlay, showingAddressBeforePlay, rotationBeforePlay;
    var lastPathTitle, lastSpeedAltIndex, lastSpeed, lastAlt, lastVideoIndexPath, lastVideoTime01, lastTimePlay, lastHoverPlayTime01,
        lastHoverPlayIndex, lastHoverRotation, lastPlayMarkerRotation, lastIsShowingMiniVideo;
    var path, directions, times, pathLength, minMaxSpeedAlt, speedConversion, speedUnit, altConversion, altUnit;
    var time01Next, timeNext, videoPopupLightButton, showingSpeed, speedButton, altButton;
    var speedAltCanvasObj, speedAltCanvasElem, speedAltMouseListener, isHoveringOverSpeedAlt, altSpeedHover01, graphBar;
/**
 * method tf.ui.VideoTrackPlayer.Show - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} bool - parameter description?
*/
    this.Show = function (bool) { if (videoPopup) { videoPopup.Show(bool); theThis.OnContainerResize();} }
/**
 * method tf.ui.VideoTrackPlayer.IsShowing - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.IsShowing = function () { return videoPopup ? videoPopup.IsShowing() : false; }
/**
 * method tf.ui.VideoTrackPlayer.Toggle - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.Toggle = function () { theThis.Show(!theThis.IsShowing()); }
/**
 * method tf.ui.VideoTrackPlayer.OnContainerResize - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.OnContainerResize = function () { return onContainerResize(); }
/**
 * method tf.ui.VideoTrackPlayer.Play - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} videoURL - parameter description?
 * @param {?} pathGeometry - parameter description?
 * @param {?} path - parameter description?
 * @param {?} directions - parameter description?
 * @param {?} times - parameter description?
 * @param {?} timeStart - parameter description?
 * @param {?} speedConversion - parameter description?
 * @param {?} speedUnit - parameter description?
 * @param {?} altConversion - parameter description?
 * @param {?} altUnit - parameter description?
*/
    this.Play = function (videoURL, pathGeometry, path, directions, times, timeStart, speedConversion, speedUnit, altConversion, altUnit) {
        return play(videoURL, path, directions, times, timeStart, speedConversion, speedUnit, altConversion, altUnit);
    }
/**
 * method tf.ui.VideoTrackPlayer.Stop - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.Stop = function () { return stop(); }
/**
 * method tf.ui.VideoTrackPlayer.OnDelete - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.OnDelete = function () { return onDelete(); }
/**
 * method tf.ui.VideoTrackPlayer.GetIsPlaying - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetIsPlaying = function () { return isPlaying; }
    function onContainerResize() {
        videoPopup.OnContainerResize();
        speedAltCanvasObj.Repaint();
    }
    function onDelete() {
        if (mapRollOverListener) { mapRollOverListener.OnDelete(); mapRollOverListener = null; }
        if (mapResizedListener) { mapResizedListener.OnDelete(); mapResizedListener = null; }
        if (tLayer) {
            tMap.RemoveLayer(tLayer); tLayer = null;
            startMapFeature = endMapFeature = curPosMapFeature = hoverPosMapFeature = tPoly = tPolyDash = null;
            hoverPosMapFeatureVisible = false;
        }
    }
    function stop() { return onStopPlayVideo(false); }
    function saveStateBeforePlay() {
        usingGeocodingBeforePlay = tMap.IsPanelShowing(tf.consts.panelNameMapLocation);
        hadAddressBarBeforePlay = tMap.IsPanelShowing(tf.consts.paramNameAddress);
        showingAddressBeforePlay = tMap.IsShowingAddressBar();
        rotationBeforePlay = tMap.GetRotationRad();
        tMap.ShowPanel(tf.consts.paramNameAddress, false);
        tMap.ShowPanel(tf.consts.panelNameMapLocation, false);
    }
    function restoreStateAfterPlay() {
        if (usingGeocodingBeforePlay) { tMap.ShowPanel(tf.consts.panelNameMapLocation, true); }
        if (hadAddressBarBeforePlay) { tMap.ShowPanel(tf.consts.paramNameAddress, true); }
        tMap.SetRotationRad(rotationBeforePlay);
        if (videoPopup.IsShowing()) { videoPopup.Show(false); }
    }
    function resetLasts() {
        lastPathTitle = ''; lastSpeedAltIndex = 0; lastSpeed = 0; lastAlt = 0; lastVideoIndexPath = 0; lastVideoTime01 = 0; lastTimePlay = -1;
        lastHoverPlayTime01 = 0; lastHoverPlayIndex = 0; lastHoverRotation = lastPlayMarkerRotation = 0;
        path = null, directions = null, times = null, pathLength = 0;
        minMaxSpeedAlt = null;
        lastIsShowingMiniVideo = false;
    }
    function onStopPlayVideo(willPlayAnotherBool) {
        if (isPlaying) {
            tLayer.SetVisible(false);
            videoPopup.Stop();
            resetLasts();
            if (!willPlayAnotherBool) {
                restoreStateAfterPlay();
                isPlaying = false;
                if (typeof onCloseCallBack === "function") {
                    onCloseCallBack.call(onCloseCallBackThis, theThis);
                }
            }
        }
    }
    function createPolyFromPath(layerUse, path) {
        var coords = tf.helpers.GetCoordinatesFromLatLonArray(path);
        var style = { line: true, fill: true, line_color: polyColor, line_width: 1, line_alpha: 100, fill_color: "#fff", fill_alpha: 50 };
        var feature = new tf.map.Feature({ geom: new tf.map.FeatureGeom({ type: "linestring", coordinates: coords }), style: style });
        layerUse.AddMapFeature(feature);
        return feature;
    }
    function makeTemporaryStr(str) { return '[' + str + ']'; }
    function makeSpeedStr(speedMPH, isTemporary) { var speedStr = (tf.js.GetFloatNumber(speedMPH, 0) * speedConversion).toFixed(0) + ' ' + speedUnit; return isTemporary ? makeTemporaryStr(speedStr) : speedStr; }
    function makeAltStr(altFeet, isTemporary) { var altStr = (tf.js.GetFloatNumber(altFeet, 0) * altConversion).toFixed(0) + ' ' + altUnit; return isTemporary ? makeTemporaryStr(altStr) : altStr; }
    function play(videoURL, pathSet, directionsSet, timesSet, timeStart, speedConversionSet, speedUnitSet, altConversionSet, altUnitSet) {
        var wasPlaying = isPlaying;
        if (wasPlaying) { onStopPlayVideo(true); } else { saveStateBeforePlay(); }
        path = pathSet; directions = directionsSet; times = timesSet;
        speedConversion = speedConversionSet;
        speedUnit = speedUnitSet ;
        altConversion = altConversionSet ;
        altUnit = altUnitSet;
        pathLength = path.length;
        minMaxSpeedAlt = tf.helpers.CalcMinMaxSpeedAlt(path);
        var pathItem0 = path[0], pathItemN = path[pathLength - 1];
        startMapFeature.SetPointCoords([pathItem0.lon, pathItem0.lat]);
        curPosMapFeature.SetPointCoords([pathItem0.lon, pathItem0.lat]);
        endMapFeature.SetPointCoords([pathItemN.lon, pathItemN.lat]);
        if (tPoly) { tLayer.DelMapFeature(tPoly); }
        if (tPolyDash) { tLayer.DelMapFeature(tPolyDash); }
        tPoly = createPolyFromPath(tLayer, path);
        tPolyDash = createPolyFromPath(tLayer, path);
        tPoly.ChangeStyle({ line_width: polyLineWidth, zindex: 1 });
        tPolyDash.ChangeStyle({ line_width: dashLineWidth, line_color: dashLineColor, line_dash: dashStyle, zindex: 2 });
        lastPathTitle = pathItem0.timestamp;
        videoPopup.ChangeTitle(lastPathTitle);
        videoPopup.SetVideoURL(videoURL);
        tLayer.SetVisible(true);
        onVideoSeekTo(timeStart);
        videoPopup.Show(true);
        if (showingSpeed) { onShowSpeedGraph(); } else { onShowAltGraph(); }
        speedAltCanvasObj.Repaint();
        isPlaying = true;
    }
    var asyncTime01, asyncTime;
    function onVideoTimeUpdate(videoPlayer, time01, time) {
        var nSecsTime = Math.floor(time);
        asyncTime01 = time01;
        asyncTime = time;
        if (lastTimePlay != nSecsTime) {
            time01Next = time01;
            timeNext = time;
            setTimeout(asyncTimeUpdate, 50);
        }
    }
    function asyncTimeUpdate() {
        var time01 = time01Next; var time = timeNext;
        var playTime = getPathIndexFromTime01(time01, time);
        var indexPath = playTime.indexPath;
        var hasGPS = playTime.hasGPS;
        var nSecsTime = Math.floor(time);
        if (lastTimePlay != nSecsTime) {
            //tf.GetDebug().LogIfTest("TimeUpdate");
            lastTimePlay = nSecsTime;
            lastVideoTime01 = time01;
            lastVideoIndexPath = indexPath;
            var hoverVisible = hoverPosMapFeatureVisible;
            if (indexPath < pathLength) {
                var pathItem = path[indexPath];
                lastPlayMarkerRotation = getMapRotation(indexPath, lastPlayMarkerRotation);
                curPosMapFeature.SetPointCoords([pathItem.lon, pathItem.lat]);
                if (trackingOnMap) { tMap.SetCenter([pathItem.lon, pathItem.lat]); }
                lastPathTitle = pathItem.timestamp;
                if (!hasGPS) { lastPathTitle += ' [ no GPS data ]' }
                if (!(hoverVisible || videoPopup.GetIsMiniVideoShowing())) {
                    videoPopup.ChangeTitle(lastPathTitle);
                    updateSpeedAlt(indexPath, pathItem.speed, pathItem.altitude, false);
                }
                if (rotatingMap) {
                    tMap.SetRotationRad(lastPlayMarkerRotation);
                    curPosMapFeature.ChangeStyle({ rotation_rad: 0 });
                }
                else {
                    tMap.SetRotationRad(0);
                    curPosMapFeature.ChangeStyle({ rotation_rad: -lastPlayMarkerRotation });
                }
            }
            if (hoverVisible) { updateHoverPreview(lastHoverPlayTime01, lastHoverPlayIndex); }
            else { speedAltCanvasObj.Repaint(); }
        }
    }
    function getPathIndexFromTime01(time01, time) {
        var pathIndex = { indexPath: 0, hasGPS: false };
        if (pathLength > 0) {
            if (!!times) {
                var nTimes = times.length;
                if (nTimes > 0) {
                    if (time01 < 0) { time01 = 0; } else if (time01 > 1) { time01 = 1; }
                    var indexTimes = Math.floor(nTimes * time01);
                    //var indexTimes = Math.floor((nTimes - 1) * time01);
                    pathIndex = times[indexTimes];
                }
            }
        }
        return pathIndex;
    }
    function onMiniVideoChange(videoPlayer, isShowingMiniVideo, pos01) {
        var index = -1;
        if (isShowingMiniVideo != lastIsShowingMiniVideo) {
            if (lastIsShowingMiniVideo = isShowingMiniVideo) {
                if (pathLength > 0) {
                    index = getPathIndexFromTime01(pos01).indexPath;
                    var pathItem = path[index];
                    startHoverPreview(pos01, index, false);
                }
            }
            else { stopHoverPreview(false); }
        }
        if (isShowingMiniVideo) { if (index == -1) { index = getPathIndexFromTime01(pos01).indexPath; } updateHoverPreview(pos01, index, false); }
        else { updateLastSpeedAlt(false); }
    }
    function onToggleTrack() { trackingOnMap = !trackingOnMap; }
    function onToggleRotate() { rotatingMap = !rotatingMap; }
    function updateButtonLightDark() {
        speedButton.SetStyle(videoPopupLightButton ? !showingSpeed : showingSpeed);
        altButton.SetStyle(videoPopupLightButton ? showingSpeed : !showingSpeed);
        speedAltCanvasObj.Repaint();
    }
    function onShowSpeedGraph() { graphBar.SetData(path, "speed", minMaxSpeedAlt.minSpeed, minMaxSpeedAlt.maxSpeed); showingSpeed = true; updateButtonLightDark(); }
    function onShowAltGraph() { graphBar.SetData(path, "altitude", minMaxSpeedAlt.minAlt, minMaxSpeedAlt.maxAlt); showingSpeed = false; updateButtonLightDark(); }
    
    function onMouseAtSpeedAlt(notification) {
        var isHovering = notification.isInHover;
        if (isHovering != isHoveringOverSpeedAlt) { isHoveringOverSpeedAlt = isHovering; speedAltCanvasObj.Repaint(); }
        var width = speedAltCanvasElem.offsetWidth;
        altSpeedHover01 = graphBar.GetTime01FromGraphCol(notification.mouseCoords[0]);
        var pathIndex = getPathIndexFromTime01(altSpeedHover01).indexPath;
        //tf.GetDebug().LogIfTest(notification.eventName);
        switch (notification.eventName) {
            case "mouseout":
                stopHoverPreview(true);
                break;
            case 'mousedown':
                tf.GetDocMouseListener().SetCapture(onMouseAtSpeedAlt, theThis, null);
                if (hoverPosMapFeatureVisible) { stopHoverPreview(true); }
                onVideoSeekTo(altSpeedHover01);
                break;
            case 'mouseup':
                tf.GetDocMouseListener().ReleaseCapture();
                break;
            case 'mousemove':
                if (!onTouchDevice) {
                    if (notification.isInDrag) {
                        if (hoverPosMapFeatureVisible) { stopHoverPreview(true); }
                        onVideoSeekTo(altSpeedHover01);
                    }
                    else {
                        if (!hoverPosMapFeatureVisible) { startHoverPreview(altSpeedHover01, pathIndex, true); }
                        else { updateHoverPreview(altSpeedHover01, pathIndex, true); }
                    }
                }
                break;
        }
    }
    function createVideoPopup() {
        videoPopup = new tf.ui.VideoPopup(tMap.GetMapMapContainer(), backgroundColorSet, backgroundImgSet);
        videoPopup.SetZIndex(1000);
        videoPopup.SetOnClose(onStopPlayVideo, theThis);
        videoPopup.SetOnTimeUpdate(onVideoTimeUpdate, theThis);
        videoPopup.SetOnMiniVideoChangeCallBack(onMiniVideoChange, theThis);
        videoPopupLightButton = videoPopup.GetIsButtonLight();
        var buttonDim = videoPopup.GetToolBarButtonDim();
        var glyphLib = tf.ui.GetSvgGlyphLib();
        videoPopup.AddToolBarButton(
            new tf.ui.SvgGlyphToggleBtn({
                style: videoPopupLightButton, onClick: onToggleRotate, dim: buttonDim, isToggled: !rotatingMap,
                glyph: tf.styles.SvgGlyphNoCompassName, tooltip: "Stop auto heading", toggledGlyph: tf.styles.SvgGlyphCompassName, toggledTooltip: "Auto heading"
            }));
        videoPopup.AddToolBarButton(
            new tf.ui.SvgGlyphToggleBtn({
                style: videoPopupLightButton, onClick: onToggleTrack, dim: buttonDim, isToggled: !trackingOnMap,
                glyph: tf.styles.SvgGlyphNoTargetName, tooltip: "Stop auto positioning", toggledGlyph: tf.styles.SvgGlyphTargetName, toggledTooltip: "Auto positioning"
            }));
        speedButton = new tf.ui.TextBtn({ style: videoPopupLightButton ? !showingSpeed : showingSpeed, label: "", onClick: onShowSpeedGraph, tooltip: "current speed", dim: buttonDim });
        altButton = new tf.ui.TextBtn({ style: videoPopupLightButton ? showingSpeed : !showingSpeed, label: "", onClick: onShowAltGraph, tooltip: "current altitude", dim: buttonDim });
        var minWidthSpeedAltButtons = "1em";
        var speedButtonElem = speedButton.GetHTMLElement(); speedButtonElem.style.minWidth = minWidthSpeedAltButtons;
        var altButtonElem = altButton.GetHTMLElement(); altButtonElem.style.minWidth = minWidthSpeedAltButtons;
        videoPopup.AddToolBarButton(styles.AddButtonDivTopBottMargins(styles.AddButtonDivRightMargin(altButton)));
        videoPopup.AddToolBarButton(styles.AddButtonDivTopBottMargins(styles.AddButtonDivLeftRightMargins(speedButton)));
        graphBar = new tf.canvas.GraphBar();
        speedAltCanvasObj = new tf.dom.Canvas();
        speedAltCanvasObj.SetRepaint(graphBar.GetRepaintFunction(), theThis);
        speedAltCanvasElem = speedAltCanvasObj.GetHTMLElement();
        speedAltMouseListener = new tf.events.DOMMouseListener({ target: speedAltCanvasElem, callBack: onMouseAtSpeedAlt, optionalScope: theThis, callBackSettings: undefined });
        speedAltCanvasElem.style.width = "1px";
        speedAltCanvasElem.style.height = "16px";
        videoPopup.AddContent(speedAltCanvasObj);
    }
    function onVideoSeekTo(pos01) { videoPopup.SetPos01(pos01); }
    function getMapRotation(pathIndex, lastRotation) { return (directions && pathIndex >= 0 && pathIndex < pathLength) ? directions[pathIndex] - (Math.PI / 2): lastRotation; }
    function onClickFeature(notification) {
        var mapFeature = notification.mapFeature;
        if (!!mapFeature) {
            if (mapFeature == tPoly || mapFeature == tPolyDash) {
                var hitTest = tf.helpers.HitTestRoute(path, times, notification.eventCoords[1], notification.eventCoords[0]); onVideoSeekTo(hitTest.time01);
            }
            else if (mapFeature == startMapFeature) { }
            else if (mapFeature == endMapFeature) { }
            else if (mapFeature == curPosMapFeature) { }
            else if (mapFeature == hoverPosMapFeature) {
                onVideoSeekTo(lastHoverPlayTime01);
                tLayer.DelMapFeature(hoverPosMapFeature);
                hoverPosMapFeatureVisible = false;
                videoPopup.ShowMiniVideo(false, 0);
            }
        }
    }
    function onRollOverRoute(coords) {
        var hitTest = tf.helpers.HitTestRoute(path, times, coords[1], coords[0]);
        debugOut('rolling over route');
        if (!hoverPosMapFeatureVisible) { startHoverPreview(hitTest.time01, hitTest.index, true); }
        else { updateHoverPreview(hitTest.time01, hitTest.index, true); }
    }
    function onMouseMoveFeature(notification) {
        var mapFeature = notification.mapFeature;
        if (!!mapFeature) {
            if (mapFeature == tPoly || mapFeature == tPolyDash) {
                onRollOverRoute(notification.eventCoords);
            }
        }
    }
    function startHoverPreview(hover01, indexPath, activateMiniVideoBool) {
        var pathItem = path[indexPath];
        lastHoverPlayTime01 = hover01;
        lastHoverPlayIndex = indexPath;
        lastHoverRotation = getMapRotation(indexPath, 0);
        hoverPosMapFeature.SetPointCoords([pathItem.lon, pathItem.lat]);
        hoverPosMapFeature.ChangeStyle({ rotation_rad: tMap.GetRotationRad() - lastHoverRotation });
        tLayer.AddMapFeature(hoverPosMapFeature);
        hoverPosMapFeatureVisible = true;
        if (activateMiniVideoBool) { videoPopup.ShowMiniVideo(true, hover01); }
        videoPopup.ChangeTitle(makeTemporaryStr(pathItem.timestamp));
        updateSpeedAltFromItem(indexPath, pathItem, true);
        speedAltCanvasObj.Repaint();
    }
    function updateHoverPreview(hover01, pathIndex, updateMiniVideoBool) {
        if (hoverPosMapFeatureVisible) {
            lastHoverPlayTime01 = hover01;
            lastHoverPlayIndex = pathIndex;
            if (!!path) {
                var pathItem = path[pathIndex];
                if (pathItem) {
                    hoverPosMapFeature.SetPointCoords([pathItem.lon, pathItem.lat]);
                    videoPopup.ChangeTitle(makeTemporaryStr(pathItem.timestamp)); updateSpeedAltFromItem(pathIndex, pathItem, true);
                }
            }
            if (updateMiniVideoBool) { videoPopup.ShowMiniVideo(true, hover01); }
            lastHoverRotation = getMapRotation(pathIndex, lastHoverRotation);
            hoverPosMapFeature.ChangeStyle({ rotation_rad: tMap.GetRotationRad() - lastHoverRotation });
            speedAltCanvasObj.Repaint();
        }
    }
    function stopHoverPreview(deactivateMiniVideoBool) {
        if (hoverPosMapFeatureVisible) {
            tLayer.DelMapFeature(hoverPosMapFeature);
            hoverPosMapFeatureVisible = false;
        }
        if (!!deactivateMiniVideoBool) { videoPopup.ShowMiniVideo(false, 0); }
        videoPopup.ChangeTitle(lastPathTitle);
        if (path) {
            var lastPathItem = path[lastVideoIndexPath];
            if (lastPathItem) { updateSpeedAltFromItem(lastVideoIndexPath, lastPathItem, false); }
        }
        speedAltCanvasObj.Repaint();
    }
    function debugOut() { if (!!debug) { debug.LogIfTest.apply(null, arguments); } }
    function onRollOverMap(notification) {
        debugOut('rolling over map');
        if (notification.sender == tMap) { stopHoverPreview(true); }
    }
    function updateSpeedAltFromItem(indexPath, pathItem, isTemporaryBool) {
        return updateSpeedAlt(indexPath, pathItem.speed, pathItem.altitude, isTemporaryBool);
    }
    function updateLastSpeedAlt(isTemporaryBool) { updateSpeedAlt(lastSpeedAltIndex, lastSpeed, lastAlt, isTemporaryBool); }
    function updateSpeedAlt(indexPath, speedMPH, altFeet, isTemporary) {
        speedMPH = tf.js.GetFloatNumber(speedMPH, 0);
        altFeet = tf.js.GetFloatNumber(altFeet, 0);
        lastSpeedAltIndex = indexPath;
        lastSpeed = speedMPH;
        lastAlt = altFeet;
        var speedStr = makeSpeedStr(speedMPH, isTemporary), altStr = makeAltStr(altFeet, isTemporary);
        speedButton.SetText(speedStr);
        altButton.SetText(altStr);
        graphBar.SetCurIndex(lastVideoIndexPath);
        graphBar.SetIsInHover(isTemporary);
        if (isTemporary) { graphBar.SetHoverIndex(indexPath); } 
    }
    function onPreCompose(notification) {
        //asyncTime, asyncTime01
        if (asyncTime01 !== undefined) {
            var playTime = getPathIndexFromTime01(asyncTime01, asyncTime);
            var indexPath = playTime.indexPath;
            if (indexPath < pathLength) {
                var pathItem = path[indexPath], pointCoords;
                if (indexPath < pathLength - 1) {
                    var nextPathItem = path[indexPath + 1];
                    var timeInPathSeg = (asyncTime - Math.floor(asyncTime));
                    //tf.GetDebug().LogIfTest(asyncTime01 + ' ' + asyncTime + ' ' + indexPath + ' ' + timeInPathSeg);
                    pointCoords = [
                        pathItem.lon + (nextPathItem.lon - pathItem.lon) * timeInPathSeg,
                        pathItem.lat + (nextPathItem.lat - pathItem.lat) * timeInPathSeg
                    ];
                }
                else {
                    pointCoords = [pathItem.lon, pathItem.lat];
                }
                //lastPlayMarkerRotation = getMapRotation(indexPath, lastPlayMarkerRotation);
                curPosMapFeature.SetPointCoords(pointCoords);
                //if (trackingOnMap) { tMap.SetCenter(pointCoords); }
                if (rotatingMap) {
                    //tMap.SetRotationRad(lastPlayMarkerRotation);
                    curPosMapFeature.ChangeStyle({ rotation_rad: 0 });
                }
                else {
                    tMap.SetRotationRad(0);
                    curPosMapFeature.ChangeStyle({ rotation_rad: -lastPlayMarkerRotation });
                }
            }
            notification.continueAnimation();
        }
    }
    function createMapObjects() {
        var zIndex = 0;
        zIndexStartMapFeature = zIndex++; zIndexendMapFeature = zIndex++; zIndexPoly = zIndex++; zIndexPolyDash = zIndex++; zIndexcurPosMapFeature = zIndex++; zIndexHoverMarker = zIndex++;
        var startEndAlphaStyle = 50;
        var startEndStyle = { marker: true, marker_color: "#07375f", font_height: 20, font_color: "#FFFFFF", border_color: "#a4a4a4", marker_alpha: startEndAlphaStyle };
        var directionFileName = tf.platform.MakePlatformPath("image/direction.png");
        var curPosMapFeatureStyle = { border_alpha: 0, border_width: 0, scale: iconScale, zindex: zIndexcurPosMapFeature, icon: true, icon_url: directionFileName };
        var hoverPosMapFeatureStyle = { border_alpha: 0, border_width: 0, scale: (iconScale * 0.8), zindex: zIndexHoverMarker, icon: true, icon_url: directionFileName };
        tMap.ShowMapCenter(false);
        tLayer = tMap.AddFeatureLayer({ isHidden: true, isVisible: false, zIndex: 1000 });
        tLayer.AddMapFeature(startMapFeature = new tf.map.Feature({ type: "point", coordinates: [0, 0], style: tf.js.ShallowMerge(startEndStyle, { label: "Start", zindex: zIndexStartMapFeature }) }));
        tLayer.AddMapFeature(endMapFeature = new tf.map.Feature({ type: "point", coordinates: [0, 0], style: tf.js.ShallowMerge(startEndStyle, { label: "End", zindex: zIndexendMapFeature }) }));
        tLayer.AddMapFeature(curPosMapFeature = new tf.map.Feature({ type: "point", coordinates: [0, 0], style: curPosMapFeatureStyle }));
        hoverPosMapFeature = new tf.map.Feature({ type: "point", coordinates: [0, 0], style: hoverPosMapFeatureStyle });
        hoverPosMapFeatureVisible = false;
        tMap.AddListener(tf.consts.mapFeatureClickEvent, onClickFeature);
        tMap.AddListener(tf.consts.mapFeatureMouseMoveEvent, onMouseMoveFeature);
        mapRollOverListener = tMap.AddListener(tf.consts.mapMouseMoveEvent, onRollOverMap);
        mapResizedListener = tMap.AddListener(tf.consts.mapResizedEvent, onContainerResize);
        //tMap.AddListener(tf.consts.mapPreComposeEvent, onPreCompose);
    }
    function initialize() {
        //debug = tf.GetDebug();
        styles = tf.GetStyles();
        iconScale = 0.08;
        onTouchDevice = tf.browser.HasTouch();
        polyColor = "#FF2222"; polyLineWidth = 8; dashLineColor = "#000"; dashLineWidth = 1; dashStyle = [12, 6];
        hoverPosMapFeatureVisible = false;
        trackingOnMap = true;
        rotatingMap = true;
        showingSpeed = true;
        speedConversion = 1;
        altConversion = 1;
        dLayersOpacityBeforePlay = 1;
        lastIsShowingMiniVideo = isPlaying = isHoveringOverSpeedAlt = usingGeocodingBeforePlay = hadAddressBarBeforePlay = showingAddressBeforePlay = videoPopupLightButton = false;
        lastPathTitle = '';
        speedUnit = '';
        altUnit = '';
        rotationBeforePlay = time01Next = timeNext = zIndexStartMapFeature = zIndexendMapFeature = zIndexPoly = zIndexPolyDash = zIndexcurPosMapFeature = zIndexHoverMarker = pathLength = altSpeedHover01 =
            lastHoverPlayIndex = lastHoverRotation = lastPlayMarkerRotation = lastHoverPlayTime01 = lastSpeedAltIndex = lastSpeed = lastAlt = lastVideoIndexPath = lastVideoTime01 = 0;
        lastTimePlay = -1;
        createVideoPopup();
        createMapObjects();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * class tf.canvas.GraphBar - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
*/
tf.canvas.GraphBar = function () {
    var values, attributeName, minValue, maxValue, deltaValues, nValues;
    var isInHover = false, curIndex = undefined, hoverIndex = undefined;
/**
 * method tf.canvas.GraphBar.GetTime01FromGraphCol - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} graphCol - parameter description?
*/
    this.GetTime01FromGraphCol = function (graphCol) { return tf.js.NumberClip ((graphCol - graphLeft) / graphWidth, 0, 1); }
/**
 * method tf.canvas.GraphBar.GetRepaintFunction - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetRepaintFunction = function () { return repaint; }
/**
 * method tf.canvas.GraphBar.SetData - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} valuesSet - parameter description?
 * @param {?} attributeNameSet - parameter description?
 * @param {?} minValueSet - parameter description?
 * @param {?} maxValueSet - parameter description?
*/
    this.SetData = function (valuesSet, attributeNameSet, minValueSet, maxValueSet) {
        values = valuesSet;
        attributeName = attributeNameSet;
        minValue = minValueSet;
        maxValue = maxValueSet;
        nValues = values.length;
        deltaValues = maxValue - minValue;
    }
/**
 * method tf.canvas.GraphBar.SetIsInHover - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} bool - parameter description?
*/
    this.SetIsInHover = function (bool) { isInHover = !!bool; }
/**
 * method tf.canvas.GraphBar.GetIsInHover - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetIsInHover = function () { return isInHover; }
/**
 * method tf.canvas.GraphBar.SetCurIndex - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} curIndexSet - parameter description?
*/
    this.SetCurIndex = function (curIndexSet) { curIndex = curIndexSet; }
/**
 * method tf.canvas.GraphBar.SetHoverIndex - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} hoverIndexSet - parameter description?
*/
    this.SetHoverIndex = function (hoverIndexSet) { hoverIndex = hoverIndexSet; }
    var theThis = null;
    var styles = tf.GetStyles();
    var subStyles = styles.GetSubStyles();
    var graphLineW = 2;
    var graphLineHalfW = graphLineW / 2;
    var graphRadiusCur = 3;
    var graphDiameterCur = 2 * graphRadiusCur;
    var graphPixW, graphPixH, graphTop, graphBot, graphHeight, graphLeft, graphRight, graphWidth;
    function calcDims(pixWidth, pixHeight) {
        graphPixW = pixWidth;
        graphPixH = pixHeight;
        graphTop = graphRadiusCur + 1;
        graphBot = graphPixH - graphRadiusCur;
        graphHeight = graphBot - graphTop - 1;
        graphLeft = graphRadiusCur;
        graphRight = graphPixW - graphRadiusCur;
        graphWidth = graphRight - graphLeft - 1;
    }
    function paintIndexMarker(canvasCtx, lineColor, backGroundColor, curCol, curRow) {
        canvasCtx.strokeStyle = lineColor;
        canvasCtx.beginPath(); canvasCtx.moveTo(curCol, 1); canvasCtx.lineTo(curCol, graphPixH); canvasCtx.closePath(); canvasCtx.stroke();
        canvasCtx.fillStyle = backGroundColor;
        canvasCtx.beginPath(); tf.canvas.circle(canvasCtx, curCol - graphRadiusCur, curRow - graphRadiusCur, graphDiameterCur); canvasCtx.closePath(); canvasCtx.fill(); canvasCtx.stroke();
        canvasCtx.fillStyle = lineColor;
        canvasCtx.beginPath(); canvasCtx.fillRect(curCol - 0.5, curRow - 0.5, 1, 1); canvasCtx.closePath(); canvasCtx.stroke();
    }
    function getPixCol(index) { return nValues > 0 ? graphWidth / (nValues - 1) * index + graphLeft : 0; }
    function getPixRowForValue(value) {
        var thisDelta = value - minValue;
        var delta01 = thisDelta / deltaValues;
        var row = graphHeight * delta01;
        return graphPixH - (row + graphTop);
    }
    function getPixRowForIndex(index) {
        var middleRow = graphTop + graphHeight / 2;
        return deltaValues > 0 && index < nValues && nValues > 0 ? getPixRowForValue(values[index][attributeName]) : middleRow;
    }
    function paintIndex(canvasCtx, lineColor, backGroundColor, index) { paintIndexMarker(canvasCtx, lineColor, backGroundColor, getPixCol(index), getPixRowForIndex(index)); }
    function repaint(theCanvasObj, canvasCtx, pixWidth, pixHeight) {
        calcDims(pixWidth, pixHeight);
        var borderColor = subStyles.borderLightColor;
        var backGroundColor = styles.GetButtonBGColor(false);
        var lineColor = styles.GetButtonBGColor(true);
        if (isInHover) { var temp = lineColor; lineColor = backGroundColor; backGroundColor = temp; }
        canvasCtx.lineWidth = 1;
        canvasCtx.strokeStyle = borderColor;
        canvasCtx.fillStyle = backGroundColor;
        canvasCtx.imageSmoothingEnabled = false;
        //canvasCtx.imageSmoothingEnabled = true;
        //canvasCtx.translate(0.5, 0.5);
        canvasCtx.beginPath();
        canvasCtx.fillRect(0, 0, graphPixW, graphPixH);
        canvasCtx.strokeRect(0, 0, graphPixW, graphPixH);
        canvasCtx.closePath();
        canvasCtx.lineWidth = graphLineW;
        canvasCtx.strokeStyle = lineColor;
        canvasCtx.beginPath();
        var prev = nValues ? values[0] : null;
        var prevCol = graphLeft, prevRow = getPixRowForIndex(0);
        for (var i in values) {
            var cur = values[i], col = getPixCol(i), row = getPixRowForIndex(i);
            canvasCtx.moveTo(prevCol, prevRow); canvasCtx.lineTo(col, row);
            prevCol = col; prevRow = row; prev = cur;
        }
        canvasCtx.closePath();
        canvasCtx.stroke();
        if (curIndex !== undefined) { paintIndex(canvasCtx, lineColor, backGroundColor, curIndex); }
        if (isInHover && hoverIndex !== undefined) { paintIndex(canvasCtx, borderColor, backGroundColor, hoverIndex); }
        if (maxValue > 0 && minValue < 0) {
            var zeroRow = getPixRowForValue(0);
            canvasCtx.strokeStyle = "rgba(192, 0, 0, 0.5)"; canvasCtx.lineWidth = 0; canvasCtx.setLineDash([7, 14]);
            canvasCtx.beginPath(); canvasCtx.moveTo(graphLeft, zeroRow); canvasCtx.lineTo(graphRight, zeroRow); canvasCtx.closePath();
            canvasCtx.stroke();
        }
    }
    function initialize() { }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Settings used in the creation of [Popup]{@link tf.ui.Popup} instances
 * @public
 * @typedef {object} tf.types.popupSettings
 * @property {HTMLElementLike} container - Mandatory property, the container where the popup is located
 * @property {string} titleStr - Optional popup title, can be changed after creation
 * @property {HTMLElementSize} marginHor - optional horizontal margins (applies to both left and right), defaults to "0px"
 * @property {HTMLElementSize} marginVer - optional vertical margins (applies to both top and bottom), defaults to "0px"
 * @property {HTMLElementSize} maxWidth - optional maximum width, defaults to {@link void}
 * @property {HTMLElementSize} maxHeight - optional maximum height, defaults to {@link void}
 * @property {tf.types.horizontalPositioning} textAlign - Optional HTML text align for the popup container, including the location of the popup title
 * @property {tf.types.horizontalPositioning} horPos - optional horizontal positioning, defaults to {@link tf.consts.positioningCenter}
 * @property {tf.types.verticalPositioning} verPos - optional vertical positioning, defaults to {@link tf.consts.positioningCenter}
 * @property {HTMLElementLike} rectProvider - if defined, the left/top coordinates of the popup are matched to the left/top coordinates of this element
 * @property {colorWithOptionalAlpha} bkColor - optional background color used by the popup's content, default value depends on the current API style
 * @property {HTMLElementSize} fontSize - optional font size used by the popup's content, default value depends on the current API style
 * @property {boolean} noTitle - if set to <b>true</b> hides the popup's title, defaults to {@link void}
 * @property {number} zIndex - if defined, sets the zIndex of the popup. Defaults to 100
 */
/**
 * @public
 * @class
 * @summary Create instances of this class to display popups on any {@link HTMLElementLike} container, including the [TerraFly HTerraMap]{@link tf.map.Map} container
 * @param {tf.types.popupSettings} settings - creation settings
 */
tf.ui.Popup = function (settings) {
    var theThis, styles, subStyles, isVisible, updateButtonRect, rectProvider, exactLeftPxNumber, exactTopPxNumber;
    var theOnCloseThis, theOnCloseCallBack, captionObj;
    var popupObj, divPopupTitleObj, contentObj, container, popup, divPopupTitle, content, captionElem ;
    /**
     * @public
     * @function
     * @summary - Shows or hides the popup
     * @param {boolean} bool - <b>true</b> to show, <b>false</b> to hide
     * @returns {void} - | {@link void} no return value
    */
    this.Show = function (bool) { show(bool); }
    /**
     * @public
     * @function
     * @summary - Checks if the popup is visible
     * @returns {boolean} - | {@link boolean} <b>true</b> if visible, <b>false</b> otherwise
    */
    this.IsShowing = function () { return isShowing(); }
    /**
     * @public
     * @function
     * @summary - Toggles popup's visibility state
     * @returns {void} - | {@link void} no return value
    */
    this.Toggle = function () { toggle(); }
    /**
     * @public
     * @function
     * @summary - Sets the callBack for the popup's close button click event, the popup closes and the callback is notified
     * @param {function} callBack - the callBack function, the popup instance object is passed to it on notifications
     * @param {object} optionalScope - optional JavaScript scope used in the callBack
     * @returns {void} - | {@link void} no return value
    */
    this.SetOnClose = function (callBack, optionalScope) { theOnCloseThis = optionalScope; theOnCloseCallBack = tf.js.GetFunctionOrNull(callBack); }
    /**
     * @public
     * @function
     * @summary - Sets the callBack for the popup's title click event
     * @param {function} callBack - the callBack function, the popup instance object is passed to it on notifications
     * @param {object} optionalScope - optional JavaScript scope used in the callBack
     * @returns {void} - | {@link void} no return value
    */
    this.SetOnClickTitle = function (callBack, optionalScope) {
        if (divPopupTitle) {
            new tf.events.DOMClickListener({ target: captionObj, callBack: callBack, optionalScope: optionalScope, callBackSettings: undefined });
        }
    }
    /**
     * @public
     * @function
     * @summary - Retrieves the popup's title container
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the container
    */
    this.GetTitleContainer = function () { return divPopupTitle; }
    /**
     * @public
     * @function
     * @summary - Changes the popup's tile
     * @param {string} titleStr - the new title
     * @returns {void} - | {@link void} no return value
    */
    this.ChangeTitle = function (titleStr) { changeTitle(titleStr); }
    /**
     * @public
     * @function
     * @summary - Sets the tooltip text for the popup's tile
     * @param {string} toolTipStr - the tooltip
     * @returns {void} - | {@link void} no return value
    */
    this.SetTitleToolTip = function (toolTipStr) { typeof toolTipStr === "string" && !!divPopupTitle && (divPopupTitle.title = toolTipStr); }
    /**
     * @public
     * @function
     * @summary - Sets popup's zIndex
     * @param {number} zIndex - the zIndex
     * @returns {void} - | {@link void} no return value
    */
    this.SetZIndex = function (zIndex) { if (typeof zIndex == "number" && popup) { popup.style.zIndex = zIndex; } }
    /**
     * @public
     * @function
     * @summary - Gets popup's zIndex
     * @returns {number} - | {@link number} the zIndex
    */
    this.GetZIndex = function () { return popup ? popup.style.zIndex : 0; }
    /**
     * @public
     * @function
     * @summary - Notifies the popup that its container may have been resized
     * @returns {void} - | {@link void} no return value
    */
    this.OnContainerResize = function () { return onContainerResize(); }
    /**
     * @public
     * @function
     * @summary - Removes the popup's current content, if any
     * @returns {void} - | {@link void} no return value
    */
    this.ClearContent = function () { return clearContent(); }
    /**
     * @public
     * @function
     * @summary - Replaces the popup's content with new content
     * @param {HTMLContent} content - the new content
     * @returns {void} - | {@link void} no return value
    */
    this.SetContent = function (content) { if (contentObj) { if (tf.js.GetIsString(content)) { setHtmlContent(content); } else { setElemContent(content); } } }
    /**
     * @public
     * @function
     * @summary - Adds new content to the popup's existing content
     * @param {HTMLContent} content - the new content
     * @returns {void} - | {@link void} no return value
    */
    this.AddContent = function (content) { return addElemContent(content); }
    function clearContent() { if (contentObj) { contentObj.ClearContent(); }}
    function setHtmlContent (htmlContent) {
        clearContent();
        if (contentObj) { content.innerHTML = typeof htmlContent === "string" ? htmlContent : "&nbsp;"; }
        onContainerResize();
    }
    function setElemContent (elem) { clearContent(); addElemContent(elem); }
    function addElemContent(elem) {
        if (contentObj) {
            if (elem.AppendTo) { elem.AppendTo(content); } else if (elem = tf.dom.GetHTMLElementFrom(elem)) { content.appendChild(elem); } onContainerResize();
        }
    }
    function onClose() { if (theOnCloseCallBack) { theOnCloseCallBack.call(theOnCloseThis); } show(false); }
    function show(bool) {
        bool = !!bool;
        if (isVisible != bool) {
            if (bool) { checkUpdateButtonRect(); onContainerResize(true); }
            styles.ChangeOpacityVisibilityClass(popup, isVisible = bool);
            if (bool) { popup.focus(); }
        }
    }
    function isShowing() { return isVisible; }
    function toggle() { show(!isShowing()); }
    function changeTitle(titleStr) { if (captionElem) { if (typeof titleStr == "string") { captionElem.innerHTML = titleStr; } } }
    function createTitle() {
        var classNames = styles.GetPaddedDivClassNames(true, false);
        var closeButton = styles.CloseXButtonForPopup(false, onClose);
        captionObj = new tf.dom.Div({ cssClass: classNames });
        divPopupTitleObj = new tf.dom.Div({ cssClass: styles.popupCaptionClass });
        divPopupTitle = divPopupTitleObj.GetHTMLElement();
        captionElem = captionObj.GetHTMLElement();
        closeButton.AppendTo(divPopupTitleObj);
        divPopupTitleObj.AddContent(captionElem);
    }
    function onContainerResize(forceCheck) {
        var canDisplay = true;
        content.style.overflowX = "visible";
        content.style.overflowY = "visible";
        content.style.maxWidth = content.style.maxHeight = 'none';
        content.style.width = content.style.height = null;
        var popupRect = popup.getBoundingClientRect();
        var contentRect = content.getBoundingClientRect();
        if (contentRect.bottom > popupRect.bottom) {
            var contentHeight = content.clientHeight;
            var contentClientHeight = content.clientHeight;
            var contentBorderH = (contentHeight - contentClientHeight);
            var popupPaddingHeight = subStyles.popupContainerPaddingPxNumber;
            var maxBot = popupRect.bottom;
            var maxHeight = maxBot - contentRect.top - popupPaddingHeight - contentBorderH;
            content.style.height = maxHeight + "px";
        }
        content.style.overflowX = "auto";
        content.style.overflowY = "auto";
        return canDisplay;
    }
    function calcStyles() {
        var maxWidthStr, maxHeightStr;
        var padding = subStyles.popupContainerPaddingPxNumber, padding2 = 2 * padding;
        if (!!rectProvider) {
            var leftStr = "calc(" + exactLeftPxNumber + "px - " + padding + "px - " + settings.marginHor + ")";
            var topStr = "calc(" + exactTopPxNumber + "px - " + padding + "px - " + settings.marginVer + ")";
            popup.style.left = leftStr;
            popup.style.top = topStr;
            maxWidthStr = "calc(" + settings.maxWidth + " - " + padding2 + "px - " + settings.marginHor /*+ " - " + settings.marginHor*/ + " - " + exactLeftPxNumber + "px)";
            maxHeightStr = "calc(" + settings.maxHeight + " - " + padding2 + "px - " + settings.marginVer /*+ " - " + settings.marginVer*/ + " - " + exactTopPxNumber + "px)";
        }
        else {
            maxWidthStr = "calc(" + settings.maxWidth + " - " + padding2 + "px - " + settings.marginHor /*+ " - " + settings.marginHor*/ + ")";
            maxHeightStr = "calc(" + settings.maxHeight + " - " + padding2 + "px - " + settings.marginVer /*+ " - " + settings.marginVer*/ + ")";
        }
        popup.style.maxWidth = maxWidthStr;
        popup.style.maxHeight = maxHeightStr;
    }
    function checkUpdateButtonRect() {
        if (updateButtonRect) {
            var rect = rectProvider ? rectProvider.getBoundingClientRect() : { left: 0, top: 0, right: 0, bottom: 0 };
            if (rect.left != rect.right) {
                var containerRect = container.getBoundingClientRect();
                exactLeftPxNumber = rect.left - containerRect.left;
                exactTopPxNumber = rect.top - containerRect.top;
                updateButtonRect = false;
                calcStyles();
                onContainerResize();
            }
        }
    }
    function initialize() {
        styles = tf.GetStyles();
        subStyles = styles.GetSubStyles();
        isVisible = false;
        updateButtonRect = false;
        if (container = tf.dom.GetHTMLElementFrom(settings.container)) {
            var defaultTitle = "Popup", defaultMaxWH = "100%", defaultHVPos = tf.consts.positioningCenter;
            var defaultMarginPXNumber = 0, defaultMarginPXStr = defaultMarginPXNumber + "px";
            var defaultOptions = {
                titleStr: defaultTitle, horPos: defaultHVPos, verPos: defaultHVPos, bkColor: subStyles.popupContentBkColor, fontSize: subStyles.popupContentFontSizeEmNumber + "em",
                maxWidth: defaultMaxWH, maxHeight: defaultMaxWH, marginVer: defaultMarginPXNumber, marginHor: defaultMarginPXNumber, textAlign: "left", zIndex: 100
            };
            settings = tf.js.ShallowMerge(defaultOptions, settings);
            popupObj = new tf.dom.Div({ cssClass: styles.popupContainerClass + " " + styles.opacityVisibilityHideClass });
            popup = popupObj.GetHTMLElement();
            popup.style.zIndex = settings.zIndex;
            if (!settings.noTitle) { createTitle(); }
            contentObj = new tf.dom.Div({ cssClass: styles.popupContentClass });
            content = contentObj.GetHTMLElement();
            content.style.fontSize = settings.fontSize;
            content.style.backgroundColor = settings.bkColor;
            popupObj.AddContent(divPopupTitleObj);
            popupObj.AddContent(contentObj);
            settings.maxWidth = tf.js.GetDimFromStrOrPxNumber(settings.maxWidth, defaultMaxWH);
            settings.maxHeight = tf.js.GetDimFromStrOrPxNumber(settings.maxHeight, defaultMaxWH);
            var padding = subStyles.popupContainerPaddingPxNumber;
            var paddingPx = padding + "px";
            settings.marginHor = tf.js.GetDimFromStrOrPxNumber(settings.marginHor, defaultMarginPXStr);
            settings.marginVer = tf.js.GetDimFromStrOrPxNumber(settings.marginVer, defaultMarginPXStr);
            calcStyles();
            if (!(rectProvider = tf.dom.GetHTMLElementFrom(settings.rectProvider))) {
                popup.style.marginLeft = "calc(" + settings.marginHor + " - " + paddingPx + ")";
                popup.style.marginRight = "calc(" + settings.marginHor + " - " + paddingPx + ")";
                popup.style.marginTop = "calc(" + settings.marginVer + " - " + paddingPx + ")";
                popup.style.marginBottom = "calc(" + settings.marginVer + " - " + paddingPx + ")";
                styles.ApplySnapStyle(popupObj, settings);
            }
            else { updateButtonRect = true; }
            changeTitle(settings.titleStr);
            popup.style.textAlign = settings.textAlign;
            popupObj.AppendTo(container);
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * An object used in the creation of [Radio Button With Label]{@link tf.ui.RadioButtonWithLabel} instances
 * @public
 * @typedef {object} tf.types.RadioButtonWithLabelSettings
 * @property {string} labelID - optional label ID
 * @property {string} radioID - optional radio ID
 * @property {string} labelStr - label text
 * @property {string} valueStr - radio value
 * @property {boolean} checked - initially checked, if set to <b>true</b>, unchecked otherwise
 * @property {string} radioGroupStr - radio group
 * @property {string} toolTipStr - tooltip text
 */
/**
 * @public
 * @class
 * @summary Radio Button With Label is an [Insertable]{@link tf.dom.Insertable} implementing an HTML radio button with a text label.
 * Instances of this class are created by the function [AddRadioButton]{@link tf.ui.RadioButtonList} of a [Radio Button List]{@link tf.ui.RadioButtonList} instance,
 * instead of using the <b>new</b> operator
 * @param {tf.types.RadioButtonWithLabelSettings} settings - creation settings
 * @extends {tf.dom.Insertable}
 */
tf.ui.RadioButtonWithLabel = function (settings) {
    var theThis, label, labelStr, radio, div, onLabelClick, onElemClick;
    /**
     * @public
     * @function
     * @summary - Retrieves the radio button {@link HTMLElement} associated with this instance
     * @returns {HTMLElement} - | {@link HTMLElement} the element
    */
    this.GetRadioButton = function () { return radio; }
    /**
     * @public
     * @function
     * @summary - Retrieves the label {@link HTMLElement} associated with this instance
     * @returns {HTMLElement} - | {@link HTMLElement} the element
    */
    this.GetLabel = function () { return label; }
    /**
     * @public
     * @function
     * @summary - Retrieves string value associated with this instance
     * @returns {string} - | {@link string} the value
    */
    this.GetValue = function () { return radio.value; }
    /**
     * @public
     * @function
     * @summary - Toggles the <b>checked</b> state of this instance
     * @returns {void} - | {@link void} no return value
    */
    this.Toggle = function () { radio.checked = !radio.checked; }
    /**
     * @public
     * @function
     * @summary - Retrieves the <b>checked</b> state of this instance
     * @returns {boolean} - | {@link boolean} <b>true</b> if checked, <b>false</b> otherwise
    */
    this.GetIsChecked = function () { return radio.checked; }
    /**
     * @public
     * @function
     * @summary - Sets the <b>checked</b> state of this instance
     * @param {boolean} bool - <b>true</b> to check the element, <b>false</b> to uncheck it
     * @returns {void} - | {@link void} no return value
    */
    this.SetIsChecked = function (bool) { radio.checked = !!bool; }
    /**
     * @public
     * @function
     * @summary - Sets a listener for [Click Events]{@link tf.consts.DOMEventNamesClick} on this instance
     * @param {tf.types.MultiDOMEventListenerCallBack} callBack - to receive event notifications
     * @param {object} optionalScope - optional scope used with <b>callBack</b>
     * @param {object} callBackSettings - application defined properties, to be passed to <b>callBack</b> during notifications
     * @returns {void} - | {@link void} no return value
    */
    this.SetOnClick = function (callBack, optionalScope, callBackSettings) {
        theThis.OnDelete();
        //onElemClick = new tf.events.DOMClickListener({ target: radio, callBack: callBack, optionalScope: optionalScope, callBackSettings: callBackSettings });
        onLabelClick = new tf.events.DOMClickListener({ target: label, callBack: callBack, optionalScope: optionalScope, callBackSettings: callBackSettings });
    }
    /**
     * @public
     * @function
     * @summary - Use this function to delete event listeners associated with this instance
     * @returns {void} - | {@link void} no return value
    */
    this.OnDelete = function () {
        if (!!onLabelClick) { onLabelClick.OnDelete(); onLabelClick = null; }
        if (!!onElemClick) { onElemClick.OnDelete(); onElemClick = null; }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        var labelID, radioID, valueStr, checked, radioGroupStr, toolTipStr;
        labelStr = tf.js.GetNonEmptyString(settings.labelStr, "");
        valueStr = tf.js.GetNonEmptyString(settings.valueStr, labelStr);
        toolTipStr = tf.js.GetIsNonEmptyString(settings.toolTipStr) ? settings.toolTipStr : labelStr;
        radioGroupStr = tf.js.GetNonEmptyString(settings.radioGroupStr, "");
        labelID = tf.js.GetNonEmptyString(settings.labelID) ? settings.labelID : tf.dom.CreateDomElementID("tf-label-");
        radioID = tf.js.GetNonEmptyString(settings.radioID) ? settings.radioID : tf.dom.CreateDomElementID("tf-radio-");
        checked = tf.js.GetBoolFromValue(settings.checked);
        div = new tf.dom.Div({ cssClass: tf.GetStyles().GetUnPaddedDivClassNames(true, false) });
        label = document.createElement('label');
        radio = document.createElement('input');
        label.id = labelID;
        label.title = toolTipStr;
        label.htmlFor = radioID;
        radio.type = "radio";
        radio.checked = !!checked ? "checked" : null;
        radio.id = radioID;
        radio.title = toolTipStr;
        radio.name = radioGroupStr;
        radio.value = valueStr;
        label.appendChild(document.createTextNode(labelStr));
        div.AddContent(radio, label);
        div.title = toolTipStr;
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: div.GetHTMLElement() });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.ui.RadioButtonWithLabel, tf.dom.Insertable);
/**
 * An object used in the creation of [Check Box With Label]{@link tf.ui.CheckBoxWithLabel} instances
 * @public
 * @typedef {object} tf.types.CheckBoxWithLabelSettings
 * @property {string} labelID - optional label ID
 * @property {string} checkID - optional checkbox ID
 * @property {string} labelStr - label text
 * @property {boolean} checked - initially checked, if set to <b>true</b>, unchecked otherwise
 * @property {string} toolTipStr - tooltip text
 */
/**
 * @public
 * @class
 * @summary Check Box With Label is an [Insertable]{@link tf.dom.Insertable} implementing an HTML check box with a text label.
 * Instances of this class are created by the function [AddCheckBox]{@link tf.ui.CheckBoxList} of a [Check Box List]{@link tf.ui.CheckBoxList} instance,
 * instead of using the <b>new</b> operator
 * @param {tf.types.CheckBoxWithLabelSettings} settings - creation settings
 * @extends {tf.dom.Insertable}
 */
tf.ui.CheckBoxWithLabel = function (settings) {
    var theThis, label, labelStr, check, div, onLabelClick, onElemClick;
    /**
     * @public
     * @function
     * @summary - Retrieves the check box {@link HTMLElement} associated with this instance
     * @returns {HTMLElement} - | {@link HTMLElement} the element
    */
    this.GetCheckBox = function () { return check; }
    /**
     * @public
     * @function
     * @summary - Retrieves the label {@link HTMLElement} associated with this instance
     * @returns {HTMLElement} - | {@link HTMLElement} the element
    */
    this.GetLabel = function () { return label; }
    /**
     * @public
     * @function
     * @summary - Retrieves the label {@link HTMLElement} associated with this instance, provided for interface compatibility with [Radio Buttons]{@link tf.js.RadioButtonWithLabel}
     * @returns {HTMLElement} - | {@link HTMLElement} the element
    */
    this.GetValue = function () { return labelStr; }
    /**
     * @public
     * @function
     * @summary - Toggles the <b>checked</b> state of this instance
     * @returns {void} - | {@link void} no return value
    */
    this.Toggle = function () { check.checked = !check.checked; }
    /**
     * @public
     * @function
     * @summary - Retrieves the <b>checked</b> state of this instance
     * @returns {boolean} - | {@link boolean} <b>true</b> if checked, <b>false</b> otherwise
    */
    this.GetIsChecked = function () { return check.checked; }
    /**
     * @public
     * @function
     * @summary - Sets the <b>checked</b> state of this instance
     * @param {boolean} bool - <b>true</b> to check the element, <b>false</b> to uncheck it
     * @returns {void} - | {@link void} no return value
    */
    this.SetIsChecked = function (bool) { check.checked = !!bool; }
    /**
     * @public
     * @function
     * @summary - Sets a listener for [Click Events]{@link tf.consts.DOMEventNamesClick} on this instance
     * @param {tf.types.MultiDOMEventListenerCallBack} callBack - to receive event notifications
     * @param {object} optionalScope - optional scope used with <b>callBack</b>
     * @param {object} callBackSettings - application defined properties, to be passed to <b>callBack</b> during notifications
     * @returns {void} - | {@link void} no return value
    */
    this.SetOnClick = function (callBack, optionalScope, callBackSettings) {
        theThis.OnDelete();
        //onElemClick = new tf.events.DOMClickListener({ target: check, callBack: callBack, optionalScope: optionalScope, callBackSettings: callBackSettings });
        onLabelClick = new tf.events.DOMClickListener({ target: label, callBack: callBack, optionalScope: optionalScope, callBackSettings: callBackSettings });
    }
    /**
     * @public
     * @function
     * @summary - Use this function to delete event listeners associated with this instance
     * @returns {void} - | {@link void} no return value
    */
    this.OnDelete = function () {
        if (!!onLabelClick) { onLabelClick.OnDelete(); onLabelClick = null; }
        if (!!onElemClick) { onElemClick.OnDelete(); onElemClick = null; }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        var labelID, checkID, checked, radioGroupStr, toolTipStr;
        labelStr = tf.js.GetNonEmptyString(settings.labelStr, "");
        toolTipStr = tf.js.GetIsNonEmptyString(settings.toolTipStr) ? settings.toolTipStr : labelStr;
        labelID = tf.js.GetNonEmptyString(settings.labelID) ? settings.labelID : tf.dom.CreateDomElementID("tf-label-");
        checkID = tf.js.GetNonEmptyString(settings.checkID) ? settings.checkID : tf.dom.CreateDomElementID("tf-check-");
        checked = tf.js.GetBoolFromValue(settings.checked);
        div = new tf.dom.Div({ cssClass: tf.GetStyles().GetUnPaddedDivClassNames(true, false) });
        label = document.createElement('label');
        check = document.createElement('input');
        label.id = labelID;
        label.title = toolTipStr;
        label.htmlFor = checkID;
        check.type = "checkbox";
        check.checked = !!checked ? "checked" : null;
        check.id = checkID;
        check.title = toolTipStr;
        label.appendChild(document.createTextNode(labelStr));
        div.AddContent(check, label);
        div.title = toolTipStr;
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: div.GetHTMLElement() });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.ui.CheckBoxWithLabel, tf.dom.Insertable);
/**
 * An object used in the creation of [Check Box With Label And Open Close]{@link tf.ui.CheckBoxWithLabelAndOpenClose} instances
 * @public
 * @typedef {object} tf.types.CheckBoxWithLabelAndOpenCloseSettings
 * @property {string} labelStr - label text
 * @property {boolean} checked - initially checked, if set to <b>true</b>, unchecked otherwise
 * @property {string} toolTipStr - tooltip text
 */
/**
 * @public
 * @class
 * @summary Check Box With Label And Open Close is an [Insertable]{@link tf.dom.Insertable} combining a [Click Open Close Button]{@link tf.ui.ClickOpenClose} instance
 * and a [CheckBox With Label]{@link tf.ui.CheckBoxWithLabel} instance.
 * Instances of this class are created by the function [AddCheckBoxWithLabelAndOpenClose]{@link tf.ui.CheckBoxList} of a [Check Box List]{@link tf.ui.CheckBoxList} instance,
 * instead of using the <b>new</b> operator
 * @param {tf.types.CheckBoxWithLabelAndOpenCloseSettings} settings - creation settings
 * @extends {tf.dom.Insertable}
 */
tf.ui.CheckBoxWithLabelAndOpenClose = function (settings) {
    var theThis, divCheck, divAll, clickOnClose, checkBox;
    /**
     * @public
     * @function
     * @summary - Retrieves the [Check Box With Label]{@link tf.ui.CheckBoxWithLabel} instance associated with this instance
     * @returns {tf.ui.CheckBoxWithLabel} - | {@link tf.ui.CheckBoxWithLabel} the instance
    */
    this.GetCheckBox = function () { return checkBox; }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Click Open Close Button]{@link tf.ui.ClickOpenClose} instance associated with this instance
     * @returns {tf.ui.ClickOpenClose} - | {@link tf.ui.ClickOpenClose} the instance
    */
    this.GetClickOpenClose = function () { return clickOnClose; }
    /**
     * @public
     * @function
     * @summary - Use this function to delete event listeners associated with this instance
     * @returns {void} - | {@link void} no return value
    */
    this.OnDelete = function () {
        if (!!clickOnClose) { clickOnClose.OnDelete(); /*clickOnClose= null;*/ }
        if (!!checkBox) { checkBox.OnDelete(); /*checkBox = null;*/ }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        var styles = tf.GetStyles(), subStyles = styles.GetSubStyles();
        var labelStr, checked, toolTipStr;
        labelStr = tf.js.GetNonEmptyString(settings.labelStr, "");
        toolTipStr = tf.js.GetIsNonEmptyString(settings.toolTipStr) ? settings.toolTipStr : labelStr;
        checked = tf.js.GetBoolFromValue(settings.checked);
        divCheck = new tf.dom.Div({ cssClass: styles.GetUnPaddedDivClassNames(true, false) });
        var closeBtnDim = subStyles.mapControlFontSizeEmNumber + "em";
        clickOnClose = styles.AddButtonDivRightMargin(new tf.ui.ClickOpenClose({ isOpen: false, onClick: undefined, dim: closeBtnDim, style: false }));
        checkBox = new tf.ui.CheckBoxWithLabel({ labelStr: labelStr, checked: checked, toolTipStr: toolTipStr });
        var divDivCheck = divCheck.GetHTMLElement();
        divDivCheck.style.width = "calc(90% - " + closeBtnDim + ")";
        checkBox.AppendTo(divCheck);
        divAll = new tf.dom.Div({ cssClass: tf.GetStyles().GetUnPaddedDivClassNames(true, false) });
        divAll.GetHTMLElement().title = toolTipStr;
        clickOnClose.AppendTo(divAll);
        divCheck.AppendTo(divAll);
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: divAll });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.ui.CheckBoxWithLabelAndOpenClose, tf.dom.Insertable);
/**
 * @public
 * @class
 * @summary List Item is an [Insertable]{@link tf.dom.Insertable} containing a [Div]{@link tf.dom.Div} created with the 
 * standard API <b>padded div</b> [CSS style/class]{@link tf.types.CSSStyleName}, obtainable with the 
 * [GetPaddedDivClassNames]{@link tf.styles.Styles#GetPaddedDivClassNames} function, 
 * to which {@link HTMLElementLike} content can be added. Used for building disposable sub-containers
 * @param {boolean} inlineBool - set to <b>true</b> to create an <b>inline-block</b> div with optional right border separator, otherwise a <b>block</b> div style with optional bottom separator is created
 * @param {boolean} borderSeparatorBool - if <b>true</b> adds a separator border to either the div's right or bottom, depending on <b>inlineBool</b>, if <b>false</b> no separator is added
 * @extends {tf.dom.Insertable}
 */
tf.ui.ListItem = function (inlineBool, borderSeparatorBool) {
    var theThis;
    /**
     * @public
     * @function
     * @summary - Adds the given new content to contents that were previously added to this instance
     * @param {HTMLElementLike} elem - the new content
     * @returns {void} - | {@link void} no return value
    */
    this.AddContent = function (elem) { tf.dom.AddContent(elem, theThis.GetHTMLElement()); }
    /**
     * @public
     * @function
     * @summary - Checks if this instance was created with a border separator CSS style/class
     * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
    */
    this.GetHasBorderSeparator = function () { return borderSeparatorBool; }
    /**
     * @public
     * @function
     * @summary - Checks if this instance was created with as an <b>inline-block</b>
     * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
    */
    this.GetIsInline = function () { return inlineBool; }
    function initialize() {
        borderSeparatorBool = !!borderSeparatorBool;
        inlineBool = !!inlineBool;
        var className = tf.GetStyles().GetPaddedDivClassNames(inlineBool, borderSeparatorBool);
        var domElement = new tf.dom.Div({ cssClass: className }).GetHTMLElement();
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: domElement });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.ui.ListItem, tf.dom.Insertable);
/**
 * @public
 * @class
 * @summary Radio Button List is an [Insertable]{@link tf.dom.Insertable} containing an arbitrary number of [Radio Button With Label]{@link tf.ui.RadioButtonWithLabel} instances
 * @param {object} settings - creation settings
 * @param {boolean} settings.isInline - set to <b>true</b> to create a <b>horizontal</b> list, otherwise a <b>vertical</b> list is created
 * @param {string} settings.radioGroup - if defined, <b>radioGroup</b> is used as the group name of the radio buttons, otherwise a group is automatically created, defaults to {@link void}
 * @extends {tf.dom.Insertable}
 */
tf.ui.RadioButtonList = function (settings) {
    var theThis, isInline, radioGroup, domElement;
    /**
     * @public
     * @function
     * @summary - Checks if this instance is horizontal or vertical
     * @returns {boolean} - | {@link boolean} <b>true</b> if horizontal, <b>false</b> otherwise
    */
    this.GetIsInline = function () { return isInline; }
    /**
     * @public
     * @function
     * @summary - Adds the given new content to contents that were previously added to this instance
     * @param {HTMLElementLike} elem - the new content
     * @param {boolean} borderSeparatorBool - if <b>true</b> adds a separator border to either the content's right or bottom, depending on whether this list is horizontal or vertical
     * @returns {void} - | {@link void} no return value
    */
    this.AddContent = function (elem, borderSeparatorBool) {
        if (elem) { var li = new tf.ui.ListItem(isInline, borderSeparatorBool); li.AddContent(elem); li.AppendTo(domElement); }
        return elem;
    }
    /**
     * @public
     * @function
     * @summary - Creates a new [Radio Button With Label]{@link tf.ui.RadioButtonWithLabel} instance and adds it to this list
     * @param {string} labelStr - label text
     * @param {string} valueStr - radio value
     * @param {boolean} checked - initially checked, if set to <b>true</b>, unchecked otherwise
     * @param {string} toolTipStr - tooltip text
     * @param {boolean} borderSeparatorBool - if <b>true</b> adds a separator border to either the button's right or bottom, depending on whether this list is horizontal or vertical
     * @returns {tf.ui.RadioButtonWithLabel} - | {@link tf.ui.RadioButtonWithLabel} the added instance
    */
    this.AddRadioButton = function (labelStr, valueStr, checked, toolTipStr, borderSeparatorBool) {
        return this.AddContent(new tf.ui.RadioButtonWithLabel({labelStr: labelStr, valueStr: valueStr, checked: checked, radioGroupStr: radioGroup, toolTipStr: toolTipStr}), borderSeparatorBool);
    }
    function initialize() {
        var styles = tf.GetStyles();
        var settingsUse = tf.js.GetValidObjectFrom(settings);
        isInline = tf.js.GetBoolFromValue(settingsUse.isInline);
        if (!(radioGroup = tf.js.GetNonEmptyString(settingsUse.radioGroup, null))) {
            radioGroup = tf.dom.CreateDomElementID("tf-rg-");
        }
        var className = styles.GetUnPaddedDivClassNames(isInline, false) + " " + styles.GetRadioItemClasses();
        domElement = (new tf.dom.Div({ cssClass: className })).GetHTMLElement();
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: domElement });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.ui.RadioButtonList, tf.dom.Insertable);
/**
 * @public
 * @class
 * @summary Check Box List is an [Insertable]{@link tf.dom.Insertable} containing an arbitrary number of [Check Box With Label]{@link tf.ui.CheckBoxWithLabel} instances
 * @param {object} settings - creation settings
 * @param {boolean} settings.isInline - set to <b>true</b> to create a <b>horizontal</b> list, otherwise a <b>vertical</b> list is created
 * @extends {tf.dom.Insertable}
 */
tf.ui.CheckBoxList = function (settings) {
    var theThis, isInline, domElement;
    /**
     * @public
     * @function
     * @summary - Checks if this instance is horizontal or vertical
     * @returns {boolean} - | {@link boolean} <b>true</b> if horizontal, <b>false</b> otherwise
    */
    this.GetIsInline = function () { return isInline; }
    /**
     * @public
     * @function
     * @summary - Adds the given new content to contents that were previously added to this instance
     * @param {HTMLElementLike} elem - the new content
     * @param {boolean} borderSeparatorBool - if <b>true</b> adds a separator border to either the content's right or bottom, depending on whether this list is horizontal or vertical
     * @returns {void} - | {@link void} no return value
    */
    this.AddContent = function (elem, borderSeparatorBool) {
        if (elem) { var li = new tf.ui.ListItem(isInline, borderSeparatorBool); li.AddContent(elem); li.AppendTo(domElement); }
        return elem;
    }
    /**
     * @public
     * @function
     * @summary - Creates a new [Check Box With Label]{@link tf.ui.CheckBoxWithLabel} instance and adds it to this list
     * @param {string} labelStr - label text
     * @param {boolean} checked - initially checked, if set to <b>true</b>, unchecked otherwise
     * @param {string} toolTipStr - tooltip text
     * @param {boolean} borderSeparatorBool - if <b>true</b> adds a separator border to either the button's right or bottom, depending on whether this list is horizontal or vertical
     * @returns {tf.ui.CheckBoxWithLabel} - | {@link tf.ui.CheckBoxWithLabel} the added instance
    */
    this.AddCheckBox = function (labelStr, checked, toolTipStr, borderSeparatorBool) {
        return this.AddContent(new tf.ui.CheckBoxWithLabel({ labelStr: labelStr, checked: checked, toolTipStr: toolTipStr }), borderSeparatorBool);
    }
    /**
     * @public
     * @function
     * @summary - Creates a new [Check Box With Label And Open Close]{@link tf.ui.CheckBoxWithLabelAndOpenClose} instance and adds it to this list
     * @param {string} labelStr - label text
     * @param {boolean} checked - initially checked, if set to <b>true</b>, unchecked otherwise
     * @param {string} toolTipStr - tooltip text
     * @param {boolean} borderSeparatorBool - if <b>true</b> adds a separator border to either the button's right or bottom, depending on whether this list is horizontal or vertical
     * @returns {tf.ui.CheckBoxWithLabelAndOpenClose} - | {@link tf.ui.CheckBoxWithLabelAndOpenClose} the added instance
    */
    this.AddCheckBoxWithLabelAndOpenClose = function (labelStr, checked, toolTipStr, borderSeparatorBool) {
        return this.AddContent(new tf.ui.CheckBoxWithLabelAndOpenClose({ labelStr: labelStr, checked: checked, toolTipStr: toolTipStr }), borderSeparatorBool);
    }
    function initialize() {
        var styles = tf.GetStyles();
        var settingsUse = tf.js.GetValidObjectFrom(settings);
        isInline = tf.js.GetBoolFromValue(settingsUse.isInline);
        var className = styles.GetUnPaddedDivClassNames(isInline, false) + " " + styles.GetCheckItemClasses();
        domElement = (new tf.dom.Div({ cssClass: className })).GetHTMLElement();
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: domElement });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.ui.CheckBoxList, tf.dom.Insertable);
/**
 * @public
 * @class
 * @summary Radio Or Check List From Data is an [Insertable]{@link tf.dom.Insertable} implementing quick construction of simple lists
 * containing either [Radio Button With Label]{@link tf.ui.RadioButtonWithLabel} or [Check Box With Label]{@link tf.ui.CheckBoxWithLabel} instances
 * @param {object} settings - creation settings
 * @param {boolean} settings.isInline - set to <b>true</b> to create a <b>horizontal</b> list, otherwise a <b>vertical</b> list is created
 * @param {boolean} settings.isRadioList - set to <b>true</b> to create a <b>radio button</b> list, otherwise a <b>check box</b> list is created
 * @param {boolean} settings.noSeparators - set to <b>true</b> to prevent separators from being added between buttons, defaults to {@link void}
 * @param {function} settings.onClick - simple callback that receives the <b>label</b> of a button [clicked]{@link tf.consts.DOMEventNamesClick} by the user
 * @param {function} settings.optionalScope - optional scope used with <b>callback</b>
 * @param {string} settings.selRadioName - on <b>radio button</b> lists specifies the label of the button that is initially selected
 * @param {array<boolean>} settings.checkBoxes - on <b>check box</b> lists specifies the initial <b>checked</b> state for buttons on the list, 
 * should contain as many elements as the number of buttons being added, non-initialized buttons are created unchecked by default
 * @param {string|array<string>|array<string, string>} settings.data - if a <b>string</b> is used it must contain the labels of the buttons to be added separated by {@link tf.consts.charSplitStrings}.
 * if an <b>array</b> is used its elements are either the <b>strings</b> containing button labels, or two element arrays containing a button name in the
 * first position and a button tooltip in the second position.
 * @example
 * function onClick(labelClicked) {
 *     console.log('button with label "' + labelClicked + '" was clicked');
 * }
 * var checkListWithoutTooltips = new tf.ui.RadioOrCheckListFromData({
 *     isRadioList: false, onClick: onClick, isInline: false, checkedBoxes: [true, false, true],
 *     data: "Option1+Option2+Option3"
 * });
 * var radioListWithoutTooltips = new tf.ui.RadioOrCheckListFromData({
 *     isRadioList: true, onClick: onClick, isInline: false, selRadioName: "Option2",
 *     data: ["Option1", "Option2", "Option3"]
 * });
 * var checkListWithTooltips = new tf.ui.RadioOrCheckListFromData({
 *     isRadioList: false, onClick: onClick, isInline: false, checkedBoxes: [true, false, true],
 *     data: [["Option1", "Click me for option 1"], ["Option2", "Click me for option 2"], ["Option3", "Click me for option 3"]]
 * });
 * @extends {tf.dom.Insertable}
 */
tf.ui.RadioOrCheckListFromData = function (settings) {
    var theThis, list, isRadioList, callBackOnClick, buttons, lastCheckedName, optionalScope;
    /**
     * @public
     * @function
     * @summary - Checks if this is a [Radio Button With Label]{@link tf.ui.RadioButtonWithLabel} list or a [Check Box With Label]{@link tf.ui.CheckBoxWithLabel} list
     * @returns {boolean} - | {@link boolean} <b>true</b> if radio button list, <b>false</b> otherwise
    */
    this.GetIsRadioButtonList = function () { return isRadioList; }
    /**
     * @public
     * @function
     * @summary - Retrieves either the [Radio Button With Label]{@link tf.ui.RadioButtonWithLabel} or the [Check Box With Label]{@link tf.ui.CheckBoxWithLabel} instance with the
     * given label, if any
     * @param {string} label - the given label
     * @returns {tf.ui.RadioButtonWithLabel|tf.ui.CheckBoxWithLabel} - | {@link tf.ui.RadioButtonWithLabel}|{@link tf.ui.CheckBoxWithLabel} the instance with the give label, or {@link void} if none is found
    */
    this.GetButton = function (buttonName) { return buttons[buttonName]; }
    /**
     * @public
     * @function
     * @summary - Retrieves label of the last button checked
     * @returns {string} - | {@string} the label
    */
    this.GetLastCheckedLabel = function () { return lastCheckedName; }
    function notifyOnClick(theButton) { callBackOnClick.call(optionalScope, theButton.GetValue()); }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        buttons = [];
        callBackOnClick = tf.js.GetFunctionOrNull(settings.onClick);
        optionalScope = settings.optionalScope;
        var type = (isRadioList = !!settings.isRadioList) ? tf.ui.RadioButtonList : tf.ui.CheckBoxList;
        list = new type({ isInline: settings.isInline });
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: list.GetHTMLElement() });
        var data = settings.data;
        if (!!data) {
            if (typeof data === "string") { data = data.split(tf.consts.charSplitStrings); }
            if (tf.js.GetIsArray(data)) {
                var nData = data.length;
                var selRadioName = tf.js.GetNonEmptyString (settings.selRadioName);
                var checkedBoxesObj = tf.js.GetValidObjectFrom(settings.checkedBoxes);
                var noSeparators = settings.noSeparators !== undefined ? tf.js.GetBoolFromValue(settings.noSeparators) : false;
                for (var i in data) {
                    var dataItem = data[i];
                    var itemStr = null, toolTipStr = null;
                    if (tf.js.GetIsArrayWithLength(dataItem, 2)) {
                        itemStr = tf.js.GetNonEmptyString(dataItem[0]);
                        toolTipStr = tf.js.GetNonEmptyString(dataItem[1]);
                    }
                    else {
                        var itemStr = tf.js.GetNonEmptyString(dataItem);
                        toolTipStr = 'click to select: "' + itemStr + '"';
                    }
                    if (!!itemStr) {
                        if (!buttons[itemStr]) {
                            var checked;
                            
                            if (isRadioList) { if (checked = (!selRadioName || selRadioName == itemStr)) { selRadioName = itemStr; } }
                            else { checked = !!checkedBoxesObj[itemStr]; }
                            if (checked) { lastCheckedName = itemStr; }
                            var borderSeparatorBool = noSeparators ? false : i != nData - 1;
                            var button = isRadioList ?
                                list.AddRadioButton(itemStr, itemStr, checked, toolTipStr, borderSeparatorBool) :
                                list.AddCheckBox(itemStr, checked, toolTipStr, borderSeparatorBool);
                            var onClickFunction = function (theButton, theButtonName) {
                                return function () {
                                    lastCheckedName = theButtonName;
                                    if (isRadioList) { theButton.SetIsChecked(true); } else { theButton.Toggle(); }
                                    if (!!callBackOnClick) { setTimeout(function () { return notifyOnClick(theButton); }, 10); }
                                }
                            }(button, itemStr);
                            buttons[itemStr] = button;
                            button.SetOnClick(onClickFunction, theThis, undefined);
                        }
                        else { tf.GetDebug().LogIfTest("tf.ui.RadioOrCheckListFromData: adding duplicate button: " + itemStr); }
                    }
                }
            }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.ui.RadioOrCheckListFromData, tf.dom.Insertable);
/**
 * @public
 * @class
 * @summary Radio Or Check Popup From Data is a [Popup]{@link tf.ui.Popup} containing an instance of [Radio Or Check List From Data]{@link tf.ui.RadioOrCheckListFromData}
 * @param {object} settings - creation settings
 * @param {HTMLElementLike} settings.container - Mandatory param, the container where the popup is located
 * @param {HTMLElementSize} settings.marginHor - optional horizontal margins (applies to both left and right), defaults to "0px"
 * @param {HTMLElementSize} settings.marginVer - optional vertical margins (applies to both top and bottom), defaults to "0px"
 * @param {HTMLElementSize} settings.maxWidth - optional maximum width, defaults to {@link void}
 * @param {HTMLElementSize} settings.maxHeight - optional maximum height, defaults to {@link void}
 * @param {number} zIndex - if defined, sets the zIndex of the popup. Defaults to 100
 * @param {boolean} settings.isInline - set to <b>true</b> to create a <b>horizontal</b> list, otherwise a <b>vertical</b> list is created
 * @param {boolean} settings.isRadioList - set to <b>true</b> to create a <b>radio button</b> list, otherwise a <b>check box</b> list is created
 * @param {function} settings.onClick - simple callback that receives the <b>label</b> of a button [clicked]{@link tf.consts.DOMEventNamesClick} by the user
 * @param {function} settings.optionalScope - optional scope used with <b>callback</b>
 * @param {string} settings.selRadioName - on <b>radio button</b> lists specifies the label of the button that is initially selected
 * @param {array<boolean>} settings.checkBoxes - on <b>check box</b> lists specifies the initial <b>checked</b> state for buttons on the list, 
 * should contain as many elements as the number of buttons being added, non-initialized buttons are created unchecked by default
 * @param {string|array<string>|array<string, string>} settings.data - if a <b>string</b> is used it must contain the labels of the buttons to be added separated by '+'.
 * if an <b>array</b> is used its elements are either the <b>strings</b> containing button labels, or two element arrays containing a button name in the
 * first position and a button tooltip in the second position.
 */
tf.ui.RadioOrCheckPopupFromData = function (settings) {
    var theThis, popup, radioList;;
    /**
     * @public
     * @function
     * @summary - Sets popup's zIndex
     * @param {number} zIndex - the zIndex
     * @returns {void} - | {@link void} no return value
    */
    this.SetZIndex = function (zIndex) { popup && popup.SetZIndex(zIndex); }
    /**
     * @public
     * @function
     * @summary - Gets popup's zIndex
     * @returns {number} - | {@link number} the zIndex
    */
    this.GetZIndex = function () { return popup ? popup.GetZIndex() : 0; }
    /**
     * @public
     * @function
     * @summary - Sets the callBack for the popup's close button click event, the popup closes and the callback is notified
     * @param {function} callBack - the callBack function, the popup instance object is passed to it on notifications
     * @returns {void} - | {@link void} no return value
    */
    this.SetOnClose = function (callBack) { popup.SetOnClose(callBack, optionalScope); }
    /**
     * @public
     * @function
     * @summary - Changes the popup's tile
     * @param {string} titleStr - the new title
     * @returns {void} - | {@link void} no return value
    */
    this.SetTitle = function (titleStr) { popup && popup.ChangeTitle(titleStr); }
    /**
     * @public
     * @function
     * @summary - Shows or hides the popup
     * @param {boolean} bool - <b>true</b> to show, <b>false</b> to hide
     * @returns {void} - | {@link void} no return value
    */
    this.Show = function (bool) { if (popup) { popup.Show(bool); if (!!bool) { onContainerResize(); } } }
    /**
     * @public
     * @function
     * @summary - Checks if the popup is visible
     * @returns {boolean} - | {@link boolean} <b>true</b> if visible, <b>false</b> otherwise
    */
    this.IsShowing = function () { return popup ? popup.IsShowing() : false; }
    /**
     * @public
     * @function
     * @summary - Toggles popup's visibility state
     * @returns {void} - | {@link void} no return value
    */
    this.Toggle = function () { this.Show(!this.IsShowing()); }
    /**
     * @public
     * @function
     * @summary - Notifies the popup that its container may have been resized
     * @returns {void} - | {@link void} no return value
    */
    this.OnContainerResize = function () { onContainerResize(); }
    function onContainerResize() { if (popup) { popup.OnContainerResize(); } }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (settings.container) {
            (popup = new tf.ui.Popup({
                container: settings.container,
                titleStr: settings.title,
                maxHeight: "100%",
                maxWidth: "100%",
                horPos: settings.horPos,
                verPos: settings.verPos,
                marginHor: settings.marginHor,
                marginVer: settings.marginVer,
                zIndex: settings.zIndex
            })).AddContent(radioList = new tf.ui.RadioOrCheckListFromData({
                isRadioList: settings.isRadioList, onClick: settings.onClick, data: settings.data, isInline: settings.isInline, checkBoxes: settings.checkBoxes, selRadioName: settings.selRadioName
            }));
            popup.SetOnClose(settings.onClose, settings.optionalScope);
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * class tf.ui.ToolBarPopup - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} container - parameter description?
 * @param {?} rectProvider - parameter description?
*/
tf.ui.ToolBarPopup = function (container, rectProvider) {
    var styles = tf.GetStyles();
    var formatDiv = styles.GetUnPaddedDivClassNames(true, false);
    var focusElem = null;
    var isVisible = false;
    var updateButtonRect = true;
    var exactLeftPxNumber = undefined;
    var exactTopPxNumber = undefined;
/**
 * method tf.ui.ToolBarPopup.SetFocusElem - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} focusElem - parameter description?
*/
    this.SetFocusElem = function (focusElem) { return setFocusElem (focusElem) ;}
/**
 * method tf.ui.ToolBarPopup.Show - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} bool - parameter description?
*/
    this.Show = function (bool) { show(bool); }
/**
 * method tf.ui.ToolBarPopup.IsShowing - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.IsShowing = function () { return isShowing(); }
/**
 * method tf.ui.ToolBarPopup.Toggle - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.Toggle = function () { toggle(); }
/**
 * method tf.ui.ToolBarPopup.AddContent - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} content - parameter description?
 * @param {?} noRightBar - parameter description?
 * @param {?} noWrapper - parameter description?
*/
    this.AddContent = function (content, noRightBar, noWrapper) { return addContent(content, noRightBar, noWrapper); }
    //this.GetHTMLElement = function () { return popup; }
    var theThis = null;
    var popupObj = null;
    var popup = null;
    function setFocusElem(focusElemSet) { focusElem = tf.dom.GetHTMLElementFrom (focusElemSet);}
    function checkUpdateButtonRect() {
        if (updateButtonRect) {
            var rect = rectProvider ? rectProvider.getBoundingClientRect() : { left:0, top: 0, right: 0, bottom: 0 };
            if (rect.left != rect.right) {
                var containerRect = container.getBoundingClientRect();
                exactLeftPxNumber = rect.left - containerRect.left;
                exactTopPxNumber = rect.top - containerRect.top;
                updateButtonRect = false;
                //setTimeout(checkUpdateButtonRect, 500);
                calcStyles();
            }
            else {
                setTimeout(checkUpdateButtonRect, 500);
            }
        }
    }
    function show(bool) {
        bool = !!bool;
        if (isVisible != bool) {
            if (bool) { checkUpdateButtonRect(); }
            if (isVisible != bool) { styles.ChangeOpacityVisibilityClass(popup, isVisible = bool); if (isVisible) { if (!!focusElem) { focusElem.focus(); } } }
        }
    }
    function isShowing() { return isVisible }
    function toggle() { show(!isShowing()); }
    function addContent(content, noRightBar, noWrapper) {
        if (!!content) {
            if (!!noWrapper) {
                if (!noRightBar) { tf.dom.AddCSSClass(content, styles.rightBorderSeparatorLightClass); }
                content.AppendTo(popup);
            }
            else {
                var divContentObj = new tf.dom.Div({ cssClass: formatDiv });
                if (!noRightBar) { tf.dom.AddCSSClass(divContentObj, styles.rightBorderSeparatorLightClass); }
                styles.ApplyMiddleVerticalAlignStyle(divContentObj);
                divContentObj.AddContent(content);
                divContentObj.AppendTo(popup);
            }
        }
    }
    function calcStyles() {
        var maxWidthStr, maxHeightStr;
        var leftStr = exactLeftPxNumber + "px";
        var topStr = exactTopPxNumber + "px" ;
        popup.style.left = leftStr;
        popup.style.top = topStr;
        popup.style.maxWidth = "calc(100% - " + leftStr + ")";
        popup.style.maxHeight = "calc(100% - " + topStr + ")";
    }
    function initialSetup() {
        popupObj = new tf.dom.Div({ cssClass: styles.mapToolBarContainerClass + " " + styles.opacityVisibilityHideClass });
        rectProvider = tf.dom.GetHTMLElementFrom(rectProvider);
        popup = popupObj.GetHTMLElement();
        popup.style.zIndex = 100;
        popupObj.AppendTo(container);
        calcStyles();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialSetup(); })(this);
};
/**
 * @public
 * @function
 * @summary - Traces a circle on the given context, at the given center, and with the given diameter, using {@link tf.canvas.ellipse}
 * @param {canvasContext} ctx - context on which to draw the circle
 * @param {number} aX - horizontal center coordinate
 * @param {number} aY - vertical center coordinate
 * @param {number} aDiameter - diameter
 * @returns {void} - | {@link void} no return value
*/
tf.canvas.circle = function (ctx, aX, aY, aDiameter) { tf.canvas.ellipse(ctx, aX, aY, aDiameter, aDiameter); }
/**
 * @public
 * @function
 * @summary - Traces an axis-aligned ellipse on the given context, at the given center, and with the given diameters, using <b>bezierCurveTo</b>, does
 * not fill or stroke the traced geometry
 * @param {canvasContext} ctx - context on which to draw the ellipse
 * @param {number} aX - horizontal center coordinate
 * @param {number} aY - vertical center coordinate
 * @param {number} aWidth - horizontal diameter
 * @param {number} aHeight - vertical diameter
 * @returns {void} - | {@link void} no return value
*/
tf.canvas.ellipse = function (ctx, aX, aY, aWidth, aHeight) {
    var hB = (aWidth / 2) * .5522848, vB = (aHeight / 2) * .5522848,
        eX = aX + aWidth, eY = aY + aHeight, mX = aX + aWidth / 2, mY = aY + aHeight / 2;
    ctx.moveTo(aX, mY);
    ctx.bezierCurveTo(aX, mY - vB, mX - hB, aY, mX, aY);
    ctx.bezierCurveTo(mX + hB, aY, eX, mY - vB, eX, mY);
    ctx.bezierCurveTo(eX, mY + vB, mX + hB, eY, mX, eY);
    ctx.bezierCurveTo(mX - hB, eY, aX, mY + vB, aX, mY);
}
/**
 * @public
 * @function
 * @summary - Strokes and fills a rectangle with rounded corners on the given context
 * @param {canvasContext} ctx - context on which to draw the rectangle
 * @param {number} x - the rectangle's leftmost coordinate
 * @param {number} y - the rectangle's topmost coordinate
 * @param {number} width - the width of the rectangle
 * @param {number} height - the height of the rectangle
 * @param {number} radius - the radius of the rectangle's rounded corners
 * @param {boolean} fill - if <b>true</b> the rectangle is filled with the current fill color, defaults to {@link void}
 * @param {boolean} stroke - if <b>true</b> the rectangle is stroked with the current stroke color and width, defaults to {@link void}
 * @returns {void} - | {@link void} no return value
*/
tf.canvas.StrokeFillRoundRect = function (ctx, x, y, width, height, radius, fill, stroke, dontTranslate) {
    stroke = tf.js.GetBoolFromValue(stroke, false);
    fill = tf.js.GetBoolFromValue(fill, false);
    if (fill || stroke) {
        if (!dontTranslate) { ctx.translate(0.5, 0.5); }
        var minDim = width < height ? width : height;
        radius = tf.js.GetFloatNumberInRange(radius, 0, minDim / 2);
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        if (stroke) { ctx.stroke(); }
        if (fill) { ctx.fill(); }
    }
}
/**
 * @public
 * @function
 * @summary - Strokes and fills a bubble on the given HTML5 canvas context, with an arrow callout going up from its left top corner
 * @param {canvasContext} ctx - the canvas context to draw on
 * @param {tf.types.pixelCoordinates} leftTop - left and top coordinates
 * @param {tf.types.pixelCoordinates} widthHeight - width and height dimensions 
 * @param {number} arrowHeight - in pixels, determines how far from the bubble the callout arrow ends
 * @param {number} radius - in pixels, used for rounding corners and determining the width of the callout arrow
*/
tf.canvas.StrokeFillBubbleLT = function (ctx, x, y, w, h, arrowHeight, radius) {
    var r = x + w;
    var b = y + h;
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x, y - arrowHeight);
    ctx.lineTo(x + radius * 2, y);
    ctx.lineTo(r - radius, y);
    ctx.quadraticCurveTo(r, y, r, y + radius);
    ctx.lineTo(r, y + h - radius);
    ctx.quadraticCurveTo(r, b, r - radius, b);
    ctx.lineTo(x + radius, b);
    ctx.quadraticCurveTo(x, b, x, b - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.stroke();
    ctx.fill();
}
/**
 * @public
 * @function
 * @summary - Strokes and fills a bubble on the given HTML5 canvas context, with an arrow callout going down from its left bottom corner
 * @param {canvasContext} ctx - the canvas context to draw on
 * @param {tf.types.pixelCoordinates} leftTop - left and top coordinates
 * @param {tf.types.pixelCoordinates} widthHeight - width and height dimensions 
 * @param {number} arrowHeight - in pixels, determines how far from the bubble the callout arrow ends
 * @param {number} radius - in pixels, used for rounding corners and determining the width of the callout arrow
*/
tf.canvas.StrokeFillBubbleLB = function (ctx, x, y, w, h, arrowHeight, radius) {
    var r = x + w;
    var b = y + h;
    ctx.moveTo(x + radius, y);
    ctx.lineTo(r - radius, y);
    ctx.quadraticCurveTo(r, y, r, y + radius);
    ctx.lineTo(r, y + h - radius);
    ctx.quadraticCurveTo(r, b, r - radius, b);
    ctx.lineTo(x + radius * 2, b);
    ctx.lineTo(x, b + arrowHeight);
    ctx.lineTo(x + radius, b);
    ctx.quadraticCurveTo(x, b, x, b - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.stroke();
    ctx.fill();
}
/**
 * @public
 * @function
 * @summary - Strokes and fills a bubble on the given HTML5 canvas context, with an arrow callout going up from its right top corner
 * @param {canvasContext} ctx - the canvas context to draw on
 * @param {tf.types.pixelCoordinates} leftTop - left and top coordinates
 * @param {tf.types.pixelCoordinates} widthHeight - width and height dimensions 
 * @param {number} arrowHeight - in pixels, determines how far from the bubble the callout arrow ends
 * @param {number} radius - in pixels, used for rounding corners and determining the width of the callout arrow
*/
tf.canvas.StrokeFillBubbleRT = function (ctx, x, y, w, h, arrowHeight, radius) {
    var r = x + w;
    var b = y + h;
    ctx.moveTo(x + radius, y);
    ctx.lineTo(r - radius * 2, y);
    ctx.lineTo(r, y - arrowHeight);
    ctx.lineTo(r - radius, y);
    ctx.quadraticCurveTo(r, y, r, y + radius);
    ctx.lineTo(r, y + h - radius);
    ctx.quadraticCurveTo(r, b, r - radius, b);
    ctx.lineTo(x + radius, b);
    ctx.quadraticCurveTo(x, b, x, b - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.stroke();
    ctx.fill();
}
/**
 * @public
 * @function
 * @summary - Strokes and fills a bubble on the given HTML5 canvas context, with an arrow callout going down from its right bottom corner
 * @param {canvasContext} ctx - the canvas context to draw on
 * @param {tf.types.pixelCoordinates} leftTop - left and top coordinates
 * @param {tf.types.pixelCoordinates} widthHeight - width and height dimensions 
 * @param {number} arrowHeight - in pixels, determines how far from the bubble the callout arrow ends
 * @param {number} radius - in pixels, used for rounding corners and determining the width of the callout arrow
*/
tf.canvas.StrokeFillBubbleRB = function (ctx, x, y, w, h, arrowHeight, radius) {
    var r = x + w;
    var b = y + h;
    ctx.moveTo(x + radius, y);
    ctx.lineTo(r - radius, y);
    ctx.quadraticCurveTo(r, y, r, y + radius);
    ctx.lineTo(r, y + h - radius);
    ctx.quadraticCurveTo(r, b, r - radius, b);
    ctx.lineTo(r - radius, b);
    ctx.lineTo(r, b + arrowHeight);
    ctx.lineTo(r - 2 * radius, b);
    ctx.lineTo(x + radius, b);
    ctx.quadraticCurveTo(x, b, x, b - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.stroke();
    ctx.fill();
}
/**
 * @public
 * @function
 * @summary - Strokes and fills a bubble on the given HTML5 canvas context, with an arrow callout going up from its the middle of its top edge
 * @param {canvasContext} ctx - the canvas context to draw on
 * @param {tf.types.pixelCoordinates} leftTop - left and top coordinates
 * @param {tf.types.pixelCoordinates} widthHeight - width and height dimensions 
 * @param {number} arrowHeight - in pixels, determines how far from the bubble the callout arrow ends
 * @param {number} radius - in pixels, used for rounding corners and determining the width of the callout arrow
*/
tf.canvas.StrokeFillBubbleMidT = function (ctx, x, y, w, h, arrowHeight, radius) {
    var r = x + w;
    var b = y + h;
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + w / 2 - radius / 2, y);
    ctx.lineTo(x + w / 2, y - arrowHeight);
    ctx.lineTo(x + w / 2 + radius / 2, y);
    ctx.lineTo(x + radius * 2, y);
    ctx.lineTo(r - radius, y);
    ctx.quadraticCurveTo(r, y, r, y + radius);
    ctx.lineTo(r, y + h - radius);
    ctx.quadraticCurveTo(r, b, r - radius, b);
    ctx.lineTo(x + radius, b);
    ctx.quadraticCurveTo(x, b, x, b - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.stroke();
    ctx.fill();
}
/**
 * @public
 * @function
 * @summary - Strokes and fills a bubble on the given HTML5 canvas context, with an arrow callout going down from its the middle of its bottom edge
 * @param {canvasContext} ctx - the canvas context to draw on
 * @param {tf.types.pixelCoordinates} leftTop - left and top coordinates
 * @param {tf.types.pixelCoordinates} widthHeight - width and height dimensions 
 * @param {number} arrowHeight - in pixels, determines how far from the bubble the callout arrow ends
 * @param {number} radius - in pixels, used for rounding corners and determining the width of the callout arrow
*/
tf.canvas.StrokeFillBubbleMidB = function (ctx, x, y, w, h, arrowHeight, radius) {
    var r = x + w;
    var b = y + h;
    ctx.moveTo(x + radius, y);
    ctx.lineTo(r - radius, y);
    ctx.quadraticCurveTo(r, y, r, y + radius);
    ctx.lineTo(r, y + h - radius);
    ctx.quadraticCurveTo(r, b, r - radius, b);
    ctx.lineTo(x + w / 2 + radius / 2, b);
    ctx.lineTo(x + w / 2, b + arrowHeight);
    ctx.lineTo(x + w / 2 - radius / 2, b);
    ctx.lineTo(x + radius, b);
    ctx.quadraticCurveTo(x, b, x, b - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.stroke();
    ctx.fill();
}
/**
 * @public
 * @function
 * @summary - Strokes and fills a bubble on the given HTML5 canvas context, with an arrow callout going up from its the middle of its right edge
 * @param {canvasContext} ctx - the canvas context to draw on
 * @param {tf.types.pixelCoordinates} leftTop - left and top coordinates
 * @param {tf.types.pixelCoordinates} widthHeight - width and height dimensions 
 * @param {number} arrowHeight - in pixels, determines how far from the bubble the callout arrow ends
 * @param {number} radius - in pixels, used for rounding corners and determining the width of the callout arrow
*/
tf.canvas.StrokeFillBubbleMidR = function (ctx, x, y, w, h, arrowHeight, radius) {
    var r = x + w;
    var b = y + h;
    ctx.moveTo(x + radius, y);
    ctx.lineTo(r - radius, y);
    ctx.quadraticCurveTo(r, y, r, y + radius);
    ctx.lineTo(r + arrowHeight, y + h / 2);
    ctx.lineTo(r, b - radius);
    ctx.quadraticCurveTo(r, b, r - radius, b);
    ctx.lineTo(x + radius, b);
    ctx.quadraticCurveTo(x, b, x, b - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.stroke();
    ctx.fill();
}
/**
 * @public
 * @function
 * @summary - Strokes and fills a bubble on the given HTML5 canvas context, with an arrow callout going down from its the middle of its left edge
 * @param {canvasContext} ctx - the canvas context to draw on
 * @param {tf.types.pixelCoordinates} leftTop - left and top coordinates
 * @param {tf.types.pixelCoordinates} widthHeight - width and height dimensions 
 * @param {number} arrowHeight - in pixels, determines how far from the bubble the callout arrow ends
 * @param {number} radius - in pixels, used for rounding corners and determining the width of the callout arrow
*/
tf.canvas.StrokeFillBubbleMidL = function (ctx, x, y, w, h, arrowHeight, radius) {
    var r = x + w;
    var b = y + h;
    ctx.moveTo(x + radius, y);
    ctx.lineTo(r - radius, y);
    ctx.quadraticCurveTo(r, y, r, y + radius);
    ctx.lineTo(r, y + h - radius);
    ctx.quadraticCurveTo(r, b, r - radius, b);
    ctx.lineTo(x + radius, b);
    ctx.quadraticCurveTo(x, b, x, b - radius);
    ctx.lineTo(x - arrowHeight, y + h / 2);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.stroke();
    ctx.fill();
}
/**
 * @public
 * @function
 * @summary - Draws a rectangle with rounded corners from the left top coordinates of given context to the given dimensions.
 * Can be used with {@link tf.canvas.CreateMemoryImage}
 * @param {canvasContext} ctx - context on which to draw the rectangle
 * @param {object} settings - drawing settings
 * @param {number} settings.width - rectangle width in pixels
 * @param {number} settings.height - rectangle height in pixels
 * @param {number} settings.radius - rounded corners radius in pixels
 * @param {boolean} settings.fill - if <b>true</b> the rectangle is filled, defaults to <b>false</b>
 * @param {colorWithOptionalAlpha} settings.fill_color - fill color
 * @param {boolean} settings.line - if <b>true</b> the rectangle is stroked, defaults to <b>false</b>
 * @param {colorWithOptionalAlpha} settings.line_color - stroke color
 * @param {number} settings.line_width - stroke width in pixels
 * @returns {tf.types.iconAnchor} - | {@link tf.types.iconAnchor} the rectangle's anchor
*/
tf.canvas.DrawRoundRect = function (ctx, settings) {
    var defaultSettings = { width: 10, height: 10, radius: 2, fill: false, fill_color: "#fff", line: false, line_color: "#000", line_width: 1 };
    var settings = tf.js.ShallowMerge(defaultSettings, settings);
    var width = settings.width, height = settings.height, radius = settings.radius, fill = !!settings.fill, stroke = !!settings.line, strokeW = 0;
    if (!settings.dontTranslate) { ctx.translate(0.5, 0.5); }
    ctx.canvas.width = width;
    ctx.canvas.height = height;
    ctx.beginPath();
    ctx.clearRect(0, 0, width, height);
    //ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    if (stroke) { ctx.strokeStyle = settings.line_color; ctx.lineWidth = strokeW = settings.line_width; }
    if (fill) { ctx.fillStyle = settings.fill_color; }
    if (settings.line_dash !== undefined) {
        ctx.setLineDash(settings.line_dash);
    }
    tf.canvas.StrokeFillRoundRect(ctx, strokeW / 2, strokeW / 2, width - strokeW, height - strokeW, radius, fill, stroke, settings.dontTranslate);
    ctx.closePath();
    return [0.5, 0.5];
}
/**
 * @public
 * @function
 * @summary - Draws a bubble around given text with an optional callout arrow. Used to implement the <b>marker</b> style in [Map Feature Sub Style]{@link tf.map.FeatureSubStyle}
 * instances. Can be used with {@link tf.canvas.CreateMemoryImage}
 * @param {canvasContext} ctx - context on which to draw the rectangle
 * @param {object} settings - marker settings
 * @param {string} settings.label - the text
 * @param {number} settings.font - the text font, without size
 * @param {hexColor} settings.font_color - text font color
 * @param {number} settings.font_height - the text height, in pixels
 * @param {tf.types.opacity0100} settings.font_opacity - text font opacity
 * @param {hexColor} settings.line_color - text stroke color
 * @param {tf.types.opacity0100} settings.line_opacity - text stroke opacity
 * @param {number} settings.border_line_color - border stroke color
 * @param {tf.types.opacity0100} settings.border_line_opacity - border stroke opacity
 * @param {number} settings.border_line_width - border stroke width in pixels
 * @param {number} settings.fill_color - bubble fill color
 * @param {tf.types.opacity0100} settings.fill_opacity - bubble fill opacity
 * @param {number} settings.arrowHeight - in pixels, determines how far from the bubble the callout arrow ends
 * @param {number} settings.radius - in pixels, used for rounding corners and determining the width of the callout arrow
 * @param {tf.types.horizontalPositioning} settings.horPos - horizontal positioning of the bubble
 * @param {tf.types.verticalPositioning} settings.verPos - vertical positioning of the bubble
 * @returns {tf.types.iconAnchor} - | {@link tf.types.iconAnchor} the marker's anchor
*/
tf.canvas.DrawTextMarkerImage = function (ctx, settings) {
    settings = tf.js.GetValidObjectFrom(settings);
    //var horPos = tf.js.GetNonEmptyString(settings.horpos, tf.consts.positioningLeft);
    var horPos = tf.js.GetNonEmptyString(settings.horpos, tf.consts.positioningCenter);
    //var horPos = tf.js.GetNonEmptyString(settings.horpos, tf.consts.positioningRight);
    var verPos = tf.js.GetNonEmptyString(settings.verpos, tf.consts.positioningTop);
    //var verPos = tf.js.GetNonEmptyString(settings.verpos, tf.consts.positioningCenter);
    //var verPos = tf.js.GetNonEmptyString(settings.verpos, tf.consts.positioningBottom);
    var isLeft, isCenterHor, isTop, isCenterVer;
    var strokeFunction, iconAnchor = [0.5, 0.5];
    switch (horPos.toLowerCase()) {
        default:
        case tf.consts.positioningCenter: isCenterHor = true; isLeft = false; iconAnchor[0] = 0.5; break;
        case tf.consts.positioningLeft: isCenterHor = false; isLeft = true; iconAnchor[0] = 1; break;
        case tf.consts.positioningRight: isCenterHor = false; isLeft = false; iconAnchor[0] = 0; break;
    }
    switch (verPos.toLowerCase()) {
        case tf.consts.positioningCenter: isCenterVer = true; isTop = false; iconAnchor[1] = 0.5; break;
        case tf.consts.positioningTop: isCenterVer = false; isTop = true; iconAnchor[1] = 1; break;
        case tf.consts.positioningBottom: isCenterVer = false; isTop = false; iconAnchor[1] = 0; break;
    }
    var label = tf.js.GetNonEmptyString(settings.label, '');
    var textStrokeColor = settings.line_color != null ? settings.line_color : "0xFFFFFF";
    var textStrokeOpac = settings.line_opacity != null ? settings.line_opacity : 0.2;
    var textStrokeWidth = settings.line_width != null ? settings.line_width : 0;
    var textFillColor = settings.font_color != null ? settings.font_color : "0x000000";
    var textFillOpac = settings.font_opacity != null ? settings.font_opacity : 1.0;
    var olTextStrokeColor = tf.js.GetRGBAColor(textStrokeColor, textStrokeColor, textStrokeOpac);
    var olTextFillColor = tf.js.GetRGBAColor(textFillColor, textFillColor, textFillOpac);
    var bgStrokeColor = settings.border_line_color != null ? settings.border_line_color : "0x000000";
    var bgStrokeOpac = settings.border_line_opacity != null ? settings.border_line_opacity : 1.0;
    var bgStrokeWidth = settings.border_line_width != null ? settings.border_line_width : 2;
    var bgFillColor = settings.fill_color != null ? settings.fill_color : "0xffb27f";
    var bgFillOpac = settings.fill_opacity != null ? settings.fill_opacity : 1.0;
    var olBGStrokeColor = tf.js.GetRGBAColor(bgStrokeColor, bgStrokeColor, bgStrokeOpac);
    var olBGFillColor = tf.js.GetRGBAColor(bgFillColor, bgFillColor, bgFillOpac);
    var styles = tf.GetStyles(), subStyles = styles.GetSubStyles();
    var defaultFontHeighPX = subStyles.markerFontSizePXNumber;
    var aFontHeightPX = settings.font_height != null ? tf.js.GetIntNumberInRange(settings.font_height, 8, 20, defaultFontHeighPX) : defaultFontHeighPX;
    var defaultFontName = subStyles.markerFontFamily;
    var aFontName = typeof settings.font === "string" && settings.font.length ? settings.font : defaultFontName;
    var aFont = aFontHeightPX + "px " + aFontName;
    var arrow_length = settings.arrow_length ? settings.arrow_length : 12;
    var marginPix = 2;
    var marginL = marginPix, marginR = marginPix, marginT = marginPix + 1, marginB = marginPix - 1, marginX = marginL + marginR, marginY = marginT + marginB;
    ctx.font = aFont;
    ctx.strokeStyle = olTextStrokeColor;
    ctx.lineWidth = textStrokeWidth;
    ctx.fillStyle = olTextFillColor;
    if (!settings.dontTranslate) { ctx.translate(0.5, 0.5); }
    var wText = ctx.measureText(label).width;
    var hText = aFontHeightPX /*+ textStrokeWidth*/;
    var textL = marginL + textStrokeWidth / 2;
    var textT = marginT /*+ textStrokeWidth / 2*/;
    var textBubbleW = wText + marginX + textStrokeWidth;
    var textBubbleH = hText + marginY + textStrokeWidth;
    textL += bgStrokeWidth / 2;
    textT += bgStrokeWidth / 2;
    textBubbleW += 2 * bgStrokeWidth;
    textBubbleH += 2 * bgStrokeWidth;
    var canvasW = textBubbleW - bgStrokeWidth + 1;
    var canvasH = textBubbleH + arrow_length - bgStrokeWidth;
    var xStrokeCoord = bgStrokeWidth / 2;
    var yStrokeCoord = bgStrokeWidth / 2;
    if (isLeft) {
        if (isTop) {
            strokeFunction = tf.canvas.StrokeFillBubbleRB;
        }
        else if (isCenterVer) {
            strokeFunction = tf.canvas.StrokeFillBubbleMidR;
            canvasW += arrow_length;
            canvasH -= arrow_length;
        }
        else {
            strokeFunction = tf.canvas.StrokeFillBubbleRT;
            yStrokeCoord += arrow_length;
            textT += arrow_length;
        }
    }
    else if (isCenterHor) {
        if (isTop) {
            strokeFunction = tf.canvas.StrokeFillBubbleMidB;
        }
        else if (isCenterVer) {
            strokeFunction = tf.canvas.StrokeFillRoundRect;
            canvasH -= arrow_length;
        }
        else {
            strokeFunction = tf.canvas.StrokeFillBubbleMidT;
            yStrokeCoord += arrow_length;
            textT += arrow_length;
        }
    }
    else {
        if (isTop) {
            strokeFunction = tf.canvas.StrokeFillBubbleLB;
        }
        else if (isCenterVer) {
            strokeFunction = tf.canvas.StrokeFillBubbleMidL;
            canvasW += arrow_length;
            canvasH -= arrow_length;
            xStrokeCoord += arrow_length;
            textL += arrow_length;
        }
        else {
            strokeFunction = tf.canvas.StrokeFillBubbleLT;
            yStrokeCoord += arrow_length;
            textT += arrow_length;
        }
    }
    var radius = tf.js.NumberClip((hText + marginY) * 0.35, 1, 10000);
    ctx.canvas.width = canvasW;
    ctx.canvas.height = canvasH;
    ctx.font = aFont;
    ctx.lineCap = "square";
    ctx.lineJoin = "round";
    ctx.beginPath();
    ctx.clearRect(0, 0, canvasW, canvasH);
    //ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.strokeStyle = olBGStrokeColor;
    ctx.lineWidth = bgStrokeWidth;
    ctx.fillStyle = olBGFillColor;
    if (isCenterHor && isCenterVer) { tf.canvas.StrokeFillRoundRect(ctx, xStrokeCoord, yStrokeCoord, textBubbleW - 2 * bgStrokeWidth, textBubbleH - 2 * bgStrokeWidth, radius, true, true, settings.dontTranslate); }
    else { strokeFunction(ctx, xStrokeCoord, yStrokeCoord, textBubbleW - 2 * bgStrokeWidth, textBubbleH - 2 * bgStrokeWidth, arrow_length, radius, settings.dontTranslate); }
    ctx.closePath();
    ctx.strokeStyle = olTextStrokeColor;
    ctx.lineWidth = textStrokeWidth;
    ctx.fillStyle = olTextFillColor;
    ctx.textBaseline = 'top';
    if (textStrokeWidth > 0) {
        /*ctx.shadowColor = "rgb(164,164,164)";
        ctx.shadowBlur = 7;*/
        ctx.strokeText(label, textL, textT);
        //ctx.shadowBlur = 0;
    }
    ctx.fillText(label, textL, textT);
    return iconAnchor;
}
/**
 * A callback that can be used with the function [CreateMemoryImage]{@link tf.canvas.CreateMemoryImage}
 * @public
 * @callback tf.types.CreateMemoryImageDrawFunction
 * @param {canvasContext} ctx - context to draw on
 * @param {object} settings - draw settings whose contents vary depending on the callback
 * @returns {tf.types.iconAnchor} - | {@link tf.types.iconAnchor} the drawing's anchor
*/
/**
 * Object returned by the function [CreateMemoryImage]{@link tf.canvas.CreateMemoryImage}
 * @public
 * @typedef tf.types.CreateMemoryImageResult
 * @property {string} image - an HTML string that can be used in places where an <b>img</b> can be used
 * @property {tf.types.iconAnchor} anchor - the image's anchor
*/
/**
 * @public
 * @function
 * @summary - Uses the given callback to draw arbitrary content on the returned memory image, created with <b>toDataURL</b>
 * @param {object} settings - image creation settings
 * @param {tf.types.CreateMemoryImageDrawFunction} settings.drawFunction - the callback to draw content
 * @param {object} settings.drawSettings - object passed to <b>drawFunction</b>
 * @returns {tf.types.CreateMemoryImageResult} - | {@link tf.types.CreateMemoryImageResult} the image and it's anchor
*/
tf.canvas.CreateMemoryImage = function (settings) {
    settings = tf.js.GetValidObjectFrom(settings);
    var drawFunction = tf.js.GetFunctionOrNull(settings.drawFunction);
    var image, anchor;
    if (!!drawFunction) {
        //var useCanvas = !!settings.canvas ? settings.canvas : tf.GetStyles().GetHiddenCanvas();
        var useCanvas = document.createElement('canvas');
        var ctx = useCanvas.getContext("2d");
        //ctx.save();
        anchor = drawFunction(ctx, settings.drawSettings);
        //image = useCanvas.toDataURL("image/png");
        //image = ctx;
        //ctx.restore();
    }
    return { image: useCanvas, anchor: anchor };//{ image: image, anchor: anchor };
}
/**
 * method tf.canvas.PaintSlider - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} canvasElem - parameter description?
 * @param {?} width - parameter description?
 * @param {?} height - parameter description?
 * @param {?} thumbConstDim - parameter description?
 * @param {?} roundRectRadius - parameter description?
 * @param {?} backFillColor - parameter description?
 * @param {?} backStrokeColor - parameter description?
 * @param {?} thumbStrokeColor - parameter description?
 * @param {?} thumbFillColor - parameter description?
 * @param {?} thumbStrokeColorNoHover - parameter description?
 * @param {?} thumbFillColorNoHover - parameter description?
 * @param {?} mouseFillColor - parameter description?
 * @param {?} pos01 - parameter description?
 * @param {?} isInHover - parameter description?
 * @param {?} mouse01 - parameter description?
*/
tf.canvas.PaintSlider = function (
    canvasElem,
    width,
    height,
    thumbConstDim,
    roundRectRadius,
    backFillColor,
    backStrokeColor,
    thumbStrokeColor,
    thumbFillColor,
    thumbStrokeColorNoHover,
    thumbFillColorNoHover,
    mouseFillColor,
    pos01,
    isInHover,
    mouse01) {
    var fill = true;
    var stroke = true;
    canvasElem.width = width;
    canvasElem.height = height;
    var ctx = canvasElem.getContext("2d");
    ctx.save();
    ctx.translate(0.5, 0.5);
    ctx.canvas.width = width;
    ctx.canvas.height = height;
    ctx.beginPath();
    ctx.clearRect(0, 0, width, height);
    ctx.closePath();
    ctx.beginPath();
    ctx.fillStyle = backFillColor;
    ctx.strokeStyle = backStrokeColor;
    ctx.lineWidth = 2;
    tf.canvas.StrokeFillRoundRect(ctx, roundRectRadius / 2, roundRectRadius / 2, width - roundRectRadius, height - roundRectRadius, roundRectRadius, fill, stroke);
    ctx.closePath();
    var mid = Math.round(width * pos01);
    ctx.beginPath();
    if (isInHover) {
        var midMouse = Math.round(width * mouse01);
        ctx.lineWidth = 1;
        ctx.strokeStyle = "#fff";
        ctx.fillStyle = mouseFillColor;
        ctx.fillRect(midMouse - thumbConstDim + 1, 1, thumbConstDim + 1, height - 2);
        //ctx.strokeRect(midMouse - thumbConstDim, 1, thumbConstDim + 1, height - 2);
    }
    else {
        ctx.fillStyle = thumbStrokeColorNoHover;
        ctx.fillStyle = thumbFillColorNoHover;
        ctx.fillRect(2, 2, mid, height - 4);
    }
    ctx.closePath();
    ctx.lineWidth = 2;
    mid = Math.round(width * pos01);
    ctx.beginPath();
    ctx.strokeStyle = thumbStrokeColor;
    ctx.fillStyle = thumbFillColor;
    ctx.fillRect(mid - thumbConstDim + 1, 0, thumbConstDim + 1, height);
    //ctx.strokeRect(mid - thumbConstDim, 0, thumbConstDim + 1, height);
    ctx.closePath();
    ctx.restore();
};
/**
 * class tf.dom.Canvas - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
*/
tf.dom.Canvas = function () {
    var theThis = null, canvasElem = null, canvasCtx = null, repaintCallBack = null, repaintCallBackThis = null;
/**
 * method tf.dom.Canvas.Repaint - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.Repaint = function () { return paintCanvas(); }
/**
 * method tf.dom.Canvas.SetRepaint - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} repaintCallBackSet - parameter description?
 * @param {?} repaintCallBackThisSet - parameter description?
*/
    this.SetRepaint = function (repaintCallBackSet, repaintCallBackThisSet) {
        repaintCallBack = tf.js.GetFunctionOrNull(repaintCallBackSet);
        repaintCallBackThis = repaintCallBackThisSet;
    }
    function paintCanvas() {
        if (!!repaintCallBack) {
            var pixWidth = canvasElem.clientWidth; var pixHeight = canvasElem.clientHeight; canvasElem.width = pixWidth; canvasElem.height = pixHeight;
            canvasCtx.save(); repaintCallBack.call(repaintCallBackThis, theThis, canvasCtx, pixWidth, pixHeight); canvasCtx.restore();
        }
    }
    function initialize() {
        var divObj = new tf.dom.Div({ cssClass: tf.GetStyles().GetUnPaddedDivClassNames(false, true) });
        canvasElem = document.createElement('canvas');
        canvasElem.style.width = '100%';
        canvasElem.style.height = '100%';
        canvasCtx = canvasElem.getContext("2d");
        divObj.AddContent(canvasElem);
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: divObj.GetHTMLElement() });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
}
tf.js.InheritFrom(tf.dom.Canvas, tf.dom.Insertable);
/**
 * class tf.ui.CanvasSlider - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} initPos01 - parameter description?
 * @param {?} controlHeight - parameter description?
 * @param {?} hoverDrawBool - parameter description?
*/
tf.ui.CanvasSlider = function (initPos01, controlHeight, hoverDrawBool) {
    var theThis = null;
    var styles = tf.GetStyles();
    var paintSlider = tf.canvas.PaintSlider;
    var slideConstDim = controlHeight ? controlHeight : "0.8em";
    var thumbConstDim = 4;
    var divObj = null;
    var divElem = null;
    var canvasElem = null;
    var pos01 = null;
    var hover01 = null;
    var mouse01 = null;
    var thumbFillColorHover = "#FFF", thumbStrokeColorHover = styles.GetButtonBGColor(true), backFillColorHover = styles.GetButtonBGColor(true), backStrokeColorHover = "#333";
    var thumbFillColorNoHover = styles.GetButtonBGColor(true), thumbStrokeColorNoHover = styles.GetButtonBGColor(true), backFillColorNoHover = "#fff", backStrokeColorNoHover = "#bfbfbf";
    var thumbFillColor = thumbFillColorNoHover, thumbStrokeColor = thumbStrokeColorNoHover, backFillColor = backFillColorHover, backStrokeColor = backStrokeColorHover;
    var mouseFillColor = styles.GetSubStyles().disabledTextColor;
    var mouseMoveCallBack = null, thisMouseMoveCallBack = null;
    var clickCallBack = null, thisClickCallBack = null;
    var hoverCallBack = null, thisHoverCallBack = null;
    var hoverListener = null;
    var isInHover = false;
    var isInDrag = false;
/**
 * method tf.ui.CanvasSlider.GetIsInDrag - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetIsInDrag = function () { return isInDrag; }
/**
 * method tf.ui.CanvasSlider.GetIsInHover - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetIsInHover = function () { return isInHover; }
/**
 * method tf.ui.CanvasSlider.GetHover01 - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetHover01 = function () { return hover01; }
/**
 * method tf.ui.CanvasSlider.GetMouse01 - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetMouse01 = function () { return mouse01; }
/**
 * method tf.ui.CanvasSlider.SetOnClickListener - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} theCallBack - parameter description?
 * @param {?} theThisForCallBack - parameter description?
*/
    this.SetOnClickListener = function (theCallBack, theThisForCallBack) {
        clickCallBack = typeof theCallBack === "function" ? theCallBack : null;
        thisClickCallBack = theThisForCallBack;
    }
/**
 * method tf.ui.CanvasSlider.SetOnHoverListener - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} theCallBack - parameter description?
 * @param {?} theThisForCallBack - parameter description?
*/
    this.SetOnHoverListener = function (theCallBack, theThisForCallBack) {
        hoverCallBack = typeof theCallBack === "function" ? theCallBack : null;
        thisHoverCallBack = theThisForCallBack;
    }
/**
 * method tf.ui.CanvasSlider.SetOnMouseMoveListener - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} theCallBack - parameter description?
 * @param {?} theThisForCallBack - parameter description?
*/
    this.SetOnMouseMoveListener = function (theCallBack, theThisForCallBack) {
        mouseMoveCallBack = typeof theCallBack === "function" ? theCallBack : null;
        thisMouseMoveCallBack = theThisForCallBack;
    }
/**
 * method tf.ui.CanvasSlider.Repaint - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.Repaint = function () { paintCanvas(); }
/**
 * method tf.ui.CanvasSlider.SetPos01 - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} pos01Set - parameter description?
*/
    this.SetPos01 = function (pos01Set) { return setPos01(pos01Set, true); }
/**
 * method tf.ui.CanvasSlider.GetPos01 - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetPos01 = function () { return pos01; }
/**
 * method tf.ui.CanvasSlider.SetColors - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} thumbFillColorSet - parameter description?
 * @param {?} thumbStrokeColorSet - parameter description?
 * @param {?} backFillColorSet - parameter description?
 * @param {?} backStrokeColorSet - parameter description?
*/
    this.SetColors = function (thumbFillColorSet, thumbStrokeColorSet, backFillColorSet, backStrokeColorSet) { return setColors(thumbFillColorSet, thumbStrokeColorSet, backFillColorSet, backStrokeColorSet); }
/**
 * method tf.ui.CanvasSlider.SetMouseFillColor - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} mouseFillColorSet - parameter description?
*/
    this.SetMouseFillColor = function (mouseFillColorSet) { mouseFillColor = mouseFillColorSet; paintCanvas(); }
    function setColors(thumbFillColorSet, thumbStrokeColorSet, backFillColorSet, backStrokeColorSet) {
        thumbFillColor = thumbFillColorSet;
        thumbStrokeColor = thumbStrokeColorSet;
        backFillColor = backFillColorSet;
        backStrokeColor = backStrokeColorSet;
    }
    function setPos01(pos01Set, doRepaint) {
        pos01 = tf.js.GetFloatNumberInRange(pos01Set, 0, 1, 0.5);
        if (doRepaint) { paintCanvas(); }
    }
    function setPosSlideColors(hoverColorsBool) {
        if (!!hoverColorsBool && hoverDrawBool) {
            setColors(thumbFillColorHover, thumbStrokeColorHover, backFillColorHover, backStrokeColorHover);
        }
        else {
            setColors(thumbFillColorNoHover, thumbStrokeColorNoHover, backFillColorNoHover, backStrokeColorNoHover);
        }
    }
    function paintCanvas() {
        var roundRectRadius = 2;
        paintSlider(canvasElem, divElem.clientWidth, divElem.clientHeight, thumbConstDim, roundRectRadius,
            backFillColor, backStrokeColor, thumbStrokeColor, thumbFillColor, thumbStrokeColorNoHover, thumbFillColorNoHover, mouseFillColor,
            pos01, isInHover && !isInDrag && hoverDrawBool, mouse01);
    }
    function notifyPos01Change() { if (clickCallBack) { clickCallBack.call(thisClickCallBack, theThis, pos01); } }
    function onMouseEvent(ev) {
        var mousePosXY = tf.events.GetMouseEventCoords(ev);
        var width = divElem ? divElem.offsetWidth : 0;
        var click01 = width ? mousePosXY[0] / width : 0;
        if (isInDrag) { if (click01 != pos01) { setPos01(click01, true); notifyPos01Change(); } }
        else if (click01 != mouse01) { mouse01 = click01; }
        if (mouseMoveCallBack) {
            mouseMoveCallBack.call(thisClickCallBack, theThis, mouse01);
        }
    }
    function onMouseDnSlide(ev) { isInDrag = true; onMouseEvent(ev); }
    function onMouseUpSlide(ev) { isInDrag = false; onMouseEvent(ev); }
    function onMouseMoveSlide(ev) { onMouseEvent(ev); }
    var wasInHover = false;
    function onHover() {
        if (isInHover = hoverListener.GetIsInHover()) {
            isInDrag = false;
        }
        setPosSlideColors(isInHover);
        if (wasInHover != isInHover) {
            wasInHover = isInHover;
            paintCanvas();
        }
        var mousePosXY = tf.events.GetMouseEventCoords(hoverListener.GetLastEvent());
        var width = divElem ? divElem.offsetWidth : 0;
        var click01 = width ? mousePosXY[0] / width : 0;
        if (click01 != hover01) {
            hover01 = click01;
            if (hoverCallBack) { hoverCallBack.call(thisHoverCallBack, theThis, hover01); }
        }
    }
    function initialize() {
        hoverDrawBool = !!hoverDrawBool;
        divObj = new tf.dom.Div({ cssClass: styles.unPaddedBlockDivClass });
        divElem = divObj.GetHTMLElement();
        canvasElem = document.createElement('canvas');
        canvasElem.style.width = '100%';
        canvasElem.style.height = '100%';
        divElem.style.height = slideConstDim;
        divElem.style.width = "1px";
        var listeners = {
            "mousemove": onMouseMoveSlide,
            "mouseup": onMouseUpSlide,
            "mousedown": onMouseDnSlide
        };
        for (var i in listeners) { tf.events.AddDOMEventListener(divElem, i, listeners[i]); }
        hoverListener = new tf.events.DOMHoverListener({ target: divElem, callBack: onHover, optionalScope: theThis, callBackSettings: null });
        setPos01(initPos01, false);
        setPosSlideColors(false);
        divObj.AddContent(canvasElem);
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: divObj });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.ui.CanvasSlider, tf.dom.Insertable);
/**
 * method tf.urlapi.NormalizeJSONProperties - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} properties - parameter description?
*/
tf.urlapi.NormalizeJSONProperties = function (properties) {
    if (!!properties) {
        if (properties.Latitude != undefined) { properties.lat = properties.Latitude; delete properties.Latitude; }
        else if (properties.latitude != undefined) { properties.lat = properties.latitude; delete properties.latitude; }
        if (properties.Longitude != undefined) { properties.lon = properties.Longitude; delete properties.Longitude; }
        else if (properties.longitude != undefined) { properties.lon = properties.longitude; delete properties.longitude; }
    }
    return properties;
}
/**
 * method tf.urlapi.NormalizeFieldID - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} fieldIDStr - parameter description?
*/
tf.urlapi.NormalizeFieldID = function (fieldIDStr) {
    fieldIDStr = typeof fieldIDStr === "string" ? fieldIDStr.toLowerCase().trim() : "";
    return fieldIDStr === "latitude" ? "lat" : (fieldIDStr === "longitude" ? "lon" : fieldIDStr);
}
/**
 * class tf.urlapi.TabDelimitedDataParser - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
*/
tf.urlapi.TabDelimitedDataParser = function () {
    var fields = [];
    var dataSet = [];
    var delimitorFieldContent = "==";
    var delimitorContentSTATS = "===";
/**
 * method tf.urlapi.TabDelimitedDataParser.ParseData - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} dataStr - parameter description?
 * @param {?} fieldsFilter - parameter description?
*/
    this.ParseData = function (dataStr, fieldsFilter) {
        fields = [];
        dataSet = [];
        var data = dataStr.substring(dataStr.indexOf(delimitorFieldContent) + 4, dataStr.indexOf(delimitorContentSTATS) - 1);
        var lines = data.split('\n');
        var fieldsList = dataStr.slice(dataStr.indexOf("\r\n=\r\n") + 5, dataStr.indexOf("\r\n==\r\n"));
        fields = fieldsList.split('\t');
        var fieldsCount = fields.length;
        if (fieldsCount == 700 && fields[699] == "offset") fieldsCount -= 1;
        var normalizeFnc = tf.urlapi.NormalizeFieldID;
        var getStringFnc = tf.js.GetNonEmptyString;
        typeof fieldsFilter === "object" || (fieldsFilter = undefined) ;
        var fieldsFilterIndices = [];
        var fieldsFilterLen = fieldsFilter !== undefined ? fieldsFilter.length : 0;
        for (var iField = 0 ; iField < fieldsCount ; iField++) {
            var thisField = normalizeFnc(fields[iField]);
            fields[iField] = thisField ;
            for (var i = 0 ; i < fieldsFilterLen ; i++) {
                var thisFilter = fieldsFilter[i];
                if (thisField == thisFilter) {
                    fieldsFilterIndices.push(iField);
                }
            }
        }
        var iDataLine = 0, nLines = lines.length;
        for (var iLine = 0; iLine < nLines; ++iLine)//for each line
        {
            var thisLine = lines[iLine].trim();
            if (thisLine.length > 0) {
                var record = thisLine.split('\t');
                if (fieldsCount == record.length) {
                    var recordSet = [];
                    if (fieldsFilterLen == 0) {
                        for (var iField = 0; iField < fieldsCount; ++iField) {
                            var fieldID = fields[iField];
                            var fieldValue = getStringFnc(record[iField]);
                            if (fieldValue) { recordSet[fieldID] = fieldValue; }
                        }
                    }
                    else {
                        for (var i = 0; i < fieldsFilterLen ; ++i) {
                            var iField = fieldsFilterIndices[i];
                            var fieldID = fields[iField];
                            var fieldValue = getStringFnc(record[iField]);
                            if (fieldValue) { recordSet[fieldID] = fieldValue; }
                        }
                    }
                    dataSet[iDataLine++] = recordSet;
                }
            }
        }
    }
/**
 * method tf.urlapi.TabDelimitedDataParser.GetFields - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetFields = function () { return fields; }
/**
 * method tf.urlapi.TabDelimitedDataParser.GetFieldName - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} index - parameter description?
*/
    this.GetFieldName = function (index) { return fields[index]; }
/**
 * method tf.urlapi.TabDelimitedDataParser.GetNFields - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetNFields = function () { return fields.length ;}
/**
 * method tf.urlapi.TabDelimitedDataParser.GetFieldIndex - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} fieldName - parameter description?
*/
    this.GetFieldIndex = function (fieldName) {
        var index = -1 ;
        if (typeof fieldName === "string" && fieldName.length > 0) {
            index = fields.indexOf(fieldName.toLowerCase().trim());
        }
        return index;
    }
/**
 * method tf.urlapi.TabDelimitedDataParser.GetDataSet - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetDataSet = function () { return dataSet; }
/**
 * method tf.urlapi.TabDelimitedDataParser.GetNRecords - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetNRecords = function () { return dataSet.length;}
/**
 * method tf.urlapi.TabDelimitedDataParser.GetRecord - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} index - parameter description?
*/
    this.GetRecord = function (index) { index = tf.js.GetNonNegativeIntFrom(index); return index < this.GetNRecords () ? dataSet[index] : null; }
};
/**
 * A callback function that listens to events notified by [App Container Sizer]{@link tf.layout.AppContainerSizer} instances
 * @public
 * @callback tf.types.AppContainerSizerCallBack
 * @param {object} notification - the notification
 * @param {tf.layout.AppContainerSizer} notification.sender - the instance sending the notification
 * @param {tf.types.pixelCoordinates} notification.dims - the current dimensions of the container
 * @returns {void} - | {@link void} no return value
 */
/**
 * @public
 * @class
 * @summary A {@link singleton} instance of App Container Sizer is created by an application to automatically resize its
 * top container when the Browser window changes size. App Container Sizer automatically notifies layout changes to an arbitrary number 
 * of [maps]{@link tf.map.Map} and event listeners
 * @param {object} settings - creation settings
 * @param {HTMLElementLike} settings.container - Mandatory property, the top application container
 * @param {boolean} settings.fitContainerToWindow - if <b>true</b> the <b>container</b> is resized to match the Browser window size, 
 * set to <b>false</b> when the application is running in a sub-container, defaults to <b>true</b>
 * @param {string} settings.documentTitle - if defined, sets the HTML document's <b>title</b>
 * @param {tf.types.AppContainerSizerCallBack} settings.onResize - optional callback for resize events
 */
tf.layout.AppContainerSizer = function (settings) {
    var theThis, fitContainerToWindow, onResizeDelayCallBack, onMapResizeDelayCallBack, container, containerElem, maps, resizeListeners;
    /**
     * @public
     * @function
     * @summary - Retrieves the {@link HTMLElementLike} container associated with this instance
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the container
    */
    this.GetContainer = function () { return container; }
    /**
     * @public
     * @function
     * @summary - Programmatically triggers a resize, executing the same logic as when the Browser window changes size, including notifying map instances and listeners
     * @returns {void} - | {@link void} no return value
    */
    this.OnResize = function () { return onDelayedResize(); }
    /**
     * @public
     * @function
     * @summary - Programmatically triggers map size updates, does not notify listeners
     * @returns {void} - | {@link void} no return value
    */
    this.UpdateMapSizes = function () { return onDelayedMapResize(); }
    /**
     * @public
     * @function
     * @summary - Adds a callback listener for resize events
     * @param {tf.types.AppContainerSizerCallBack} callBack - the callback for event notifications
     * @returns {tf.events.EventListener} - | {@link tf.events.EventListener} the event listener
    */
    this.AddResizeListener = function (callBack) { return resizeListeners.Add(callBack); }
    /**
     * @public
     * @function
     * @summary - Adds the given [map]{@link tf.map.Map} to the list of maps that are notified of resize events
     * @param {tf.map.Map} map - the given map
     * @returns {void} - | {@link void} no return value
    */
    this.AddMap = function (map) { return addMap(map); }
    /**
     * @public
     * @function
     * @summary - Removes the given [map]{@link tf.map.Map} from the list of maps that are notified of resize events
     * @param {tf.map.Map} map - the given map
     * @returns {void} - | {@link void} no return value
    */
    this.DelMap = function (map) { return delMap(map); }
    function addMap(map) { if (!!(map = tf.js.GetMapFrom(map))) { var id = map.GetID(); if (!maps[id]) { maps[id] = map; } } }
    function delMap(map) { if (!!(map = tf.js.GetMapFrom(map))) { var id = map.GetID(); if (!!maps[id]) { delete maps[id]; } } }
    function updateMapSizes() {
        for (var i in maps) { maps[i].OnResize(); }
    }
    function onResize() {
        if (!!container) {
            var winW, winH;
            if (fitContainerToWindow) { var winDims = tf.dom.FitContainerToWindowDims(container); winW = winDims[0]; winH = winDims[1]; }
            else { winW = containerElem.clientWidth; winH = containerElem.clientHeight; }
            resizeListeners.Notify({ sender: theThis, dims: [winW, winH] });
            onDelayedMapResize();
            //updateMapSizes();
        }
    }
    function onDelayedResize() {
        if (!!onResizeDelayCallBack) {
            onResizeDelayCallBack.DelayCallBack();
        }
    }
    function onDelayedMapResize() {
        updateMapSizes();
        if (!!onMapResizeDelayCallBack) {
            onMapResizeDelayCallBack.DelayCallBack();
        }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings); maps = {}; resizeListeners = new tf.events.EventNotifier();
        fitContainerToWindow = tf.js.GetBoolFromValue(settings.fitContainerToWindow, true);
        if (tf.js.GetIsNonEmptyString(settings.documentTitle)) { document.title = settings.documentTitle; tf.GetStyles().AddBodyStyle(); }
        if (containerElem = tf.dom.GetHTMLElementFrom(container = settings.container)) {
            /*if (fitContainerToWindow) {*/
                resizeListeners.Add(settings.onResize);
                onResizeDelayCallBack = new tf.events.DelayedCallBack(250, onResize);
                onMapResizeDelayCallBack = new tf.events.DelayedCallBack(250, updateMapSizes);
                tf.events.AddDOMEventListener(window, tf.consts.DOMEventNamesResize, onDelayedResize);
                new tf.events.DOMFullScreenChangeListener({ callBack: onDelayedResize, optionalScope: theThis });
                if (!!settings.useUpdateSizesInterval) {
                    setInterval(updateMapSizes, 5000);
                }
            //}
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * @public
 * @class
 * @summary Single Pane is an [Insertable]{@link tf.dom.Insertable} implementing a layout with a single pane
 * @extends {tf.dom.Insertable}
 */
tf.layout.SinglePane = function () {
    var theThis, container;
    /**
     * @public
     * @function
     * @summary - Retrieves the {@link HTMLElementLike} container associated with this instance
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the container
    */
    this.GetContainer = function () { return container; }
    function initialize() {
        container = new tf.dom.Div({ cssClass: tf.GetStyles().appContainerClass });
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: container });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.layout.SinglePane, tf.dom.Insertable);
/**
 * @public
 * @class
 * @summary Top Bot is an [Insertable]{@link tf.dom.Insertable} implementing a layout with a top pane and a bottom pane
 * @extends {tf.dom.Insertable}
 */
tf.layout.TopBot = function () {
    var theThis = null, container = null, top = null, bot = null;
    /**
     * @public
     * @function
     * @summary - Retrieves the {@link HTMLElementLike} container associated with this instance
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the container
    */
    this.GetContainer = function () { return container; }
    /**
     * @public
     * @function
     * @summary - Retrieves the top pane {@link HTMLElementLike} container
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the container
    */
    this.GetTop = function () { return top; }
    /**
     * @public
     * @function
     * @summary - Retrieves the bottom pane {@link HTMLElementLike} container
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the container
    */
    this.GetBot = function () { return bot; }
    function initialize() {
        var styles = tf.GetStyles();
        var unpaddedBlockDivClass = styles.unpaddedBlockDivClass;
        (container = new tf.dom.Div({ cssClass: styles.appContainerClass })).AddContent(
            top = new tf.dom.Div({ cssClass: unpaddedBlockDivClass }),
            bot = new tf.dom.Div({ cssClass: unpaddedBlockDivClass }));
        bot.GetHTMLElement().style.position = top.GetHTMLElement().style.position = "relative";
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: container.GetHTMLElement() });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.layout.TopBot, tf.dom.Insertable);
/**
 * @public
 * @class
 * @summary Left Right is an [Insertable]{@link tf.dom.Insertable} implementing a layout with two side by side panes
 * @extends {tf.dom.Insertable}
 */
tf.layout.LeftRight = function () {
    var theThis = null, container = null, left = null, right = null;
    /**
     * @public
     * @function
     * @summary - Retrieves the {@link HTMLElementLike} container associated with this instance
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the container
    */
    this.GetContainer = function () { return container; }
    /**
     * @public
     * @function
     * @summary - Retrieves the left pane {@link HTMLElementLike} container
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the container
    */
    this.GetLeft = function () { return left; }
    /**
     * @public
     * @function
     * @summary - Retrieves the right pane {@link HTMLElementLike} container
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the container
    */
    this.GetRight = function () { return right; }
    function initialize() {
        var styles = tf.GetStyles();
        (container = new tf.dom.Div({ cssClass: styles.appContainerClass })).AddContent(
            right = new tf.dom.Div({ cssClass: styles.rightSideContainerClass }),
            left = new tf.dom.Div({ cssClass: styles.leftSideContainerClass }));
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: container.GetHTMLElement() });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.layout.LeftRight, tf.dom.Insertable);
/**
 * @public
 * @class
 * @summary Left Mid Right is an [Insertable]{@link tf.dom.Insertable} implementing a layout with three side by side panes
 * @extends {tf.dom.Insertable}
 */
tf.layout.LeftMidRight = function () {
    var theThis, container, left, mid, right;
    /**
     * @public
     * @function
     * @summary - Retrieves the {@link HTMLElementLike} container associated with this instance
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the container
    */
    this.GetContainer = function () { return container; }
    /**
     * @public
     * @function
     * @summary - Retrieves the left pane {@link HTMLElementLike} container
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the container
    */
    this.GetLeft = function () { return left; }
    /**
     * @public
     * @function
     * @summary - Retrieves the middle pane {@link HTMLElementLike} container
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the container
    */
    this.GetMid = function () { return mid; }
    /**
     * @public
     * @function
     * @summary - Retrieves the right pane {@link HTMLElementLike} container
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the container
    */
    this.GetRight = function () { return right; }
    function initialize() {
        var styles = tf.GetStyles();
        (container = new tf.dom.Div({cssClass: styles.appContainerClass})).AddContent(
            right = new tf.dom.Div({cssClass: styles.rightSideContainerClass}),
            left = new tf.dom.Div({cssClass: styles.floatLeftSideContainerClass}),
            mid = new tf.dom.Div({ cssClass: styles.leftSideContainerClass }));
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: container.GetHTMLElement() });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.layout.LeftMidRight, tf.dom.Insertable);
/**
 * A callback function that listens to events notified by [Left Separator Right]{@link tf.layout.LeftSeparatorRight} instances
 * @public
 * @callback tf.types.LeftSeparatorRightCallBack
 * @param {object} notification - the notification
 * @param {tf.layout.LeftSeparatorRight} notification.sender - the instance sending the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * @public
 * @class
 * @summary Left Separator Right is an [Insertable]{@link tf.dom.Insertable} implementing a layout with two side by side panes and a vertical separator betweeen them. 
 * Its variable width right side pane is programmatically collapsible, and automatically toggles its collapsed state in response to [click]{@link tf.consts.DOMEventNamesClick} events
 * @param {object} settings - creation settings
 * @param {tf.types.LeftSeparatorRightCallBack} settings.onLayoutChange - optional callback to receive layout change notifications
 * @param {object} settings.optionalScope - optional scope used with <b>onLayoutChange</b>
 * @param {tf.types.CSSStyleSpecs} settings.separatorStyle - optional CSS style specifications to be applied to the vertical separator
 * @param {boolean} settings.initiallyCollapsed - if set to <b>false</b> starts with the right pane uncollapsed, if <b>true</b> or <b>void</b> the right side starts collapsed
 * @extends {tf.dom.Insertable}
 */
tf.layout.LeftSeparatorRight = function (settings) {
    var theThis, onLayoutChangeCallBack, optionalScope, styles, isCollapsed;
    var containerAll, containerAllObj;
    var leftSideContainerObj, leftSideContainer;
    var leftRightSideSeparatorObj, leftRightSideSeparator;
    var rightSideContainerObj, rightSideContainer;
    var onClick, rightIsShowing;
    /**
     * @public
     * @function
     * @summary - Retrieves the {@link HTMLElementLike} container associated with this instance
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the container
    */
    this.GetContainer = function () { return containerAllObj; }
    /**
     * @public
     * @function
     * @summary - Retrieves the left pane {@link HTMLElementLike} container
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the container
    */
    this.GetLeft = function () { return leftSideContainerObj; }
    /**
     * @public
     * @function
     * @summary - Retrieves the right pane {@link HTMLElementLike} container
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the container
    */
    this.GetRight = function () { return rightSideContainerObj; }
    /**
     * @public
     * @function
     * @summary - Determines if the right side pane is currently collapsed
     * @returns {bool} - | {@link bool} <b>true</b> if yes, <b>false</b> otherwise
    */
    this.GetIsRightSideCollapsed = function () { return isCollapsed; }
    /**
     * @public
     * @function
     * @summary - Toggles the right side pane's collapsed status
     * @returns {void} - | {@link void} no return value
    */
    this.ToggleRightSideCollapsed = function () { onClickSeparator(); }
    /**
     * @public
     * @function
     * @summary - Sets the right side pane's collapsed status
     * @param {boolean} bool - set to <b>true</b> to collapse the right side pane, <b>false</b> to expand it
     * @returns {void} - | {@link void} no return value
    */
    this.SetRightSideCollapsed = function (bool) { return setRightSideCollapsed(bool); }
    function notifyLayoutChange() { if (!!onLayoutChangeCallBack) { onLayoutChangeCallBack.call(settings.optionalScope, { sender: theThis }); } }
    function onClickSeparator(notification) { isCollapsed = !isCollapsed; updatePaneVisibility(); notifyLayoutChange(); }
    function setRightSideCollapsed(bool) { isCollapsed = !!bool; updatePaneVisibility(); notifyLayoutChange(); }
    function updatePaneVisibility() {
        if (!!containerAll) {
            var separatorWillShow = true;
            var rightWillShow = separatorWillShow && (!isCollapsed);
            rightIsShowing = rightWillShow;
            leftRightSideSeparator.style.display = separatorWillShow ? 'block' : 'none';
            rightSideContainer.style.display = rightWillShow ? 'block' : 'none';
            leftRightSideSeparator.title = rightWillShow ? "Collapse" : "Restore";
        }
       
    }
    function initialize() {
        styles = tf.GetStyles();
        isCollapsed = true;
        rightIsShowing = false;
        settings = tf.js.GetValidObjectFrom(settings);
        onLayoutChangeCallBack = tf.js.GetFunctionOrNull(settings.onLayoutChange);
        containerAll = (containerAllObj = new tf.dom.Div({ cssClass: styles.appContainerClass })).GetHTMLElement();
        leftSideContainerObj = new tf.dom.Div({ cssClass: styles.leftSideContainerClass });
        leftSideContainer = leftSideContainerObj.GetHTMLElement();
        leftRightSideSeparatorObj = new tf.dom.Div({ cssClass: styles.leftRightSideSeparatorClass });
        leftRightSideSeparator = leftRightSideSeparatorObj.GetHTMLElement();
        onClick = new tf.events.DOMClickListener({ target: leftRightSideSeparator, callBack: onClickSeparator, optionalScope: theThis, callBackSettings: null });
        rightSideContainerObj = new tf.dom.Div({ cssClass: styles.rightSideContainerClass });
        rightSideContainer = rightSideContainerObj.GetHTMLElement();
        rightSideContainerObj.AppendTo(containerAllObj);
        leftRightSideSeparatorObj.AppendTo(containerAllObj);
        leftSideContainerObj.AppendTo(containerAllObj);
        if (tf.js.GetIsValidObject(settings.separatorStyle)) {
            styles.ApplyStyleProperties(leftRightSideSeparatorObj, settings.separatorStyle);
        }
        if (tf.js.GetIsFalseNotUndefined(settings.initiallyCollapsed)) {
            isCollapsed = false;
        }
        updatePaneVisibility();
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: containerAllObj });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
}
tf.js.InheritFrom(tf.layout.LeftSeparatorRight, tf.dom.Insertable);
/**
 * A callback function that listens to events notified by [Header Content Footer]{@link tf.layout.HeaderContentFooter} instances
 * @public
 * @callback tf.types.HeaderContentFooterCallBack
 * @param {object} notification - the notification
 * @param {tf.layout.HeaderContentFooter} notification.sender - the instance sending the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * @public
 * @class
 * @summary Header Content Footer is an [Insertable]{@link tf.dom.Insertable} implementing a vertical layout divided into Header, Content, and Footer panes.
 * Its width is variable, depending on the content if its panes, and it assumes the full height of its container. The Header pane displays the TerraFly logo along with an optional application defined
 * logo, and may contain an arbitrary number of application defined add-ons such as options, toolbars, and information panels.
 * The Content pane stretches the midsection of the layout and is suitable for displaying application defined scrollable content, such as [Keyed Table]{@link tf.ui.KeyedTable} instances,
 * or plain [Table]{@link tf.ui.Table} instances. The Footer pane is positioned at the bottom of the layout, its visibility status automatically adjusts to changes in the height of the layout,
 * and can be programmatically controlled
 * @param {object} settings - creation settings
 * @param {tf.types.HeaderContentFooterCallBack} settings.onLayoutChange - optional callback to receive layout change notifications
 * @param {object} settings.optionalScope - optional scope used with <b>onLayoutChange</b>
 * @param {string} settings.appLogoImgStr - optional url to an application defined logo image to be displayed with the TerraFly logo in the Header pane
 * @param {color} settings.logoBkColor - optional background color used on the logo subcontainer of the Header pane, ignored if <b>logoStyle</b> is defined
 * @param {tf.types.CSSStyleSpecs} settings.logoStyle - optional CSS style specifications to be applied to the logo subcontainer of the Header pane
 * @param {tf.types.CSSStyleSpecs} settings.pageStyle - optional CSS style specifications to be applied to layout container
 * @param {tf.types.CSSStyleSpecs} settings.headerStyle - optional CSS style specifications to be applied to the Header pane
 * @param {tf.types.CSSStyleSpecs} settings.contentStyle - optional CSS style specifications to be applied to the Content pane
 * @param {tf.types.CSSStyleSpecs} settings.footerStyle - optional CSS style specifications to be applied to the Footer pane
 * @extends {tf.dom.Insertable}
 */
tf.layout.HeaderContentFooter = function (settings) {
    var theThis, styles, subStyles, onLayoutChangeCallBack, pageObj, headerObj, contentObj, footerObj;
    var page, header, content, footer, headerContentObj, logoObj, tfLogoImgObj, appLogoImgObj, optionalScope;
    var headerAddOnObj, footerContentObj, isShowingFooter, isFooterAutoHidden;
    /**
     * @public
     * @function
     * @summary - Creates a container [Div]{@link tf.dom.Div} suitable for adding to this layout's header pane with the functions 
     * [SetHeader]{@link tf.layout.HeaderContainerFooter#SetHeader} or [AddToHeader]{@link tf.layout.HeaderContainerFooter#AddToHeader}.
     * The container returned can be used to display toolbars or other application defined content
     * @returns {tf.dom.Div} - | {@link tf.dom.Div} the container
    */
    this.CreateUnPaddedDivForHeader = function () { return new tf.dom.Div({ cssClass: styles.unPaddedBlockDivClass }); }
    /**
     * @public
     * @function
     * @summary - Replaces the contents of the <b>Header</b> pane with the given element, triggers a layout change event
     * @param {HTMLElementLike} elem - the given element
     * @returns {void} - | {@link void} no return value
    */
    this.SetHeader = function (elem) { return changeContent(headerAddOnObj, elem); }
    /**
     * @public
     * @function
     * @summary - Adds the given element to the contents of the <b>Header</b> pane, triggers a layout change event
     * @param {HTMLElementLike} elem - the given element
     * @returns {void} - | {@link void} no return value
    */
    this.AddToHeader = function (elem) { return addToHeader(elem); }
    /**
     * @public
     * @function
     * @summary - Replaces the contents of the <b>Content</b> pane with the given element, triggers a layout change event
     * @param {HTMLElementLike} elem - the given element
     * @returns {void} - | {@link void} no return value
    */
    this.SetContent = function (elem) { return changeContent(contentObj, elem); }
    /**
     * @public
     * @function
     * @summary - Replaces the contents of the <b>Footer</b> pane with the given element, triggers a layout change event
     * @param {HTMLElementLike} elem - the given element
     * @returns {void} - | {@link void} no return value
    */
    this.SetFooter = function (elem) { return changeContent(footerContentObj, elem); }
    /**
     * @public
     * @function
     * @summary - Triggers a layout change event. This function should be called when the visibility status or the dimensions of sub-contents 
     * of this layout are programmatically modified. This function should not be called in addition to calling the layout's functions SetHeader, AddToHeader, 
     * SetContent or SetFooter, which all automatically trigger layout change events
     * @param {HTMLElementLike} elem - the given element
     * @returns {void} - | {@link void} no return value
    */
    this.NotifyLayoutChange = function () { return notifyLayoutChange(); }
    /**
     * @public
     * @function
     * @summary - Notifies the layout that its container may have been resized
     * @returns {void} - | {@link void} no return value
    */
    this.OnResize = function () { return onResize(); }
    /**
     * @public
     * @function
     * @summary - Checks if the footer has been automatically hidden in response to changes in the layout height
     * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
    */
    this.GetIsFooterAutoHidden = function () { return isFooterAutoHidden; }
    /**
     * @public
     * @function
     * @summary - Checks if the footer is visible when the layout height permits it
     * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
    */
    this.GetIsShowingFooter = function () { return isShowingFooter; }
    /**
     * @public
     * @function
     * @summary - Shows or hides the <b>footer</b> pane
     * @param {boolean} bool - set to <b>true</b> to dislay the footer pane, when the layout's height permits it, <b>false</b> to hide it
     * @returns {void} - | {@link void} no return value
    */
    this.SetIsShowingFooter = function (showBool) { if ((showBool = !!showBool) != isShowingFooter) { isShowingFooter = showBool; onResize(); } }
    function notifyLayoutChange() { if (!!onLayoutChangeCallBack) { onLayoutChangeCallBack.call(optionalScope, { sender: theThis }); } }
    function changeContent(parent, elem) { parent.ClearContent(); parent.AddContent(elem); notifyLayoutChange(); }
    function addToHeader(elem) { headerContentObj.InsertContentBefore(elem, headerAddOnObj); notifyLayoutChange(); }
    function onLogoImageLoaded() { onResize(); }
    function onResize() {
        //var containerw = page.clientWidth;
        var containerh = page.clientHeight;
        var headerh = header.clientHeight;
        var footerWillShow = isShowingFooter && (containerh - headerh >= 100);
        var contentWillShow = containerh > headerh;
        content.style.display = contentWillShow ? 'block' : 'none';
        footer.style.display = footerWillShow ? 'block' : 'none';
        if (contentWillShow) {
            var footerh = footer.clientHeight;
            var contenth = footerWillShow ? containerh - (headerh + footerh) : containerh - (headerh);
            content.style.height = contenth + "px";
        }
        isFooterAutoHidden = footerWillShow;
    }
    function initialize() {
        styles = tf.GetStyles();
        subStyles = styles.GetSubStyles();
        isShowingFooter = true;
        isFooterAutoHidden = false;
        var appLogoImgStr = tf.js.GetNonEmptyString(settings.appLogoImgStr, "");
        var logoBkColor = tf.js.GetNonEmptyString(settings.logoBkColor, "#00a");
        var noBorderBlockDivClasses = styles.GetPaddedDivClassNames(false, false);
        onLayoutChangeCallBack = tf.js.GetFunctionOrNull(settings.onLayoutChange);
        optionalScope = settings.optionalScope;
        pageObj = new tf.dom.Div({ cssClass: styles.hcfLayoutClass });
        headerObj = new tf.dom.Div({ cssClass: styles.hcfLayoutHeaderClass });
        contentObj = new tf.dom.Div({ cssClass: styles.hcfLayoutContentClass });
        footerObj = new tf.dom.Div({ cssClass: styles.hcfLayoutFooterClass });
        page = pageObj.GetHTMLElement();
        header = headerObj.GetHTMLElement();
        content = contentObj.GetHTMLElement();
        footer = footerObj.GetHTMLElement();
        headerContentObj = new tf.dom.Div({ cssClass: noBorderBlockDivClasses });
        styles.ApplyStyleProperties(headerContentObj, subStyles.textAlignCenterStyle);
        footerContentObj = new tf.dom.Div({ cssClass: noBorderBlockDivClasses });
        styles.ApplyStyleProperties(footerContentObj, subStyles.textAlignCenterStyle);
        logoObj = new tf.dom.Div({ cssClass: styles.unPaddedBlockDivClass });
        var logoStyle = logoObj.GetHTMLElement().style;
        logoStyle.backgroundColor = logoBkColor;
        logoStyle.borderRadius = "4px";
        tfLogoImgObj = new tf.dom.Img({ src: tf.platform.GetPoweredByTerraFlyLogoImgStr(), cssClass: styles.imgLogoStyleClass, onLoad: onLogoImageLoaded });
        appLogoImgObj = new tf.dom.Img({ src: appLogoImgStr, cssClass: styles.imgLogoStyleClass, onLoad: onLogoImageLoaded });
        logoObj.AddContent(appLogoImgObj);
        logoObj.AddContent(tfLogoImgObj);
        headerAddOnObj = new tf.dom.Div({ cssClass: styles.unPaddedBlockDivClass });
        logoObj.AppendTo(headerContentObj);
        headerAddOnObj.AppendTo(headerContentObj);
        headerContentObj.AppendTo(headerObj);
        footerContentObj.AppendTo(footerObj);
        function tryApplyStyle(obj, style) { if (tf.js.GetIsValidObject(style)) { styles.ApplyStyleProperties(obj, style); } }
        tryApplyStyle(pageObj, settings.pageStyle);
        tryApplyStyle(contentObj, settings.contentStyle);
        tryApplyStyle(headerObj, settings.headerStyle);
        tryApplyStyle(footerObj, settings.footerStyle);
        tryApplyStyle(logoObj, settings.logoStyle);
        headerObj.AppendTo(pageObj);
        contentObj.AppendTo(pageObj);
        footerObj.AppendTo(pageObj);
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: pageObj });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.layout.HeaderContentFooter, tf.dom.Insertable);
/**
 * A callback function to receive the notification that the function [CreateURLAPIMaps]{@link tf.urlapi.CreateURLAPIMaps} has finished the process of creating all maps
 * @public
 * @callback tf.types.CreateURLAPIMapsCallBack
 * @param {object} notification - the notification
 * @param {tf.types.URLParametersObject} notification.parameters - url parameters in {@link object} format
 * @param {enumerable<tf.map.Map>} notification.maps - an enumerable containing the maps created
 * @param {enumerable<tf.urlapi.DLayerList>} notification.dLayers - an enumerable containing the [DLayer Lists]{@link tf.urlapi.DLayerList} created
 * @returns {void} - | {@link void} no return value
 */
/**
 * @public
 * @function
 * @summary - creates and configures one or more [Map]{@link tf.map.Map} instances based on the given settings, including url parameters, and adds them to the given containers.
 * Notifies a callback when all maps are created
 * @param {object} settings - creation settings
 * @param {tf.types.CreateURLAPIMapsCallBack} settings.onCreated - a mandatory callback to receive a notification when all maps are created
 * @param {object} settings.optionalScope - optional scope used with <b>onCreated</b>
 * @param {enumerable<HTMLElementLike>} settings.mapContainers - a mandatory enumerable of the containers to which map instances are added
 * @param {boolean} settings.allowDLayers - set to <b>false</b> to prevent the creation of a [DLayer List]{@link tf.urlapi.DLayerList} specified by [URL Parameters]{@link tf.types.URLParameters}, defaults to <b>true</b>
 * @param {function} settings.dLayersPreProcessDataItem - passed to [DLayer List]{@link tf.urlapi.DLayerList}, defaults to {@link void} 
 * @param {tf.types.URLParameters} settings.parameters - optional parameters to initialize the maps, dlayers
 * @returns {void} - | {@link void} no return value
*/
tf.urlapi.CreateURLAPIMaps = function (settings) {
    if (tf.js.GetIsValidObject(settings) && tf.js.GetIsValidObject(settings.mapContainers)) {
        var onCreatedCallBack = tf.js.GetFunctionOrNull(settings.onCreated);
        if (!!onCreatedCallBack) {
            var parameters = settings.parameters;
            if (!tf.js.GetIsValidObject(parameters)) {
                if (tf.js.GetIsString(parameters)) {
                    parameters = tf.urlapi.ParseURLAPIParameters(parameters);
                }
                else { parameters = {}; }
            }
            var dLayersAllowed = tf.js.GetBoolFromValue(settings.allowDLayers, true);
            var nDLayerExtent = tf.js.GetIntNumberInRange(parameters[tf.consts.paramNameDLExtent], 0, 999, 0);
            //nDLayerExtent = true;
            var viewCenterLat = tf.js.GetLatitudeFrom(parameters[tf.consts.paramNameLat]);
            var viewCenterLon = tf.js.GetLongitudeFrom(parameters[tf.consts.paramNameLon]);
            if (!parameters[tf.consts.paramNamePanels]) { parameters[tf.consts.paramNamePanels] = tf.consts.defaultPanels; }
            if (parameters[tf.consts.paramNameTFLogo] === tf.consts.tfLogoOffStr) { parameters[tf.consts.paramNameTFLogo] = false; } else { parameters[tf.consts.paramNameTFLogo] = true; }
            var panelParams = tf.js.GetNonEmptyString(parameters[tf.consts.paramNamePanels], '');
            var mapEngine = tf.map.GetMapEngineFrom(parameters[tf.consts.paramNameFMap]);
            if (parameters[tf.consts.paramNameTFLogo]) { panelParams += tf.consts.charSplitStrings + tf.consts.paramNameTFLogo; }
            var useMapNik2 = mapEngine == tf.consts.mapnik2Engine;
            if (useMapNik2) { delete parameters[tf.consts.paramNameLegend]; } else { delete parameters[tf.consts.paramNameLegendH]; }
            tf.urlapi.LoadRemoteParameters(parameters, createMaps);
        }
    }
    function createMaps() {
        function updateToggleButtonTexts(toggleButton, bool) {
            var text = bool ? "2D view" : "3D view";
            var toolTip = bool ? "Switch to 2D view" : "Switch to 3D view";
            toggleButton.SetText(text); toggleButton.ChangeToolTip(toolTip);
        }
        var mapLegendStr = useMapNik2 ? tf.urlapi.RemovePlugInPhotoFromLegend(parameters[tf.consts.paramNameLegendM]).legendStr : null;
        var hybridLegendStr = useMapNik2 ? parameters[tf.consts.paramNameLegendH] : parameters[tf.consts.paramNameLegend];
        var legendAndPlugInPhoto = tf.urlapi.RemovePlugInPhotoFromLegend(hybridLegendStr);
        hybridLegendStr = legendAndPlugInPhoto.legendStr;
        var messageTimeout = tf.js.GetFloatNumberInRange(parameters[tf.consts.paramNameMessageTimeout], tf.consts.minMessageTimeout, tf.consts.maxMessageTimeout, tf.consts.defaultMessageTimeout);
        //var dLayercenter = { Latitude: viewCenterLat, Longitude: viewCenterLon };
        var mapSettings = {
            fullScreenContainer: settings.fullScreenContainer,
            center: [viewCenterLon, viewCenterLat],
            mapType: parameters[tf.consts.paramNameType],
            mapAerialSource: parameters[tf.consts.paramNameSource],
            mapLayerSourceURL: parameters[tf.consts.mapLayerSourceName],
            mapEngine: mapEngine,
            panels: panelParams,
            addressBarText: parameters[tf.consts.paramNameAddress],
            addressBarHelp: parameters[tf.consts.paramNameHelp],
            panOnClick: true,
            goDBOnDoubleClick: true,
            legendH: hybridLegendStr,
            legendM: mapLegendStr,
            messageTimeout: messageTimeout,
            vidParam: parameters[tf.consts.paramNameVid],
            passThroughString: parameters[tf.consts.paramNamePassThrough],
            level: parameters[tf.consts.paramNameLevel],
            resolution: parameters[tf.consts.paramNameRes]
        };
        var allMaps = [], allDLayers = [], allPerspectiveMaps = [], allPerspectiveDLayers = [], perspectiveMapToggleButtons = [];
        var dLayersInfo = dLayersAllowed ? tf.urlapi.GetDLayersInfoFromURLParameters(parameters) : [];
        var hasDLayers = dLayersAllowed ? tf.js.GetIsNonEmptyArray(dLayersInfo) : false;
        var usePerspectiveMap = parameters[tf.consts.paramNamePerspectiveMap], perspectiveMapIsInitiallyVisible;
        var actualDLayersPreProcessServiceData = tf.js.GetFunctionOrNull(settings.dLayersPreProcessServiceData);
        var styles;
        if (usePerspectiveMap != undefined && tf.js.GetIsValidObject(tf.webgl) && tf.webgl.PerspectiveMap !== undefined) {
            if (tf.webgl.GetWebGL().GetHasWebGL()) {
                perspectiveMapIsInitiallyVisible = tf.js.GetBoolFromValue(usePerspectiveMap);
                usePerspectiveMap = true;
                styles = tf.GetStyles();
            }
            else {
                usePerspectiveMap = perspectiveMapIsInitiallyVisible = false;
            }
        }
        var toggleButtonSpecs = { position: 'absolute', bottom: '0.5em', marginLeft: '50%', transform: "translate(-50%, 0)", zIndex: 2 };
        for (var i in settings.mapContainers) {
            var thisContainer = settings.mapContainers[i];
            if (tf.dom.GetHTMLElementFrom(thisContainer)) {
                mapSettings.container = thisContainer;
                var map = new tf.map.Map(mapSettings);
                var perspectiveMap, perspectiveDLayer;
                var dLayersPreProcessServiceData = !!usePerspectiveMap ?
                    function (index) {
                        return function (data, dLayer) {
                            var mapDLayers = allPerspectiveDLayers[index];
                            if (!!mapDLayers) { mapDLayers.PreProcessServiceData(data, dLayer); }
                            if (!!actualDLayersPreProcessServiceData) { actualDLayersPreProcessServiceData(data, dLayer); }
                        }
                    }(allPerspectiveDLayers.length) :
                    actualDLayersPreProcessServiceData;
                var dLayers = hasDLayers ? new tf.urlapi.DLayerList({
                    dLayersInfo: dLayersInfo, map: map, preProcessDataItem: settings.dLayersPreProcessDataItem, preProcessServiceData: dLayersPreProcessServiceData,
                    nDLayerExtent: nDLayerExtent
                }) : undefined;
                allMaps.push(map);
                if (!!usePerspectiveMap) {
                    perspectiveMap = new tf.webgl.PerspectiveMap({ map: map, isVisible: perspectiveMapIsInitiallyVisible });
                    allPerspectiveMaps.push(perspectiveMap);
                    var toggleButton = new tf.ui.TextBtn({ style: styles.mapTextBtnClass, label: "", /*onClick: onToggleClick,*/ tooltip: "", dim: 20 });
                    var onToggleClick = function (perspectiveMap, toggleButton) {
                        return function () {
                            var bool = !perspectiveMap.GetIsVisible();
                            perspectiveMap.SetIsVisible(bool);
                            updateToggleButtonTexts(toggleButton, bool);
                        }
                    }(perspectiveMap, toggleButton);
                    var onPerspectiveMapVisibilityChange = function (perspectiveMap, toggleButton) {
                        return function (notification) {
                            var bool = perspectiveMap.GetIsVisible();
                            updateToggleButtonTexts(toggleButton, bool);
                        }
                    }(perspectiveMap, toggleButton);
                    perspectiveMap.AddListener(tf.consts.perspectiveMapVisibilityChangeEvent, onPerspectiveMapVisibilityChange);
                    toggleButton.SetOnClick(onToggleClick);
                    updateToggleButtonTexts(toggleButton, perspectiveMapIsInitiallyVisible);
                    styles.ApplyStyleProperties(toggleButton, toggleButtonSpecs);
                    toggleButton.AppendTo(map.GetMapMapContainer());
                    perspectiveMapToggleButtons.push(toggleButton);
                }
                if (!!dLayers) {
                    allDLayers.push(dLayers);
                    if (!!usePerspectiveMap) {
                        var perspectiveDLayer = new tf.webgl.PerspectiveDLayers({ perspectiveMap: perspectiveMap });
                        allPerspectiveDLayers.push(perspectiveDLayer);
                    }
                }
            }
        }
        var notification = {
            parameters: parameters, maps: allMaps, dLayers: allDLayers,
            perspectiveMaps: allPerspectiveMaps, perspectiveDLayers: allPerspectiveDLayers,
            perspectiveToggleButtons: perspectiveMapToggleButtons
        };
        setTimeout(function () { onCreatedCallBack.call(settings.optionalScope, notification); }, 10);
    }
};
/**
 * Object returned by the function [RemovePlugInPhotoFromLegend]{@link tf.urlapi.RemovePlugInPhotoFromLegend}
 * @public
 * @typedef {object} tf.types.RemovePlugInPhotoFromLegendResult
 * @property {boolean} bla.requestedPlugInPhoto - set to <b>true</b> if the flag was found and removed, <b>false</b> otherwise
 * @property {tf.types.legendString} bla.legendStr - the legend string, either unchanged or without the flag
*/
/**
 * @public
 * @function
 * @summary - Checks for the presence and removes a flag requesting the creation of obsolete Geoimages layer from the given legend string
 * @param {tf.types.legendString} legendStr - the given legend string
 * @returns {tf.types.RemovePlugInPhotoFromLegendResult} - | {@link tf.types.RemovePlugInPhotoFromLegendResult} the flag and legend
*/
tf.urlapi.RemovePlugInPhotoFromLegend = function (legendStr) {
    var requestedPlugInPhoto = false;
    var legendStrUse = tf.js.GetNonEmptyString(legendStr, "");
    if (!!legendStr) {
        var unescapedLegend = unescape(legendStr);
        var legendArray = unescapedLegend.split(';');
        legendStrUse = "";
        for (var i = 0; i < legendArray.length; i++) {
            //tf.GetDebug().LogIfTest(legendArray[i]);
            if (legendArray[i].indexOf("plugin_photo") != -1) { requestedPlugInPhoto = true; }
            else { legendStrUse += legendArray[i] + ";"; }
        }
        legendStrUse = tf.js.ClipEndingChar(legendStrUse, ';');
    }
    return { requestedPlugInPhoto: requestedPlugInPhoto, legendStr: legendStrUse };
}
/**
 * Object returned by the function [BreakUrlParamString]{@link tf.urlapi.BreakUrlParamString}
 * @public
 * @typedef {object} tf.types.BreakUrlParamStringResult
 * @property {string} tag - either <b>'#'</b> or <b>'?'</b>
 * @property {string} urlPart - the portion of the string before <b>tag</b>
 * @property {string} paramsPart - the portion of the string after <b>tag</b>
*/
/**
 * @public
 * @function
 * @summary - Breaks a full url string into two parts separated by either a <b>'#'</b> or <b>'?'</b>
 * @param {string} strFullUrl - the given full url
 * @returns {tf.types.BreakUrlParamStringResult} - | {@link tf.types.BreakUrlParamStringResult} the broken parts
*/
tf.urlapi.BreakUrlParamString = function (strFullUrl) {
    var strFullUrlUse = tf.js.GetNonEmptyString(strFullUrl);
    var tag, urlPart, paramsPart;
    function splitStrInTwo (fullStr, splitChar) {
        var splitStr = fullStr.split(splitChar), leftSideStr = '', rightSideStr = '', didSplit;
        if (didSplit = (splitStr.length == 2)) { leftSideStr = splitStr[0]; rightSideStr = splitStr[1]; } else { leftSideStr = fullStr; rightSideStr = ''; }
        return { leftSideStr: leftSideStr, rightSideStr: rightSideStr, didSplit: didSplit };
    }
    if (!!strFullUrlUse) {
        var charsSplit = ['#', '?'];
        var split;
        for (var c in charsSplit) {
            var splitChar = charsSplit[c];
            if ((split = splitStrInTwo(strFullUrlUse, splitChar)).didSplit) {
                tag = splitChar;
                urlPart = split.leftSideStr;
                paramsPart = split.rightSideStr;
                break;
            }
        }
        if (!split.didSplit) {
            tag = '?';
            urlPart = strFullUrlUse;
            paramsPart = '';
        }
    }
    else { tag = '?'; urlPart = ''; paramsPart = ''; }
    return { tag: tag, urlPart: urlPart, paramsPart: paramsPart };
}
/**
 * @public
 * @function
 * @summary - Modifies a full url string by breaking it with {@link tf.urlapi.BreakUrlParamString} and then
 * concatenating the url part, the tag, the given defaults string, the original params part, and the given overrides string, in that order
 * @param {string} strOriginalURL - the given full url
 * @param {string} strDefaults - the given default parameters
 * @param {string} strOverrides - the given override parameters
 * @returns {string} - | {@link string} the modified url
*/
tf.urlapi.ModifyURLParamString = function (strOriginalURL, strDefaults, strOverrides) {
    var strOriginalURLUse = tf.js.GetNonEmptyString(strOriginalURL);
    var strDefaultsUse = tf.js.GetNonEmptyString(strDefaults);
    var strOverridesUse = tf.js.GetNonEmptyString(strOverrides);
    var urlBroken = tf.urlapi.BreakUrlParamString(strOriginalURLUse);
    var paramsPart = urlBroken.paramsPart;
    if (!!strDefaultsUse) {
        if (paramsPart.length > 0 && paramsPart.charAt(0) != '&') { paramsPart = '&' + paramsPart; }
        paramsPart = strDefaultsUse + paramsPart;
    }
    if (!!strOverridesUse) { paramsPart += strOverridesUse; }
    return urlBroken.urlPart + urlBroken.tag + paramsPart;
}
/**
 * @public
 * @function
 * @summary - Parses the given full url string for parameters to be merged with the given defaults, unescapes parameter values, converts property names to lowercase
 * @param {string} fullURL - the given full url
 * @param {object} defaultParameters - the given default parameters
 * @returns {object} - | {@link object} the <b>fullURL</b> parameters combined with the <b>defaultParameters</b> in object format
*/
tf.urlapi.ParseURLParameters = function (fullURL, defaultParameters) {
    var parameters = tf.js.GetIsValidObject(defaultParameters) ? defaultParameters : {};
    if (tf.js.GetIsNonEmptyString(fullURL)) {
        var urlBroken = tf.urlapi.BreakUrlParamString(fullURL);
        var paramsPart = urlBroken.paramsPart;
        var paramStringArray = paramsPart.split("&");
        var paramStringArrayLen = paramStringArray.length;
        if (paramStringArrayLen) {
            for (var i = 0; i < paramStringArrayLen; ++i) {
                var equalIndex = paramStringArray[i].indexOf("=");
                if (equalIndex != -1) {
                    var key = paramStringArray[i].substring(0, equalIndex).toLowerCase();
                    var value = paramStringArray[i].substring(equalIndex + 1, paramStringArray[i].length);
                    parameters[key] = unescape(value);
                }
            }
        }
    }
    else if (tf.js.GetIsValidObject(fullURL)) { parameters = tf.js.ShallowMerge(parameters, fullURL); }
    return parameters;
}
/**
 * @public
 * @function
 * @summary - Parses the given full url string for parameters to be merged with the default values of TerraFly {@link tf.types.URLParameters}
 * @param {string} fullURL - the given full url
 * @param {object} overrideDefaults - optional object containing default values, defaults to {@link void}
 * @returns {object} - | {@link object} the <b>fullURL</b> parameters combined with the defaults
*/
tf.urlapi.ParseURLAPIParameters = function (fullURL, overrideDefaults) {
    var defaultParameters = {};
    defaultParameters[tf.consts.paramNameLat] = tf.consts.defaultLatitude;
    defaultParameters[tf.consts.paramNameLon] = tf.consts.defaultLongitude;
    defaultParameters[tf.consts.paramNameRes] = undefined; //tf.consts.defaultRes;
    defaultParameters[tf.consts.paramNameLevel] = tf.consts.defaultLevel;
    defaultParameters[tf.consts.paramNamePanels] = tf.consts.defaultPanels;
    defaultParameters[tf.consts.paramNameLegend] = tf.consts.defaultLegend;
    defaultParameters[tf.consts.paramNameLegendH] = tf.consts.defaultLegendH;
    defaultParameters[tf.consts.paramNameLegendM] = tf.consts.defaultLegendM;
    defaultParameters[tf.consts.paramNameAddress] = tf.consts.defaultAddress;
    defaultParameters[tf.consts.paramNameVid] = tf.consts.defaultVid;
    defaultParameters[tf.consts.paramNamePassThrough] = tf.consts.defaultTFPassThrough;
    defaultParameters[tf.consts.paramNameTFLogo] = tf.consts.defaultTFLogoOn ? tf.consts.tfLogoOnStr : tf.consts.tfLogoOffStr;
    defaultParameters[tf.consts.paramNameType] = tf.consts.typeNameHybrid;
    defaultParameters[tf.consts.paramNameFMap] = tf.consts.defaultFMap;
    defaultParameters[tf.consts.paramNameSource] = tf.consts.defaultSourceName;
    defaultParameters[tf.consts.paramNameMessageTimeout] = tf.consts.defaultMessageTimeout;
    defaultParameters[tf.consts.paramNameHelp] = tf.consts.defaultHelp;
    defaultParameters[tf.consts.paramNameApps] = tf.consts.defaultApps;
    if (tf.js.GetIsValidObject(overrideDefaults)) { defaultParameters = tf.js.ShallowMerge(defaultParameters, overrideDefaults); }
    var parameters = tf.urlapi.ParseURLParameters(fullURL, defaultParameters);
    var addressStr = parameters[tf.consts.paramNameAddress];
    addressStr = typeof addressStr === "string" ? addressStr.replace(/\+/g, " ") : "";
    parameters[tf.consts.paramNameAddress] = addressStr;
    return parameters;
}
/**
 * @public
 * @function
 * @summary - Retrieves the actual value of some url parameters from remote files or services
 * @param {tf.types.URLParametersObject} parameters - the given parameters, in {@link object} format
 * @param {function} callBack - a function called (without parameters) after all remote url parameters are retrieved
 * @returns {void} - | {@link void} no return value
*/
tf.urlapi.LoadRemoteParameters = function (parameters, callBack) {
    var nParamsToProcess = 0;
    function setTimeoutCallBack() { if (!!callBackUse) { setTimeout(function () { callBackUse() }, 10); } }
    function onLoadedParam(paramName, param) { parameters[paramName] = param; if (nParamsToProcess > 1) { --nParamsToProcess } else { setTimeoutCallBack(); } }
    if (tf.js.GetIsValidObject(parameters)) {
        var callBackUse = tf.js.GetFunctionOrNull(callBack);
        var paramsWithDDURLDD = [ tf.consts.paramNameLegend, tf.consts.paramNameLegendH, tf.consts.paramNameLegendM ];
        var paramsWithDDURLDDCount = paramsWithDDURLDD.length;
        if (!!paramsWithDDURLDDCount) {
            for (var i in paramsWithDDURLDD) { if (parameters[paramsWithDDURLDD[i]]) { ++nParamsToProcess; } }
            if (!!nParamsToProcess) {
                for (var i = 0 ; i < paramsWithDDURLDDCount ; i++) {
                    var thisParamName = paramsWithDDURLDD[i];
                    var thisParam = parameters[thisParamName];
                    if (thisParam) { new tf.urlapi.URLPartsLoader(thisParamName, thisParam, onLoadedParam); }
                }
            }
            else { setTimeoutCallBack(); }
        }
        else { setTimeoutCallBack(); }
    }
}
/**
 * @private
 * @class
 * @summary - Retrieves one remote url parameter and notifies a callback. Used internally by the API
 * @param {string} paramName - the name of the parameter, in {@link object} format
 * @param {string} initialParam - the initial parameter value, containing a remote reference enclosed with '$$' strings (prefix and suffix)
 * @param {function} onLoadedParamParts - called when all parts of this parameter have been loaded, receiving the loaded parameter name and its value, in that order
 * @returns {void} - | {@link void} no return value
*/
tf.urlapi.URLPartsLoader = function (paramName, initialParam, onLoadedParamParts) {
    var theThis, paramParts, paramPartsCounter;
    /**
     * @public
     * @function
     * @summary - Retrieves initial parameter value, containing a remote reference enclosed with '$$' strings (prefix and suffix)
     * @returns {string} - | {@link string} the parameter value
    */
    this.GetInitialParam = function () { return initialParam; }
    function loadParamParts(param) {
        if (param.indexOf(tf.consts.urlPartsSeparatorStr) != -1) {
            paramParts = param.split(tf.consts.urlPartsSeparatorStr);
            paramPartsCounter = 0;
            for (var i = 1; i < paramParts.length; i += 2) {
                paramPartsCounter++;
                new tf.ajax.GetRequest({ url: paramParts[i], onDataLoaded: onURLPartLoaded, requestProps: i, autoSend: true, overrideMimeType: 'text/plain', useRedirect: false });
            }
        }
        else { onLoadedParamParts.call(undefined, paramName, param); }
    }
    function onURLPartLoaded(notification) {
        if (notification.httpRequest.status == 200) {
            var content = unescape(notification.httpRequest.responseText);
            paramParts[notification.requestProps] = content.replace(/[\r\n]/g, "");
            if (! --paramPartsCounter) { combineParameters(); }
        }
    }
    function combineParameters() {
        var result = ""; for (var i = 0; i < paramParts.length; i++) { result += paramParts[i]; } loadParamParts(result);
    }
    function initialize() { loadParamParts(initialParam); }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Settings used in the creation of [Table Row]{@link tf.ui.TableRow} instances
 * @public
 * @typedef {object} tf.types.TableRowSettings
 * @property {tf.js.KeyedItem} keyedItem - an optional [Keyed Item]{@link tf.js.KeyedItem} instance to be associated with the Table Row
 * @property {tf.types.CSSStyleSpecs} style - Style assumed by the Table Row when unselected
 * @property {tf.types.CSSStyleSpecs} selectedStyle - Style assumed by the Table Row when selected
*/
/**
 * @public
 * @class
 * @summary A Table Row instance belongs to a single [Table]{@link tf.ui.Table} instance and displays application defined {@link HTMLContent}.
 * Applications create Table Rows and then add them to a [Table]{@link tf.ui.Table} using one of its functions [AppendRow]{@link tf.ui.Table#AppendRow}, 
 * [InsertRowAfter]{@link tf.ui.Table#InsertRowAfter}, and [InsertRowBefore]{@link tf.ui.Table#InsertRowBefore}
 * @param {tf.types.TableRowSettings} settings - creation settings
 */
tf.ui.TableRow = function (settings) {
    var theThis, savedDisplay, isShowing, styles, keyedItem;
    var domObj, domElement, container, hoverListener, isSelected, clickListener, style, selectedStyle;
    var colorSelected, colorUnSelected;
    /**
     * @public
     * @function
     * @summary - Retrieves the [Keyed Item]{@link tf.js.KeyedItem} instance associated with this Table Row instance, if one was associated during creation
     * @returns {tf.js.KeyedItem} - | {@link tf.js.KeyedItem} the associated item instance, or {@link void} if no instance was associated
    */
    this.GetKeyedItem = function () { return keyedItem; }
    /**
     * @public
     * @function
     * @summary - Shows or hides this instance
     * @param {boolean} bool - <b>true</b> to show, <b>false</b> to hide
     * @returns {void} - | {@link void} no return value
    */
    this.ShowOrHide = function (bool) { return showOrHide(bool); }
    /**
     * @public
     * @function
     * @summary - Checks if this instance is visible
     * @returns {boolean} - | {@link boolean} <b>true</b> if visible, <b>false</b> otherwise
    */
    this.IsShowing = function () { return isShowing; }
    /**
     * @public
     * @function
     * @summary - Retrieves the {@link tf.ui.Table} instance associated with this Table Row instance
     * @returns {tf.ui.Table} - | {@link tf.ui.Table} the table
    */
    this.GetTable = function () { return container; }
    /**
     * @public
     * @function
     * @summary - Removes any content that was previously added to this Table Row instance
     * @returns {void} - | {@link void} no return value
    */
    this.ClearContent = function () { domObj.ClearContent(); };
    /**
     * @public
     * @function
     * @summary - Replaces any content that was previously added to this Table Row instance with the given new content
     * @param {HTMLElementLike} elem - the new content
     * @returns {void} - | {@link void} no return value
    */
    this.ReplaceContent = function (elem) { this.ClearContent(); this.AppendRow(elem); }
    /**
     * @public
     * @function
     * @summary - Adds the given new content to contents that were previously added to this Table Row instance
     * @param {HTMLElementLike} elem - the new content
     * @returns {void} - | {@link void} no return value
    */
    this.AddContent = function (elem) {
        if (tf.js.GetIsNonEmptyString(elem)) { domElement.innerHTML = elem; }
        else { tf.dom.AddContent(elem, domElement); }
    }
    /**
     * @public
     * @function
     * @summary - If necessary, scrolls the associated [Table]{@link tf.ui.Table} to ensure that this Table Row instance is visible
     * @returns {void} - | {@link void} no return value
    */
    this.EnsureVisible = function () { if (!!container) { return container.EnsureVisible(theThis); } }
    /**
     * @public
     * @function
     * @summary - Selects this Table Row among all other rows in its associated [Table]{@link tf.ui.Table} instance
     * @param {boolean} ensureVisibleBool - set to <b>true</b> to scroll the table, if necessary, to make this instance visible
     * @param {boolean} bypassNotification - set to <b>true</b> to prevent the table from notifying a change in selection
     * @returns {void} - | {@link void} no return value
    */
    this.Select = function (ensureVisibleBool, bypassNotification) { return select(ensureVisibleBool, bypassNotification); }
    /**
     * @public
     * @function
     * @summary - Checks if this Table Row instance is the currently selected row in its associated [Table]{@link tf.ui.Table} instance.
     * @returns {boolean} - | {@link boolean} <b>true</b> if this row is selected, <b>false</b> otherwise
    */
    this.GetIsSelected = function () { return isSelected; }
    /**
     * @private
     * @function
     * @summary - Retrieves the {@link HTMLElementLike} used by this instance. Used internally by the API
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the element
    */
    this.privateGetHTMLElement = function () { return domElement; }
    /**
     * @private
     * @function
     * @summary - Changes this Table Row instance's style to reflect the given selected status. Used internally by the API
     * @param {boolean} bool - <b>true</b> if selected, <b>false</b> otherwise
     * @returns {void} - | {@link void} no return value
    */
    this.SetSelectedStyle = function (bool) { return setSelectedStyle(bool); }
    /**
     * @private
     * @function
     * @summary - Changes this Table Row instance's style to reflect the given selected status. Used internally by the API
     * @param {tf.ui.Table} containerSet
     * @returns {void} - | {@link void} no return value
    */
    this.OnAddToContainer = function (containerSet) { if (containerSet instanceof tf.ui.Table) { container = containerSet; } }
    /**
     * @private
     * @function
     * @summary - Removes this Table Row instance from its associated [Table]{@link tf.ui.Table} instance. Used internally by the API
     * @returns {void} - | {@link void} no return value
    */
    this.OnRemoveFromContainer = function () { container = null; }
    function setSelectedStyle(isSelectedSet) {
        var styleUse;
        if (isSelected = !!isSelectedSet) { styleUse = selectedStyle; } else { styleUse = style; }
        if (!!styleUse) { styles.ApplyStyleProperties(domElement, styleUse); }
        else { domElement.style.backgroundColor = isSelected ? colorSelected : colorUnSelected; }
    }
    function showOrHide(showBool) { if (isShowing != !!showBool) { isShowing = !!showBool; domElement.style.display = isShowing ? savedDisplay : 'none'; } }
    function select(ensureVisibleBool, bypassNotification) { if (!!container) { container.SelectRow(theThis, ensureVisibleBool, bypassNotification); } }
    function onHover(notification) {
        var content = notification.target, retVal = false;
        if (content) {
            if (notification.isInHover) {
                if (!!container) { retVal = container.OnHoverIntoContent(theThis); }
            }
        }
        return retVal;
    }
    function onClick(notification) {
        var retVal = false;
        if (!!container) { retVal = container.OnClickContent(theThis); }
        return retVal;
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        styles = tf.GetStyles();
        keyedItem = settings.keyedItem;
        var subStyles = styles.GetSubStyles();
        colorSelected = subStyles.containerDarkSelBackgroundColor;
        colorUnSelected = subStyles.containerDarkBackgroundColor;
        style = settings.style;
        selectedStyle = settings.selectedStyle;
        domObj = new tf.dom.Div({ cssClass: styles.listContentClass });
        domElement = domObj.GetHTMLElement();
        savedDisplay = 'block';
        hoverListener = new tf.events.DOMHoverListener({ target: domObj, callBack: onHover, optionalScope: theThis, callBackSettings: null });
        clickListener = new tf.events.DOMClickListener({ target: domObj, callBack: onClick, optionalScope: theThis, callBackSettings: null });
        isShowing = true;
        isSelected = false;
        setSelectedStyle(false);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Row selection notifications sent by {@link tf.ui.Table} instances
 * @public
 * @typedef {object} TableRowSelectNotification
 * @property {tf.ui.Table} sender - the instance sending the notification
 * @property {tf.ui.TableRow} selected - the [Table Row]{@link tf.ui.TableRow} instance that has been selected
 * @property {tf.ui.TableRow} prevSelected - the pleviously selected [Table Row]{@link tf.ui.TableRow} instance, or {@link void}
 * @property {boolean} isClick - <b>true</b> only if a mouse click event initiated the selection
 * @property {tf.ui.KeyedTable} keyedTable - the [Keyed Table]{@link tf.ui.KeyedTable} instance associated with the Table, if one was provided when the Table's was created
*/
/**
 * A callback function that can be used in the creation of instances of [Table]{@link tf.ui.Table}
 * @public
 * @callback tf.types.TableRowSelectCallBack
 * @param {tf.types.TableRowSelectNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * Settings used in the creation of [Table]{@link tf.ui.Table} instances
 * @public
 * @typedef {object} tf.types.TableSettings
 * @property {tf.ui.KeyedTable} keyedTable - an optional [Keyed Table]{@link tf.ui.KeyedTable} instance to be associated with the Table
 * @property {tf.types.TableRowSelectCallBack} onSelect - an optional callback to be notified of [Table Row]{@link tf.ui.TableRow} selection changes
 * @property {object} optionalScope - optional scope used with <b>onSelect</b>
 * @property {boolean} selectOnHover - Allows or prevents the Table from selecting a [Table Row]{@link tf.ui.TableRow} instance when the mouse pointer hovers over it
 * @property {tf.types.CSSStyleSpecs} style - Style assumed by the Table
*/
/**
 * @public
 * @class
 * @summary A Table instance is an [Insertable]{@link tf.dom.Insertable} implementing a standard vertical table with scrolling and contains zero or more 
 * [Table Row]{@link tf.ui.TableRow} instances, one of which can be marker as "Selected", either by calling the
 * function [SelectRow]{@link tf.ui.Table#SelectRow} of this Table, or when a mouse pointer click (and optionally hover)
 * event occurs on a row.
 * @param {tf.types.TableSettings} settings - creation settings
 * @extends {tf.dom.Insertable}
 */
tf.ui.Table = function (settings) {
    var theThis, containerObj, containerElem, optionalScope, onSelectCallBack, contents, nContents, selectedContent, selectOnHoverBool, keyedTable;
    /**
     * @public
     * @function
     * @summary - Retrieves the [Keyed Table]{@link tf.ui.KeyedTable} instance associated with this table instance, if one was associated during creation
     * @returns {tf.ui.KeyedTable} - | {@link tf.ui.KeyedTable} the associated instance, or {@link void} if no instance was associated
    */
    this.GetKeyedTable = function () { return keyedTable; }
    /**
     * @public
     * @function
     * @summary - Checks if this Table Instance automatically selects a [Table Row]{@link tf.ui.TableRow} instance when the mouse pointer hovers over it.
     * Selection of a row always occurs on mouse click events
     * @returns {boolean} - | {@link boolean} <b>true</b> if selection on hover is allowed, <b>false</b> otherwise
    */
    this.GetSelectOnHover = function () { return selectOnHoverBool; }
    /**
     * @public
     * @function
     * @summary - Allows or prevents this Table Instance to/from automatically selecting a [Table Row]{@link tf.ui.TableRow} instance when the mouse pointer hovers over it.
     * Selection of a row always occurs on mouse click events
     * @param {boolean} bool - <b>true</b> to allow select on hover, <b>false</b> to prevent it
     * @returns {void} - | {@link void} no return value
    */
    this.SetSelectOnHover = function (bool) { selectOnHoverBool = !!bool; }
    /**
     * @public
     * @function
     * @summary - Adds the given [Table Row]{@link tf.ui.TableRow] instance to the end of this Table instance
     * @param {tf.ui.TableRow} tableRow - the table row
     * @returns {void} - | {@link void} no return value
    */
    this.AppendRow = function (tableRow) {
        if (!!tableRow && tableRow instanceof tf.ui.TableRow) {
            tableRow.OnAddToContainer(theThis);
            containerObj.AddContent(tableRow.privateGetHTMLElement());
            contents.push(tableRow);
            ++nContents;
        }
    }
    
    /**
     * @public
     * @function
     * @summary - Inserts the the given [Table Row]{@link tf.ui.TableRow] instance before an existing row instance
     * @param {tf.ui.TableRow} tableRow - the table row to insert
     * @param {tf.ui.TableRow} existingTableRow - the existing table row, before which <b>tableRow</b> will be inserted
     * @returns {void} - | {@link void} no return value
    */
    this.InsertRowBefore = function (tableRow, existingTableRow) {
        if (
            (!!tableRow && tableRow instanceof tf.ui.TableRow) &&
            (!!existingTableRow && existingTableRow instanceof tf.ui.TableRow) &&
            existingTableRow.GetTable() == theThis) {
            tableRow.OnAddToContainer(theThis);
            containerObj.InsertContentBefore(tableRow.privateGetHTMLElement(), existingTableRow);
            contents.push(tableRow);
            ++nContents;
        }
    }
    /**
     * @public
     * @function
     * @summary - Inserts the the given [Table Row]{@link tf.ui.TableRow] instance after an existing row instance
     * @param {tf.ui.TableRow} tableRow - the table row to insert
     * @param {tf.ui.TableRow} existingTableRow - the existing table row, after which <b>tableRow</b> will be inserted
     * @returns {void} - | {@link void} no return value
    */
    this.InsertRowAfter = function (tableRow, existingTableRow) {
        if (
            (!!tableRow && tableRow instanceof tf.ui.TableRow) &&
            (!!existingTableRow && existingTableRow instanceof tf.ui.TableRow) &&
            existingTableRow.GetTable() == theThis) {
            tableRow.OnAddToContainer(theThis);
            containerObj.InsertContentAfter(tableRow.privateGetHTMLElement(), existingTableRow);
            contents.push(tableRow);
            ++nContents;
        }
    }
    /**
     * @public
     * @function
     * @summary - Removes the given [Table Row]{@link tf.ui.TableRow] instance from this Table instance
     * @param {tf.ui.TableRow} tableRow - the table row to remove
     * @returns {void} - | {@link void} no return value
    */
    this.DelRow = function (tableRow) {
        if (!!tableRow && tableRow instanceof tf.ui.TableRow && tableRow.GetTable() == theThis) {
            var index = contents.indexOf(tableRow);
            if (index != -1) { contents.splice(index, 1); }
            containerElem.removeChild(tableRow.privateGetHTMLElement());
            tableRow.OnRemoveFromContainer();
            --nContents;
        }
    }
    /**
     * @public
     * @function
     * @summary - Removes all [Table Row]{@link tf.ui.TableRow] instances from this Table instance
     * @returns {void} - | {@link void} no return value
    */
    this.Clear = function () {
        nContents = contents.length;
        for (var i = 0 ; i < nContents ; ++i) { contents[i].OnRemoveFromContainer(); }
        contents = [];
        containerObj.ClearContent();
        selectedContent = null;
        nContents = 0;
    }
    /**
     * @public
     * @function
     * @summary - Retrieves the number of [Table Row]{@link tf.ui.TableRow] instances currently in this Table instance
     * @returns {number} - | {@link number} the number of table row instances
    */
    this.GetRowCount = function () { return nContents; }
    /**
     * @public
     * @function
     * @summary - Selects a [Table Row]{@link tf.ui.TableRow} instance among all other rows
     * @param {tf.ui.TableRow} tableRow - the table row to select
     * @param {boolean} ensureVisibleBool - set to <b>true</b> to scroll the table, if necessary, to make this instance visible
     * @param {boolean} bypassNotification - set to <b>true</b> to prevent the table from notifying a change in selection
     * @returns {void} - | {@link void} no return value
    */
    this.SelectRow = function (tableRow, ensureVisibleBool, bypassNotification) { return selectContent(tableRow, ensureVisibleBool, bypassNotification); }
    /**
     * @public
     * @function
     * @summary - Retrieves the currently selected [Table Row]{@link tf.ui.TableRow} instance
     * @returns {tf.ui.TableRow} - | {@link tf.ui.TableRow} the selected row, or {@link void} if no row is selected
    */
    this.GetSelectedRow = function () { return selectedContent; }
    /**
     * @public
     * @function
     * @summary - If necessary, scrolls this Table instance to ensure that the given [Table Row]{@link tf.ui.TableRow} instance is visible
     * @param {tf.ui.TableRow} tableRow - the table row to select
     * @returns {void} - | {@link void} no return value
    */
    this.EnsureVisible = function (tableRow) { return ensureVisible(tableRow); }
    /**
     * @public
     * @function
     * @summary - If necessary, scrolls this Table instance to ensure that the currently selected [Table Row]{@link tf.ui.TableRow} instance is visible
     * @returns {void} - | {@link void} no return value
    */
    this.EnsureSelectedContentVisible = function () { return this.EnsureVisible(this.GetSelectedRow()); }
    /**
     * @private
     * @function
     * @summary - Used internally by the API
     * @param {tf.ui.TableRow} theContent - the table row
     * @returns {void} - | {@link void} no return value
    */
    this.OnHoverIntoContent = function (theContent) { return onHoverIntoContent(theContent); }
    /**
     * @private
     * @function
     * @summary - Used internally by the API
     * @param {tf.ui.TableRow} theContent - the table row
     * @returns {void} - | {@link void} no return value
    */
    this.OnClickContent = function (theContent) { return onClickContent(theContent); }
    /**
     * @private
     * @function
     * @summary - Retrieves the number of [Table Row]{@link tf.ui.TableRow] instances currently in this Table instance
     * @returns {number} - | {@link number} the number of table row instances
     * @deprecated
    */
    //this.GetContents = function () { return contents; }
    function onClickContent(theContent) { selectContent(theContent, false, false, true); return true;}
    function onHoverIntoContent(theContent) { if (selectOnHoverBool) { selectContent(theContent, false, false, false); } }
    function ensureVisible(content) {
        if (!!content && content instanceof tf.ui.TableRow && content.GetTable() == theThis) {
            if (content = content.privateGetHTMLElement()) {
                var outerContainer = containerElem.parentNode;
                if (!!outerContainer) {
                    outerContainer.scrollTop = content.offsetTop - outerContainer.offsetTop;
                }
            }
        }
    }
    function unselectContent() {
        if (!!selectedContent) {
            selectedContent.SetSelectedStyle(false);
            selectedContent = null;
        }
    }
    function notifySelect(prevSel, isClick) {
        if (!!onSelectCallBack) { onSelectCallBack.call(optionalScope, { sender: theThis, selected: selectedContent, prevSelected: prevSel, isClick: !!isClick, keyedTable: keyedTable }); }
    }
    function selectContent(content, ensureVisibleBool, bypassNotification, isClick) {
        if (!!content && content instanceof tf.ui.TableRow) {
            if (content.GetTable() == theThis) {
                var prevSel = selectedContent;
                var alreadySelected = content == prevSel;
                if (!alreadySelected) {
                    unselectContent();
                    selectedContent = content;
                    selectedContent.SetSelectedStyle(true);
                }
                if (!!ensureVisibleBool) { ensureVisible(content); }
                if (!bypassNotification) { notifySelect(prevSel, isClick); }
            }
        }
    }
    function initialize() {
        var styles = tf.GetStyles();
        contents = [];
        nContents = 0;
        selectedContent = null;
        onSelectCallBack = tf.js.GetFunctionOrNull(settings.onSelect);
        optionalScope = settings.optionalScope;
        selectOnHoverBool = !!settings.selectOnHover;
        containerObj = new tf.dom.Div({ cssClass: tf.GetStyles().unPaddedBlockDivClass });
        containerElem = containerObj.GetHTMLElement();
        keyedTable = settings.keyedTable;
        if (tf.js.GetIsValidObject(settings.style)) { styles.ApplyStyleProperties(containerElem, settings.style); }
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: containerElem });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.ui.Table, tf.dom.Insertable);
/**
 * Content requests sent by {@link tf.ui.KeyedTable} instances
 * @public
 * @typedef {object} tf.types.KeyedRowTableRowContentRequest
 * @property {tf.ui.Table} sender - the instance sending the notification
 * @property {tf.js.KeyedItem} keyedItem - the [Keyed Item]{@link tf.js.KeyedItem} instance for which content is being requested
 * @property {object} properties - application defined properties provided in the creation of the [Keyed Table]{@link tf.ui.KeyedTable} instance
*/
/**
 * A callback function that provides content for [Table Row]{@link tf.ui.TableRow} instances in [Keyed Tables]{@link tf.ui.KeyedTable}
 * @public
 * @callback tf.types.KeyedRowTableGetContent
 * @param {tf.types.KeyedRowTableRowContentRequest} request - the request
 * @returns {HTMLElementLike} - | {@link HTMLElementLike} the requested content
 */
/**
 * Notifications sent by {@link tf.ui.KeyedTable} instances
 * @public
 * @typedef {object} tf.types.KeyedTableNotification
 * @property {tf.ui.Table} sender - the instance sending the notification
 * @property {tf.types.keyedFeatureListEventName} eventName - the name of the event
 * @property {object} properties - application defined properties provided in the creation of the [Keyed Table]{@link tf.ui.KeyedTable} instance
 * @property {tf.types.KeyedListEventNotification} keyedListNotification - the associated [Keyed List]{@link tf.js.KeyedList} notification
*/
/**
 * A callback function that receives change notifications from instances of [Keyed Table]{@link tf.ui.KeyedTable}
 * @public
 * @callback tf.types.KeyedTableCallBack
 * @param {tf.types.KeyedTableNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * Settings used in the creation of [Keyed Table]{@link tf.ui.KeyedTable} instances
 * @public
 * @typedef {object} tf.types.KeyedTableSettings
 * @property {tf.js.KeyedList} keyedList - the associated [Keyed List]{@link tf.js.KeyedList} instance
 * @property {tf.types.PropertyName} propertyName - the name of the [Keyed Item]{@link tf.js.KeyedItem} property to be associated with [Table Rows]{@link tf.ui.TableRow} in this table.
 * @property {object} optionalScope - optional JavaScript scope used in callBacks and notifications
 * @property {tf.types.KeyedTableCallBack} onContentChange - a callback to receive notifications from this table
 * @property {tf.types.KeyedRowTableGetContent} getRowContent - a callback to provide content for [Table Row]{@link tf.ui.TableRow} instances in this table
 * @property {object} properties - application defined properties, passed to notifications and callbacks
 * @property {tf.types.TableSettings} tableSettings - used in the creation of the associated [Table]{@link tf.ui.Table} instance, whose <b>keyedTable</b> property will be automatically defined by the Keyed Table
 * @property {tf.types.TableRowSettings} rowSettings - used in the creation of [Table Row]{@link tf.ui.TableRow} instances, whose <b>keyedItem</b> property will be automatically defined by the Keyed Table
*/
/**
 * @public
 * @class
 * @summary A Keyed Table creates and manages a [Table]{@link tf.ui.Table} instance to which [Table Rows]{@link tf.ui.TableRow} are automatically added, updated, and deleted 
 * based in the [Keyed Items]{@link tf.js.KeyedItem} and [events]{@link tf.types.keyedListEventName} of a given [Keyed List]{@link tf.js.KeyedList} instance. 
 * Keyed Tables obtain row content from a callback, and notify table change events to a single listener, both of which are specified on creation
 * @param {tf.types.KeyedTableSettings} settings - creation settings
 */
tf.ui.KeyedTable = function (settings) {
    var theThis, table, keyedList, onChangeCallBack, listMonitor, getRowContentCallBack, optionalScope, propertyName, properties;
    /**
     * @public
     * @function
     * @summary - Retrievs the application defined properties provided in the creation of this Keyed Table instance
     * @returns {object} - | {@link object} the properties
    */
    this.GetProperties = function () { return properties; }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Keyed List]{@link tf.js.KeyedList} instance associated with this Keyed Table instance
     * @returns {tf.js.KeyedList} - | {@link tf.js.KeyedList} the keyed list instance
    */
    this.GetKeyedList = function () { return keyedList; }
    /**
     * @public
     * @function
     * @summary - Retrieves the name of the [Keyed Item]{@link tf.js.KeyedItem} property that is associated with with [Table Rows]{@link tf.ui.TableRow} in this Keyed Table instance
     * @returns {tf.types.PropertyName} - | {@link tf.types.PropertyName} the name
    */
    this.GetPropertyName = function () { return propertyName; }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Table Row]{@link tf.ui.TableRow} associated with the given [Keyed Item]{@link tf.js.KeyedItem}, if one exists
     * @param {tf.js.KeyedItem} keyedItem - the keyed item
     * @returns {tf.ui.TableRow} - | {@link tf.ui.TableRow} the Table Row instance or {@link void}
    */
    this.GetRowFromKeyedItem = function (keyedItem) { return getTableRowFromItem(keyedItem); }
    function onListItemsAddedOrUpdated(notification) {
        var items = notification.items;
        for (var i in items) {
            var thisItem = items[i];
            var row = getTableRowFromItem(thisItem);
            var isNewItem = !row;
            var content;
            if (isNewItem) { setTableRowToItem(thisItem, row = new tf.ui.TableRow(tf.js.ShallowMerge(settings.rowSettings, { keyedItem: thisItem}))); } else { row.ClearContent(); }
            if (!!getRowContentCallBack) {
                var data = getRowContentCallBack.call(optionalScope, { sender: theThis, keyedItem: thisItem, properties: properties });
                if (tf.js.GetIsValidObject(data)) { content = data.content; }
            }
            if (!!content) { row.AddContent(content); } else { row.privateGetHTMLElement().innerHTML = thisItem.GetKey(); }
        }
    }
    function notifyChange(keyedListNotification, type) {
        if (!!onChangeCallBack) {
            onChangeCallBack.call(optionalScope, { sender: theThis, eventName: type, properties: properties, keyedListNotification: keyedListNotification });
        }
    }
    function onListItemsAdded(notification) {
        onListItemsAddedOrUpdated(notification);
        notifyChange(notification, tf.consts.keyedTableRowsAddedEvent);
    }
    function onListItemsUpdated(notification) {
        onListItemsAddedOrUpdated(notification);
        notifyChange(notification, tf.consts.keyedTableRowsUpdatedEvent);
    }
    function onListItemsDeleted(notification) {
        var items = notification.items;
        for (var i in items) {
            var thisItem = items[i], tableRow = getTableRowFromItem(thisItem);
            if (!!tableRow) { table.DelRow(tableRow); setTableRowToItem(thisItem, null); }
        }
        notifyChange(notification, tf.consts.keyedTableRowsDeletedEvent);
    }
    function getTableRowFromItem(keyedItem) { return tf.js.GetObjProperty(keyedItem, propertyName); }
    function setTableRowToItem(keyedItem, row) { tf.js.SetObjProperty(keyedItem, propertyName, row); if (!!row) { table.AppendRow(row); } }
    function deleteTableRowFromItem(keyedItem) { var row = getTableRowFromItem(keyedItem); if (!!row) { setTableRowToItem(keyedItem, null); row.OnDelete(); } }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        table = new tf.ui.Table(tf.js.ShallowMerge(settings.tableSettings, { keyedTable: theThis }));
        getRowContentCallBack = tf.js.GetFunctionOrNull(settings.getRowContent);
        optionalScope = settings.optionalScope;
        onChangeCallBack = tf.js.GetFunctionOrNull(settings.onContentChange);
        propertyName = tf.js.GetNonEmptyString(settings.propertyName, tf.consts.TableRowProperty);
        properties = tf.js.GetIsValidObject(settings.properties) ? settings.properties : {};
        if (tf.js.GetIsInstanceOf(settings.keyedList, tf.js.KeyedList)) {
            keyedList = settings.keyedList;
            var listeners = {};
            listeners[tf.consts.keyedListDeleteEvent] = onListItemsDeleted;
            listeners[tf.consts.keyedListAddedItemsEvent] = onListItemsAdded;
            listeners[tf.consts.keyedListUpdatedItemsEvent] = onListItemsUpdated;
            listeners[tf.consts.keyedListDeletedItemsEvent] = onListItemsDeleted;
            listMonitor = keyedList.AddListeners(listeners);
            keyedList.NotifyItemsAdded(onListItemsAddedOrUpdated);
        }
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: table });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.ui.KeyedTable, tf.dom.Insertable);
/**
 * Settings extracted by the function [GetDLayersInfoFromURLParameters]{@link tf.urlapi.GetDLayersInfoFromURLParameters} to be used in the creation of [DLayer]{@link tf.urlapi.DLayer} instances
 * @public
 * @typedef {object} tf.types.URLDLayerSettings
 * @property {string} - dLayerLegend - the name of the DLayer
 * @property {string} - dLayerData - the remote service associated with the DLayer
 * @property {string} - dLayerField - the name of the field to display as a [Map Feature]{@link tf.map.Feature}
 * @property {boolean} - dLayerSelect - the initial map visibility of the DLayer, <b>true</b> if visible, <b>false</b> otherwise
 * @property {string} - dLayerColor - the color with which to display text markers belonging to the DLayer
*/
/**
 * @public
 * @function
 * @summary - Extracts settings used to create a [DLayer List]{@link tf.urlapi.DLayerList} from the given url parameters 
 * @param {tf.types.URLParametersObject} parameters - the given parameters, in {@link object} format
 * @returns {enumerable<tf.types.URLDLayerSettings>} - | {@link enumerable} <{@link tf.types.URLDLayerSettings}> the retrieved settings
*/
tf.urlapi.GetDLayersInfoFromURLParameters = function (parameters) {
    var dLayers = [];
    if (tf.js.GetIsValidObject(parameters)) {
        var index = 0;
        if (getDLayerFromURL("", index)) { ++index; } if (getDLayerFromURL("0", index)) { ++index; } for (var iDLayer = 1 ; getDLayerFromURL(iDLayer, index) ; ++iDLayer) { ++index; }
    }
    function getDLayerFromURL(withSuffix, dLayerIndex) {
        var dLayerLegend;
        if (dLayerLegend = parameters[tf.consts.paramNameDLLegend + withSuffix]) {
            var dLayerData = parameters[tf.consts.paramNameDLData + withSuffix];
            var dLayerField = parameters[tf.consts.paramNameDLField + withSuffix];
            var dLayerSelect = tf.js.GetBoolFromValue(parameters[tf.consts.paramNameDLSelect + withSuffix], true);
            var dLayerColors = parameters[tf.consts.paramNameDLColor + withSuffix];
            if (!dLayerColors) { dLayerColors = ","; }
            var dLayerMarkerStyle = parameters["dLayerMarkerStyle" + withSuffix]
            var dLayerMarkerHoverStyle = parameters["dLayerMarkerHoverStyle" + withSuffix]
            if (!tf.js.GetIsValidObject(dLayerMarkerHoverStyle)) {
                dLayerMarkerHoverStyle = dLayerMarkerStyle;
            }
            dLayers.push({
                markerStyle: dLayerMarkerStyle,
                markerHoverStyle: dLayerMarkerHoverStyle,
                dLayerLegend: dLayerLegend, dLayerData: dLayerData, dLayerField: dLayerField, dLayerSelect: dLayerSelect, dLayerColors: dLayerColors, dLayerIndex: dLayerIndex
            });
            return true;
        }
        return false;
    }
    return dLayers;
};
/**
 * @public
 * @function
 * @summary - Creates links associated with [DLayer]{@link tf.urlapi.DLayer} record properties for display in a [Map's]{@link tf.map.Map} Info Window 
 * @param {string} href - the url associated with the link
 * @param {string} label - the text associated with the link
 * @param {string} toolTip - the link's tooltip
 * @param {string} target - the link's target
 * @param {tf.types.CSSStyleName} cssClass - optional css class. If defined, sets the HTML <b>class</b> property, defaults to {@link void}
 * @returns {tf.dom.Link} - | {@link tf.dom.Link} the link
*/
tf.urlapi.CreateInfoWindowLink = function (href, label, toolTip, target, cssClass) {
    var link = null; if (!!href) { link = new tf.dom.Link({ href: href, label: label, tooltip: toolTip, target: target, cssClass: cssClass }); } return link;
}
/**
 * @public
 * @function
 * @summary - Creates images associated with [DLayer]{@link tf.urlapi.DLayer} record properties for display in a [Map's]{@link tf.map.Map} Info Window 
 * @param {string} href - the url associated with the image
 * @returns {tf.dom.Img} - | {@link tf.dom.Img} the image
*/
tf.urlapi.CreateInfoWindowImg = function (href) { var img = null; if (!!href) { img = new tf.dom.Img({ src: href/*, cssClass: tf.GetStyles().imgForInfoWindowClass*/ }); } return img; }
/**
 * @public
 * @function
 * @summary - Creates HTML spans associated with [DLayer]{@link tf.urlapi.DLayer} record properties for display in a [Map's]{@link tf.map.Map} Info Window 
 * @param {string} text - the text to be placed inside the span
 * @returns {tf.dom.Span} - | {@link tf.dom.Span} the span
*/
tf.urlapi.CreateInfoWindowSpan = function (text) { var span = null; if (!!text) { span = new tf.dom.Span(); span.AddContent(text); } return span; }
/**
 * @public
 * @function
 * @summary - Creates information to be displayed in a [Map's]{@link tf.map.Map} Info Window about the given properties of a [DLayer]{@link tf.urlapi.DLayer} record
 * @param {object} props - the given properties associated with the map feature
 * @returns {void} - | {@link void} no return value
*/
tf.urlapi.BuildDLayerFeatureInfoWindow = function (props) {
    var div = new tf.dom.Div({ cssClass: tf.GetStyles().dLayerInfoClass });
    var thisProp;
    var linkTarget = '_top';
    if (thisProp = tf.urlapi.CreateInfoWindowLink(props.Display_Link_Detail, "Detail", "View Detail Report", linkTarget)) { div.AddContent(thisProp); }
    if (thisProp = tf.urlapi.CreateInfoWindowLink(props.Display_Link_Report_Recentered, "Nearby", "View Nearby Report", linkTarget)) { div.AddContent(thisProp); }
    if (thisProp = tf.urlapi.CreateInfoWindowLink(props.Display_Link_Location, "Location", "View Location Report", linkTarget)) { div.AddContent(thisProp); }
    if (thisProp = tf.urlapi.CreateInfoWindowLink(props.Display_Link_Pro, "Pro", "Professional detail report for realtors only", linkTarget)) { div.AddContent(thisProp); }
    if (thisProp = tf.urlapi.CreateInfoWindowSpan(props.Display_Summary_Short_Text)) { div.AddContent(thisProp); }
    if (props.Display_Thumbnail) {
        if (thisProp = tf.urlapi.CreateInfoWindowLink(props.Display_Link_Detail, "", "View Detail Report", linkTarget)) {
            var imgProp = tf.urlapi.CreateInfoWindowImg(props.Display_Thumbnail);
            if (imgProp) { imgProp.AppendTo(thisProp); div.AddContent(thisProp); }
        }
        else if (thisProp = tf.urlapi.CreateInfoWindowImg(props.Display_Thumbnail)) { div.AddContent(thisProp); }
    }
    if (thisProp = tf.urlapi.CreateInfoWindowSpan(props.Display_Summary_Longer_Text)) { div.AddContent(thisProp); }
    else if (thisProp = tf.urlapi.CreateInfoWindowSpan(props.Display_Summary_Midsize_Text)) { div.AddContent(thisProp); }
    if (thisProp = props.Display_Label) { if (thisProp.length > 1) { props.popupTitle = thisProp; } }
    props.infoWindowContent = div;
};
/**
 * @public
 * @function
 * @summary - Displays the information associated with the [DLayer]{@link tf.urlapi.DLayer} [Known Property Name]{@link tf.types.KnownAPIPropertyName} ({@link tf.consts.DLayerProperty})
 * in a [Map's]{@link tf.map.Map} Info Window 
 * @param {object} object - the object with an associated [DLayer Property]{@link tf.consts.DLayerProperty}
 * @returns {void} - | {@link void} no return value
*/
tf.urlapi.ShowdLayerInfoWindow = function (object) {
    var props = tf.js.GetObjProperty(object, tf.consts.DLayerProperty);
    if (!!props) {
        var infoWindowContent = props.properties.infoWindowContent;
        if (!infoWindowContent) {
            tf.urlapi.BuildDLayerFeatureInfoWindow(props.properties);
            infoWindowContent = props.properties.infoWindowContent
        }
        if (!!infoWindowContent) {
            var map = tf.js.GetMapFrom(props.map);
            if (!!map) {
                var label = tf.js.GetNonEmptyString(props.label);
                var position = tf.js.GetFunctionOrNull(object.GetPointCoords) ? object.GetPointCoords() : [0, 0];
                if (tf.js.GetIsNonEmptyString(props.properties.popupTitle)) { label = props.properties.popupTitle; }
                map.ShowInfoPopup(label, infoWindowContent, position);
            }
        }
    }
};
//tf.types.DLayerSettings
/**
 * @public
 * @class
 * @summary - DLayer instances retrieve records from TerraFly data sets and display their corresponding [Map Features]{@link tf.map.Feature} on the [Map]{@link tf.map.Map}.
 * Information pertaining to individual records is displayed using the map's Info Window.
 * @param {object} settings - creation settings, includes all properties in {@link tf.types.URLDLayerSettings} plus:
 * @param {tf.urlapi.DLayerList} settings.dLayerList - the associated DLayer List instance
 * @param {tf.map.Map} settings.map - the associated Map instance
 * @param {number} settings.zIndex - the zindex of the [Feature Layer]{@link tf.map.FeatureLayer} instance associated with this DLayer instance
 * @param {number} settings.topZIndex - the highest zindex used by [DLayer]{@link tf.urlapi.DLayer} instances in <b>dLayerList</b>
 * @param {tf.types.opacity01} settings.opacity - the opacity of the [Feature Layer]{@link tf.map.FeatureLayer} instance associated with this DLayer instance, defaults to <b>1</b>
 * @param {function} settings.preProcessDataItem - called to filter each dlayer data record
 * @param {function} settings.preProcessServiceData - called to filter the list of dlayer records
*/
tf.urlapi.DLayer = function (settings) {
    var theThis = null;
    var fileTypeXMLFilter = new RegExp('filetype=\.xml');
    var fileTypeGeoJSONReplace = 'filetype=.json';
    var map, featureLayer, legend, url_xml, display_fields, layer_select, colors, zIndex, index, topZIndex;
    var keyedList, downloadURL, keyedListsTimedRefresh, featureList, opacity;
    var isImageMarker, addedFeaturesListener, deletedFeaturesListener;
    var fontHeight, imgMarkerBaseStyle, imgMarkerBaseHoverStyle, textMarkerBaseStyle, textMarkerBaseHoverStyle, markerStyle, markerHoverStyle;
    var defaultColors, nDefaultColors, layerColor, fontColor, usingCustomMarkers, preProcessDataItem, preProcessServiceData, lastHoverFeatures;
    var mapListeners, nDLayerExtent, featuresExtent, showsInfoWindow;
    this.GetDisplayFieldName = function () { return display_fields; }
    this.GetMarkerStyleSpecs = function () {
        return {
            textMarkerBaseStyle: textMarkerBaseStyle,
            textMarkerBaseHoverStyle: textMarkerBaseHoverStyle,
            imgMarkerBaseStyle: imgMarkerBaseStyle,
            imgMarkerBaseHoverStyle: imgMarkerBaseHoverStyle
        };
    }
    this.GetFeaturesExtent = function () { return !!featuresExtent ? featuresExtent.slice(0) : [];}
    this.CalcExtent = function (maxRecords) { return calcExtent(maxRecords); }
    this.SetExtent = function () { return setExtent(); }
    this.MergeExtent = function () { return mergeExtent(); }
    this.AddListenersToMap = function(map) { return addListenersToMap(map) ; }
    this.GetShowsInfoWindow = function () { return showsInfoWindow; }
    this.SetShowsInfoWindow = function (bool) { showsInfoWindow = !!bool; }
    /**
     * @public
     * @function
     * @summary - Retrieves the index of this DLayer index in its [DLayer List]{@link tf.urlapi.DLayerList}
     * @returns {number} - | {@link number} the index
    */
    this.GetIndex = function () { return index; }
    /**
     * @public
     * @function
     * @summary - Retrieves the [DLayer List]{@link tf.urlapi.DLayerList} to which this DLayer instance belongs
     * @returns {tf.urlapi.DLayerList} - | {@link tf.urlapi.DLayerList} the list
    */
    this.GetDLayerList = function () { return settings.dLayerList; }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Map]{tf.map.Map} instance where this DLayer instance displays its [Map Features]{@link tf.map.Feature}
     * @returns {tf.map.Map} - | {@link tf.map.Map} the list
    */
    this.GetMap = function () { return map; }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Feature Layer]{tf.map.FeatureLayer} instance where this DLayer instance displays its [Map Features]{@link tf.map.Feature}
     * @returns {tf.map.FeatureLayer} - | {@link tf.map.FeatureLayer} the layer
    */
    this.GetFeatureLayer = function () { return featureLayer; }
    /**
     * @public
     * @function
     * @summary - Retrieves the name of this DLayer instance
     * @returns {string} - | {@link string} the name
    */
    this.GetName = function () { return legend; }
    /**
     * @public
     * @function
     * @summary - Removes all features from the [Feature Layer]{@link tf.map.FeatureLayer} instance associated with this DLayer instance
     * @returns {void} - | {@link void} no return value
    */
    this.RemoveAll = function () { if (!!keyedList) { keyedList.RemoveAllItems(); } }
    /**
     * @public
     * @function
     * @summary - Instructs this DLayer instance to replace its current records with records related to the current map center coordinates
     * @returns {void} - | {@link void} no return value
    */
    this.Refresh = function () { return refresh(); }
    /**
     * @public
     * @function
     * @summary - Determines if this DLayer instance is currently refreshing its records
     * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
    */
    this.GetIsRefreshing = function () { return keyedListsTimedRefresh.GetIsRefreshing(); }
//    this.RemoveFromMap = function () { return removeFromMap(); }
    /**
     * @public
     * @function
     * @summary - Changes the opacity of the [Feature Layer]{@link tf.map.FeatureLayer} instance associated with this DLayer instance
     * @param {tf.types.opacity01} opacity - the new opacity
     * @returns {void} - | {@link void} no return value
    */
    this.SetOpacity = function (opacity) { return setOpacity(opacity); }
    /**
     * @public
     * @function
     * @summary - Creates a [Keyed Table]{@link tf.ui.KeyedTable} associated with this DLayer instance's [Keyed List]{@link tf.js.KeyedList}
     * @param {tf.types.KeyedTableSettings} keyedTableSettings - used in the creation of the table
     * @returns {void} - | {@link void} no return value
    */
    this.CreateKeyedTable = function (keyedTableSettings) {
        var table = new tf.ui.KeyedTable(tf.js.ShallowMerge(keyedTableSettings, { keyedList: keyedList }));
        return table;
    }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Keyed Feature List]{@link tf.map.KeyedFeatureList} associated with this DLayer instance
     * @param {tf.map.Feature} mapFeature - the feature
     * @returns {tf.map.KeyedFeatureList} - | {@link tf.map.KeyedFeatureList} the feature list
    */
    this.GetFeatureList = function () { return featureList; }
    /**
     * @public
     * @function
     * @summary - Retrieves the [DLayer Properties]{@link tf.consts.DLayerProperty} associated with the given map feature
     * @param {tf.map.Feature} mapFeature - the feature
     * @returns {object} - | {@link object} the properties, actual contents vary depending on the DLayer's data set, may be {@link void} if <b>mapFeature</b> does not have DLayer Properties
    */
    this.GetDLayerFeatureProps = function (mapFeature) { return getDLayerFeatureProps(mapFeature); }
    /**
     * @public
     * @function
     * @summary - Retrieves the zindex of the [Feature Layer]{@link tf.map.FeatureLayer} instance associated with this DLayer instance
     * @returns {number} - | {@link number} the zIndex
    */
    this.GetZIndex = function () { return zIndex; }
    /**
     * @public
     * @function
     * @summary - Changes the zindex of the [Feature Layer]{@link tf.map.FeatureLayer} instance associated with this DLayer instance
     * @param {number} zindex - the new zIndex
     * @returns {void} - | {@link void} no return value
    */
    this.SetZIndex = function (zIndexSet) { zIndex = zIndexSet; if (!!featureLayer) { featureLayer.SetZIndex(zIndex); } }
    function setOpacity(opacitySet) {
        opacitySet = tf.js.GetFloatNumberInRange(opacitySet, 0, 1, 1);
        if (opacity != opacitySet) { opacity = opacitySet; if (!!featureLayer) { featureLayer.SetOpacity(opacity); } }
    }
    function refresh() { keyedList.RemoveAllItems(); if (!!featureLayer) { featureLayer.RemoveAllFeatures(); } updateDownloadURL(); keyedListsTimedRefresh.RefreshNow(); }
    function removeFromMap() {
        if (!!mapListeners) {
            for (var i in mapListeners) {
                mapListeners[i].hover.OnDelete();
                mapListeners[i].click.OnDelete();
            }
            mapListeners = null;
        }
    }
    function createFeaturesFromSpecs(specs) {
        var features;
        if (tf.js.GetIsValidObject(specs)) {
            for (var i in specs) {
                var spec = specs[i];
                if (tf.js.GetHasGeoJSONGeometryProperties(spec)) {
                    if (!features) { features = []; }
                    features.push(new tf.map.Feature(spec));
                }
            }
        }
        return features;
    }
    function myPreProcessServiceData(data) {
        //tf.GetDebug().FileLog(data["category id"] + '-results', data);
        var parsedData = [];
        if (!featureLayer) {
            var layerDescription;
            
            if (tf.js.GetIsValidObject(data) && tf.js.GetIsNonEmptyString(data.title)) {
                layerDescription = data.title;
            }
            else {
                layerDescription = "Map layer: " + legend;
            }
            featureLayer = map.AddFeatureLayer({
                //useClusters: true, clusterStyle: {}, clusterLabelStyle: textMarkerBaseStyle,
                name: legend, description: layerDescription, isVisible: layer_select, isHidden: false, color: layerColor, zIndex: zIndex, opacity: opacity
            });
        }
        if (!!preProcessServiceData) { preProcessServiceData(data, theThis); }
        if (tf.js.GetIsValidObject(data) && tf.js.GetIsNonEmptyArray(data.features) &&
            tf.js.GetHasGeoJSONGeometryProperties(data.features[0].geometry)) {
            var props = data.properties;
            if (tf.js.GetIsValidObject(props)) {
                if (tf.js.GetIsValidObject(props.markerStyle)) {
                    markerStyle = props.markerStyle;
                    markerHoverStyle = tf.js.GetIsValidObject(props.markerHoverStyle) ? props.markerHoverStyle : markerStyle;
                    usingCustomMarkers = true;
                }
            }
            var catID = data["category id"];
            if (tf.js.GetIsNonEmptyString(catID)) {
                catID = catID.toLowerCase();
                if (catID == "geoimages") {
                    markerStyle = [{
                        "zindex": 1, "round_rect": true, "round_rect_width": 50, "round_rect_height": 40, "round_rect_radius": 5, "fill": true, "fill_color": "#ebebeb", "fill_alpha": 100, "line": true, "line_color": "#000", "line_width": 2
                    }, {
                        "zindex": 1, "scale": 1, "icon": true, "icon_url": "$[L]"
                    }];
                    markerHoverStyle = [{
                        "zindex": 2, "round_rect": true, "round_rect_width": 64, "round_rect_height": 52, "round_rect_radius": 10, "fill": true, "fill_color": "#ebebeb", "fill_alpha": 100, "line": true, "line_color": "#00a", "line_width": 3
                    }, {
                        "zindex": 2, "scale": 1.2, "icon": true, "icon_url": "$[L]"
                    }];
                    usingCustomMarkers = true;
                }
                else if (catID == "alta") {
                    var addStyle = { rotate_with_map: false };
                    imgMarkerBaseStyle = tf.js.ShallowMerge(imgMarkerBaseStyle, addStyle);
                    imgMarkerBaseHoverStyle = tf.js.ShallowMerge(imgMarkerBaseHoverStyle, addStyle);
                }
            }
            parsedData = data.features;
            for (var i in parsedData) {
                var thisFeature = parsedData[i]; thisFeature.properties = tf.urlapi.NormalizeJSONProperties(thisFeature.properties);
                if (!!preProcessDataItem) { preProcessDataItem(thisFeature.properties); }
                thisFeature.properties.hoverFeatures = createFeaturesFromSpecs(thisFeature.properties.hoverFeatureSpecs);
                thisFeature.properties.additionalFeatures = createFeaturesFromSpecs(thisFeature.properties.additionalFeatureSpecs);
            }
            if (!featureList) {
                var prefix = "http://", len_of_prefix = prefix.length;
                var properties = data.features[0].properties, label = properties[display_fields];
                if (tf.js.GetIsNonEmptyString(label)) {
                    isImageMarker = label.trim().toLowerCase().substring(0, len_of_prefix) == prefix;
                    createFeatureList();
                }
            }
        }
        //else { setTimeout(refresh, 5000); }
        return parsedData;
    }
    function getDLayerFeatureProps(mapFeature) { return tf.js.GetObjProperty(mapFeature, tf.consts.DLayerProperty); }
    function onFeatureClick(notification) {
        var props = getDLayerFeatureProps(notification.mapFeature);
        if (!!props) {
            if (props.dLayer == theThis) {
                if (showsInfoWindow && tf.browser.HasTouch()) { tf.urlapi.ShowdLayerInfoWindow(notification.mapFeature); }
                else if (!!props.windowOpen) { window.open(props.windowOpen, "_blank"); }
            }
        }
    }
    // for polylines and such associated with the dlayer marker
    function removeLastHoverFeatures() { for (var i in lastHoverFeatures) { featureLayer.DelMapFeature(lastHoverFeatures[i]); } lastHoverFeatures = []; }
    function addFeatures(features) { if (tf.js.GetIsValidObject(features)) { for (var i in features) { featureLayer.AddMapFeature(features[i]); } } }
    function onFeatureHoverInOut(notification) {
        var props = getDLayerFeatureProps(notification.mapFeature);
        if (!!props) {
            if (props.dLayer == theThis) {
                removeLastHoverFeatures();
                if (notification.isInHover) {
                    addFeatures(lastHoverFeatures = props.properties.hoverFeatures);
                    featureLayer.SetZIndex(topZIndex);
                    if (showsInfoWindow) {
                        tf.urlapi.ShowdLayerInfoWindow(notification.mapFeature);
                    }
                }
                else { featureLayer.SetZIndex(zIndex); }
            }
        }
    }
    function setExtent() {
        var refreshOnRes = settings.dLayerList.GetRefreshOnResChange();
        if (refreshOnRes) { settings.dLayerList.SetRefreshOnResChange(false); }
        if (!!featuresExtent) { map.SetVisibleExtent(featuresExtent); }
        //tf.GetDebug().AddExtent(featuresExtent, featureLayer);
        if (refreshOnRes) { setTimeout(function () { settings.dLayerList.SetRefreshOnResChange(true); }, 1000); }
    }
    function mergeExtent() {
        if (!!featuresExtent) {
            var visibleExtent = map.GetVisibleExtent();
            var mergedExtent = tf.js.MergeMapExtents(visibleExtent, featuresExtent);
            var refreshOnRes = settings.dLayerList.GetRefreshOnResChange();
            if (refreshOnRes) { settings.dLayerList.SetRefreshOnResChange(false); }
            map.SetVisibleExtent(mergedExtent);
            if (refreshOnRes) { setTimeout(function () { settings.dLayerList.SetRefreshOnResChange(true); }, 1000); }
        }
    }
    function calcExtent(maxRecords) {
        featuresExtent = null;
        if (!!featureList) {
            var mapFeatures = featureList.GetFeatures();
            var nAddToExtent = tf.js.GetIntNumberInRange(maxRecords, 0, mapFeatures.length, mapFeatures.length);
            if (nAddToExtent > 0) {
                for (var i = 0 ; i < nAddToExtent ; ++i) {
                    var feature = mapFeatures[i], featureCoords = feature.GetPointCoords();
                    if (!featuresExtent) { featuresExtent = [featureCoords[0], featureCoords[1], featureCoords[0], featureCoords[1]]; }
                    else { featuresExtent = tf.js.UpdateMapExtent(featuresExtent, featureCoords); }
                }
            }
        }
    }
    function onFeaturesAdded(notification) {
        featuresExtent = null;
        var count = 0;
        for (var i in notification.items) {
            var keyedItem = notification.items[i];
            var mapKeyedFeature = featureList.GetFeatureFromItem(keyedItem);
            var mapFeature = mapKeyedFeature.GetMapFeature();
            var itemData = keyedItem.GetData();
            var properties = itemData.properties;
            var featureCoords = mapFeature.GetPointCoords();
            if (count < nDLayerExtent) {
                if (!featuresExtent) { featuresExtent = [featureCoords[0], featureCoords[1], featureCoords[0], featureCoords[1]]; }
                else { featuresExtent = tf.js.UpdateMapExtent(featuresExtent, featureCoords); }
                count++;
            }
            mapFeature.GetLayer = function () { return featureLayer };
            //if (properties.Display_Label !== undefined) { tf.urlapi.BuildDLayerFeatureInfoWindow(properties); }
            tf.js.SetObjProperty(mapFeature, tf.consts.DLayerProperty, { properties: properties, label: legend, map: map, dLayer: theThis });
            addFeatures(properties.additionalFeatures);
        }
        map.ShowSomeKeyedFeatures(featureList, notification.keys, true);
        if (!!count) { nDLayerExtent = 0; mergeExtent(); }
    }
    function onFeaturesDeleted(notification) {
        map.ShowSomeKeyedFeatures(featureList, notification.keys, false);
    }
    function getStyle(mapFeature, isHover) {
        var style;
        var keyedItem = !!mapFeature ? mapFeature.GetKeyedItem() : null;
        if (keyedItem) {
            var itemProperties = keyedItem.GetData().properties;
            //tf.GetDebug().FileLog("props", itemProperties);
            if (usingCustomMarkers) {
                var baseTextStyle = isHover ? markerHoverStyle : markerStyle;
                if (tf.js.GetIsNonEmptyArray(baseTextStyle)) {
                    style = [];
                    for (var i in baseTextStyle) { style.push(tf.js.ReplaceObjectWithValues(tf.js.ShallowMerge(baseTextStyle[i]), itemProperties)); }
                }
                else { style = tf.js.ShallowMerge(baseTextStyle); style = tf.js.ReplaceObjectWithValues(style, itemProperties); }
            }
            else {
                var label = itemProperties[display_fields];
                var prefix = "http://", len_of_prefix = prefix.length;
                var isImageMarker = label.trim().toLowerCase().substring(0, len_of_prefix) == prefix;
                if (isImageMarker) {
                    var customPerMarkerStyle = { icon_url: label };
                    style = isHover ? tf.js.ShallowMerge(imgMarkerBaseHoverStyle, customPerMarkerStyle) : tf.js.ShallowMerge(imgMarkerBaseStyle, customPerMarkerStyle);
                }
                else {
                    var baseTextStyle = isHover ? textMarkerBaseHoverStyle : textMarkerBaseStyle;
                    var customPerMarkerStyle = { label: label/*, marker_color: layerColor*/ };
                    if (tf.js.GetIsNonEmptyArray(baseTextStyle)) { style = baseTextStyle.slice(0); style[0] = tf.js.ShallowMerge(style[0], customPerMarkerStyle); }
                    else { style = tf.js.ShallowMerge(baseTextStyle, customPerMarkerStyle); }
                }
            }
        }
        return style;
    }
    function getNormalStyle(mapFeature) { return getStyle(mapFeature, false); }
    function getHoverStyle(mapFeature) { return getStyle(mapFeature, true); }
    function createFeatureList() {
        featureList = new tf.map.KeyedFeatureList({
            featureStyleSettings: { style: getNormalStyle, hoverStyle: getHoverStyle },
            getGeometryFromData: getGeometryFromData, propertyName: tf.consts.KeyedFeatureFromDLayer,
            onCreated: undefined, keyedList: keyedList, layerName: legend
        });
        addedFeaturesListener = featureList.AddListener(tf.consts.keyedFeaturesAddedEvent, onFeaturesAdded);
        deletedFeaturesListener = featureList.AddListener(tf.consts.keyedFeaturesDeletedEvent, onFeaturesDeleted);
        addListenersToMap(map);
    }
    function addListenersToMap(map) {
        if (!!(map = tf.js.GetMapFrom(map))) {
            if (!mapListeners) { mapListeners = []; }
            mapListeners.push({
                hover: map.AddListener(tf.consts.mapFeatureHoverInOutEvent, onFeatureHoverInOut),
                click: map.AddListener(tf.consts.mapFeatureClickEvent, onFeatureClick)
            });
        }
    }
    function updateDownloadURL() {
        if (!!map) {
            var lowerURL = url_xml.toLowerCase();
            if (lowerURL.indexOf('.txt') == -1) {
                var currentLevel = map.GetLevel(), currentCenter = map.GetCenter();
                downloadURL = url_xml + "&x1=" + currentCenter.Longitude + "&y1=" + currentCenter.Latitude + "&cres=" + map.GetResolution() + "&timestamp=" + (new Date()).getTime();
            }
            else {
                downloadURL = url_xml;
            }
            //tf.GetDebug().LogIfTest(downloadURL);
        }
        //downloadURL = "http://localhost/terramap/apps/bq.txt";
    }
    function needsUpdateItemData(updateObj) { return false; }
    function getKeyFromItemData(itemData) { return itemData.properties.Display_Link_Detail; }
    function getGeometryFromData(itemData) { return itemData.geometry; }
    function initialize() {
        if (tf.js.GetIsValidObject(settings)) {
            showsInfoWindow = true;
            preProcessDataItem = tf.js.GetFunctionOrNull(settings.preProcessDataItem);
            preProcessServiceData = tf.js.GetFunctionOrNull(settings.preProcessServiceData);
            legend = settings.dLayerLegend;
            map = settings.map;
            url_xml = settings.dLayerData ? unescape(settings.dLayerData) : "";
            display_fields = !!settings.dLayerField ? settings.dLayerField : "L";
            layer_select = typeof settings.dLayerSelect === "string" ? settings.dLayerSelect.toLowerCase() != "false" : !!settings.dLayerSelect;
            colors = settings.dLayerColors.split(",");
            zIndex = settings.zIndex;
            topZIndex = settings.topZIndex;
            index = settings.dLayerIndex;
            nDLayerExtent = tf.js.GetIntNumberInRange(settings.nDLayerExtent, 0, 999, 0);
            setOpacity(settings.opacity);
            defaultColors = ["#ffb27f", "#7fe5ff", "#ffe57f", "#7fb2ff", "#e6ff7f", "#807fff", "#b3ff7f", "#b37fff", "#80ff7f", "#e67fff", "#7fffb2", "#ff7fe5", "#7fffe5", "#ff7fb2"];
            nDefaultColors = defaultColors.length;
            layerColor = colors[0].length > 0 ? colors[0] : defaultColors[index % nDefaultColors];
            fontColor = colors[1].length > 0 ? colors[1] : "#000";
            url_xml = url_xml.replace(fileTypeXMLFilter, fileTypeGeoJSONReplace);
            updateDownloadURL();
            if (tf.js.GetIsValidObject(settings.markerStyle)) {
                markerStyle = settings.markerStyle;
                markerHoverStyle = tf.js.GetIsValidObject(settings.markerHoverStyle) ? settings.markerHoverStyle : markerStyle;
                usingCustomMarkers = true;
            }
            /*else {*/
                imgMarkerBaseStyle = { icon: true, icon_anchor: [0.5, 0.5], scale: 1.0, zindex: 1 };
                imgMarkerBaseHoverStyle = tf.js.ShallowMerge(imgMarkerBaseStyle, { scale: 1.5, zindex: 2 });
                fontHeight = tf.GetStyles().GetSubStyles().markerFontSizePXNumber;
                /*textMarkerBaseStyle = {
                    marker: true, font_height: fontHeight, border_color: "#000", border_width: 2, zindex: 1, line_color: "#fff", marker_arrowlength: 12, line_opacity: 0.6, line_width: 2,
                    marker_color: layerColor, font_color: fontColor, marker_opacity: 0.8, border_opacity: 0.6
                };*/
                textMarkerBaseStyle = {
                    marker: true, font_height: fontHeight, border_color: "#000", border_width: 2, zindex: 1, line_color: "#fff", marker_arrowlength: 12, line_opacity: 60, line_width: 2,
                    marker_color: layerColor, font_color: fontColor, marker_opacity: 85, border_opacity: 60
                };
                textMarkerBaseHoverStyle = tf.js.ShallowMerge(textMarkerBaseStyle, { font_height: fontHeight + 1, zindex: 2, border_color: "#000", border_width: 3/*, scale: 1.1*/, marker_arrowlength: 8 });
            //}
            keyedList = (keyedListsTimedRefresh = new tf.js.KeyedListsPeriodicRefresh({
                onCreated: settings.onCreated, retryOnFail: false,
                serviceURL: function () { return downloadURL; },
                preProcessServiceData: myPreProcessServiceData, useRedirect: false,
                refreshCallback: settings.refreshCallback, refreshMillis: 0, refreshOnCreate: true,
                keyedLists: [{
                    name: legend, keepNotUpdated: true, getKeyFromItemData: getKeyFromItemData, needsUpdateItemData: needsUpdateItemData
                }]
            })).GetKeyedList(legend);
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * @public
 * @class
 * @summary - DLayer List instances include one or more [DLayer]{@link tf.urlapi.DLayer} instances
 * @param {object} settings - creation settings
 * @param {tf.map.Map} settings.map - a map instance to display DLayer features
 * @param {function} settings.preProcessDataItem - called to filter each dlayer data record
 * @param {function} settings.preProcessServiceData - called to filter the list of dlayer records
 * @param {enumerable<tf.types.URLDLayerSettings>} settings.dLayersInfo - settings objects, one for each DLayer to be created
*/
tf.urlapi.DLayerList = function (settings) {
    var theThis, dLayers, dLayersOpacity, topZIndex, map, nDLayerExtent, resChangeListener, refreshOnResChange;
    this.AddListenersToMap = function (map) { for (var i in dLayers) { dLayers[i].AddListenersToMap(map); } }
    this.SetRefreshOnResChange = function (bool) { refreshOnResChange = !!bool; }
    this.GetRefreshOnResChange = function () { return refreshOnResChange; }
    /**
     * @public
     * @function
     * @summary - Retrieves the highest zindex used by [DLayer]{@link tf.urlapi.DLayer} instances in this DLayer List instance
     * @returns {number} - | {@link number} the zIndex
    */
    this.GetTopZIndex = function () { return topZIndex; }
    /**
     * @public
     * @function
     * @summary - Moves the given [DLayer]{@link tf.urlapi.DLayer} instance to the top of all other instances in this DLayer List instance
     * @param {tf.urlapi.DLayer} dLayer - the given DLayer instance
     * @returns {void} - | {@link void} no return value
    */
    this.MoveToTopZIndex = function (dLayer) { return moveToTopZIndex(dLayer); }
    /**
     * @public
     * @function
     * @summary - Sets the opacity of all [DLayer]{@link tf.urlapi.DLayer} instances in this DLayer List instance
     * @param {tf.types.opacity01} opacity - the new opacity
     * @returns {void} - | {@link void} no return value
    */
    this.SetAllOpacity = function (opacity) { for (var i in dLayers) { var dLayer = dLayers[i]; dLayer.SetOpacity(opacity); } }
    /**
     * @public
     * @function
     * @summary - Removes all features from all [DLayer]{@link tf.urlapi.DLayer} instances associated with this DLayer List instance
     * @returns {void} - | {@link void} no return value
    */
    this.RemoveAll = function () { for (var i in dLayers) { var dLayer = dLayers[i]; dLayer.RemoveAll(); } }
    /**
     * @public
     * @function
     * @summary - Refreshes all [DLayer]{@link tf.urlapi.DLayer} instances associated with this DLayer List instance
     * @returns {void} - | {@link void} no return value
    */
    this.RefreshAll = function () { for (var i in dLayers) { var dLayer = dLayers[i]; dLayer.Refresh(); } }
    this.SetShowsInfoWindow = function (bool) { for (var i in dLayers) { var dLayer = dLayers[i]; dLayer.SetShowsInfoWindow (bool); }; }
//    this.RemoveFromMap = function () { for (var i in dLayers) { var dLayer = dLayers[i]; dLayer.RemoveFromMap(opacity); } dLayers = []; }
    /**
     * @public
     * @function
     * @summary - Retrieves a [DLayer]{@link tf.urlapi.DLayer} instance associated with this DLayer List instance by the given index
     * @param {number} index - the given index
     * @returns {tf.urlapi.DLayer} - | {@link tf.urlapi.DLayer} the DLayer instance, or {@link void} if <b>index</b> is invalid
    */
    this.Get = function (index) { return get(index); }
    /**
     * @public
     * @function
     * @summary - Retrieves the number of [DLayer]{@link tf.urlapi.DLayer} instances associated with this DLayer List instance
     * @returns {number} - | {@link number} the number of instances
    */
    this.GetCount = function () { return dLayers.length; }
    function isValidDLayerIndex(index) { return !!dLayers ? index >= 0 && index < dLayers.length : false; }
    function get(index) { return isValidDLayerIndex(index) ? dLayers[index] : null; }
    function moveToTopZIndex(dLayer) {
        if (tf.js.GetIsInstanceOf(dLayer, tf.urlapi.DLayer) && dLayer.GetDLayerList() == theThis) {
            var thisZIndex = dLayer.GetZIndex();
            for (var i in dLayers) {
                var thisDLayer = dLayers[i];
                if (thisDLayer != dLayer) {
                    var thisDLayerZIndex = thisDLayer.GetZIndex();
                    if (thisDLayerZIndex > thisZIndex) {
                        thisDLayer.SetZIndex(thisDLayerZIndex - 1);
                    }
                }
            }
            dLayer.SetZIndex(topZIndex - 1);
        }
    }
    function add(dLayerInfo, zIndex) {
        var indexInDLayers = dLayers.length;
        var dLayerSettings = tf.js.ShallowMerge(dLayerInfo, {
            indexInDLayers: indexInDLayers,
            dLayerList: theThis, map: map, zIndex: zIndex, topZIndex: topZIndex, opacity: settings.opacity, preProcessDataItem: settings.preProcessDataItem,
            preProcessServiceData: settings.preProcessServiceData
        });
        if (indexInDLayers == 0) { dLayerSettings.nDLayerExtent = nDLayerExtent; }
        var newDLayer = new tf.urlapi.DLayer(dLayerSettings);
        dLayers.push(newDLayer);
    }
    function initialize() {
        var minZIndex = 10;
        var thisZIndex = 0;
        settings = tf.js.GetValidObjectFrom(settings);
        nDLayerExtent = tf.js.GetIntNumberInRange(settings.nDLayerExtent, 0, 999, 0);
        if (!!(map = tf.js.GetMapFrom(settings.map))) {
            var dLayersInfo = tf.js.GetIsNonEmptyArray(settings.dLayersInfo) ? settings.dLayersInfo : [];
            var nDLayers = dLayersInfo.length;
            topZIndex = nDLayers + minZIndex;
            var thisDLayerZIndex = topZIndex;
            dLayers = [];
            refreshOnResChange = settings.refreshOnResChange != undefined ? !!settings.refreshOnResChange : true;
            for (var i in dLayersInfo) {
                add(dLayersInfo[i], --thisDLayerZIndex);
            }
            resChangeListener = map.AddListener(tf.consts.mapResolutionChangeEvent, function (notification) {
                if (!!refreshOnResChange) {
                    theThis.RefreshAll();
                }
            });
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * class tf.ui.HorSplitter - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} splitterObj - parameter description?
 * @param {?} topObj - parameter description?
 * @param {?} botObj - parameter description?
 * @param {?} resizeCallBack - parameter description?
 * @param {?} resizeCallBackThis - parameter description?
*/
tf.ui.HorSplitter = function (splitterObj, topObj, botObj, resizeCallBack, resizeCallBackThis) {
    var theThis = null;
    var docMouse = tf.GetDocMouseListener();
    var splitterDiv, topDiv = null, botDiv = null;
    var mouseListenerSplitter = null;
    var mouseListenerDoc = null;
    var isDragging = false;
    var releaseEventName = docMouse.GetReleaseEventName();
/**
 * method tf.ui.HorSplitter.GetIsDragging - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetIsDragging = function () { return isDragging; }
    var heightTop = null;
    var heightBot = null;
    var yStartDrag = null;
    function startDrag(event) {
        tf.GetDebug().LogIfTest("Splitter Start");
        stopDrag();
        docMouse.SetCapture(onMouseOnSplitter, theThis, null);
        isDragging = true;
        heightTop = topDiv.offsetHeight;
        heightBot = botDiv.offsetHeight;
        yStartDrag = event.screenY;
    }
    function continueDrag(event, eventName) {
        if (isDragging) {
            tf.GetDebug().LogIfTest("Splitter Drag: " + eventName);
            var yDrag = event.screenY;
            var offset = yDrag - yStartDrag;
            var newHeightTop = heightTop + offset;
            var newHeightBot = heightBot - offset;
            topDiv.style.height = newHeightTop + "px";
            botDiv.style.height = newHeightBot + "px";
            notifyResize();
        }
    }
    function stopDrag() {
        if (isDragging) {
            docMouse.ReleaseCapture();
            tf.GetDebug().LogIfTest("Splitter Stop");
            isDragging = false;
        }
    }
    function onMouseOnSplitter(mouseListener, argumentsArray, event, eventName, posX, posY) {
        tf.GetDebug().LogIfTest('needs adjust parameters');
        if (isDragging) { if (eventName == 'mouseup' || eventName == "touchend" || eventName == "touchcancel") { stopDrag(); } else if (eventName != releaseEventName) { continueDrag(event, eventName); } }
        else if (eventName == 'mousedown' || eventName == "touchstart") { startDrag(event); }
        return isDragging;
    }
    function notifyResize() { if (!!resizeCallBack) { resizeCallBack.call(resizeCallBackThis, theThis); } }
    function initialize() {
        resizeCallBack = typeof resizeCallBack === "function" ? resizeCallBack : null;
        splitterDiv = splitterObj.GetHTMLElement();
        topDiv = topObj.GetHTMLElement();
        botDiv = botObj.GetHTMLElement();
        mouseListenerSplitter = new tf.events.DOMMouseListener({ target: splitterDiv, callBack: onMouseOnSplitter, optionalScope: theThis, callBackSettings: undefined });
    }
    (function actualConstructor(theThisSet) {
        theThis = theThisSet;
        initialize();
    })(this);
};
/**
 * Specifications for the next animation set, returned by [Map Animation Callbacks]{@link tf.types.MapAnimationCallBack}, passed to
 * the function {@link tf.map.Map#StartAnimation}, upon receiving an [Animation Request]{@link tf.types.MapAnimationRequest} 
 * sent by a {@link tf.map.Map} instance
 * @public
 * @typedef {object} tf.types.MapAnimationStep
 * @property {tf.types.mapCoordinates} center - the new map center, if defined
 * @property {tf.types.mapResolution} resolution - the new map resolution, if defined
 * @property {number} rotation - the new map rotation, in radians, if defined
 * @property {number} duration - the duration of the animation step, in milliseconds
 * @property {boolean} notifyListeners - if set to <b>true</b> event notifications are sent to listeners during the animation, 
 * @property {tf.types.EasingFunction} easing - if not defined defaults to {@link tf.units.EaseInAndOut}
 * otherwise notifications are sent only when the animation ends, defaults to {@link void}
*/
/**
 * A request for the next animation step sent by {@link tf.map.Map} instances to callBacks passed to the function {@link tf.map.Map#StartAnimation}
 * @public
 * @typedef {object} tf.types.MapAnimationRequest
 * @property {tf.map.Map} sender - the instance sending the notification
 * @property {number} step - the current animation step, starts at 0 and is incremented at each call. 
 * Used by the callBack to determine which data to return for the next setp of the animation, and
 * when to stop the animation. 
 * An ongoing animation may be prematurely stoped by calls made to {@link tf.map.Map#StartAnimation} 
 * or {@link tf.map.Map#EndAnimation}, in which case this property is set to <b>-1</b>
*/
/**
 * A callback function that can be passed to the function {@link tf.map.Map#StartAnimation} to start an ongoing map animation
 * @public
 * @callback tf.types.MapAnimationCallBack
 * @param {tf.types.MapAnimationRequest} request - a request for the next animation step
 * @returns {tf.types.MapAnimationStep} - | {@link tf.types.MapAnimationStep} the requested next step, or {@link void} to end the animation
 */
/**
 * Map UTM coordinates use the array format <b>[ x, y, zone  ]</b>
 * @public
 * @typedef {array} tf.types.mapUTMCoordinates
 */
/**
 * Map coordinates use the GeoJSON array format <b>[ {@link tf.types.longitude}, {@link tf.types.latitude} ]</b>
 * @public
 * @typedef {array} tf.types.mapCoordinates
 */
/**
 * Map extents delimit a rectangular map area and are defined by a 4-position coordinate array in the order: <b>[ minLon, minLat, maxLon, maxLat ]</b>, where min/maxLon coordinates 
 * are {@link tf.types.longitude} and min/maxLat coordinates are {@link tf.types.latitude}
 * @public
 * @typedef {array} tf.types.mapExtent
 */
/**
 * An instance of a map layer class, currently only {@link tf.map.FeatureLayer}
 * @public
 * @typedef {tf.types.mapLayer} tf.types.mapLayer
 */
/**
 * A callback function that can be passed to the function [Add Listener]{@link tf.map.Map#AddListener} of a [Map]{@link tf.map.Map} instance to start receiving event notifications from it
 * @public
 * @callback tf.types.MapEventCallBack
 * @param {tf.types.MapEventNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * A callback, provided by map ({@link tf.map.Map}) instances during {@link tf.consts.mapPreComposeEvent} and {@link tf.consts.mapPostComposeEvent} notifications, 
 * to start a new rendering cycle after the current one completes
 * @public
 * @callback tf.types.MapContinueAnimation
 * @returns {void} - | {@link void} no return value
 * @see {@link tf.types.MapShowFeatureImmediately}
 */
/**
 * A callback, provided by map ({@link tf.map.Map}) instances during {@link tf.consts.mapPreComposeEvent} and {@link tf.consts.mapPostComposeEvent} notifications, to display instances of {@link tf.map.Feature} 
 * during the post compose phase of the map rendering cycle. This can be used to achieve animation effects, and to display transient map features that are not associated with a persistent data set
 * @public
 * @callback tf.types.MapShowFeatureImmediately
 * @param {tf.map.Feature} mapFeature - the map feature to show
 * @returns {void} - | {@link void} no return value
 * @see {@link tf.types.MapContinueAnimation}
 */
/**
 * Elements in the <b>featureCluster</b> property included in some notifications sent by {@link tf.map.Map} instances.
 * @public
 * @typedef {object} tf.types.MapFeatureClusterElement
 * @property {tf.map.Feature} mapFeature - a map feature in the cluster
 * @property {tf.map.KeyedFeature} keyedFeature - the keyed feature associated with the <b>mapFeature</b>, if any
 * @property {string} styleName - the name of the style of the <b>mapFeature</b>, if any
 */
/**
 * Notifications sent by {@link tf.map.Map} instances. Properties are included in the event notifications that require them, and undefined otherwise
 * @public
 * @typedef {object} tf.types.MapEventNotification
 * @property {tf.map.Map} sender - the instance sending the notification
 * @property {tf.types.mapEventName} eventName - the name of the event
 * @property {tf.types.mapCoordinates} eventCoords - the map coordinates associated with the event, if any
 * @property {tf.types.mapResolution} resolution - the map resolution in {@link tf.consts.mapResolutionChangeEvent} notifications
 * @property {tf.types.mapLevel} level - the map level in {@link tf.consts.mapLevelChangeEvent} notifications
 * @property {tf.map.KeyedFeature} keyedFeature - the keyed feature associated with the event, if any
 * @property {tf.map.Feature} mapFeature - the map feature associated with the event, if any
 * @property {string} styleName - the name of the style of the map feature associated with the event, if any
 * @property {boolean} isInHover - <b>true</b> if for "hover in" events, <b>false</b> for "hover out" events
 * @property {tf.map.KeyedFeature} nextKeyedFeature - the next keyed feature being "hovered in" in "hover out" event notifications
 * @property {tf.map.Feature} nextFeature - the next map feature being "hovered in" in "hover out" event notifications
 * @property {tf.map.KeyedFeature} prevKeyedFeature - the previous keyed feature being "hovered out" in "hover in" event notifications
 * @property {tf.map.Feature} prevFeature - the previous map feature being "hovered out" in "hover in" event notifications
 * @property {tf.map.Feature} prevFeature - the previous map feature being "hovered out" in "hover in" event notifications
 * @property {tf.types.MapShowFeatureImmediately} showFeatureImmediately - a function that displays an instance of {@link tf.map.Feature} during the post compose phase of the map rendering cycle
 * @property {tf.types.MapContinueAnimation} continueAnimation - a function that instructs the {@link tf.map.Map} instance to start a new rendering cycle after the current one completes
 * @property {tf.types.mapType} oldType - the map type being replaced in {@link tf.consts.mapTypeChangeEvent} notifications
 * @property {tf.types.mapType} newType - the new map type in {@link tf.consts.mapTypeChangeEvent} notifications
 * @property {array<tf.types.MapFeatureClusterElement>} featureCluster - an array containing information about map features in the same cluster as the map feature 
 * for which the event was triggered. This property is <b>undefined</b> in
 * non-cluster related event notifications
*/
/**
 * Settings used by the [map]{@link tf.map.Map} function [AddFeatureLayer]{@link tf.map.Map#AddFeatureLayer}
 * @public
 * @typedef {object} tf.types.AddFeatureLayerSettings
 * @property {string} name - the layer name, displayed in the Map Layers popup
 * @property {string} description - the layer description
 * @property {boolean} isVisible - if <b>false</b> the layer is created invisible, defaults to <b>true</b>
 * @property {boolean} isHidden - if <b>false</b> the layer is not listed in the Map Layers popup, defaults to <b>true</b>
 * @property {number} zIndex - the layer zIndex, defaults to 0
 * @property {tf.types.opacity01} opacity - the layer opacity, defaults to 1
 * @property {tf.types.MinMaxLevels} minMaxLevels - if defined, constrains the layer's visibility to the given range, defaults to {@link void}
 * @property {boolean} useClusters - if <b>true</b> the layer can only display [Features]{@link tf.map.Feature] with [point geometries]{@link tf.types.GeoJSONGeometryType} 
 * and displays clusters of features into a single feature. Defaults to <b>void</b>
 * @property {number} clusterFeatureDistance - the distance in pixels under which [Map Features]{@link tf.map.Feature] are clustered together
 * @property {tf.types.MapFeatureStyleLike} clusterStyle - style used to display a cluster of [Map Features]{@link tf.map.Feature]
 * @property {tf.types.MapFeatureStyleSettings} clusterLabelStyle - style used to display the number of [Map Features]{@link tf.map.Feature] in a cluster
*/
/**
 * View settings used in the creation of [Map]{@link tf.map.Map} instances
 * @public
 * @typedef {object} tf.types.MapViewSettings
 * @property {tf.types.mapExtent} extent - optional allowed map extent (to restrict map navigation)
 * @property {tf.types.mapLevel} minLevel - optional minimum level allowed
 * @property {tf.types.mapLevel} maxLevel - optional maximum level allowed
*/
/**
 * A string containing the url to a Map Tile Server
 * @public
 * @typedef {string} tf.types.mapTileServerUrl
 */
/**
 * Settings used in the creation of [Map]{@link tf.map.Map} instances
 * @public
 * @typedef {object} tf.types.MapSettings
 * @property {HTMLElementLike} container - the container where the map is created, this is a mandatory property
 * @property {HTMLElementLike} fullScreenContainer - defines the container to be displayed in fullscreen, if not defined, <b>document.body</b> is displayed in fullscreen
 * @property {tf.types.mapCoordinates} center - optional map center, defaults to [ {@link tf.consts.defaultLongitude}, {@link tf.consts.defaultLatitude}]
 * @property {tf.types.mapLevel} level - optional map level, defaults to {@link tf.consts.defaultLevel}
 * @property {tf.types.mapResolution} resolution - optional map resolution, defaults to {@link void}, if defined takes precedence over <b>level</b>
 * @property {tf.types.mapEngine} mapEngine - optional map engine, defaults to {@link tf.consts.mapnik2Engine}
 * @property {tf.types.mapType} mapType - optional map type, defaults to {@link tf.consts.typeNameHybrid}
 * @property {tf.types.mapAerialSource} mapAerialSource - the source of Aerial map tiles, defaults to {@link tf.consts.sourceName_best_available}
 * @property {tf.types.MapViewSettings} viewSettings - optional view settings
 * @property {tf.types.mapTileServerUrl} mapLayerSourceURL - optional alternative map engine, defaults to {@link void}, if defined replaces <b>mapEngine</b>
 * @property {tf.types.opacity01} mapLayerSourceHybridModeOpacity - optional opacity used with <b>mapLayerSourceURL</b> when the map type is set to {@link tf.consts.typeNameHybrid}, defaults to 1
 * @property {tf.types.mapPanelNamesString} panels - if present sets the visibility status of map panels
 * @property {boolean} showMapCenter - if set to <b>false</b> prevents the map center image from being overlayed on map, otherwise the map center is displayed
 * @property {boolean} panOnClick - if set to <b>false</b> prevents the map from panning to the map location clicked by the user
 * @property {boolean} goDBOnDoubleClick - if set to <b>false</b> prevents the map from displaying the TerraFly geoquery page corresponding to the map location double clicked by the user
 * @property {string} addressBarHelp - if present sets the text that is displayed when the user clicks the '?' button in the map's Address Bar
 * @property {string} passThroughString - if present sets the value of a string used by the map when interacting with some TerraFly services
 * @property {string} vidParam - if present sets the value of a string used by the map when interacting with some TerraFly services
 * @property {number} messageTimeout - if present sets the time after which the Message Popup automatically hides itself, defaults to {@link tf.consts.defaultMessageTimeout}
 * @property {tf.types.legendString} legendH - if present sets the value of the {@link tf.consts.typeNameHybrid} legend, defaults to {@link tf.consts.defaultLegendH}
 * @property {tf.types.legendString} legendM - if present sets the value of the {@link tf.consts.typeNameMap} legend, defaults to {@link tf.consts.defaultLegendM}
*/
/**
 * @public
 * @class
 * @summary Create instances of this class to display the TerraFly HTerraMap
 * @param {tf.types.MapSettings} settings - map creation settings
 */
tf.map.Map = function (settings) {
    var mapNikDebug = null;
    var styles, subStyles;
    var mapPrivateLayerZIndex = 10000;
    var id = null;
    var mapCanvas = null;
    var layersByName;
    //TileService 2.0 raster service urls
    var defaultMap2RasterImageUrls =
    [
        'http://131.94.133.184/TileService/rmix.aspx?projection=bing&x={x}&y={y}&z={z}',
        'http://131.94.133.186/TileService/rmix.aspx?projection=bing&x={x}&y={y}&z={z}',
        'http://131.94.133.188/TileService/rmix.aspx?projection=bing&x={x}&y={y}&z={z}',
        'http://131.94.133.190/TileService/rmix.aspx?projection=bing&x={x}&y={y}&z={z}'
    ];
    var allEventDispatchers = null;
    var pixelTranslateCallBack;
    var animationCallBack, animationOptionalScope, animationStep, isAnimating, animationSpecs;
    this.GetCanvas = function () { return mapCanvas; }
    this.SetPixelTranslateCallBack = function (callBack) { pixelTranslateCallBack = tf.js.GetFunctionOrNull(callBack); }
    this.SetTarget = function (newTarget) { olMap.setTarget(newTarget); }
    this.RestoreTarget = function () { olMap.setTarget(mapContainer); }
    this.getAPIMap = function () { return olMap; }
    this.getAPIView = function () { return olView; }
    this.GetControlContainer = function () { return mapControlContainerHTML; }
    this.CreateMapWithSameLayers = function (container) {
        var map;
        if (tf.dom.GetHTMLElementFrom(container)) {
            var mapSettings = {
                container: container,
                center: getCenter(),
                panels: "noaddress+nomaplocation+nouserlocation+nomapscale",
                panOnClick: false,
                goDBOnDoubleClick: false,
                resolution: getResolution()
            };
            map = new tf.map.Map(mapSettings);
            map.SetHasInteractions(false);
            map.ShowMapCenter(false);
            map.getAPIMap().setLayerGroup(olMap.getLayerGroup());
        }
        return map;
    }
    /*this.ShareLayersWith = function (map) {
        if (!!(map = tf.js.GetMapFrom(map))) {
            map.getAPIMap().setLayerGroup(olMap.getLayerGroup());
        }
    }*/
    /**
     * @public
     * @function
     * @summary - Returns the map instance's unique identifier
     * @returns {number} - | {@link number} the map instance's unique identifier
    */
    this.GetID = function () { return id; }
    /**
     * @public
     * @function
     * @summary - Returns the map container that was passed in the creation of the map instance
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the map container
    */
    this.GetMapContainer = function () { return containerAll; }
    /**
     * @private
     * @function
     * @summary - Returns the top map container
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the top map container
    */
    this.GetMapMapContainer = function () { return mapContainerAllObj; }
    /**
     * @public
     * @function
     * @summary - Returns the map engine that was passed in the creation of the map instance
     * @returns {tf.types.mapEngine} - | {@link tf.types.mapEngine} the map engine
    */
    this.GetMapEngine = function () { return mapEngine; }
    /**
     * @public
     * @function
     * @summary - Uses the browser's geolocation service to create or update (and display) a map feature at the estimated user location
     * @returns {void} - | {@link void} no return value
    */
    this.ShowUserLocation = function () { return updateUserLocation(); }
    /**
     * @public
     * @function
     * @summary - Hides the map feature positioned at the estimated user location, if it has been created
     * @returns {void} - | {@link void} no return value
    */
    this.HideUserLocation = function () { return hideUserLocation(); }
    /**
     * @public
     * @function
     * @summary - CenterUses the browser's geolocation service to center the map to the estimated user location
     * @returns {void} - | {@link void} no return value
    */
    this.CenterToUserLocation = function () { return requestCenterToUserLocation(); }
    /**
     * @public
     * @function
     * @summary - Requests the map to initiate a render cycle. Should not be called from within a render cycle (e.g. during a map {@link tf.consts.mapPostComposeEvent} event)
     * @returns {void} - | {@link void} no return value
    */
    this.Render = function () { return render(); }
    /**
     * @public
     * @function
     * @summary - Sets the value of a string used by the map when interacting with some TerraFly services
     * @param {string} tfPassThroughString - the string value
     * @returns {void} - | {@link void} no return value
    */
    this.SetTFPassThroughString = function (passTroughString) { setTFPassThroughString(passTroughString); }
    /**
     * @public
     * @function
     * @summary - Returns the value of a string used by the map when interacting with some TerraFly services
     * @returns {string} - | {@link string} the string value
    */
    this.GetTFPassThroughString = function () { return getTFPassTroughString(); }
    /**
     * @public
     * @function
     * @summary - Sets the value of a string used by the map when interacting with some TerraFly services
     * @param {string} vidParamStr - the string value
     * @returns {void} - | {@link void} no return value
    */
    this.SetVIDParamStr = function (vidParamStr) { setVIDParamStr(vidParamStr); }
    /**
     * @public
     * @function
     * @summary - Returns the value of a string used by the map when interacting with some TerraFly services
     * @returns {string} - | {@link string} the string value
    */
    this.GetVIDParamStr = function () { return getVIDParamStr(); }
    /**
     * @public
     * @function
     * @summary - Sets the text that is displayed in the map's Address Bar
     * @param {string} addressBarText - the text
     * @returns {void} - | {@link void} no return value
    */
    this.SetAddressBarText = function (addressBarText) { return setAddressBarText(addressBarText); }
    /**
     * @public
     * @function
     * @summary - Returns the text displayed in the map's Address Bar
     * @returns {string} - | {@link string} the text
    */
    this.GetAddressBarText = function () { return getAddressBarText(); }
    /**
     * @public
     * @function
     * @summary - Sets the text that is displayed when the user clicks the '?' button in the map's Address Bar
     * @param {string} addressBarHelpStr - the text
     * @returns {void} - | {@link void} no return value
    */
    this.SetAddressBarHelp = function (addressBarHelpStr) { return setAddressBarHelp(addressBarHelpStr); }
    /**
     * @public
     * @function
     * @summary - Opens a GeoQuery page for the given address
     * @param {string} addressStr - the address
     * @returns {void} - | {@link void} no return value
    */
    this.GoDBByAddress = function (addressStr) { goDBByAddress(addressStr); }
    /**
     * @public
     * @function
     * @summary - Opens a GeoQuery page for the given coordinates
     * @param {tf.types.mapCoordinates} pointCoords - the coordinates
     * @returns {void} - | {@link void} no return value
    */
    this.GoDBByCoords = function (pointCoords) { goDBByCoords(pointCoords); }
    /**
     * @public
     * @function
     * @summary - Opens a GeoQuery page for the coordinates at the center of the map
     * @returns {void} - | {@link void} no return value
    */
    this.GoDBByCenterCoords = function () { goDBByCenterCoords(); }
    /**
     * @public
     * @function
     * @summary - Allows or prevents the map from opening a GeoQuery page corresponding to the map coordinates double clicked by the user
     * @param {boolean} bool - Set to <b>true</b> to allow, <b>false</b> to prevent
     * @returns {void} - | {@link void} no return value
    */
    this.SetGoDBOnDoubleClick = function (bool) { setGoDBOnDoubleClick(bool); }
    /**
     * @public
     * @function
     * @summary - Determines if the map is allowed to open a GeoQuery page corresponding to the map coordinates double clicked by the user
     * @returns {boolean} - | {@link boolean} <b>true</b> if it is allowed, <b>false</b> otherwise
    */
    this.GetGoDBOnDoubleClick = function () { return getGoDBOnDoubleClick(); }
    /**
     * @public
     * @function
     * @summary - Allows or prevents automatic re-centering to the coordinates clicked by the user
     * @param {boolean} bool - Set to <b>true</b> to allow, <b>false</b> to prevent
     * @returns {void} - | {@link void} no return value
    */
    this.SetUsePanOnClick = function (bool) { setUsePanOnClick(bool); }
    /**
     * @public
     * @function
     * @summary - Determines if the map is allowed to automatically re-center to the coordinates clicked by the user
     * @returns {boolean} - | {@link boolean} <b>true</b> if it is allowed, <b>false</b> otherwise
    */
    this.IsUsingPanOnClick = function () { return isUsingPanOnClick(); }
    /**
     * @public
     * @function
     * @summary - Rotates the map clockwise to the given angle
     * @param {number} rotationDeg - The angle in degrees
     * @returns {void} - | {@link void} no return value
    */
    this.SetRotationDeg = function (rotationDeg) { return setRotationDeg(rotationDeg); }
    /**
     * @public
     * @function
     * @summary - Obtains the clockwise map rotation angle
     * @returns {number} - | {@link number} the angle in degrees
    */
    this.GetRotationDeg = function (rotationDeg) { return getRotationDeg(); }
    /**
     * @public
     * @function
     * @summary - Rotates the map clockwise to the given angle
     * @param {number} rotationRad - The angle in radians
     * @returns {void} - | {@link void} no return value
    */
    this.SetRotationRad = function (rotationRad) { return setRotationRad(rotationRad); }
    /**
     * @public
     * @function
     * @summary - Obtains the clockwise map rotation angle
     * @returns {number} - | {@link number} the angle in radians
    */
    this.GetRotationRad = function (rotationRad) { return getRotationRad(); }
    /**
     * @public
     * @function
     * @summary - Translates the given pixel coordinates into map coordinates
     * @param {tf.types.pixelCoordinates} pixelCoords - the pixel coordinates
     * @returns {tf.types.mapCoordinates} - | {@link tf.types.mapCoordinates} the map coordinates
    */
    this.PixelToMapCoords = function (pixelCoords) { return pixelToMapCoords(pixelCoords); }
    /**
     * @public
     * @function
     * @summary - Translates the given map coordinates into pixel coordinates
     * @param {tf.types.mapCoordinates} pointCoords - the map coordinates
     * @returns {tf.types.pixelCoordinates} - | {@link tf.types.pixelCoordinates} the pixel coordinates
    */
    this.MapToPixelCoords = function (pointCoords) { return mapToPixelCoords(pointCoords); }
    /**
     * @public
     * @function
     * @summary - Obtains the distance in pixels between two map given coordinates
     * @param {tf.types.mapCoordinates} pointCoords1 - the first map coordinates
     * @param {tf.types.mapCoordinates} pointCoords2 - the second map coordinates
     * @returns {number} - | {@link number} the distance between the map coordinates in pixels
    */
    this.GetPixelDistance = function (pointCoords1, pointCoords2) { return getPixelDistance(pointCoords1, pointCoords2); }
    /**
     * @public
     * @function
     * @summary - Obtains the distance in pixels between the center of the map and the given map coordinates
     * @param {tf.types.mapCoordinates} pointCoords - the given map coordinates
     * @returns {number} - | {@link number} the distance between the map center and the map coordinates in pixels
    */
    this.GetPixelDistanceFromCenter = function (pointCoords) { return getPixelDistanceFromCenter(pointCoords); }
    /**
     * @public
     * @function
     * @summary - Checks if the given map coordinates are displayed at the same pixel coordinates as the map center
     * @param {tf.types.mapCoordinates} pointCoords - the given map coordinates
     * @returns {boolean} - | {@link boolean} <b>true</b> if the pixel coordinates of the center coincide with the pixel coordinates of the given the map coordinates, <b>false</b> otherwise
    */
    this.IsSamePixelAsCenter = function (pointCoords) { return isSamePixelAsCenter(pointCoords); }
    /**
     * @public
     * @function
     * @summary - Checks if the given map coordinates are within the current map viewing area
     * @param {tf.types.mapCoordinates} pointCoords - the given map coordinates
     * @returns {boolean} - | {@link boolean} <b>true</b> if the pixel coordinates of given coordinates are visible, <b>false</b> otherwise
    */
    this.GetAreMapCoordsVisible = function (pointCoords) { return getAreMapCoordsVisible(pointCoords); }
    /**
     * @public
     * @function
     * @summary - Recenters the map to the given coordinates
     * @param {tf.types.mapCoordinates} pointCoords - the new map center coordinates
     * @returns {void} - | {@link void} no return value
    */
    this.SetCenter = function (pointCoords) { setCenter(pointCoords); }
    /**
     * @public
     * @function
     * @summary - Recenters the map to the given coordinates and changes the map level to the given level
     * @param {tf.types.mapCoordinates} pointCoords - the new map center coordinates
     * @param {tf.types.mapLevel} level - the new map level
     * @returns {void} - | {@link void} no return value
    */
    this.SetCenterAndLevel = function (pointCoords, level) { setCenterAndLevel(pointCoords, level); }
    /**
     * @public
     * @function
     * @summary - Retrieves the current map center coordinates
     * @returns {tf.types.mapCoordinates} - | {@link tf.types.mapCoordinates} the map center coordinates
    */
    this.GetCenter = function () { return getCenter(); }
    /**
     * @public
     * @function
     * @summary - Sets the map level
     * @param {tf.types.mapLevel} level - the desired map level
     * @returns {void} - | {@link void} no return value
    */
    this.SetLevel = function (level) { setLevel(level); }
    /**
     * @public
     * @function
     * @summary - Gets the current map level
     * @returns {tf.types.mapLevel} - | {@link tf.types.mapLevel} the current map level
    */
    this.GetLevel = function () { return getLevel(); }
    /**
     * @public
     * @function
     * @summary - Sets the map resolution
     * @param {tf.types.mapResolution} resolution - the desired map resolution
     * @returns {void} - | {@link void} no return value
    */
    this.SetResolution = function (resolution) { setResolution(resolution); }
    /**
     * @public
     * @function
     * @summary - Gets the current map resolution
     * @returns {tf.types.mapResolution} - | {@link tf.types.mapResolution} the current map resolution
    */
    this.GetResolution = function () { return getResolution() }
    /**
     * @public
     * @function
     * @summary - Incrementally changes the map level to the given level if it differs from the current map level. If the given level matches the current
     * map level no animation is performed and the optional callback is immediatelly notified
     * @param {tf.types.mapLevel} newLevel - the desired new level
     * @param {tf.types.MapEventCallBack} callBack - if defined, receives a notification when the animation ends
     * @param {number} duration - the duration of the animation per level changed, in milliseconds, defaults to {@link tf.consts.defaultMapAnimatedDurationPerLevelMillis}
     * @param {boolean} notifyListeners - Set to <b>true</b> to send event notifications during the animation, defaults to {@link void}
     * @param {tf.types.EasingFunction} easing - if not defined defaults to {@link tf.units.EaseInAndOut}
     * @returns {void} - | {@link void} no return value
    */
    this.AnimatedSetLevel = function (newLevel, callBack, durationPerLevel, notifyListeners, easing) { return animatedSetLevel(newLevel, callBack, durationPerLevel, notifyListeners, easing); }
    /**
     * @public
     * @function
     * @summary - Incrementally recenters the map to the given map coordinates if their corresponding pixel coordinates differ from those of the center of the map, 
     * otherwise [SetCenter]{@link tf.map.Map#SetCenter} is performed instead of an animation, and the optional calback is notified immediately
     * @param {tf.types.mapCoordinates} pointCoords - the new map center coordinates
     * @param {tf.types.MapEventCallBack} callBack - if defined, receives a notification when the animation ends
     * @param {number} duration - the duration of the animation, in milliseconds, defaults to {@link tf.consts.defaultMapAnimatedCenterDurationMillis}
     * @param {boolean} notifyListeners - Set to <b>true</b> to send event notifications during the animation, defaults to {@link void}
     * @param {tf.types.EasingFunction} easing - if not defined defaults to {@link tf.units.EaseInAndOut}
     * @returns {void} - | {@link void} no return value
    */
    this.AnimatedSetCenter = function (pointCoords, callBack, duration, notifyListeners, easing) { animatedSetCenter(pointCoords, callBack, duration, notifyListeners, easing); }
    /**
     * @public
     * @function
     * @summary - Recenters the map to the given coordinates, uses incremental animation if the new center coordinates are visible
     * @param {tf.types.mapCoordinates} pointCoords - the new map center coordinates
     * @param {number} duration - the duration of the animation, in milliseconds, defaults to {@link tf.consts.defaultMapAnimatedCenterDurationMillis}
     * @returns {void} - | {@link void} no return value
    */
    this.AnimatedSetCenterIfDestVisible = function (pointCoords, duration) { animatedSetCenterIfDestVisible(pointCoords, duration); }
    /**
     * @public
     * @function
     * @summary - Checks if the map is performing an animation
     * @returns {boolean} - | {@link boolean} <b>true</b> if an animation is in progress, <b>false</b> otherwise
    */
    this.GetIsAnimating = function () { return isAnimating; }
    /**
     * @public
     * @function
     * @summary - Starts a map animation
     * @param {tf.types.MapAnimationCallBack} callBack - the animation callback
     * @param {object} optionalScope - optional JavaScript scope used with <b>callBack</b>
     * @returns {void} - | {@link void} no return value
    */
    this.StartAnimation = function (callBack, optionalScope) { return startAnimation(callBack, optionalScope); }
    /**
     * @public
     * @function
     * @summary - Stops an ongoing map animation
     * @returns {void} - | {@link void} no return value
    */
    this.EndAnimation = function () { return endAnimation(); }
    /**
     * @public
     * @function
     * @summary - Calls a TerraFly service to determine the map coordinates corresponding to the given address and performs a "fly" animation to re-center the map to those coordinates
     * @param {string} addressStr - the address
     * @returns {void} - | {@link void} no return value
    */
    this.FlyToAddress = function (addressStr) { return flyToAddress(addressStr); }
    /**
     * @public
     * @function
     * @summary - Retrieves the visible map extent
     * @returns {tf.types.mapExtent} - | {@link tf.types.mapExtent} the map extent
    */
    this.GetVisibleExtent = function () { return getVisibleExtent(); }
    /**
     * @public
     * @function
     * @summary - Sets the visible map extent
     * @param {tf.types.mapExtent} extent - the new map extent
     * @returns {void} - | {@link void} no return value
    */
    this.SetVisibleExtent = function (extent) { return setVisibleExtent(extent); }
    /**
     * @public
     * @function
     * @summary - Removes the given layer instance from the map
     * @param {tf.types.mapLayer} layerInstance - the layer instance
     * @returns {void} - | {@link void} no return value
    */
    this.RemoveLayer = function (layerInstance) { removeLayer(layerInstance); }
    /**
     * @public
     * @function
     * @summary - Adds a [Feature Layer]{@link tf.map.FeatureLayer} to the map
     * @param {tf.types.AddFeatureLayerSettings} layerSettings - layer instance creation settings
     * @returns {tf.map.FeatureLayer} - | {@link tf.map.FeatureLayer} the added feature layer
    */
    this.AddFeatureLayer = function (layerSettings) { return addFeatureLayer(layerSettings); }
    /**
     * @public
     * @function
     * @summary - Notifies the map that its container may have been resized
     * @returns {void} - | {@link void} no return value
    */
    this.OnResize = function () { return onResize(); }
    /**
     * @public
     * @function
     * @summary - Obtains the size of the map in pixels
     * @returns {tf.types.pixelCoordinates} - | {@link tf.types.pixelCoordinates} the size of the map in pixels
    */
    this.GetPixelSize = function () { return getPixelSize(); }
    /**
     * @public
     * @function
     * @summary - Moves the map center by a pixel offset
     * @param {tf.types.pixelCoordinates} pixelOffset - the offset
     * @returns {void} - | {@link void} no return value
    */
    this.PanByPixelOffset = function (pixelOffset) { panByPixelOffset(pixelOffset); }
    /**
     * @public
     * @function
     * @summary - Adds a listener for the given map event name
     * @param {tf.types.mapEventName} eventName - the name of the map event
     * @param {tf.types.MapEventCallBack} callBack - the callback for event notifications
     * @returns {tf.events.EventListener} - | {@link tf.events.EventListener} the event listener
    */
    this.AddListener = function (eventName, callBack) { return allEventDispatchers.AddListener(eventName, callBack); }
    /**
     * @public
     * @function
     * @summary - Adds one or more listeners for the given map event names
     * @param {tf.types.EventNamesAndCallBacks} eventNamesAndCallBacks - the event names and callbacks
     * @returns {tf.types.EventNamesAndListeners} - | {@link tf.types.EventNamesAndListeners} the event names and listeners
    */
    this.AddListeners = function (eventNamesAndCallBacks) { return allEventDispatchers.AddListeners(eventNamesAndCallBacks); }
    /**
     * @public
     * @function
     * @summary - Shows or hides the map center image overlay
     * @param {boolean} bool - set to <b>true</b> to dislay the center image, <b>false</b> to hide it
     * @returns {void} - | {@link void} no return value
    */
    this.ShowMapCenter = function (bool) { return showMapCenter(bool); }
    /**
     * @public
     * @function
     * @summary - Checks if the map center image overlay is visible
     * @returns {boolean} - | {@link boolean} <b>true</b> if visible, <b>false</b> otherwise
    */
    this.IsShowingMapCenter = function () { return isShowingMapCenter; }
    /**
     * @public
     * @function
     * @summary - Shows or hides map panels
     * @param {tf.types.mapPanelNamesString} strPanels - a string containing the names of panels to be shown, panels not listed are hidden
     * @returns {void} - | {@link void} no return value
    */
    this.ShowPanels = function (strPanels) { return showPanels(strPanels); }
    /**
     * @public
     * @function
     * @summary - Shows or hides a map panel
     * @param {tf.types.mapPanelName} strPanel - the map panel
     * @param {boolean} showBool - <b>true</b> to show the panel, <b>false</b> to hide it
     * @returns {void} - | {@link void} no return value
    */
    this.ShowPanel = function (strPanel, showBool) { return showPanel(strPanel, showBool); }
    /**
     * @public
     * @function
     * @summary - Retrieves the current visibility state of a map panel
     * @param {tf.types.mapPanelName} strPanel - the map panel
     * @returns {boolean} - | {@link boolean} <b>true</b> if the panel is visible, <b>false</b> otherwise
    */
    this.IsPanelShowing = function (strPanel) { return isPanelShowing(strPanel); }
    /**
     * @public
     * @function
     * @summary - Shows or hides the full screen button
     * @param {boolean} bool - <b>true</b> to show, <b>false</b> to hide
     * @returns {void} - | {@link void} no return value
    */
    this.SetFullScreenButtonVisibility = function (bool) { showPanel(tf.consts.panelNameFullscreen, bool); }
    /**
     * @public
     * @function
     * @summary - Shows or hides the TerraFly Map Logo
     * @param {boolean} bool - <b>true</b> to show, <b>false</b> to hide
     * @returns {void} - | {@link void} no return value
    */
    this.SetLogoVisibility = function (visible) { return setLogoVisibility(visible); }
    /**
     * @public
     * @function
     * @summary - Shows the map full screen mode
     * @returns {void} - | {@link void} no return value
    */
    this.FullScreen = function () { return onFullScreen(); }
    /**
     * @public
     * @function
     * @summary - Toggles the map between full screen and normal modes
     * @returns {void} - | {@link void} no return value
    */
    this.ToggleMapFullScreen = function () { return toggleMapFullScreen(); }
    /**
     * @public
     * @function
     * @summary - Sets the map type 
     * @param {tf.types.mapType} type - the map type
     * @returns {void} - | {@link void} no return value
    */
    this.SetMapType = function (type) { setMapType(type, true); }
    /**
     * @public
     * @function
     * @summary - Gets the map type 
     * @returns {tf.types.mapType} - | {@link tf.types.mapType} the map type
    */
    this.GetMapType = function () { return currentMode; }
    /**
     * @public
     * @function
     * @summary - Sets the source of Aerial map tiles
     * @param {tf.types.mapAerialSource} source - the source
     * @returns {void} - | {@link void} no return value
    */
    this.SetSource = function (source) { setSource(source, true); }
    /**
     * @public
     * @function
     * @summary - Gets the source of Aerial map tiles
     * @returns {tf.types.mapAerialSource} - | {@link tf.types.mapAerialSource} the source
    */
    this.GetSource = function () { return currentSource; }
    /**
     * @public
     * @function
     * @summary - Sets the values of the [Hybrid]{@link tf.consts.typeNameHybrid} and [Map]{@link tf.consts.typeNameMap} [Legend Strings]{@link tf.types.legendString}
     * @param {tf.types.legendString} legendStrHybrid - used with [Hybrid]{@link tf.consts.typeNameHybrid} type
     * @param {tf.types.legendString} legendStrMap - used with [Map]{@link tf.consts.typeNameMap} type
     * @returns {void} - | {@link void} no return value
    */
    this.SetLegend = function (legendStrHybrid, legendStrMap) { setLegend(legendStrHybrid, legendStrMap); }
    /**
     * @public
     * @function
     * @summary - Checks if map interactions (pan, zoom, etc.) are allowed
     * @returns {boolean} - | {@link boolean} <b>true</b> if interactions are allowed, <b>false</b> otherwise
    */
    this.GetHasInteractions = function () { return getHasInteractions(); }
    /**
     * @public
     * @function
     * @summary - Allows or prevents map interactions (pan, zoom, etc.)
     * @param {boolean} bool - set to <b>true</b> to allow interactions, <b>false</b> to prevent interactions
     * @returns {void} - | {@link void} no return value
    */
    this.SetHasInteractions = function (bool) { setHasInteractions(bool); }
    /**
     * @public
     * @function
     * @summary - Shows the Address Bar
     * @returns {void} - | {@link void} no return value
    */
    this.ShowAddressBar = function () { showAddressBar(); }
    /**
     * @public
     * @function
     * @summary - Hides the Address Bar
     * @returns {void} - | {@link void} no return value
    */
    this.HideAddressBar = function () { hideAddressBar(); }
    /**
     * @public
     * @function
     * @summary - Toggles the Address Bar visibility state
     * @returns {void} - | {@link void} no return value
    */
    this.ToggleAddressBar = function () { toggleAddressBar(); }
    /**
     * @public
     * @function
     * @summary - Checks if the Address Bar is visible
     * @returns {boolean} - | {@link boolean} <b>true</b> if the bar is visible, <b>false</b> otherwise
    */
    this.IsShowingAddressBar = function () { return isShowingAddressBar(); }
    /**
     * @public
     * @function
     * @summary - Shows the Message Popup
     * @param {HTMLElementLike} contents - the contents to be displayed
     * @returns {void} - | {@link void} no return value
    */
    this.ShowMessage = function (contents) { showMessage(contents); }
    /**
     * @public
     * @function
     * @summary - Hides the Message Popup
     * @returns {void} - | {@link void} no return value
    */
    this.HideMessage = function () { hideMessage(); }
    /**
     * @public
     * @function
     * @summary - Toggles the Message Popup visibility state
     * @returns {void} - | {@link void} no return value
    */
    this.ToggleMessage = function () { toggleMessage(); }
    /**
     * @public
     * @function
     * @summary - Checks if the Message Popup is visible
     * @returns {boolean} - | {@link boolean} <b>true</b> if the popup is visible, <b>false</b> otherwise
    */
    this.IsShowingMessage = function () { return isShowingMessage(); }
    /**
     * @public
     * @function
     * @summary - Sets the time after which the Message Popup automatically hides itself
     * @param {number} timeoutSecs - the time in seconds
     * @returns {void} - | {@link void} no return value
    */
    this.SetMessageTimeout = function (timeoutSecs) { setMessageTimeout(timeoutSecs); }
    /**
     * @public
     * @function
     * @summary - Hides any visible control popups (layers, types, sources, etc.)
     * @returns {void} - | {@link void} no return value
    */
    this.HideOpenControlPopups = function () { hideOpenControlPopups(); }
    /**
     * @public
     * @function
     * @summary - Hides any visible popups (information, location, message)
     * @returns {void} - | {@link void} no return value
    */
    this.HideOpenPopups = function () { hideOpenPopups(); }
    /**
     * @public
     * @function
     * @summary - Checks if the Information Popup is visible
     * @returns {boolean} - | {@link boolean} <b>true</b> if the popup is visible, <b>false</b> otherwise
    */
    this.IsShowingInfoPopup = function () { return isShowingInfoWindow(); }
    /**
     * @public
     * @function
     * @summary - Toggles the visibility state of the Information Popup
     * @returns {void} - | {@link void} no return value
    */
    this.ToggleInfoPopup = function () { toggleInfoWindow(); }
    /**
     * @public
     * @function
     * @summary - Hides the Information Popup
     * @returns {void} - | {@link void} no return value
    */
    this.HideInfoPopup = function () { hideInfoWindow(); }
    /**
     * @public
     * @function
     * @summary - Shows the Information Popup
     * @param {string} title - title of the popup
     * @param {HTMLElementLike} content - content of the popup
     * @param {tf.types.mapCoordinates} pointCoords - map coordinates associated with the popup
     * @returns {void} - | {@link void} no return value
    */
    this.ShowInfoPopup = function (title, content, pointCoords) { showInfoWindow(title, content, pointCoords); }
    /**
     * @public
     * @function
     * @summary - Checks if the Information Popup is pinned
     * @returns {boolean} - | {@link boolean} <b>true</b> if the popup is pinned, <b>false</b> otherwise
    */
    this.IsInfoPopupPinned = function () { return infoWindowPinned; }
    /**
     * @public
     * @function
     * @summary - Toggles the pinned state of the Information Popup
     * @returns {void} - | {@link void} no return value
    */
    this.ToggleInfoPopupPin = function () { toggleInfoWindowPin(); }
    /**
     * @public
     * @function
     * @summary - Allows the user to interactivelly define a rectangular map area for information download from a TerraFly service
     * @returns {void} - | {@link void} no return value
    */
    this.StartDownloadInteraction = function () { return startDownloadInteraction(); }
    /**
     * @public
     * @function
     * @summary - Cancels an ongoing Download interaction
     * @returns {void} - | {@link void} no return value
    */
    this.CancelDownloadInteraction = function () { return cancelDownloadInteraction(); }
    /**
     * @public
     * @function
     * @summary - Allows the user to interactivelly measure distances and areas
     * @returns {void} - | {@link void} no return value
    */
    this.StartMeasureInteraction = function () { return startMeasureInteraction(); }
    /**
     * @public
     * @function
     * @summary - Cancels an ongoing Measure interaction
     * @returns {void} - | {@link void} no return value
    */
    this.CancelMeasureInteraction = function () { return cancelMeasureInteraction(); }
    /**
     * @public
     * @function
     * @summary - Collapses or expands the Overview Map according to the given parameter
     * @param {boolean} bool - set to <b>true</b> to collapse the Overview Map, <b>false</b> to expand it
     * @returns {void} - | {@link void} no return value
    */
    this.SetOverviewMapCollapsed = function (bool) {
        if (mapControls[tf.consts.panelNameOverview].isOn) { mapControls[tf.consts.panelNameOverview].control.setCollapsed(!!bool); }
    }
    /**
     * @public
     * @function
     * @summary - Checks if the Overview Map is collapsed
     * @returns {boolean} - | {@link boolean} <b>true</b> if the Overview Map is collapsed, <b>false</b> otherwise
    */
    this.IsOverviewMapCollapsed = function () { return mapControls[tf.consts.panelNameOverview].isOn && mapControls[tf.consts.panelNameOverview].control.getCollapsed(); }
    /**
     * @public
     * @function
     * @summary - Sets map view options
     * @param {tf.types.MapViewSettings} viewSettings - view options
     * @returns {void} - | {@link void} no return value
    */
    this.SetView = function (viewSettings) { return setView(viewSettings); }
    /**
     * @public
     * @function
     * @summary - Sets a custom Map Tile layer source along with its {@link tf.consts.typeNameHybrid} opacity
     * @param {tf.types.mapTileServerUrl} mapLayerSourceURLSet - alternative map engine
     * @param {tf.types.opacity01} mapLayerSourceHybridModeOpacitySet - opacity used when the map type is set to {@link tf.consts.typeNameHybrid}
     * @returns {void} - | {@link void} no return value
    */
    this.SetMapLayerSource = function (mapLayerSourceURLSet, mapLayerSourceHybridModeOpacitySet) {
        return setMapLayerSource(mapLayerSourceURLSet, mapLayerSourceHybridModeOpacitySet);
    }
    /**
     * @public
     * @function
     * @summary - Shows or hides all keyed features in the given list
     * @param {tf.map.KeyedFeatureList} keyedFeatureList - the list
     * @param {boolean} showOrHideBool - <b>true</b> to show the features, <b>false</b> to hide them
     * @param {string} styleName - optional feature style name
     * @returns {void} - | {@link void} no return value
    */
    this.ShowAllKeyedFeatures = function (keyedFeatureList, showOrHideBool, styleName) { return showAllKeyedFeatures(keyedFeatureList, showOrHideBool, styleName); }
    /**
     * @public
     * @function
     * @summary - Shows or hides the keyed features in the given list whose keys are included in the given list of keys
     * @param {tf.map.KeyedFeatureList} keyedFeatureList - the list
     * @param {enumerable} keyList - an enumerable containing the keys of the features to be shown or hidden
     * @param {boolean} showOrHideBool - <b>true</b> to show the features, <b>false</b> to hide them
     * @param {string} styleName - optional feature style name
     * @returns {void} - | {@link void} no return value
    */
    this.ShowSomeKeyedFeatures = function (keyedFeatureList, keyList, showOrHideBool, styleName) { return showSomeKeyedFeatures(keyedFeatureList, keyList, showOrHideBool, styleName); }
    /**
     * @public
     * @function
     * @summary - Shows or hides one keyed feature
     * @param {tf.map.KeyedFeature} keyedFeature - the feature
     * @param {boolean} showOrHideBool - <b>true</b> to show the features, <b>false</b> to hide them
     * @param {string} styleName - optional feature style name
     * @returns {void} - | {@link void} no return value
    */
    this.ShowKeyedFeature = function (keyedFeature, showOrHideBool, styleName) { return showKeyedFeature(feature, showOrHideBool, styleName); }
    /**
     * @public
     * @function
     * @summary - Checks if a given keyed feature is being shown
     * @param {tf.map.KeyedFeature} keyedFeature - the feature
     * @returns {boolean} - | {@link boolean} <b>true</b> if the feature is being shown, <b>false</b> otherwise
    */
    this.GetIsShowingKeyedFeature = function (keyedFeature) { return getIsShowingKeyedFeature(keyedFeature); }
    /**
     * @public
     * @function
     * @summary - Obtains the map feature layer for showing a given keyed feature, if one exists
     * @param {tf.map.KeyedFeature} keyedFeature - the feature
     * @returns {tf.map.FeatureLayer} - | {@link tf.map.FeatureLayer} the feature layer, or null if none exists
    */
    this.GetLayerForKeyedFeature = function (keyedFeature) { return getLayerForKeyedFeature(keyedFeature); }
    /**
     * @public
     * @function
     * @summary - Obtains the map feature layer for showing a given keyed feature list, if one exists
     * @param {tf.map.KeyedFeatureList} keyedFeatureList - the feature list
     * @returns {tf.map.FeatureLayer} - | {@link tf.map.FeatureLayer} the feature layer, or null if none exists
    */
    this.GetLayerForKeyedFeatureList = function (keyedFeatureList) { return getLayerForKeyedFeatureList(keyedFeatureList); }
    /**
     * @public
     * @function
     * @summary - Obtains a map feature layer given its name, if one exists
     * @param {string} name - the feature layer name
     * @returns {tf.map.FeatureLayer} - | {@link tf.map.FeatureLayer} the feature layer, or null if none exists
    */
    this.GetLayerByName = function (name) { return getLayerByName(name); }
    /**
     * @private
     * @function
     * @summary - adds a deprecated {@link TLayer} instance to the map
     * @param {tf.types.FeatureLayerSettings} layerSettings - layer creation settings
     * @returns {TLayer} - the deprecated TLayer instance
     * @deprecated This function will soon be removed
    */
    this.deprecatedAddLegacyLayer = function (layerSettings) { return addLegacyLayer(layerSettings); }
    /**
     * @private
     * @function
     * @summary - Requests the map to immediately initiate a render cycle. Should not be called from within a render cycle (e.g. during a map {@link tf.consts.mapPostComposeEvent} event)
     * @returns {void} - | {@link void} no return value
    */
    this.renderNow = function () { return renderNow(); }
    /**
     * @private
     * @function
     * @summary - Adds an HTML overlay to the map
     * @param {tf.map.HTMLOverlay} mapHTMLOverlay - the overlay instance
     * @returns {void} - | {@link void} no return value
    */
    this.addHTMLOverlay = function (mapHTMLOverlay) { if (!!mapHTMLOverlay && mapHTMLOverlay instanceof tf.map.HTMLOverlay) { olMap.addOverlay(mapHTMLOverlay.getAPIOverlay()); } }
    /**
     * @private
     * @function
     * @summary - Removes an HTML overlay from the map
     * @param {tf.map.HTMLOverlay} mapHTMLOverlay - the overlay instance
     * @returns {void} - | {@link void} no return value
    */
    this.removeHTMLOverlay = function (mapHTMLOverlay) { if (!!mapHTMLOverlay && mapHTMLOverlay instanceof tf.map.HTMLOverlay) { olMap.removeOverlay(mapHTMLOverlay.getAPIOverlay()); } }
    /**
     * @private
     * @function
     * @summary - Adds an HTML control to the map
     * @param {tf.map.HTMLControl} mapHTMLControl - the control instance
     * @returns {void} - | {@link void} no return value
    */
    this.addHTMLControl = function (mapHTMLControl) { if (!!mapHTMLControl && mapHTMLControl instanceof tf.map.HTMLControl) { olMap.addControl(mapHTMLControl.getAPIControl()); } }
    /**
     * @private
     * @function
     * @summary - Removes an HTML control from the map
     * @param {tf.map.HTMLControl} mapHTMLControl - the control instance
     * @returns {void} - | {@link void} no return value
    */
    this.removeHTMLControl = function (mapHTMLControl) { if (!!mapHTMLControl && mapHTMLControl instanceof tf.map.HTMLControl) { olMap.removeControl(mapHTMLControl.getAPIControl()); } }
    function showAllKeyedFeatures(keyedFeatureList, showOrHideBool, styleNameForShow) {
        if (keyedFeatureList instanceof tf.map.KeyedFeatureList) {
            var featureLayer = getLayerForKeyedFeatureList(keyedFeatureList);
            if (!!featureLayer) {
                if (!!showOrHideBool) {
                    var keyedList = keyedFeatureList.GetKeyedList();
                    var keyedItemList = keyedList.GetKeyedItemList();
                    for (var i in keyedItemList) { featureLayer.AddKeyedFeature(keyedFeatureList.GetFeature(keyedItemList[i].GetKey()), styleNameForShow, true); }
                    featureLayer.AddWithheldFeatures();
                } else { featureLayer.RemoveAllFeatures(); }
            }
        }
    }
    function showSomeKeyedFeatures(keyedFeatureList, keyList, showOrHideBool, styleNameForShow) {
        if (keyedFeatureList instanceof tf.map.KeyedFeatureList && typeof keyList === "object") {
            var featureLayer = getLayerForKeyedFeatureList(keyedFeatureList);
            if (!!featureLayer) {
                var keyedList = keyedFeatureList.GetKeyedList();
                showOrHideBool = !!showOrHideBool;
                for (var i in keyList) {
                    var keyedItem = keyedList.GetItem(keyList[i]);
                    if (!!keyedItem) {
                        var keyedFeature = keyedFeatureList.GetFeature(keyedItem.GetKey());
                        if (showOrHideBool) { featureLayer.AddKeyedFeature(keyedFeature, styleNameForShow, true); } else { featureLayer.DelKeyedFeature(keyedFeature, true); }
                    }
                }
                if (showOrHideBool) { featureLayer.AddWithheldFeatures(); } else { featureLayer.DelWithheldFeatures(); }
            }
        }
    }
    function showFeature(keyedFeature, showOrHideBool, styleNameForShow) {
        var featureLayer = getLayerForKeyedFeature(keyedFeature);
        if (!!featureLayer) { if (!!showOrHideBool) { featureLayer.AddKeyedFeature(keyedFeature, styleNameForShow, false); } else { featureLayer.DelKeyedFeature(keyedFeature, false); } }
    }
    function getIsShowingKeyedFeature(keyedFeature) {
        var featureLayer = getLayerForKeyedFeature(keyedFeature);
        return !!featureLayer ? featureLayer.ContainsKeyedFeature(keyedFeature) : false;
    }
    function getLayerForKeyedFeature(keyedFeature) { return tf.js.GetIsInstanceOf(keyedFeature, tf.map.KeyedFeature) ? getLayerByName(keyedFeature.GetLayerName()) : null; }
    function getLayerForKeyedFeatureList(keyedFeatureList) { return tf.js.GetIsInstanceOf(keyedFeatureList, tf.map.KeyedFeatureList) ? getLayerByName(keyedFeatureList.GetLayerName()) : null; }
    function getLayerByName(name) { return layersByName[name]; }
    var mapLayerSourceURL = null;
    var mapLayerSourceHybridModeOpacity = 1;
    var mapLayerSourceURLWasSet = false;
    function setMapLayerSource(mapLayerSourceURLSet, mapLayerSourceHybridModeOpacitySet) {
        mapLayerSourceURL = !!mapLayerSourceURLSet && typeof mapLayerSourceURLSet == "string" && mapLayerSourceURLSet.length > 0 ? mapLayerSourceURLSet : null;
        mapLayerSourceHybridModeOpacity = tf.js.GetFloatNumberInRange(mapLayerSourceHybridModeOpacitySet, 0.0, 1.0, 1.0);
        mapLayerSourceURLWasSet = false;
        setVectorLayerParams();
    }
    var useMapNik2 = null;
    var firstFeatureOnly = true;
    var infoFeatureName = "Info";
    var theThis = null;
    var mapButtonDimEmStr;
    var baseLayersPopup = null;
    var layersPopup = null;
    var typesPopup = null;
    var sourcesPopup = null;
    var infoWindowPopup = null;
    var locInfoWindowPopup = null;
    var messagePopup = null;
    var addressPopup = null;
    var downloadPopup = null;
    var measurePopup = null;
    var zIndexPopups = [];
    var baseNotification;
    function addToZIndexPopups(popup, theThis) {
        if (popup) {
            zIndexPopups.push(popup);
            popup.SetZIndex(minZIndexPopup++);
            popup.SetOnClickTitle(function () { return onClickMessagePopup(popup); }, theThis);
        }
    }
    function promoteToTopZIndex(popup) {
        if (popup) {
            var currentZIndex = popup.GetZIndex();
            if (currentZIndex < minZIndexPopup - 1) {
                var nZIndexPopups = zIndexPopups.length;
                var topZIndex = nZIndexPopups + minZIndexPopup;
                popup.SetZIndex(topZIndex);
                minZIndexPopup = topZIndex + 1;
                if (topZIndex > maxZIndex + nZIndexPopups) {
                    for (var i = 0 ; i < nZIndexPopups ; i++) {
                        var adjustedZIndex = zIndexPopups[i].GetZIndex() - startMinZIndexPopup;
                        zIndexPopups[i].SetZIndex(adjustedZIndex);
                    }
                    minZIndexPopup = startMinZIndexPopup + nZIndexPopups;
                }
            }
        }
    }
    var olMap = null;
    var olView = null;
    var rasterLayer = null;
    var vectorLayer = null;
    var vectorLayerSource = null, rasterLayerSource = null;
    var mapEngine = null, currentMode = null, currentSource = null;
    var mapFeatureLayers = [];
    var hiddenMapFeatureLayers = [];
    var invalidLatLon = -999;
    var invalidZoom = -1;
    var invalidRes = 0;
    var currentRes = invalidRes;
    var currentLevel = invalidZoom;
    var currentLat = invalidLatLon;
    var currentLon = invalidLatLon;
    var styles = tf.GetStyles();
    var containerAll = null, mapContainerAllObj = null, mapContainerObj = null, mapContainerAll = null, mapContainer = null;
    var mapControlContainerObj, mapControlContainerHTML;
    var maxZIndex = 500;
    var initialZIndex = 1;
    var zIndex = initialZIndex;
    var isShowingMapCenter = true;
    var mapCenterButton = null;
    var minZIndexPopup = 0;
    var startMinZIndexPopup = 0;
    function createDivs(containerAllSet) {
        containerAll = tf.dom.GetHTMLElementFrom(containerAllSet);
        mapContainerAllObj = new tf.dom.Div({ cssClass: styles.mapContainerClass });
        mapContainerObj = new tf.dom.Div({ cssClass: styles.mapSubContainerClass });
        //mapControlContainerObj = new tf.dom.Div({ cssClass: styles.mapContainerClass });
        mapControlContainerObj = new tf.dom.Div({ cssClass: styles.GetUnPaddedDivClassNames(false, false) });
        mapControlContainerHTML = mapControlContainerObj.GetHTMLElement();
        mapControlContainerHTML.style.backgroundColor = "rgba(255, 0, 0, 0.6)";
        //mapControlContainerHTML.title = "hello, world.";
        mapContainerAll = mapContainerAllObj.GetHTMLElement();
        mapContainer = mapContainerObj.GetHTMLElement();
        mapContainerObj.AppendTo(mapContainerAll);
        mapControlContainerObj.AppendTo(mapContainerAll);
        /*mapContainer.style.zIndex = zIndex++;
        mapContainer.style.height = "200%";
        mapContainer.style.width = "200%";
        mapContainer.style.transform = "translate(-50%, -50%)";*/
        minZIndexPopup = zIndex + 200;
        startMinZIndexPopup = minZIndexPopup;
        //var dim = subStyles.mapButtonDimEmNumber;
        var dim = (subStyles.locationPopupContentFontSizeEmNumber * 2);
        htmlFeedDiv = new tf.dom.Div({ cssClass: styles.dLayerInfoClass });
        var htmlFeedDivStyle = htmlFeedDiv.GetHTMLElement().style;
        htmlFeedDivStyle.textAlign = 'center';
        htmlFeedDivStyle.display = 'inline';
        var toggleBtn = styles.AddButtonDivRightMargin(new tf.ui.SvgGlyphBtn({
            style: styles.mapSvgGlyphInPopupClass, glyph: tf.styles.SvgGlyphCloseXName,
            onClick: toggleLocInfoWindow, tooltip: tf.consts.mapLocationPopupHideTip, dim: dim + "em"
        }));
        toggleBtn.GetHTMLElement().style.display = 'inline-block';
        infoPopupDiv = new tf.dom.Div({ cssClass: styles.unPaddedInlineBlockDivClass });
        infoPopupDiv.AddContent(toggleBtn);
        infoPopupDiv.AddContent(htmlFeedDiv);
        if (!!containerAll) { mapContainerAllObj.AppendTo(containerAll); }
    }
    var olSourceVector = null;
    var olLayer = null;
    var privateTLayer = null;
    var userPosFeature = null;
    var userPosLocationFeature = null;
    var olInfoFeature = null;
    var olLocFeature = null;
    function privateNotifyTLayerVisibilityChange(tLayer) { if (layersPopup) { layersPopup.UpdateLayerVisibilityFromMap(); } }
    function privateSetDeleteCmdCallBack(tLayer, deleteCmdCallBack) { if (tLayer) { tLayer.exportSetDeleteCmdCallBack = deleteCmdCallBack; } }
    function removeLayer(layerObj) {
        if (tf.js.GetIsMapFeatureLayer(layerObj)) {
            var isHidden = layerObj.GetIsHidden();
            var layerArray = isHidden ? hiddenMapFeatureLayers : mapFeatureLayers;
            var index = layerArray.indexOf(layerObj);
            if (index != -1) {
                var layerName = layerObj.GetName();
                if (tf.js.GetIsNonEmptyString(layerName)) { delete layersByName[layerName]; }
                layerObj.RemoveAllFeatures();
                layerObj.exportSetDeleteCmdCallBack.call(layerObj);
                layerArray.splice(index, 1);
                if (!isHidden) { refreshLayersPopup(); }
            }
        }
    }
    function addLegacyLayer(layerSettings) { return doAddFeatureLayer(layerSettings, true); }
    function addFeatureLayer(layerSettings) { return doAddFeatureLayer(layerSettings, false); }
    function doAddFeatureLayer(layerSettings, isLegacy) {
        var featureLayer = null;
        var settingsUse = tf.js.ShallowMerge(layerSettings);
        var canAddLayer = true;
        var layerName = null;
        if (tf.js.GetIsNonEmptyString(settingsUse.name)) {
            if (!(canAddLayer = !getLayerByName(layerName = settingsUse.name))) {
                tf.GetDebug().LogIfTest("tf.map.Map: adding layer with duplicate name: " + layerName);
            }
        }
        if (canAddLayer) {
            settingsUse = tf.js.ShallowMerge(settingsUse, {
                map: theThis,
                olMap: olMap,
                notifyDelFeatures: privateNotifyDelFeatures,
                notifyVisibilityChange: privateNotifyTLayerVisibilityChange,
                setDeleteCmdCallBack: privateSetDeleteCmdCallBack
            });
            featureLayer = !!isLegacy ? new TLayer(settingsUse) : new tf.map.FeatureLayer(settingsUse);
            if (!!layerName) { layersByName[layerName] = featureLayer; }
            if (!!featureLayer.GetIsHidden()) { hiddenMapFeatureLayers.push(featureLayer); } else { mapFeatureLayers.push(featureLayer); refreshLayersPopup(); }
        }
        return featureLayer;
    }
    function panByPixelOffset(pixelOffset) {
        if (tf.js.GetIsArrayWithMinLength(pixelOffset, 2)) {
            var x = tf.js.GetFloatNumber(pixelOffset[0], 0);
            var y = tf.js.GetFloatNumber(pixelOffset[1], 0);
            if (x != 0 || y != 0) {
                var center = getCenter();
                var sCenter = mapToPixelCoords(center);
                sCenter.X += x; sCenter.Y += y;
                var newCenter = pixelToMapCoords([sCenter.X, sCenter.Y]);
                setCenter(newCenter);
            }
        }
    }
    function getOLViewCenter() { return olView.getCenter(); }
    function getCenterCoords() { return tf.units.OL2TM(getOLViewCenter()); }
    function getCenter() {
        var center = getCenterCoords();
        center.Longitude = center[0];
        center.Latitude = center[1];
        return center;
    }
    function getPixelDistance(pointCoords1, pointCoords2) {
        var P1 = mapToPixelCoords(pointCoords1);
        var P2 = mapToPixelCoords(pointCoords2);
        var distanceX = P1[0] - P2[0];
        var distanceY = P1[1] - P2[1];
        var distanceSQ = (distanceX * distanceX) + (distanceY * distanceY);
        return Math.sqrt(distanceSQ);
    }
    function isSamePixelAs(pointCoords1, pointCoords2) { return getPixelDistance(pointCoords1, pointCoords2) == 0; };
    function getPixelDistanceFromCenter(pointCoords) {
        return getPixelDistance(/*[currentLon, currentLat]*/getCenter(), pointCoords);
    }
    function isSamePixelAsCenter(pointCoords) { return getPixelDistanceFromCenter(pointCoords) == 0; }
    function actualPixelToMapCoords(pointCoords) {
        var mapCoords = olMap.getCoordinateFromPixel(pointCoords);
        if (!tf.js.GetIsArrayWithMinLength(mapCoords, 2)) { mapCoords = [0, 0]; }
        else { mapCoords = tf.units.OL2TM(mapCoords); }
        return mapCoords;
    }
    function pixelToMapCoords(pointCoords) { return actualPixelToMapCoords(translatePixelCoords(pointCoords)); }
    function actualMapToPixelCoords(pointCoords) {
        var pixelCoords = olMap.getPixelFromCoordinate(tf.units.TM2OL(pointCoords));
        if (!tf.js.GetIsArrayWithMinLength(pixelCoords, 2)) { pixelCoords = [0, 0]; }
        return pixelCoords;
    }
    function mapToPixelCoords(pointCoords) { return translatePixelCoords(actualMapToPixelCoords(pointCoords)); }
    function onResize() {
        var width = mapContainerAll.clientWidth;
        var height = mapContainerAll.clientHeight;
        olMap.setSize([width, height]);
    }
    function getPixelSize() {
        if (olMap) { return olMap.getSize(); }
        else if (mapContainerAll) { return [mapContainerAll.clientWidth, mapContainerAll.clientHeight]; }
        return [0, 0];
    }
    function setLogoVisibility(visible) { return showPanel(tf.consts.panelNameTFLogo, !!visible); }
    var addressBarIsShowing = undefined;
    //var locInfoWindowIsShowing = undefined;
    var locInfoWindowIsShowing = false;
    //var locInfoWindowIsShowing = true;
    function showPanel(strPanel, showBool) {
        if (tf.js.GetIsNonEmptyString(strPanel)) {
            var strPanelLower = strPanel.toLowerCase();
            var panelControl = mapControls[strPanelLower];
            if (!!panelControl) {
                if ((showBool = !!showBool) != panelControl.isOn) {
                    if (panelControl.isOn = !panelControl.isOn) {
                        if (panelControl.control) {
                            olMap.addControl(panelControl.control);
                            switch (strPanelLower) {
                                case tf.consts.panelNameAddress:
                                    if (addressBarIsShowing === undefined || addressBarIsShowing == true) { showAddressBar(); }
                                    break;
                                case tf.consts.panelNameMapLocation:
                                    setUseRevGeocoderOnMoveEnd(showLocInfoWindowOnMoveEnd);
                                    if (locInfoWindowIsShowing === undefined || locInfoWindowIsShowing == true) { showLocInfoWindow(); }
                                    break;
                            }
                        }
                    }
                    else {
                        olMap.removeControl(panelControl.control);
                        switch (strPanelLower) {
                            case tf.consts.panelNameAddress:
                                addressBarIsShowing = isShowingAddressBar();
                                hideAddressBar();
                                break;
                            case tf.consts.panelNameMapLocation:
                                locInfoWindowIsShowing = isShowingLocInfoWindow();
                                hideLocInfoWindow();
                                setUseRevGeocoderOnMoveEnd(false);
                                break;
                        }
                    }
                }
            }
        }
    }
    function isPanelShowing(strPanel) {
        var isVisible = false;
        if (tf.js.GetIsNonEmptyString(strPanel)) {
            var panelControl = mapControls[strPanel.toLowerCase()];
            if (!!panelControl) { isVisible = panelControl.isOn; }
        }
        return isVisible;
    }
    function showPanels(strPanels) {
        if (tf.js.GetIsNonEmptyString(strPanels)) {
            strPanels = strPanels.split(tf.consts.charSplitStrings);
            var nParams = strPanels.length;
            var paramShown = [];
            var allstrPanels = tf.consts.allPanelNames;
            var allstrPanelsLen = allstrPanels.length;
            var showAddress = true;
            var showMapLocation = true;
            var showMapScale = true;
            var showMapRotate = true;
            var showUserLocation = true;
            for (var i = 0 ; i < nParams ; ++i) {
                var paramName = strPanels[i].toLowerCase();
                if (paramName == tf.consts.panelNameNoAddress) { showAddress = false; }
                else if (paramName == tf.consts.panelNameNoMapLocation) { showMapLocation = false; }
                else if (paramName == tf.consts.panelNameNoMapRotate) { showMapRotate = false; }
                else if (paramName == tf.consts.panelNameNoMapScale) { showMapScale = false; }
                else if (paramName == tf.consts.panelNameNoUserLocation) { showUserLocation = false; }
                else {
                    for (var j = 0 ; j < allstrPanelsLen ; ++j) {
                        var thisPanelParam = allstrPanels[j];
                        if (thisPanelParam == paramName) {
                            paramShown[j] = true;
                            showPanel(paramName, true);
                            break;
                        }
                    }
                }
            }
            for (var j = 0 ; j < allstrPanelsLen ; ++j) { var thisPanelShown = paramShown[j]; if (!thisPanelShown) { showPanel(allstrPanels[j], false); } }
            showPanel(tf.consts.panelNameAddress, showAddress);
            showPanel(tf.consts.panelNameMapLocation, showMapLocation);
            showPanel(tf.consts.panelNameMapRotate, showMapRotate);
            showPanel(tf.consts.panelNameMapScale, showMapScale);
            showPanel(tf.consts.panelNameUserLocation, showUserLocation);
        }
    }
    function setLegend(legendStrHybrid, legendStrMap) {
        //tf.GetDebug().LogIfTest("setting legend");
        var legendStrHybridUse = tf.js.GetNonEmptyString(legendStrHybrid, "");
        var legendStrMapUse = tf.js.GetNonEmptyString(legendStrMap, "");
        var decodedHybridLegend = new tf.map.aux.LegendDecoder(legendStrHybridUse);
        var decodedMapLayers = useMapNik2 ? new tf.map.aux.LegendDecoder(legendStrMapUse) : null;
        baseLayersPopup.SetLegend(decodedHybridLegend, decodedMapLayers);
        refreshLayersPopup();
    }
    function isShowingPopup(popup) { return !!popup && popup.IsShowing(); }
    function showInfoPopup(popup) { if (!!popup) { hideOpenControlPopups(); popup.Show(true); } }
    function showControlPopup(popup) { if (!!popup) { hideOpenControlPopups(); showInfoPopup(popup); } }
    function hidePopup(popup) { !!popup && popup.Show(false); }
    function togglePopup(popup) { if (isShowingPopup(popup)) { hidePopup(popup); } else { showPopup(popup); } }
    function toggleControlPopup(popup) { if (isShowingPopup(popup)) { hidePopup(popup); } else { showControlPopup(popup); } }
    function isShowingMapType() { return isShowingPopup(typesPopup); }
    function showMapType() { showControlPopup(typesPopup); }
    function hideMapType() { hidePopup(typesPopup); }
    function toggleMapType() { toggleControlPopup(typesPopup); }
    function isShowingAddressBar() { return isShowingPopup(addressPopup); }
    function toggleAddressBar() { toggleControlPopup(addressPopup); }
    function hideAddressBar() { hidePopup(addressPopup); }
    function showAddressBar() { showControlPopup(addressPopup); }
    function isShowingMapLayers() { return isShowingPopup(layersPopup); }
    function showMapLayers() {
        if (mapFeatureLayers.length > 0) {
            showControlPopup(layersPopup);
        }
        else {
            showMapBaseLayers();
        }
    }
    function hideMapLayers() { hidePopup(layersPopup); }
    function toggleMapLayers() {
        if (isShowingMapLayers()) {
            hideMapLayers();
        }
        else {
            showMapLayers();
        }
    }
    function isShowingMapSource() { return isShowingPopup(sourcesPopup); }
    function showMapSource() { showControlPopup(sourcesPopup); }
    function hideMapSource() { hidePopup(sourcesPopup); }
    function toggleMapSource() { toggleControlPopup(sourcesPopup); }
    function isShowingMapBaseLayers() { return isShowingPopup(baseLayersPopup); }
    function showMapBaseLayers() { if (baseLayersPopup && baseLayersPopup.GetHasLegend()) { showControlPopup(baseLayersPopup); } }
    function hideMapBaseLayers() { hidePopup(baseLayersPopup); }
    function toggleMapBaseLayers() { toggleControlPopup(baseLayersPopup); }
    function hideOpenControlPopups() {
        //hideAddressBar();
        hideMapType();
        hideMapLayers();
        hideMapSource();
        hideMapBaseLayers();
    }
    function hideOpenPopups() {
        hideInfoWindow();
        hideLocInfoWindow();
        hideMessage();
        hideOpenControlPopups();
    }
    var mapControls = [];
    function privateSetSource(source) { setSource(source, false); }
    function privateSetMode(mode) { setMapType(mode, false); }
    function privateInfoOnClose() { hideInfoWindow(); }
    function privateLocInfoOnClose() {
        //hideLocInfoWindow();
    }
    function privateMessageOnClose() { hideMessage(); }
    function privateHasLegendCallBack() { return baseLayersPopup ? baseLayersPopup.GetHasLegend() : false; }
    function refreshLayersPopup() { if (layersPopup) { layersPopup.RefreshContent(); } }
    function onClickMessagePopup(thePopup) {
        if (thePopup.IsShowing()) {
            var promote = true;
            if (thePopup == messagePopup) {
                if (isShowingMessage()) {
                    if (messageHideInterval) {
                        clearMessageInterval();
                        thePopup.ShowTitleColorInfo(true);
                    }
                    else { hideMessage(); }
                }
            }
            else if (thePopup == infoWindowPopup) { toggleInfoWindowPin(); }
            else if (thePopup == locInfoWindowPopup) { promote = false; }
            if (promote && thePopup.IsShowing()) { promoteToTopZIndex(thePopup); }
        }
    }
    var currentHString = "";
    var currentMString = "";
    var curMapServerIndex = 0, curRasterServerIndex;
    var defaultMapnikStringH = "osm_water,osm_buildings,osm_roads,osm_road_names,osm_place_names";
    var defaultMapnikStringM = "osm_land,osm_landuse,osm_water,osm_buildings,osm_roads,osm_road_names,osm_place_names";
    var currentMapnikStringH = defaultMapnikStringH;
    var currentMapnikStringM = defaultMapnikStringM;
    var getVectorTileFunction = null;
    function getMapLayerSourceURL(tileCoordZXY) {
        var thisURL = mapLayerSourceURL;
        thisURL = thisURL.replace("\{x\}", tileCoordZXY[1].toString());
        thisURL = thisURL.replace("\{y\}", (-tileCoordZXY[2] - 1).toString());
        //thisURL = thisURL.replace("\{y\}", tileCoordZXY[2].toString());
        thisURL = thisURL.replace("\{z\}", tileCoordZXY[0].toString());
        return thisURL;
    }
    function isHybridMode() { return currentMode == tf.consts.typeNameHybrid; }
    function getMapnik1VectorTile(tileCoordZXY, pixelRatio, projection) {
        var thisURL = undefined;
        if (!!mapLayerSourceURL) { thisURL = getMapLayerSourceURL(tileCoordZXY); }
        else {
            var usingHybrid = isHybridMode();
            var mapURLPrefix = "http://terranode-";
            var mapURLs = ["163", "167", "170", "246"];
            var nURLs = mapURLs.length;
            var mapPrefixStr = ".cs.fiu.edu/cache_mapnik/Default.aspx?TargetImageType=png&style=BT&Composite=";
            var mapType = usingHybrid ? "HYBRID" : "MAP";
            var strUse = usingHybrid ? currentHString : currentMString;
            var mapSuffixStr = "&projType=merc&type=" + mapType + "&x=" + tileCoordZXY[1] + "&y=" + (-tileCoordZXY[2] - 1) + "&z=" + tileCoordZXY[0];
            var mapFullStr = mapPrefixStr + strUse + mapSuffixStr;
            if (curMapServerIndex == nURLs) { curMapServerIndex = 0; }
            thisURL = mapURLPrefix + mapURLs[curMapServerIndex++] + mapFullStr;
        }
        return thisURL;
    }
    function getMapnik2VectorTile(tileCoordZXY, pixelRatio, projection) {
        var thisURL = undefined;
        if (!!mapLayerSourceURL) { thisURL = getMapLayerSourceURL(tileCoordZXY); }
        else {
            var usingHybrid = isHybridMode();
            var mapURLPrefix = "http://131.94.133.";
            var mapURLIPs = ["184", "186", "188", "190"];
            var nMapURLIPs = mapURLIPs.length;
            var service = usingHybrid ? "vmix" : "vector";
            var mapURLMiddle = "/TileService/" + service + ".aspx?projection=bing&styleset=";
            var mapStyle = usingHybrid ? "hybrid" : "map";
            var layersStr = usingHybrid ? currentMapnikStringH : currentMapnikStringM;
            var basicLayersStr = "&layers=" + layersStr;//"osm_land,osm_landuse,osm_water,osm_buildings,osm_roads,osm_road_names,osm_place_names";
            var mapURLSuffix = "&x=" + tileCoordZXY[1] + "&y=" + (-tileCoordZXY[2] - 1) + "&z=" + tileCoordZXY[0];
            if (!!mapNikDebug) { mapNikDebug.LogIfTest('Requested map layers: ' + basicLayersStr); }
            if (curMapServerIndex >= nMapURLIPs) { curMapServerIndex = 0; }
            thisURL = mapURLPrefix + mapURLIPs[curMapServerIndex++] + mapURLMiddle + mapStyle + basicLayersStr + mapURLSuffix;
        }
        return thisURL;
    }
    function setVectorLayerParams() {
        if (vectorLayerSource) {
            var usingHybrid = isHybridMode();
            if (!!mapLayerSourceURL) {
                vectorLayer.setOpacity(usingHybrid ? mapLayerSourceHybridModeOpacity : 1);
                rasterLayer.setOpacity(usingHybrid ? 1.0 - mapLayerSourceHybridModeOpacity : 1);
            }
        }
    }
    function refreshVectorLayer() {
        vectorLayerSource = new ol.source.XYZ({ tileUrlFunction: getVectorTileFunction, crossOrigin: 'anonymous' }); vectorLayer.setSource(vectorLayerSource);
    }
    function refreshRasterLayer() {
        if (!!rasterLayer) {
            rasterLayerSource = new ol.source.XYZ({ tileUrlFunction: getRasterTileFunction, crossOrigin: 'anonymous' }); rasterLayer.setSource(rasterLayerSource);
        }
    }
    function privateNotifyLegendOptionChange() { if (!mapLayerSourceURL) { refreshVectorLayer(); } }
    function privateNotifyLegendStringChange(currentHStringSet, currentMStringSet) {
        if (useMapNik2) {
            currentMapnikStringH = baseLayersPopup.GetHasLegendH() ? currentHStringSet : tf.js.GetNonEmptyString(currentHStringSet, defaultMapnikStringH);
            currentMapnikStringM = baseLayersPopup.GetHasLegendM() ? currentMStringSet : tf.js.GetNonEmptyString(currentMStringSet, defaultMapnikStringM);
        }
        else { currentHString = currentHStringSet; currentMString = currentMStringSet; }
        if (!!mapNikDebug) { mapNikDebug.LogIfTest('Map Hybrid layers: ' + currentMapnikStringH); mapNikDebug.LogIfTest('Map Map layers: ' + currentMapnikStringM); }
        setVectorLayerParams();
    }
    var singleAttribution = null;
    var olOverviewMapControl = null;
    var olScaleLineControl = null;
    var olRotateControl = null;
    var rotationDuration = 250;
    function createMapControls() {
        mapControls[tf.consts.panelNameAddress] = {
            control: new tf.map.ui.CustomControl(theThis, styles.mapAddressButtonClass, "A", showAddressBar, { tipLabel: tf.consts.addressBarName, imageLabel: getSearchButtonImg(), target: mapControlContainerHTML }),
            isOn: false
        };
        mapControls[tf.consts.panelNameZoom] = { control: new ol.control.Zoom({ zoomInLabel: tf.map.ui.CreateMapButtonTextSpan("+"), zoomOutLabel: tf.map.ui.CreateMapButtonTextSpan("-"), target: mapControlContainerHTML }), isOn: false };
        mapControls[tf.consts.panelNameLayers] = {
            control: new tf.map.ui.CustomControl(theThis, styles.mapLayersButtonClass, "L", showMapLayers, { tipLabel: tf.consts.mapLayersName, imageLabel: getLayersButtonImg(), target: mapControlContainerHTML }),
            isOn: false
        };
        mapControls[tf.consts.panelNameType] = {
            control: new tf.map.ui.CustomControl(theThis, styles.mapTypeButtonClass, "T", showMapType, { tipLabel: tf.consts.mapTypesName, imageLabel: getTypeButtonImg(), target: mapControlContainerHTML }),
            isOn: false
        };
        mapControls[tf.consts.panelNameMeasure] = {
            control: new tf.map.ui.CustomControl(theThis, styles.mapMeasureButtonClass, "M", startMeasureInteraction, { tipLabel: tf.consts.mapMeasureName, imageLabel: getMeasureButtonImg(), target: mapControlContainerHTML }),
            isOn: false
        };
        mapControls[tf.consts.panelNameDownload] = {
            control: new tf.map.ui.CustomControl(theThis, styles.mapDownloadButtonClass, "D", startDownloadInteraction, { tipLabel: tf.consts.mapDownloadName, imageLabel: getDownloadButtonImg(), target: mapControlContainerHTML }),
            isOn: false
        };
        mapControls[tf.consts.panelNameSource] = {
            control: new tf.map.ui.CustomControl(theThis, styles.mapSourceButtonClass, "S", showMapSource, { tipLabel: tf.consts.mapSourcesName, target: mapControlContainerHTML }),
            isOn: false
        };
        mapControls[tf.consts.panelNameTFLogo] = {
            control: new tf.map.ui.CustomLogo(theThis, styles.mapTFLogoControlClass, { imageLabel: tf.platform.GetPoweredByTerraFlyLogo(), target: mapControlContainerHTML }),
            isOn: false
        };
        mapControls[tf.consts.panelNameFullscreen] = {
            control: new tf.map.ui.CustomControl(theThis, styles.mapFullScreenButtonClass, getFullScreenLabelNormal(), toggleMapFullScreen, { tipLabel: tf.consts.fullScreenToolTipNormal, target: mapControlContainerHTML }),
            isOn: false
        };
        mapControls[tf.consts.panelNameMapLocation] = {
            control: new tf.map.ui.CustomControl(theThis, styles.mapLocationButtonClass, "C", toggleLocInfoWindowShow, {
                tipLabel: showLocInfoWindowOnMoveEnd ? tf.consts.mapLocationHideTip : tf.consts.mapLocationShowTip, imageLabel: getMapLocationButtonImg(), target: mapControlContainerHTML
            }),
            isOn: false
        };
        if (!!navigator.geolocation) {
            mapControls[tf.consts.panelNameUserLocation] = {
                control: new tf.map.ui.CustomControl(theThis, styles.mapUserLocationButtonClass, "U", buttonRequestCenterToUserLocation, {
                    tipLabel: tf.consts.centerToUserLocationTip, imageLabel: getMapUserLocationButtonImg(), target: mapControlContainerHTML
                }),
                isOn: false
            };
        }
        var rasterImageURLs = defaultMap2RasterImageUrls;
        olOverviewMapControl = new ol.control.OverviewMap({
            layers: [new ol.layer.Tile({ source: new ol.source.XYZ({ urls: rasterImageURLs, crossOrigin: 'anonymous' }) })],
            className: 'ol-overviewmap',
            collapseLabel: tf.map.ui.CreateMapButtonTextSpan("\u00BB"),
            label: tf.map.ui.CreateMapButtonTextSpan("\u00AB"),
            collapsed: true, target: mapControlContainerHTML
        });
        mapControls[tf.consts.panelNameOverview] = {
            control: olOverviewMapControl,
            isOn: false
        };
        olScaleLineControl = new ol.control.ScaleLine({target: mapControlContainerHTML});
        mapControls[tf.consts.panelNameMapScale] = {
            control: olScaleLineControl,
            isOn: false
        };
        olRotateControl = new ol.control.Rotate({
            autoHide: false,
            label: tf.map.ui.CreateMapButtonTextSpan("\u21e7"),
            tipLabel: "Reset Map Rotation",
            resetNorth: function () {
                var currentRotation = getRotationRad();
                if (currentRotation == 0) {
                    showMessage(
                        "- Hold down SHIFT & ALT then Click & Drag to rotate<br/>" +
                        "- On touch screens, use two fingers to rotate "
                        );
                }
                else {
                    currentRotation = currentRotation % (2 * Math.PI);
                    if (currentRotation < -Math.PI) { currentRotation += 2 * Math.PI; }
                    if (currentRotation > Math.PI) { currentRotation -= 2 * Math.PI; }
                    olMap.beforeRender(ol.animation.rotate({
                        rotation: currentRotation,
                        duration: rotationDuration,
                        easing: ol.easing.easeOut
                    }));
                    setRotationRad(0);
                }
            },
            target: mapControlContainerHTML
        });
        olRotateControl.element.style.zIndex = 1;
        mapControls[tf.consts.panelNameMapRotate] = {
            control: olRotateControl,
            isOn: false
        };
    }
    function getLayersForLayersPopup() { return mapFeatureLayers; }
    function createMapPopups() {
        var containerForAddressAndMessage = !!containerAll ? containerAll : mapContainerAll;
        baseLayersPopup =
            useMapNik2 ?
            new tf.map.ui.Mapnik2Popup(mapContainerAll, theThis, privateNotifyLegendStringChange, privateNotifyLegendOptionChange, mapControls[tf.consts.panelNameLayers].control, mapNikDebug) :
            new tf.map.ui.Mapnik1Popup(mapContainerAll, theThis, privateNotifyLegendStringChange, privateNotifyLegendOptionChange, mapControls[tf.consts.panelNameLayers].control, mapNikDebug);
        layersPopup = new tf.map.ui.LayersPopup(mapContainerAll, theThis, privateHasLegendCallBack, mapControls[tf.consts.panelNameLayers].control, showMapBaseLayers, getLayersForLayersPopup);
        addressPopup = new tf.map.ui.AddressBar(containerForAddressAndMessage, theThis, mapControls[tf.consts.panelNameAddress].control);
        typesPopup = new tf.map.ui.TypesPopup(mapContainerAll, theThis, privateSetMode, mapControls[tf.consts.panelNameType].control);
        sourcesPopup = new tf.map.ui.SourcesPopup(mapContainerAll, theThis, privateSetSource, mapControls[tf.consts.panelNameSource].control);
        locInfoWindowPopup = new tf.map.ui.LocationPopup(mapContainerAll);
        locInfoWindowPopup.SetOnClose(privateLocInfoOnClose, theThis);
        locInfoWindowPopup.SetZIndex(99);
        infoWindowPopup = new tf.map.ui.InfoPopup(mapContainerAll);
        infoWindowPopup.SetOnClose(privateInfoOnClose, theThis);
        addToZIndexPopups(infoWindowPopup, theThis);
        messagePopup = new tf.map.ui.MessagePopup(containerForAddressAndMessage);
        messagePopup.SetOnClose(privateMessageOnClose, theThis);
        addToZIndexPopups(messagePopup, theThis);
    }
    function setNewExtent(overviewDiv) {
        try {
            var offset = overviewDiv.helper.position();
            var divSize = [overviewDiv.helper.width(), overviewDiv.helper.height()];
            var mapSize = map.getPixelSize();
            var c = map.getView().getResolution();
            var xMove = offset.left * (Math.abs(mapSize[0] / divSize[0]));
            var yMove = offset.top * (Math.abs(mapSize[1] / divSize[1]));
            var bottomLeft = [0 + xMove, mapSize[1] + yMove];
            var topRight = [mapSize[0] + xMove, 0 + yMove];
            var left = map.getCoordinateFromPixel(bottomLeft);
            var top = map.getCoordinateFromPixel(topRight);
            var extent = [left[0], left[1], top[0], top[1]];
            map.getView().fit(extent, mapSize);
            map.getView().setResolution(c);
        }
        catch (exception) { }
    }
    var overviewMapElem = null, overviewBoxElem = null, overviewBoxParent = null;
    function onClickOverviewMap(notification) {
        var ovMap = olOverviewMapControl.getOverviewMap();
        var evTarget = tf.events.GetEventTarget(notification.event);
        var mouseOffset = tf.events.GetMouseEventCoords(notification.event);
        if (!evTarget || !mouseOffset) { return; }
        var clickX = mouseOffset[0];
        var clickY = mouseOffset[1];
        if (evTarget != overviewMapElem) {
            if (evTarget == overviewBoxElem) {
                clickX += overviewBoxParent.offsetLeft;
                clickY += overviewBoxParent.offsetTop;
            }
            else {
                clickX += evTarget.offsetLeft;
                clickY += evTarget.offsetTop;
            }
        }
        var coordinate = tf.units.OL2TM(ovMap.getCoordinateFromPixel([clickX, clickY]));
        setCenter(coordinate);
    }
    function hookOverviewMapClick() {
        overviewMapElem = document.getElementsByClassName("ol-overviewmap-map");
        if (overviewMapElem.length > 0) {
            overviewMapElem = overviewMapElem[0];
            overviewBoxElem = document.getElementsByClassName("ol-overviewmap-box");
            if (overviewBoxElem.length > 0) {
                overviewMapElem.style.cursor = 'pointer';
                overviewBoxElem = overviewBoxElem[0];
                overviewBoxParent = overviewBoxElem.parentNode;
                new tf.events.DOMClickListener({ target: overviewMapElem, callBack: onClickOverviewMap, optionalScope: theThis, callBackSettings: undefined });
            }
        }
        else {
            setTimeout(hookOverviewMapClick, 1000);
        }
    }
    function createRasterAndVectorLayers() {
        vectorLayerSource = new ol.source.XYZ({ tileUrlFunction: getVectorTileFunction, crossOrigin: 'anonymous' });
        rasterLayerSource = new ol.source.XYZ({ tileUrlFunction: getRasterTileFunction, crossOrigin: 'anonymous' });
        //var rasterImageURLs = defaultMap2RasterImageUrls;
        /*rasterLayer = new ol.layer.Tile({
            source: new ol.source.XYZ({
                urls: rasterImageURLs, 
                tileLoadFunction: function (imageTile, src) {
                var imgElement = imageTile.getImage();
                imgElement.src = "http://localhost/terramap/image/tile.png";
                }
            })
        });*/
        rasterLayer = new ol.layer.Tile({ source: rasterLayerSource });
        vectorLayer = new ol.layer.Tile({ source: vectorLayerSource });
        olMap.addLayer(rasterLayer);
        olMap.addLayer(vectorLayer);
    }
    function setMapType(mode, updatePopup) {
        var modeSet = tf.js.GetNonEmptyString(mode, tf.consts.defaultSourceName);
        modeSet = modeSet.toLowerCase();
        var oldMode = currentMode;
        if (!currentMode || currentMode != modeSet) {
            var rasterVisible = false, vectorVisible = false;
            switch (modeSet) {
                default:
                case tf.consts.typeNameHybrid:
                    rasterVisible = vectorVisible = true;
                    currentMode = tf.consts.typeNameHybrid;
                    break;
                case tf.consts.typeNameMap:
                    vectorVisible = true;
                    currentMode = tf.consts.typeNameMap;
                    break;
                case tf.consts.typeNameAerial:
                    rasterVisible = true;
                    currentMode = tf.consts.typeNameAerial;
                    break;
            }
            rasterLayer.setVisible(rasterVisible);
            vectorLayer.setVisible(vectorVisible);
            if (updatePopup) { if (typesPopup) { typesPopup.UpdateModeFromMap(); } }
            refreshVectorLayer();
            setVectorLayerParams();
            mergeWithBaseAndNotifyListeners(tf.consts.mapTypeChangeEvent, { oldType: oldMode, newType: currentMode });
        }
    }
    function setSource(source, updatePopup) {
        var sourceSet = tf.js.GetNonEmptyString(source, tf.consts.defaultSourceName);
        if (!currentSource || currentSource != sourceSet) {
            currentSource = sourceSet;
            if (!!updatePopup) { if (sourcesPopup) { sourcesPopup.UpdateSourceFromMap(); } }
            refreshRasterLayer();
        }
    }
    function getRasterTileFunction(tileCoordZXY, pixelRatio, projection) {
        var thisURL = undefined;
        var mapURLPrefix = "http://131.94.133.";
        var mapURLIPs = ["184", "186", "188", "190"];
        var nMapURLIPs = mapURLIPs.length;
        var mapURLMiddle = "/TileService/rmix.aspx?projection=bing&source=" + currentSource;
        var mapURLSuffix = "&x=" + tileCoordZXY[1] + "&y=" + (-tileCoordZXY[2] - 1) + "&z=" + tileCoordZXY[0];
        if (curMapServerIndex >= nMapURLIPs) { curMapServerIndex = 0; }
        thisURL = mapURLPrefix + mapURLIPs[curMapServerIndex++] + mapURLMiddle + mapURLSuffix;
        return thisURL;
    }
    function setCenter(pointCoords) {
        if (tf.js.GetIsArrayWithMinLength(pointCoords, 2)) {
            var center = tf.units.TM2OL(pointCoords);
            olView.setCenter(center);
        }
    }
    function setCenterAndLevel(pointCoords, level) { setCenter(pointCoords); setLevel(level); }
    function getResolution() { return olView.getResolution(); }
    function setResolution(resolution) {
        resolution = tf.js.GetFloatNumber(resolution, tf.units.GetResolutionByLevel(tf.consts.defaultLevel));
        if (resolution != currentRes) {
            olView.setResolution(resolution);
            currentRes = getResolution();
            resChanged = true;
            var level = tf.units.GetLevelByResolution(currentRes);
            if (!isAnimating) {
                onDelayResEnd.DelayCallBack();
            }
            if (level != currentLevel) {
                currentLevel = level;
                if (!isAnimating) {
                    onDelayZoomEnd.DelayCallBack();
                }
            }
        }
    }
    function getLevel() { return currentLevel; }
    function setLevel(level) {
        level = tf.js.GetLevelFrom(level);
        if (level != currentLevel) {
            currentLevel = level;
            olView.setZoom(level);
            currentRes = getResolution();
            resChanged = levelChanged = true;
            if (!isAnimating) {
                onDelayResEnd.DelayCallBack();
                onDelayZoomEnd.DelayCallBack();
            }
        }
    }
    function setView(viewSettings) {
        viewSettings = tf.js.GetValidObjectFrom(viewSettings);
        var extent = viewSettings.extent;
        var minLevel = tf.js.GetLevelFrom(viewSettings.minLevel);
        var maxLevel = tf.js.GetLevelFrom(viewSettings.maxLevel);
        if (minLevel > maxLevel) { var t = minLevel; minLevel = maxLevel; maxLevel = t; }
        var levelNow = getLevel();
        var center = olView.getCenter();
        if (levelNow < minLevel) { levelNow = minLevel; }
        if (levelNow > maxLevel) { levelNow = maxLevel; }
        var tmExtent;
        if (tf.js.GetIsArrayWithLength(extent, 4)) {
            tmExtent = extent.slice(0);
            extent = ol.extent.applyTransform(extent, ol.proj.getTransform(tf.consts.tmSystem, tf.consts.olSystem));
        }
        else {
            extent = undefined;
        }
        var enableRotation = viewSettings.enableRotation !== undefined ? !!viewSettings.enableRotation : true;
        var newSettings = {
            enableRotation: enableRotation,
            maxZoom: maxLevel,
            minZoom: minLevel,
            center: center,
            zoom: levelNow,
            extent: extent
        };
        var newOLView = new ol.View(newSettings);
        olMap.setView(olView = newOLView);
        hookUpOLViewEvents();
        newSettings.extent = tmExtent;
        mergeWithBaseAndNotifyListeners(tf.consts.mapViewSettingsChangedEvent, newSettings);
    }
    function hookUpOLViewEvents() {
        olView.on('change:resolution', function (event) {
            var newLevel = tf.units.GetLevelByResolution(currentRes = getResolution());
            resChanged = true;
            levelChanged = newLevel != currentLevel;
            currentLevel = newLevel;
            if (!isAnimating) {
                onDelayResEnd.DelayCallBack();
                if (levelChanged) { onDelayZoomEnd.DelayCallBack(); }
            }
            //tf.GetDebug().LogIfTest('level: ' + currentLevel + ' res: ' + currentRes);
        }, theThis);
    }
    var userPosLocationStyleSpecs = { marker: true, label: '.', zindex: 1, border_color: "#00f", border_width: 2, marker_color: "#000", font_color: "#fff", font_height: 16 };
    function buttonRequestCenterToUserLocation() { return requestCenterToUserLocation(true, true); }
    function updateUserLocation() { return requestCenterToUserLocation(false, false); }
    function requestCenterToUserLocation(showCoordinates, panToBool) {
        if (!!navigator.geolocation) { navigator.geolocation.getCurrentPosition(function (position) { centerToUserLocation(position, showCoordinates, panToBool); }, failedGeoLoc); }
    }
    function failedGeoLoc(err) { }
    var userPosFeatureAlreadyAdded = false;
    function centerToUserLocation(position, showCoordinates, panToBool) {
        var lat = position.coords.latitude;
        var lon = position.coords.longitude;
        if (panToBool) {
            //panTo(lat, lon);
            setCenter([lon, lat]);
        }
        userPosFeature.SetPointCoords([lon, lat]);
        userPosLocationFeature.SetPointCoords([lon, lat]);
        userPosLocationFeature.ChangeStyle(tf.js.ShallowMerge(userPosLocationStyleSpecs, { label: 'User at: ( ' + lat.toFixed(6) + ',' + lon.toFixed(6) + ' )' }));
        if (!userPosFeatureAlreadyAdded) {
            privateTLayer.AddMapFeature(userPosFeature);
            userPosFeatureAlreadyAdded = true;
        }
    }
    function hideUserLocation() {
        if (userPosFeatureAlreadyAdded) {
            privateTLayer.DelMapFeature(userPosFeature);
            userPosFeatureAlreadyAdded = false;
        }
    }
    var olInteractions, olInteractionsCopy, mapDrawInteraction, onDelayMoveEnd, onDelayZoomEnd, onDelayResEnd;
    
    function createOLInteractions() { return new ol.interaction.defaults({ doubleClickZoom: false }); }
    function createOLViewAndMap() {
        olView = new ol.View({
            //enableRotation: false,
            maxZoom: tf.consts.maxLevel/*,
            minZoom: tf.consts.minLevel*/
        });
        var olControl = ol.control.defaults(
            //{ attribution: false, rotate: false, zoom: false }).extend([new ol.control.Rotate({ autoHide: /*false*/true })/*, new ol.control.ScaleLine()*/]
            { attribution: false, rotate: false, zoom: false }
        );
        olInteractions = createOLInteractions();
        olInteractionsCopy = new ol.Collection();
        olInteractionsCopy.extend(olInteractions.getArray());
        olMap = new ol.Map
        ({
            loadTilesWhileAnimating: true,
            loadTilesWhileInteracting: true,
            renderer: 'canvas',
            target: mapContainer,
            view: olView,
            controls: olControl,
            interactions: olInteractions
        });
        createRasterAndVectorLayers();
        olSourceVector = new ol.source.Vector();
        olLayer = new ol.layer.Vector({ source: olSourceVector/*, visible: true*/, zIndex: mapPrivateLayerZIndex });
        olLayer.setVisible(true);
        olMap.addLayer(olLayer);
        privateTLayer = addFeatureLayer({ isVisible: true, isHidden: true, color: "#fff", zIndex: mapPrivateLayerZIndex - 1 });
        /*privateTLayer = new tf.map.FeatureLayer(theThis, olMap, "", "", true, true, "#fff", null, null,
            false, null, null, null, false, null, mapPrivateLayerZIndex - 1
            );*/
        //privateTLayer.AddMarker(tf.consts.defaultLatitude, tf.consts.defaultLongitude, "hello, world.");
        var snapToPixel = false;
        var circle_radius = 16;
        var userPosGeom = new tf.map.FeatureGeom({ type: "point", coordinates: [tf.consts.defaultLongitude, tf.consts.defaultLatitude] });
        var userPosStyleSpecs = [
            { circle: true, circle_radius: circle_radius + 2, fill: true, fill_color: "#ebebeb", fill_alpha: 60, zindex: 2, snaptopixel: snapToPixel },
            { circle: true, circle_radius: circle_radius - 2, fill: false, fill_color: "#abf", line: true, line_color: "#00a", line_width: 1, zindex: 3, snaptopixel: snapToPixel },
            { circle: true, circle_radius: circle_radius - 8, fill: true, fill_color: "#f84", line: true, line_color: "#00f", line_width: 1, zindex: 4, snaptopixel: snapToPixel }
        ];
        var userPosHoverStyleSpecs = [
            tf.js.ShallowMerge(userPosStyleSpecs[0], { fill_color: "#fbfbfb" }),
            tf.js.ShallowMerge(userPosStyleSpecs[1], { line_width: 2 }),
            { circle: true, circle_radius: circle_radius - 8, fill: true, fill_color: "#f84", line: true, line_color: "#00f", line_width: 1, zindex: 4, snaptopixel: snapToPixel }
        ];
        userPosFeature = new tf.map.Feature({ geom: userPosGeom, style: userPosStyleSpecs, hoverStyle: userPosHoverStyleSpecs });
        userPosLocationFeature = new tf.map.Feature({ geom: userPosGeom, style: userPosLocationStyleSpecs });
        userPosFeature.SetOnHoverInOutListener(onHoverInOutUserPosFeature);
    }
    function onHoverInOutUserPosFeature() {
        if (userPosFeature.GetIsInHover()) {
            privateTLayer.AddMapFeature(userPosLocationFeature);
        }
        else { privateTLayer.DelMapFeature(userPosLocationFeature); }
    }
    var levelChanged, resChanged, posChanged;
    function checkSizePopups() {
        if (addressPopup) { addressPopup.OnContainerResize(); }
        if (measurePopup) { measurePopup.OnContainerResize(); }
        if (baseLayersPopup) { baseLayersPopup.OnContainerResize(); }
        if (infoWindowPopup) { infoWindowPopup.OnContainerResize(); }
        if (layersPopup) { layersPopup.OnContainerResize(); }
        if (sourcesPopup) { sourcesPopup.OnContainerResize(); }
        if (typesPopup) { typesPopup.OnContainerResize(); }
        if (locInfoWindowPopup) { locInfoWindowPopup.OnContainerResize(); }
        if (messagePopup) { messagePopup.OnContainerResize(); }
    }
    function addPointMarker(pointCoords, style, name) {
        var lat = tf.js.GetLatitudeFrom(pointCoords[1]);
        var lon = tf.js.GetLongitudeFrom(pointCoords[0]);
        var markerPoint = new ol.geom.Point([lon, lat]).transform(tf.consts.tmSystem, tf.consts.olSystem);
        var olFeature = new ol.Feature({ geometry: markerPoint, markerName: name });
        olFeature.setStyle(style);
        olSourceVector.addFeature(olFeature);
        return olFeature;
    }
    function getFullScreenLabelNormal() { return styles.GetUnicodeDoubleHorArrow(); }
    function getFullScreenLabelFull() { return styles.GetUnicodeXClose(); }
    function getSearchButtonImg() { return new tf.ui.SvgGlyphBtn({ style: styles.mapSvgGlyphInButtonClass, glyph: tf.styles.SvgGlyphMagnifyingLensName, dim: mapButtonDimEmStr, noChangeOnHover: true }); }
    function getLayersButtonImg() { return new tf.ui.SvgGlyphBtn({ style: styles.mapSvgGlyphInButtonClass, glyph: tf.styles.SvgGlyphMapLayersName, dim: mapButtonDimEmStr, noChangeOnHover: true }); }
    function getMeasureButtonImg() { return new tf.ui.SvgGlyphBtn({ style: styles.mapSvgGlyphInButtonClass, glyph: tf.styles.SvgGlyphMeasuringTapeName, dim: mapButtonDimEmStr, noChangeOnHover: true }); }
    function getDownloadButtonImg() { return new tf.ui.SvgGlyphBtn({ style: styles.mapSvgGlyphInButtonClass, glyph: tf.styles.SvgGlyphDownloadName, dim: mapButtonDimEmStr, noChangeOnHover: true }); }
    function getTypeButtonImg() { return new tf.ui.SvgGlyphBtn({ style: styles.mapSvgGlyphInButtonClass, glyph: tf.styles.SvgGlyphEarthName, dim: mapButtonDimEmStr, noChangeOnHover: true }); }
    function getMapLocationButtonImg() { return new tf.ui.SvgGlyphBtn({ style: styles.mapSvgGlyphInButtonClass, glyph: tf.styles.SvgGlyphBullsEye2Name, dim: mapButtonDimEmStr, noChangeOnHover: true }); }
    function getMapUserLocationButtonImg() { return new tf.ui.SvgGlyphBtn({ style: styles.mapSvgGlyphInButtonClass, glyph: tf.styles.SvgGlyphUserLocationName, dim: mapButtonDimEmStr, noChangeOnHover: true }); }
    function getMapInfoPinImgSrc() { return tf.platform.MakePlatformPath("image/pin260pinned.png"); }
    function getMapInfoUnPinImgSrc() { return tf.platform.MakePlatformPath("image/pin260.png"); }
    var pinInfoMarkerSrc = getMapInfoPinImgSrc();
    var unPinInfoMarkerSrc = getMapInfoUnPinImgSrc();
    function makeMarkerStyle(pinFile, pinAnchor) {
        var markerStyle =
            [new ol.style.Style({
                image: new ol.style.Icon({
                    crossOrigin: "",
                    src: pinFile,
                    anchor: pinAnchor
                })
            })];
        return markerStyle;
    }
    function createInfoMarkerStyle(pinned) {
        var aPin = pinned ? pinInfoMarkerSrc : unPinInfoMarkerSrc;
        return makeMarkerStyle(aPin, [0.5, 0.05]);
    }
    var pinInfoMarker = createInfoMarkerStyle(true);
    var unPinInfoMarker = createInfoMarkerStyle(false);
    function showInfoMarker(pointCoords) {
        olInfoFeature = addPointMarker(pointCoords, unPinInfoMarker, infoFeatureName);
    }
    function hideInfoMarker() {
        if (olInfoFeature) {
            olSourceVector.removeFeature(olInfoFeature);
            olInfoFeature = null;
        }
    }
    var infoWindowPinned = false;
    function toggleInfoWindowPin() {
        if (olInfoFeature) {
            infoWindowPinned = !infoWindowPinned;
            var markerUse = infoWindowPinned ? pinInfoMarker : unPinInfoMarker;
            olInfoFeature.setStyle(markerUse);
            infoWindowPopup.ShowTitleColorInfo(infoWindowPinned);
        }
    }
    function isShowingInfoWindow() { return infoWindowPopup ? infoWindowPopup.IsShowing() : false; }
    function hideInfoWindow() {
        if (isShowingInfoWindow()) {
            hideInfoMarker();
            infoWindowPopup.ShowTitleColorInfo(false);
            infoWindowPopup.Show(false);
            infoWindowPinned = false;
        }
    }
    function toggleInfoWindow() {
        if (isShowingInfoWindow()) { hideInfoWindow(); } else { showInfoWindow(); }
    }
    function showInfoWindow(title, content, pointCoords) {
        if (infoWindowPopup) {
            if (!infoWindowPinned) {
                if (!!content) {
                    //hideOpenControlPopups();
                    hideInfoMarker();
                    showInfoMarker(pointCoords);
                    infoWindowPopup.SetTitle(title);
                    infoWindowPopup.SetContent(content);
                    promoteToTopZIndex(infoWindowPopup);
                    infoWindowPopup.Show(true);
                }
            }
        }
    }
    var showLocInfoWindowOnMoveEndByDefault;
    var showLocInfoWindowOnMoveEnd;
    function setLocInfoWindowShow() {
        setUseRevGeocoderOnMoveEnd(showLocInfoWindowOnMoveEnd);
        if (!showLocInfoWindowOnMoveEnd) {
            hideLocInfoWindow();
            mapControls[tf.consts.panelNameMapLocation].control.ChangeToolTip(tf.consts.mapLocationShowTip);
        }
        else {
            showLocInfoWindow();
            mapControls[tf.consts.panelNameMapLocation].control.ChangeToolTip(tf.consts.mapLocationHideTip);
        }
    }
    function toggleLocInfoWindowShow() {
        showLocInfoWindowOnMoveEnd = !showLocInfoWindowOnMoveEnd;
        setLocInfoWindowShow();
    }
    function toggleLocInfoWindow() { if (isShowingLocInfoWindow()) { hideLocInfoWindow(); } else { showLocInfoWindow(); } }
    function isShowingLocInfoWindow() { return locInfoWindowPopup ? locInfoWindowPopup.IsShowing() : false; }
    function hideLocInfoWindow() {
        if (isShowingLocInfoWindow()) {
            locInfoWindowPopup.Show(false);
        }
    }
    function showLocInfoWindow() {
        if (locInfoWindowPopup) {
            /*promoteToTopZIndex(locInfoWindowPopup);*/
            locInfoWindowPopup.Show(true);
        }
    }
    var infoPopupDiv = null;
    var htmlFeedDiv = null;
    function updateLocInfoWindow(myLabel, myContent, useUpdatedColor) {
        locInfoWindowPopup.ShowTitleColorInfo(!!useUpdatedColor);
        locInfoWindowPopup.SetTitle(typeof myLabel == "string" && myLabel.length > 0 ? myLabel : "Location");
        htmlFeedDiv.ClearContent();
        if (typeof myContent === "string") { htmlFeedDiv.GetHTMLElement().innerHTML = myContent; } else { htmlFeedDiv.AddContent(myContent); }
        locInfoWindowPopup.SetContent(infoPopupDiv);
        if (showLocInfoWindowOnMoveEnd) { if (!isShowingLocInfoWindow()) { showLocInfoWindow(); } }
    }
    var messagePinned = false;
    function setMessageTimeout(timeoutSecs) {
        messageTimeoutSecs = (typeof timeoutSecs == "number" && timeoutSecs >= 0) ? timeoutSecs : defaultmessageTimeoutSecs;
    }
    function isShowingMessage() { return isShowingPopup(messagePopup); }
    function showMessage(content) {
        if (messagePopup && !messagePinned) {
            clearMessageInterval();
            messagePopup.SetContent(content);
            messagePopup.ShowTitleColorInfo(false);
            promoteToTopZIndex(messagePopup);
            showInfoPopup(messagePopup);
            setMessageTimeoutObject();
        }
    }
    function toggleMessage() { if (isShowingMessage()) { hideMessage() } else { showMessage(); } }
    function hideMessage() {
        if (isShowingMessage()) {
            clearMessageInterval();
            hidePopup(messagePopup);
            messagePinned = false;
        }
    }
    var messageHideInterval = null;
    var defaultmessageTimeoutSecs = 5;
    var messageTimeoutSecs = defaultmessageTimeoutSecs;
    function clearMessageInterval() {
        if (messageHideInterval) {
            clearInterval(messageHideInterval);
            messageHideInterval = null;
        }
    }
    function setMessageTimeoutObject() {
        if (messageTimeoutSecs) {
            messageHideInterval = setTimeout(hideMessage, messageTimeoutSecs * 1000);
        }
    }
    function onNotifyMoveEnd() {
        if (resChanged) { baseLayersPopup.OnResolutionChange(currentRes); }
        mergeWithBaseAndNotifyListeners(tf.consts.mapMoveEndEvent, makeCurrentLatLonNotification());
        levelChanged = false;
        posChanged = false;
    }
    function createLevelResolutionNotification() { return { level: currentLevel, resolution: currentRes }; }
    function onNotifyResolutionEnd() {
        baseLayersPopup.OnResolutionChange(currentRes);
        mergeWithBaseAndNotifyListeners(tf.consts.mapResolutionChangeEvent, createLevelResolutionNotification());
        resChanged = false;
    }
    function onNotifyZoomEnd() {
        //baseLayersPopup.OnResolutionChange(currentRes);
        mergeWithBaseAndNotifyListeners(tf.consts.mapLevelChangeEvent, createLevelResolutionNotification());
        levelChanged = false;
    }
    var minAniSpeed = 100;
    var maxAniSpeed = 9999999999;
    function makeAnimatedCallBackNotification() {
        return mergeWithBaseNotification(tf.js.ShallowMerge(makeCurrentLatLonNotification(), createLevelResolutionNotification()));
    }
    function notifyAnimationEnd(callBack) {
        if (!!(callBack = tf.js.GetFunctionOrNull(callBack))) {
            var notification = makeAnimatedCallBackNotification();
            setTimeout(function () { callBack(notification); }, 1);
            //callBack(notification);
        }
    }
    function animatedSetLevel(newLevel, callBack, durationPerLevel, notifyListeners, easing) {
        newLevel = tf.js.GetLevelFrom(newLevel);
        var levelDiff = Math.abs(currentLevel - newLevel);
        if (levelDiff != 0) {
            durationPerLevel = tf.js.GetFloatNumberInRange(durationPerLevel, minAniSpeed, maxAniSpeed, tf.consts.defaultMapAnimatedDurationPerLevelMillis);
            var speed = levelDiff * durationPerLevel;
            if (speed <= 0) { speed = 10; }
            startAnimation(function (request) {
                var nextStep;
                if (request.step == 0) {
                    nextStep = {
                        duration: speed,
                        resolution: tf.units.GetResolutionByLevel(newLevel),
                        notifyListeners: !!notifyListeners
                    };
                    if (tf.js.GetFunctionOrNull(easing)) { nextStep.easing = easing; }
                }
                else {
                    notifyAnimationEnd(callBack); callBack = null;
                }
                return nextStep;
            }, theThis);
        }
        else { notifyAnimationEnd(callBack); }
    }
    function animatedSetCenter(pointCoords, callBack, duration, notifyListeners, easing) {
        if (isSamePixelAsCenter(pointCoords)) {
            setCenter(pointCoords);
            notifyAnimationEnd(callBack);
        }
        else {
            var latitude = tf.js.GetLatitudeFrom(pointCoords[1]);
            var longitude = tf.js.GetLongitudeFrom(pointCoords[0]);
            duration = tf.js.GetFloatNumberInRange(duration, minAniSpeed, maxAniSpeed, tf.consts.defaultMapAnimatedCenterDurationMillis);
            var center = getCenter();
            startAnimation(function (request) {
                var nextStep;
                if (request.step == 0) {
                    nextStep = {
                        duration: duration,
                        center: [longitude, latitude],
                        notifyListeners: !!notifyListeners
                    };
                    if (tf.js.GetFunctionOrNull(easing)) { nextStep.easing = easing; }
                }
                else if (!!callBack) { notifyAnimationEnd(callBack); callBack = null; }
                return nextStep;
            }, theThis);
        }
    }
    function animatedSetCenterIfDestVisible(pointCoords, speed) {
        if (getAreMapCoordsVisible(pointCoords)) { animatedSetCenter(pointCoords, speed, null, false); } else { setCenter(pointCoords); }
    }
    var hasInteractions = true;
    var hadZoomControl = false;
    function getHasInteractions() { return hasInteractions; }
    function setHasInteractions(bool) {
        bool = !!bool;
        if (bool != hasInteractions) {
            if (bool) { addInteractions(); }
            else { removeInteractions(); }
        }
    }
    function removeInteractions() {
        if (hasInteractions) {
            olInteractions.clear();
            if (hadZoomControl = mapControls[tf.consts.panelNameZoom].isOn) { showPanel(tf.consts.panelNameZoom, false); }
            hasInteractions = false;
        }
    }
    function addInteractions() {
        if (!hasInteractions) {
            olInteractions.extend(olInteractionsCopy.getArray());
            if (hadZoomControl) { showPanel(tf.consts.panelNameZoom, true); }
            mapDrawInteraction.Restore();
            hadZoomControl = false;
            hasInteractions = true;
        }
    }
    var vidParamStr = null;
    function setVIDParamStr(vidParamStrSet) { vidParamStr = typeof vidParamStrSet === "string" && vidParamStrSet.length > 0 ? vidParamStrSet : null; }
    function getVIDParamStr() { return vidParamStr; }
    var passTroughString = null;
    function setTFPassThroughString(passThroughStringSet) {
        passTroughString = tf.js.GetNonEmptyString(passThroughStringSet, null);
        if (tf.js.GetIsNonEmptyString(passTroughString)) { if (passTroughString.charAt(0) != '&') { passTroughString = '&' + passTroughString; } }
    }
    function getTFPassTroughString() { return passTroughString; }
    var revGeocoder = null;
    function isUsingRevGeocoderOnMoveEnd() { return revGeocoder != null && revGeocoder.IsListeningToMoveEnd(); }
    function setUseRevGeocoderOnMoveEnd(bool) { if (revGeocoder) { revGeocoder.SetListenToMoveEnd(bool); } }
    var tDBPage = null;
    var geoCodeFlyer = null;
    function onEndGeoCodeFlyer(Lat, Lon, ErrorMsg, GeoCodeResult) {
        if (isUsingRevGeocoderOnMoveEnd()) {
            if (geoCodeFlyer == null || !geoCodeFlyer.DidMove()) { revGeocoder.TryShowGeocode(Lat, Lon, ErrorMsg, GeoCodeResult); }
            //revGeocoder.TryShowGeocode(Lat, Lon, ErrorMsg, GeoCodeResult);
        }
        else if (tf.js.GetIsNonEmptyString(ErrorMsg)) { showMessage(ErrorMsg); }
    }
    function flyToAddress(addressStr) {
        var tryToFly = true;
        if (geoCodeFlyer) {
            geoCodeFlyer.Cancel();
            if (tryToFly = geoCodeFlyer.WasCancelled() || geoCodeFlyer.HasCompleted()) { geoCodeFlyer = null; }
        }
        if (tryToFly) {
            if (tf.js.GetIsNonEmptyString(addressStr)) {
                geoCodeFlyer = new tf.map.aux.GeoCodeFlyer(theThis, onEndGeoCodeFlyer, addressStr);
                TGetLatLngByAddress(addressStr, geoCodeFlyer.DelayCallBack);
                //geoCodeFlyer.DelayCallBack(25.9, -80.5, "");
            }
        }
        return tryToFly;
    }
    function defaultMapOnClick(notification) { animatedSetCenter(notification.eventCoords); }
    var panOnClickListener = null;
    function AfterMapOnClickFlyEnds(lat, lon) { }
    function setUsePanOnClick(bool) {
        if ((bool = !!bool) != isUsingPanOnClick()) {
            if (bool) { panOnClickListener = allEventDispatchers.AddListener(tf.consts.mapClickEvent, defaultMapOnClick); }
            else { panOnClickListener.OnDelete(); panOnClickListener = null; }
        }
    }
    function isUsingPanOnClick() { return panOnClickListener != null; }
    function goDBByAddress(addressStr) { if (tDBPage) { tDBPage.GoDBByAddress(addressStr); } }
    function goDBByCoords(pointCoords) { if (tDBPage) { tDBPage.GoDBByCoords(pointCoords); } }
    function GoDBByCenterCoords() { if (tDBPage) { tDBPage.GoDBByCenterCoords(); } }
    var goDBOnDoubleClick = true;
    function setGoDBOnDoubleClick(bool) { goDBOnDoubleClick = !!bool; }
    function getGoDBOnDoubleClick() { return goDBOnDoubleClick; }
    function setAddressBarHelp(addressBarHelpStr) {
        if (addressPopup) {
            typeof addressBarHelpStr !== "string" && (addressBarHelpStr = "");
            addressPopup.SetAddressBarHelp(addressBarHelpStr);
        }
    }
    function setAddressBarText(addressBarText) {
        if (addressPopup) {
            typeof addressBarText !== "string" && (addressBarText = "");
            addressPopup.SetAddressBarText(addressBarText);
        }
    }
    function getAddressBarText() { return addressPopup ? addressPopup.GetAddressBarText() : ''; }
    function setRotationDeg(rotationDeg) { return setRotationRad(tf.units.DegreesToRadians(rotationDeg)); }
    function getRotationDeg() { return tf.units.RadiansToDegrees(getRotationRad()); }
    function setRotationRad(rotationRad) { olView.setRotation(tf.js.GetFloatNumber(rotationRad, 0)); }
    function getRotationRad() { return olView.getRotation(); }
    function doDownloadQuery(downloadExtent, utmExtent) {
        if (!!downloadExtent) {
            var passthroughParam = getTFPassTroughString();
            if (!passthroughParam) { passthroughParam = ''; }
            var strUrl =
                "http://vn4.cs.fiu.edu/cgi-bin/tfrectdisp.cgi?" +
                passthroughParam +
                "&dt=51306.25" +
                "&X1l=" + downloadExtent[0] +
                "&Y1l=" + downloadExtent[3] +
                "&X2l=" + downloadExtent[2] +
                "&Y2l=" + downloadExtent[1] +
                "&Source=best_available" +
                "&Res=" + getResolution() +
                "&Overlay=wcity";
            window.open(strUrl, "_blank");
        }
    }
    function onConfirmDownload() {
        var downloadExtent = mapDrawInteraction.GetMapExtent();
        var utmExtent = mapDrawInteraction.GetBoxExtent();
        if (downloadExtent) {
            doDownloadQuery(downloadExtent, utmExtent);
            cancelInteraction();
        }
        else {
            showMessage("<p/>First: Click/Touch to select a rectangular area.<p/>Then: Press the button to download.");
        }
    }
    function startInteraction(type, onEnd) { hideOpenControlPopups(); mapDrawInteraction.Start(type, onEnd); }
    function cancelInteraction() { mapDrawInteraction.Cancel(); }
    function cancelDownloadInteraction() { if (downloadPopup) { downloadPopup.Show(false); } }
    function startDownloadInteraction() {
        if (!downloadPopup) {
            downloadPopup = new tf.map.ui.DownloadBar(mapContainerAll, theThis,
                mapControls[tf.consts.panelNameDownload].control,
                cancelInteraction, onConfirmDownload, theThis);
        }
        downloadPopup.Show(true);
        startInteraction('box', cancelDownloadInteraction);
    }
    function cancelMeasureInteraction() { if (measurePopup) { measurePopup.Show(false); } }
    function privateOnChangeMeasureType() { cancelInteraction(); startMeasureInteraction(); }
    function startMeasureInteraction() {
        if (!measurePopup) {
            measurePopup = new tf.map.ui.MeasureBar(mapContainerAll, theThis,
                mapControls[tf.consts.panelNameMeasure].control,
                cancelInteraction, privateOnChangeMeasureType, theThis);
        }
        measurePopup.Show(true);
        startInteraction(measurePopup.GetIsMeasuringDistances() ? 'lines' : 'poly', cancelMeasureInteraction);
    }
    function createCenterMapButton(visibleBool) {
        mapCenterButton = new tf.ui.SvgGlyphBtn({ style: true, glyph: tf.styles.SvgGlyphBullsEye2Name, dim: "20em", noChangeOnHover: true });
        var mapCenterButtonElem = mapCenterButton.GetHTMLElement();
        tf.GetStyles().ApplySnapToCenterStyle(mapCenterButtonElem);
        mapContainerAll.appendChild(mapCenterButtonElem);
        mapCenterButtonElem.style.display = visibleBool ? 'block' : 'none';
        mapCenterButtonElem.style.pointerEvents = 'none';
        mapCenterButtonElem.style.position = 'absolute';
        mapCenterButtonElem.style.opacity = "0.30";
        styles.AddHorShadowStyle(mapCenterButton);
        styles.AddDefaultOpacityTransitionStyle(mapCenterButton);
        mapCenterButtonElem.style.zIndex = zIndex + 5;
    }
    function onNotifyFullScreen() {
        if (tf.browser.GetIsFullScreen()) {
            mapControls[tf.consts.panelNameFullscreen].control.ChangeTitle(getFullScreenLabelFull(), tf.consts.fullScreenToolTipFull);
        } else {
            mapControls[tf.consts.panelNameFullscreen].control.ChangeTitle(getFullScreenLabelNormal(), tf.consts.fullScreenToolTipNormal);
        }
        mergeWithBaseAndNotifyListeners(tf.consts.mapFullScreenEvent);
        onResize();
    }
    function onFullScreen() {
        if (!!containerAll) {
            if (!tf.browser.GetIsFullScreen()) {
                if (tf.dom.GetHTMLElementFrom(settings.fullScreenContainer)) {
                    tf.browser.RequestFullScreen(settings.fullScreenContainer);
                }
                else {
                    tf.browser.RequestFullScreen(document.body);
                }
            }
        }
    }
    function toggleMapFullScreen() {
        if (tf.browser.GetIsFullScreen()) { tf.browser.ExitFullScreen(); } else { theThis.FullScreen(); }
    }
    function getVisibleExtent() {
        return ol.extent.applyTransform(olView.calculateExtent(olMap.getSize()), ol.proj.getTransform(tf.consts.olSystem, tf.consts.tmSystem));
    }
    function setVisibleExtent(extent) {
        extent = tf.js.GetMapExtentFrom(extent);
        if (extent[0] != extent[2] && extent[1] != extent[3]) {
            var size = olMap.getSize();
            var mapW = size[0], mapH = size[1];
            if (mapW > 0 && mapH > 0) {
                var extentMidLon = extent[0] + (extent[2] - extent[0]) / 2;
                var extentMidLat = extent[1] + (extent[3] - extent[1]) / 2;
                var extentFeature = new tf.map.FeatureGeom({ type: "linestring", coordinates: [[extent[0], extentMidLat], [extent[2], extentMidLat]] });
                var extentWM = extentFeature.GetLength();
                extentFeature = new tf.map.FeatureGeom({ type: "linestring", coordinates: [[extentMidLon, extent[1]], [extentMidLon, extent[3]]] });
                var extentHM = extentFeature.GetLength();
                var res1 = extentWM / mapW, res2 = extentHM / mapH;
                var res = res1 > res2 ? res1 : res2 ;
                setResolution(res);
                setCenter([extentMidLon, extentMidLat]);
            }
        }
    }
    function getAreMapCoordsInExtent(pointCoords, extent) {
        var lat = tf.js.GetLatitudeFrom(pointCoords[1]);
        var lon = tf.js.GetLongitudeFrom(pointCoords[0]);
        var isIn = extent[1] <= lat && extent[3] >= lat && extent[0] <= lon && extent[2] >= lon;
        return isIn;
    }
    function getAreMapCoordsVisible(pointCoords) { return getAreMapCoordsInExtent(pointCoords, getVisibleExtent()); }
    function getPixelCoordsAreVisible(xPixel, yPixel) {
        var pointCoords = pixelToMapCoords(xPixel, yPixel);
        return getAreMapCoordsVisible(pointCoords);
    }
    function render() { return !!olMap ? olMap.render() : false; }
    function renderNow() { return !!olMap ? olMap.renderSync() : false; }
    function eventIsOnMap(e) {
        //tf.GetDebug().LogIfTest(e.browserEvent.target.className);
        return e.originalEvent.target.className == "ol-unselectable"
    }
    var lastHoveredFeature = null;
    function privateNotifyDelFeatures(arg) {
        if (!!arg) {
            if (arg instanceof ol.Feature) {
                var mapFeature = arg.getProperties().mapFeature;
                if (mapFeature === lastHoveredFeature) {
                    hoverIntoFeature(null, 0, 0);
                }
            }
            else if (typeof arg === "object") {
                for (var i in arg) {
                    var thisArg = arg[i];
                    if (thisArg instanceof ol.Feature) {
                        var mapFeature = thisArg.getProperties().mapFeature;
                        if (mapFeature === lastHoveredFeature) {
                            hoverIntoFeature(null, 0, 0);
                            break;
                        }
                    }
                }
            }
        }
    }
    function hoverOutOfLastHoveredFeature(nextHoverFeature, lat, lon) {
        if (!!lastHoveredFeature) {
            var notification = mergeWithBaseNotification(tf.js.ShallowMerge(makeKeyedFeatureLatLonNotification(lastHoveredFeature, lat, lon, undefined), {
                nextKeyedFeature: getKeyedFeatureFromMapFeature(nextHoverFeature), nextFeature: nextHoverFeature, isInHover: false
            }));
            lastHoveredFeature.onHoverInOut(notification);
            doNotifyListeners(tf.consts.mapFeatureHoverInOutEvent, notification);
            lastHoveredFeature = null;
        }
    }
    function makeFeatureClusterNotification(featureCluster) { return !!featureCluster ? { featureCluster: featureCluster } : undefined; }
    function hoverIntoFeature(mapFeature, lat, lon, featureCluster) {
        if (mapFeature != lastHoveredFeature) {
            hoverOutOfLastHoveredFeature(mapFeature, lat, lon);
            if (!!mapFeature) {
                var notification = mergeWithBaseNotification(tf.js.ShallowMerge(makeKeyedFeatureLatLonNotification(mapFeature, lat, lon, featureCluster), {
                    prevKeyedFeature: getKeyedFeatureFromMapFeature(lastHoveredFeature), prevFeature: lastHoveredFeature, isInHover: true
                }));
                mapFeature.onHoverInOut(notification);
                doNotifyListeners(tf.consts.mapFeatureHoverInOutEvent, notification);
            }
            lastHoveredFeature = mapFeature;
        }
    }
    function translatePixelCoords(pixelCoords) {
        var coords;
        
        if (!!pixelCoords) {
            if (!(coords = (!!pixelTranslateCallBack ? pixelTranslateCallBack(pixelCoords) : pixelCoords.slice(0)))) { coords = pixelCoords; }
        }
        else { coords = [0,0]; }
        return coords;
    }
    function createFeatureCluster(features) {
        var cluster;
        if (!!features && features.length > 1) {
            cluster = [];
            for (var i = 0, len = features.length ; i < len ; ++i) {
                var feature = features[i], props = feature.getProperties(), mapFeature = props.mapFeature;
                if (mapFeature) {
                    //cluster.push(makeKeyedFeatureNotification(mapFeature));
                    cluster.push(mapFeature);
                }
            }
        }
        return cluster;
    }
    function onPointerMove(e) {
        if (eventIsOnMap(e)) {
            var hitMapFeature = false;
            var mapFeatures = [];
            var pixelCoords = translatePixelCoords(e.pixel);
            var featureCluster;
            olMap.forEachFeatureAtPixel(pixelCoords, function (feature, layer) {
                if (feature) {
                    var features = feature.get('features');
                    if (features) {
                        feature = features[0];
                        featureCluster = createFeatureCluster(features);
                    }
                    if (feature) {
                        var props = feature.getProperties();
                        var mapFeature = props.mapFeature;
                        if (mapFeature) {
                            mapFeatures.push(mapFeature);
                            if (firstFeatureOnly) { return true; }
                        }
                        else if (props.markerName == infoFeatureName) {
                            hitMapFeature = true;
                            return true;
                        }
                    }
                }
            });
            if (!hitMapFeature) {
                var nMapFeatures = mapFeatures.length;
                var actualCoordinate = tf.units.OL2TM(e.coordinate);
                var coordinate = actualPixelToMapCoords(pixelCoords);
                var lat = coordinate[1], lon = coordinate[0];
                var rollOverHandled = false;
                for (var i in mapFeatures) {
                    var mapFeature = mapFeatures[i];
                    var notification = mergeWithBaseNotification(makeKeyedFeatureLatLonNotification(mapFeature, lat, lon, featureCluster));
                    hoverIntoFeature(mapFeature, lat, lon, featureCluster);
                    rollOverHandled = mapFeature.onMouseMove(notification);
                    if (!rollOverHandled) { doNotifyListeners(tf.consts.mapFeatureMouseMoveEvent, notification); }
                    if (rollOverHandled || firstFeatureOnly) { break; }
                }
                if (nMapFeatures == 0) { hoverIntoFeature(null, lat, lon, featureCluster); }
                mergeWithBaseAndNotifyListeners(tf.consts.mapMouseMoveEvent,
                    tf.js.ShallowMerge(makeFeatureClusterNotification(featureCluster),
                    makePixelNotification(makeLatLonNotification(lat, lon, actualCoordinate), pixelCoords, e.pixel)));
            }
        }
    }
    function onPointerClick(e) {
        if (eventIsOnMap(e)) {
            if (!mapDrawInteraction.GetIsInteracting()) {
                var pixelCoords = translatePixelCoords(e.pixel);
                var actualCoordinate = tf.units.OL2TM(e.coordinate);
                var coordinate = actualPixelToMapCoords(pixelCoords);
                var lat = coordinate[1], lon = coordinate[0];
                var hitPrivateMapFeature = false;
                var mapFeatures = [];
                var featureCluster;
                olMap.forEachFeatureAtPixel(pixelCoords, function (feature, layer) {
                    var features = feature.get('features');
                    if (features) {
                        feature = features[0];
                        featureCluster = createFeatureCluster(features);
                    }
                    if (feature) {
                        var props = feature.getProperties();
                        if (!!props) {
                            var mapFeature = props.mapFeature;
                            if (!!mapFeature) { mapFeatures.push(mapFeature); }
                            else { var name = props.markerName; if (name == infoFeatureName) { hitPrivateMapFeature = true; toggleInfoWindowPin(); return true; } }
                        }
                    }
                }, theThis);
                if (!hitPrivateMapFeature) {
                    var nMapFeatures = mapFeatures.length;
                    var clickHandled = false;
                    var clusterNotification = makeFeatureClusterNotification(featureCluster);
                    for (var i in mapFeatures) {
                        var mapFeature = mapFeatures[i];
                        var notification = mergeWithBaseNotification(makeKeyedFeatureLatLonNotification(mapFeature, lat, lon, featureCluster));
                        clickHandled = mapFeature.onClick(notification);
                        if (!clickHandled) { doNotifyListeners(tf.consts.mapFeatureClickEvent, notification); }
                        if (clickHandled || firstFeatureOnly) { break; }
                    }
                    if (nMapFeatures == 0) {
                        mergeWithBaseAndNotifyListeners(tf.consts.mapClickEvent, tf.js.ShallowMerge(
                            tf.js.ShallowMerge(clusterNotification,
                            makePixelNotification(makeLatLonNotification(lat, lon, actualCoordinate), pixelCoords, e.pixel), { mapEvent: e })));
                    }
                }
            }
        }
    }
    function onPointerDoubleClick(e) {
        if (eventIsOnMap(e)) {
            if (!mapDrawInteraction.GetIsInteracting()) {
                var pixelCoords = translatePixelCoords(e.pixel);
                var actualCoordinate = tf.units.OL2TM(e.coordinate);
                var coordinate = actualPixelToMapCoords(pixelCoords);
                var lat = coordinate[1], lon = coordinate[0];
                var hitPrivateMapFeature = false;
                var mapFeatures = [];
                var featureCluster;
                olMap.forEachFeatureAtPixel(pixelCoords, function (feature, layer) {
                    var features = feature.get('features');
                    if (features) {
                        feature = features[0];
                        featureCluster = createFeatureCluster(features);
                    }
                    if (feature) {
                        var props = feature.getProperties();
                        if (!!props) {
                            var mapFeature = props.mapFeature;
                            if (!!mapFeature) { mapFeatures.push(mapFeature); }
                            else { var name = props.markerName; if (name == infoFeatureName) { hitPrivateMapFeature = true; toggleInfoWindowPin(); return true; } }
                        }
                    }
                }, theThis);
                if (!hitPrivateMapFeature) {
                    var nMapFeatures = mapFeatures.length;
                    var clickHandled = false;
                    for (var i in mapFeatures) {
                        var mapFeature = mapFeatures[i];
                        var notification = mergeWithBaseNotification(makeKeyedFeatureLatLonNotification(mapFeature, lat, lon, featureCluster));
                        clickHandled = mapFeature.onDoubleClick(notification);
                        if (!clickHandled) { doNotifyListeners(tf.consts.mapFeatureDblClickEvent, notification); }
                        if (clickHandled || firstFeatureOnly) { break; }
                    }
                    if (nMapFeatures == 0) {
                        if (goDBOnDoubleClick) { goDBByCoords(coordinate); } else {
                            mergeWithBaseAndNotifyListeners(tf.consts.mapDblClickEvent,
                                tf.js.ShallowMerge(makeFeatureClusterNotification(featureCluster),
                                makePixelNotification(makeLatLonNotification(lat, lon, actualCoordinate), pixelCoords, e.pixel)));
                        }
                    }
                }
            }
        }
    }
    function onMoveEnd(e) {
        var center = getCenter();
        var lat = center.Latitude, lon = center.Longitude;
        //hideOpenControlPopups();
        if (currentLat != lat && currentLon != lon) {
            currentLat = lat; currentLon = lon;
        }
        if (!isAnimating) {
            onDelayMoveEnd.DelayCallBack();
        }
    }
    function setMapEngine(mapEngineSet) {
        mapEngine = tf.map.GetMapEngineFrom(mapEngineSet);
        getVectorTileFunction = (useMapNik2 = (mapEngine !== tf.consts.mapnikEngine)) ? getMapnik2VectorTile : getMapnik1VectorTile;
    }
    //function getMapPinImgSrc() { return tf.platform.MakePlatformPath("image/mappin.png"); }
    function getKeyedFeatureFromMapFeature(mapFeature) {
        return !!mapFeature && !!tf.js.GetFunctionOrNull(mapFeature.GetKeyedFeature) ? mapFeature.GetKeyedFeature() : null;
    }
    function getMapFeatureFromMapFeature(mapFeature) {
        return !!mapFeature && !!tf.js.GetFunctionOrNull(mapFeature.GetMapFeature) ? mapFeature.GetMapFeature() : null;
    }
    function mergeWithBaseNotification(notification) { return tf.js.ShallowMerge(notification, baseNotification); }
    function doNotifyListeners(eventName, notification) {
        if (notification.sender !== theThis) {
            tf.GetDebug().LogIfTest("map: notify without sender");
        }
        allEventDispatchers.Notify(eventName, tf.js.ShallowMerge(/*mergeWithBaseNotification(*/notification/*)*/, { eventName: eventName }));
    }
    function mergeWithBaseAndNotifyListeners(eventName, notification) { return doNotifyListeners(eventName, mergeWithBaseNotification(notification)); }
    function makeLatLonNotification(lat, lon, actualCoords) {
        var eventCoords = [lon, lat]; if (actualCoords == undefined) { actualCoords = eventCoords; }
        return { eventCoords: eventCoords, actualEventCoords: actualCoords };
    }
    function makeCurrentLatLonNotification() { return makeLatLonNotification(currentLat, currentLon); }
    function makePixelNotification(notification, pixel, actualPixel) { return tf.js.ShallowMerge(notification, { pixelCoords: pixel, actualPixelCoords: actualPixel }); }
    function makeKeyedFeatureNotification(mapFeature) {
        var mapFeatureUse = getMapFeatureFromMapFeature(mapFeature);
        if (!mapFeatureUse) { mapFeatureUse = mapFeature; }
        return { keyedFeature: getKeyedFeatureFromMapFeature(mapFeatureUse), mapFeature: mapFeatureUse, styleName: mapFeatureUse.getStyleName() };
    }
    function makeKeyedFeatureLatLonNotification(mapFeature, lat, lon, featureCluster) {
        return tf.js.ShallowMerge(makeKeyedFeatureNotification(mapFeature), makeLatLonNotification(lat, lon), makeFeatureClusterNotification(featureCluster));
    }
    function addFeatureLayers(multiLayerSettings) {
        var layers = {};
        if (tf.js.GetIsValidObject(multiLayerSettings)) {
            for (var i in multiLayerSettings) {
                var thisLayerSettings = multiLayerSettings[i];
                if (tf.js.GetIsValidObject(thisLayerSettings)) {
                    var thisLayer = addFeatureLayer(thisLayerSettings);
                    if (!!thisLayer) { layers[thisLayer.GetName()] = thisLayer; }
                }
            }
        }
        return layers;
    }
    function showMapCenter(show) {
        if (isShowingMapCenter != (show = !!show)) {
            //styles.ChangeOpacityVisibilityClass(mapCenterButton, isShowingMapCenter = show);
            tf.dom.GetHTMLElementFrom(mapCenterButton).style.display = !!(isShowingMapCenter = show) ? 'block' : 'none';
        }
    }
    function checkNotifyListeners() {
        if (levelChanged) { onNotifyZoomEnd(); }
        if (resChanged) { onNotifyResolutionEnd(); }
        if (posChanged) { onNotifyMoveEnd(); }
    }
    function preRender(map, frameState) {
        if (isAnimating) {
            if (frameState.time <= animationSpecs.start + animationSpecs.duration) {
                if (frameState.time >= animationSpecs.start) {
                    //var easing = ol.easing.inAndOut;
                    //var easing = ol.easing.linear;
                    var easing = animationSpecs.easing;
                    var delta = 1 - easing((frameState.time - animationSpecs.start) / animationSpecs.duration);
                    if (animationSpecs.sourceCenter) {
                        var deltaX = animationSpecs.sourceCenter[0] - animationSpecs.endCenter[0];
                        var deltaY = animationSpecs.sourceCenter[1] - animationSpecs.endCenter[1];
                        frameState.viewState.center[0] = animationSpecs.endCenter[0] + delta * deltaX;
                        frameState.viewState.center[1] = animationSpecs.endCenter[1] + delta * deltaY;
                        var center = tf.units.OL2TM(frameState.viewState.center);
                        var newLon = center[0], newLat = center[1];
                        posChanged = newLon != currentLon || newLat != currentLat;
                        currentLat = newLat;
                        currentLon = newLon;
                    }
                    if (animationSpecs.sourceRes !== undefined) {
                        var deltaResolution = animationSpecs.sourceRes - animationSpecs.endRes;
                        var newRes;
                        var newLevel = tf.units.GetLevelByResolution(frameState.viewState.resolution = newRes = animationSpecs.endRes + delta * deltaResolution)
                        resChanged = newRes != currentRes;
                        levelChanged = newLevel != currentLevel;
                        currentLevel = newLevel;
                        currentRes = newRes;
                    }
                    if (animationSpecs.sourceRotation !== undefined) {
                        var deltaRotation = tf.units.GetShortestArcBetweenAngles(animationSpecs.endRotation, animationSpecs.sourceRotation)
                        frameState.viewState.rotation = animationSpecs.endRotation + delta * deltaRotation;
                    }
                    if (animationSpecs.notifyListeners) { checkNotifyListeners(); }
                    else { if (resChanged || levelChanged) { baseLayersPopup.OnResolutionChange(currentRes); } }
                }
            }
            else { getNextAnimationStep(); }
            if (isAnimating) {
                frameState.animate = true;
                //frameState.viewHints[0/*ol.ViewHint.ANIMATING*/] += 1;    // seems to prevent features from being drawn during animation
            }
            else { checkNotifyListeners(); }
            return isAnimating;
        }
        else {
            var center = tf.units.OL2TM(frameState.viewState.center);
            currentLat = center[1];
            currentLon = center[0];
            currentRes = frameState.viewState.resolution;
        }
        //return false;
        return isAnimating;
        //return true;
    }
    this.GetInstantCenter = function () { return [currentLon, currentLat]; }
    //this.GetInstantRotationRad = function () { }
    this.GetInstantResolution = function () { return currentRes; }
    function callAnimationCallBack() {
        return !!animationCallBack ? animationCallBack.call(animationOptionalScope, { sender: theThis, step: animationStep++ }) : null;
    }
    function endAnimation() {
        if (isAnimating) {
            if (!!animationCallBack) { animationStep = -1; callAnimationCallBack(); animationCallBack = null; }
            isAnimating = false;
            render();
        }
    }
    function getNextAnimationStep() {
        if (isAnimating) {
            var nextStep = callAnimationCallBack();
            if (tf.js.GetIsValidObject(nextStep)) {
                var nextCenter = nextStep.center !== undefined ? tf.js.GetMapCoordsFrom(nextStep.center) : undefined;
                var nextRes = nextStep.resolution !== undefined ? nextStep.resolution : undefined;
                var nextRotation = nextStep.rotation !== undefined ? nextStep.rotation : undefined;
                var duration = nextStep.duration !== undefined ? nextStep.duration : 1000;
                var notifyListeners = nextStep.notifyListeners !== undefined ? !!nextStep.notifyListeners : false;
                var easing = tf.js.GetFunctionOrNull(nextStep.easing) ? nextStep.easing : tf.units.EaseInAndOut;
                animationSpecs = {
                    notifyListeners: notifyListeners,
                    sourceRes: nextRes !== undefined ? getResolution() : undefined,
                    sourceCenter: nextCenter !== undefined ? getOLViewCenter() : undefined,
                    sourceRotation: nextRotation !== undefined ? getRotationRad() : undefined,
                    endRes: nextRes,
                    endCenter: nextCenter !== undefined ? tf.units.TM2OL(nextCenter) : undefined,
                    endRotation: nextRotation !== undefined ? nextRotation : undefined,
                    duration: duration,
                    easing: easing,
                    start: Date.now()
                };
                if (nextCenter != undefined) { setCenter(nextCenter); }
                if (nextRes !== undefined) { setResolution(nextRes); }
                if (nextRotation !== undefined) { setRotationRad(nextRotation); }
            }
            else { endAnimation(); }
        }
    }
    function startAnimation(animationCallBackSet, animationOptionalScopeSet) {
        var wasAnimating = isAnimating;
        endAnimation();
        if (!!(animationCallBack = tf.js.GetFunctionOrNull(animationCallBackSet))) {
            if (!wasAnimating) { olMap.beforeRender(preRender); }
            animationStep = 0;
            animationOptionalScope = animationOptionalScopeSet;
            isAnimating = true;
            getNextAnimationStep();
        }
    }
    var vectorContext = null, frameState = null, lastComposeEventName;
    function continueAnimation() { if (!!frameState) { frameState.animate = true; } }
    function showFeatureImmediately(mapFeature) {
        if (mapFeature instanceof tf.map.Feature) {
            if (!!vectorContext) {
                var APIStyle = mapFeature.getAPIStyle();
                for (var i in APIStyle) { vectorContext.drawFeature(mapFeature.getAPIFeature(), APIStyle[i]); }
            }
        }
    }
    this.onComposeEvent = function (eventName, event) { return onComposeEvent(eventName, event, false); }
    function onComposeEvent(eventName, event, isSelfEvent) {
        lastComposeEventName = eventName;
        vectorContext = event.vectorContext
        frameState = event.frameState;
        mergeWithBaseAndNotifyListeners(eventName, { showFeatureImmediately: showFeatureImmediately, continueAnimation: continueAnimation, canvas: event.context.canvas });
        vectorContext = null; frameState = null;
    }
    function initialize() {
        styles = tf.GetStyles();
        subStyles = styles.GetSubStyles();
        showLocInfoWindowOnMoveEndByDefault = true; 
        showLocInfoWindowOnMoveEnd = false;
        isAnimating = false;
        currentSource = "best_available";
        if (settings.messageTimeout !== undefined) { setMessageTimeout(settings.messageTimeout); }
        if (tf.js.GetIsNonEmptyString(settings.vidParam)) { setVIDParamStr(settings.vidParam); }
        if (tf.js.GetIsNonEmptyString(settings.passThroughString)) { setTFPassThroughString(settings.passThroughString); }
        levelChanged = resChanged = posChanged = false;
        mapButtonDimEmStr = subStyles.mapButtonDimEmNumber + "em";
        baseNotification = { sender: theThis };
        layersByName = {};
        settings = tf.js.GetValidObjectFrom(settings);
        id = tf.GetGlobalCounter().GetNext() + '';
        //mapNikDebug = tf.GetDebug();
        allEventDispatchers = new tf.events.MultiEventNotifier({ eventNames: tf.consts.allMapEventNames });
        setMapEngine(settings.mapEngine);
        if (tf.js.GetIsNonEmptyString(settings.mapLayerSourceURL)) { setMapLayerSource(settings.mapLayerSourceURL, settings.mapLayerSourceHybridModeOpacity); }
        createDivs(settings.container);
        var bkImgStr = tf.platform.MakePlatformPath("image/mapBack.png");
        mapContainerAll.style.backgroundImage = "url('" + bkImgStr + "')";
        onDelayMoveEnd = new tf.events.DelayedCallBack(500, onNotifyMoveEnd, theThis);
        onDelayZoomEnd = new tf.events.DelayedCallBack(500, onNotifyZoomEnd, theThis);
        onDelayResEnd = new tf.events.DelayedCallBack(500, onNotifyResolutionEnd, theThis);
        new tf.events.DOMFullScreenChangeListener({ callBack: onNotifyFullScreen, optionalScope: theThis });
        setSource(settings.mapAerialSource);
        createOLViewAndMap();
        setMapType(settings.mapType);
        createMapControls();
        createMapPopups();
        var center = tf.js.GetMapCoordsFrom(settings.center);
        var lon = tf.js.GetLongitudeFrom(center[0]);
        var lat = tf.js.GetLatitudeFrom(center[1]);
        if (settings.resolution !== undefined) {
            var res = tf.js.GetFloatNumber(settings.resolution, tf.units.GetResolutionByLevel(tf.consts.defaultLevel));
            //panTo(lat, lon);
            setCenter([lon, lat]);
            setResolution(res);
        }
        else {
            var level = tf.js.GetLevelFrom(settings.level);
            setCenterAndLevel([lon, lat], level);
            //centerTo(lat, lon, level);
        }
        createCenterMapButton(tf.js.GetBoolFromValue(settings.showMapCenter, true));
        mapDrawInteraction = new tf.map.aux.MapDrawInteraction(theThis, olMap, olSourceVector);
        //olMap.beforeRender(preRender);
        olMap.on("click", function (e) { /*if (eventIsOnMap(e)) { }*/ }, theThis);
        olMap.on("moveend", onMoveEnd, theThis);
        olMap.on("pointermove", onPointerMove, theThis);
        olMap.on("singleclick", onPointerClick, theThis);
        olMap.on("dblclick", onPointerDoubleClick, theThis);
        olMap.on('change:size', function (event) { checkSizePopups(); mergeWithBaseAndNotifyListeners(tf.consts.mapResizedEvent); }, theThis);
        olMap.on('precompose', function (event) {
            mapCanvas = event.context.canvas;
            onComposeEvent(tf.consts.mapPreComposeEvent, event, true);
        }, theThis);
        olMap.on('postcompose', function (event) {
            mapCanvas = event.context.canvas;
            onComposeEvent(tf.consts.mapPostComposeEvent, event, true);
        }, theThis);
        olMap.on('postrender', function (event) {
            mergeWithBaseAndNotifyListeners(tf.consts.mapPostRenderEvent, { event: event, canvas: mapCanvas });
        }, theThis);
        if (tf.js.GetIsValidObject(settings.viewSettings)) { setView(settings.viewSettings); } else { hookUpOLViewEvents(); }
        tDBPage = new tf.map.aux.GoDBPage(theThis);
        setTimeout(hookOverviewMapClick, 500);
        if (tf.js.GetIsNonEmptyString(settings.addressBarText)) { setAddressBarText(settings.addressBarText); }
        if (tf.js.GetIsNonEmptyString(settings.addressBarHelp)) { setAddressBarHelp(settings.addressBarHelp); }
        if (tf.js.GetIsNonEmptyString(settings.panels)) { showPanels(settings.panels); }
        else { 
            showPanel(tf.consts.panelNameMapRotate, true); 
            showPanel(tf.consts.panelNameMapScale, true); 
        }
        revGeocoder = new tf.map.aux.RevGeocoder(theThis, updateLocInfoWindow, locInfoWindowPopup);
        if (showLocInfoWindowOnMoveEndByDefault && isPanelShowing(tf.consts.panelNameMapLocation)) {
            showLocInfoWindowOnMoveEnd = true;
        }
        setLocInfoWindowShow();
        if (tf.js.GetIsBoolean(settings.panOnClick)) { setUsePanOnClick(settings.panOnClick); }
        if (tf.js.GetIsBoolean(settings.goDBOnDoubleClick)) { setGoDBOnDoubleClick(settings.goDBOnDoubleClick); }
        if (tf.js.GetIsNonEmptyString(settings.legendH)) { setTimeout(function () { setLegend(settings.legendH, settings.legendM); }, 500); }
        //if (tf.js.GetIsNonEmptyString(settings.legendH)) { setLegend(settings.legendH, settings.legendM); }
    }
    (function actualConstructor(theMapThis) { theThis = theMapThis; initialize(); })(this);
};
tf.map.RenderMap = function (settings) {
    var theThis, map, olMap, mapDiv, mapDivHTML, mapCanvas, resizeListener, viewChangeListener, xScale, yScale;
    this.GetCanvas = function () { return mapCanvas; }
    //this.Render = function () { if (!isDeleted()) { olMap.render(); }}
    this.OnDelete = function () { return onDelete(); }
    this.IsDelete = function () { return isDeleted(); }
    function isDeleted() { return map == undefined; }
    function onDelete() {
        if (!isDeleted()) {
            if (!!resizeListener) { resizeListener.OnDelete(); }
            if (!!viewChangeListener) { viewChangeListener.OnDelete(); }
            if (!!olMap) { olMap.setLayerGroup(null); }
            if (!!mapDiv) { mapDiv.OnDelete(); }
            viewChangeListener = resizeListener = map = olMap = mapDiv = mapCanvas = mapDivHTML = undefined;
        }
    }
    function updateSize() {
        var size = map.GetPixelSize();
        var width = size[0] * xScale;
        var height = size[1] * yScale;
        mapDivHTML.style.width = width + 'px';
        mapDivHTML.style.height = height + 'px';
        olMap.setSize([width, height]);
    }
    function initialize() {
        if ((tf.js.GetIsValidObject(settings)) && !!tf.js.GetMapFrom(settings.map)) {
            var styles = tf.GetStyles();
            map = tf.js.GetMapFrom(settings.map);
            if (tf.js.GetIsArrayWithMinLength(settings.scale, 2)) {
                xScale = tf.js.GetFloatNumberInRange(settings.scale[0], 0.1, 10, 1);
                yScale = tf.js.GetFloatNumberInRange(settings.scale[1], 0.1, 10, 1);
            }
            else {
                xScale = yScale = 1;
            }
            mapDiv = new tf.dom.Div({ cssClass: styles.mapSubContainerClass });
            mapDivHTML = mapDiv.GetHTMLElement();
            mapDivHTML.style.position = "absolute";
            mapDivHTML.style.left = mapDivHTML.style.top = "-99999px";
            //mapDivHTML.style.opacity = 0;
            document.body.appendChild(mapDivHTML);
            olMap = new ol.Map ({
                loadTilesWhileAnimating: true,
                loadTilesWhileInteracting: true,
                renderer: 'canvas',
                target: mapDivHTML,
                view: map.getAPIView(),
                controls: undefined,
                interactions: undefined
            });
            olMap.on('postcompose', function (event) {
                mapCanvas = event.context.canvas;
                map.onComposeEvent(tf.consts.mapPostComposeEvent, event);
                //event.frameState.animate = true;
            });
            olMap.setLayerGroup(map.getAPIMap().getLayerGroup());
            viewChangeListener = map.AddListener(tf.consts.mapViewSettingsChangedEvent, function (notification) {
                olMap.setView(map.getAPIView());
            });
            resizeListener = map.AddListener(tf.consts.mapResizedEvent, function (notification) { updateSize(); });
            updateSize();
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/*tf.map.MapContainer = function (settings) {
    var theThis, map, mapDiv, mapDivHTML, resizeListener, xScale, yScale, isActive;
    this.SetActive = function (bool) { return setActive(bool); }
    this.IsActive = function () { return isActive }
    function setActive(bool) {
        if (isActive != (bool = !!bool)) {
            if (isActive = bool) {
                map.SetTarget(mapDivHTML);
            }
            else {
                map.RestoreTarget();
            }
            map.OnResize();
        }
    }
    this.OnDelete = function () { return onDelete(); }
    this.IsDelete = function () { return isDeleted(); }
    function isDeleted() { return map == undefined; }
    function onDelete() {
        if (!isDeleted()) {
            setActive(false);
            if (!!resizeListener) { resizeListener.OnDelete(); }
            if (!!mapDiv) {
                document.body.removeChild(mapDivHTML)
                mapDiv.OnDelete();
            }
            resizeListener = map = mapDiv = mapDivHTML = undefined;
        }
    }
    function updateSize() {
        if (!isActive) {
            var size = map.GetPixelSize();
            var width = size[0] * xScale;
            var height = size[1] * yScale;
            mapDivHTML.style.width = width + 'px';
            mapDivHTML.style.height = height + 'px';
        }
        //if (isActive) { map.OnResize(); }
    }
    function initialize() {
        if ((tf.js.GetIsValidObject(settings)) && !!tf.js.GetMapFrom(settings.map)) {
            var styles = tf.GetStyles();
            map = tf.js.GetMapFrom(settings.map);
            if (tf.js.GetIsArrayWithMinLength(settings.scale, 2)) {
                xScale = tf.js.GetFloatNumberInRange(settings.scale[0], 0.1, 10, 1);
                yScale = tf.js.GetFloatNumberInRange(settings.scale[1], 0.1, 10, 1);
            }
            else { xScale = yScale = 1; }
            mapDiv = new tf.dom.Div({ cssClass: styles.mapSubContainerClass });
            mapDivHTML = mapDiv.GetHTMLElement();
            mapDivHTML.style.position = "absolute";
            mapDivHTML.style.left = mapDivHTML.style.top = "-9999px";
            document.body.appendChild(mapDivHTML);
            resizeListener = map.AddListener(tf.consts.mapResizedEvent, function (notification) { updateSize(); });
            updateSize();
            isActive = false;
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
*/
/**
 * class tf.map.aux.GeoCodeFlyer - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} theMap - parameter description?
 * @param {?} mapCallBack - parameter description?
 * @param {?} addressStr - parameter description?
*/
tf.map.aux.GeoCodeFlyer = function (theMap, mapCallBack, addressStr) {
    var targetLat = 0, targetLon = 0, targetLevel = 0;
    var errorMsg = "", geoCodeResult = "";
    var wasCancelled = false;
    var hasCompleted = false;
    var hasStarted = false;
    var didMove = false;
    var panDuration = 1250;
    /**
     * method tf.map.aux.GeoCodeFlyer.GetAddressStr - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
    */
    this.GetAddressStr = function () { return addressStr; }
    /**
     * method tf.map.aux.GeoCodeFlyer.HasStarted - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
    */
    this.HasStarted = function () { return hasStarted; }
    /**
     * method tf.map.aux.GeoCodeFlyer.HasCompleted - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
    */
    this.HasCompleted = function () { return hasCompleted; }
    /**
     * method tf.map.aux.GeoCodeFlyer.WasCancelled - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
    */
    this.WasCancelled = function () { return wasCancelled; }
    /**
     * method tf.map.aux.GeoCodeFlyer.IsFlying - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
    */
    this.IsFlying = function () { return hasStarted && !hasCompleted; }
    /**
     * method tf.map.aux.GeoCodeFlyer.DidMove - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
    */
    this.DidMove = function () { return didMove; }
    /**
     * method tf.map.aux.GeoCodeFlyer.Cancel - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
    */
    this.Cancel = function () { wasCancelled = !hasStarted; }
    /**
     * method tf.map.aux.GeoCodeFlyer.DelayCallBack - ?
     * @private
     * @function
     * @summary - method summary?
     * @description - method description?
     * @returns {?} - method returns?
     * @param {?} Lat - parameter description?
     * @param {?} Lon - parameter description?
     * @param {?} ErrorMsg - parameter description?
     * @param {?} GeoCodeResult - parameter description?
    */
    this.DelayCallBack = function (Lat, Lon, ErrorMsg, GeoCodeResult) {
        var a = arguments;
        if (!wasCancelled) {
            hasStarted = true;
            targetLat = Lat;
            targetLon = Lon;
            targetLevel = theMap.GetLevel();
            errorMsg = typeof ErrorMsg === "string" ? ErrorMsg.trim() : "";
            geoCodeResult = typeof GeoCodeResult === "string" ? GeoCodeResult.trim() : "";
            if (errorMsg.length == 0) {
                if (Lat == 0 || Lon == 0) { errorMsg = tf.consts.defaultGeocoderError; reportToCallBack(); }
                else if ((Lat >= -90) && (Lat <= 90) && (Lon >= -180) && (Lon <= 180)) {
                    var pointNW = [0, 0], pointSE = [0, 0];
                    if (theMap.IsSamePixelAsCenter([Lon, Lat])) { reportToCallBack(); }
                    else {
                        //theMap.HideOpenPopups();
                        var center = theMap.GetCenter();
                        var centerLat = center[1], centerLon = center[0];
                        var mapSize = theMap.GetPixelSize();
                        if (centerLat >= Lat) { pointNW[1] = centerLat; pointSE[1] = Lat; }
                        else { pointNW[1] = Lat; pointSE[1] = centerLat; }
                        if (centerLon <= Lon) { pointNW[0] = centerLon; pointSE[0] = Lon; }
                        else { pointNW[0] = Lon; pointSE[0] = centerLon; }
                        var zoomLevel = tf.units.GetBoundsZoomLevel(pointNW, pointSE, mapSize[0], mapSize[1]);
                        //tf.GetDebug().LogIfTest("flyTargetLevel: " + zoomLevel);
                        startGeoCodeFly();
                        if (targetLevel < zoomLevel) { theMap.AnimatedSetCenter([targetLon, targetLat], FlyEnded, panDuration, false); }
                        else { aniZoomOut(zoomLevel); }
                    }
                }
            }
            else { reportToCallBack(); }
        }
    }
    function FlyEnded(notification) {
        //tf.GetDebug().LogIfTest("fly ended");
        finishGeoCodeFly();
    }
    function aniZoomOut(zoomLevel) {
        //tf.GetDebug().LogIfTest("ani zoom out");
        theMap.AnimatedSetLevel(zoomLevel, aniFlyTo, tf.consts.defaultMapAnimatedDurationPerLevelMillis, false);
    }
    function aniFlyTo(notification) {
        //tf.GetDebug().LogIfTest("ani fly to");
        theMap.AnimatedSetCenter([targetLon, targetLat], aniZoomIn, panDuration, false);
    }
    function aniZoomIn(notification) {
        //tf.GetDebug().LogIfTest("ani zoom in");
        theMap.AnimatedSetLevel(targetLevel, FlyEnded, tf.consts.defaultMapAnimatedDurationPerLevelMillis, false);
    }
    function startGeoCodeFly() { didMove = true; theMap.EndAnimation(); theMap.SetHasInteractions(false); }
    function finishGeoCodeFly() { theMap.SetHasInteractions(true); reportToCallBack(); }
    function reportToCallBack() {
        hasCompleted = true;
        if (theMap && typeof mapCallBack == "function") { mapCallBack.call(theMap, targetLat, targetLon, errorMsg, geoCodeResult); }
    }
};
/**
 * class tf.map.aux.GeoCodeReporter - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} callBack - parameter description?
*/
tf.map.aux.GeoCodeReporter = function (callBack) {
/**
 * method tf.map.aux.GeoCodeReporter.DelayCallBack - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} Lat - parameter description?
 * @param {?} Lon - parameter description?
 * @param {?} ErrorMsg - parameter description?
 * @param {?} GeoCodeResult - parameter description?
*/
    this.DelayCallBack = function (Lat, Lon, ErrorMsg, GeoCodeResult) {
        if (typeof callBack === "function") { setTimeout(function (theCallBack) { theCallBack.call(null, Lat, Lon, ErrorMsg, GeoCodeResult); }(callBack), 10); }
    }
};
/**
 * class tf.map.aux.RevGeocoder - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} theMap - parameter description?
 * @param {?} updateLocInfoWindow - parameter description?
 * @param {?} locInfoWindowPopup - parameter description?
*/
tf.map.aux.RevGeocoder = function (theMap, updateLocInfoWindow, locInfoWindowPopup) {
    var theThis = null;
    var moveEndListener = null;
/**
 * method tf.map.aux.RevGeocoder.SetListenToMoveEnd - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} bool - parameter description?
*/
    this.SetListenToMoveEnd = function (bool) {
        if (theMap) {
            if ((bool = !!bool) != theThis.IsListeningToMoveEnd()) {
                if (bool) {
                    moveEndListener = theMap.AddListener(tf.consts.mapMoveEndEvent, onMoveEnd);
                    updateLocInfoWindow("Map Center", "Retrieving...", false);
                    var center = theMap.GetCenter();
                    theThis.LoadHTMLFeed(center.Latitude, center.Longitude);
                }
                else { moveEndListener.OnDelete(); moveEndListener = null; }
            }
        }
    }
/**
 * method tf.map.aux.RevGeocoder.IsListeningToMoveEnd - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.IsListeningToMoveEnd = function () { return moveEndListener != null; }
/**
 * method tf.map.aux.RevGeocoder.TryShowGeocode - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} targetLat - parameter description?
 * @param {?} targetLon - parameter description?
 * @param {?} errorMsg - parameter description?
 * @param {?} geoCodeResult - parameter description?
*/
    this.TryShowGeocode = function (targetLat, targetLon, errorMsg, geoCodeResult) {
        if (theMap) {
            if (typeof errorMsg === "string" && errorMsg.length > 0) { showHelp(errorMsg); }
            else { this.LoadHTMLFeed(targetLat, targetLon); }
        }
    }
    function showHelp(errorMsg) { if (theMap) { theMap.ShowMessage(errorMsg); } }
    var loadHTMLFeedObject = { ID: 0, Latitude: 0, Longitude: 0, Download: null };
    function onMoveEnd(notification) {
        //tf.GetDebug().LogIfTest("revgeocoder move end...");
        theThis.LoadHTMLFeed(notification.eventCoords[1], notification.eventCoords[0]);
    }
/**
 * method tf.map.aux.RevGeocoder.LoadHTMLFeed - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} latitude - parameter description?
 * @param {?} longitude - parameter description?
*/
    this.LoadHTMLFeed = function (latitude, longitude) {
        //tf.GetDebug().LogIfTest("loading feed...");
        //if (!theMap.GetIsAnimating()) {
            locInfoWindowPopup.ShowTitleColorInfo(false);
            latitude = tf.js.GetLatitudeFrom(latitude);
            longitude = tf.js.GetLongitudeFrom(longitude);
            var res = theMap.GetResolution();
            var strURL = "http://vn4.cs.fiu.edu/cgi-bin/reversegeocoder.cgi?Res=" + res + "&Lat=" + latitude + "&Long=" + longitude;
            var vidParam = theMap.GetVIDParamStr();
            if (vidParam) { strURL += "&vid=" + vidParam; }
            var passThrough = theMap.GetTFPassThroughString();
            if (passThrough) { strURL += passThrough; }
            if (loadHTMLFeedObject.Download) {
                loadHTMLFeedObject.Download.Cancel();
                loadHTMLFeedObject.Download = null;
            }
            loadHTMLFeedObject.ID++;
            loadHTMLFeedObject.Latitude = latitude;
            loadHTMLFeedObject.Longitude = longitude;
            loadHTMLFeedObject.Download = new tf.ajax.GetRequest({
                url: strURL, onDataLoaded: OnHTMLFeedLoaded, requestProps: loadHTMLFeedObject.ID, autoSend: true, useRedirect: false, overrideMimeType: "text/xml"
            });
        //}
    }
    function OnHTMLFeedLoaded(notification) {
        loadHTMLFeedObject.Download = null;
        if ((loadHTMLFeedObject.ID == notification.requestProps) && (notification.httpRequest.status == 200)) {
            var content = unescape(notification.httpRequest.responseText);
            content = content.replace(/\+/g, " ");
            content = content.replace(/<\/br>/g, "");
            content = content.replace(/<br>/g, " ");
            content = content.replace(/<p>/g, " ");
            //content = content.replace(/<p>/g, "<br>");
            content = content.replace(/<u>/g, "");
            content = content.replace(/<\/u>/g, "");
            content = content.replace(/<b>/g, "");
            content = content.replace(/<\/b>/g, "");
            content = content.replace(/<font color="#0000FF">/g, "");
            content = content.replace(/<\/font>/g, "");
            if (moveEndListener) { updateLocInfoWindow("Map Center", content, true); }
        }
    }
    (function construct(theThisSet) { theThis = theThisSet; })(this);
};
/**
 * class tf.map.aux.GoDBPage - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} theMap - parameter description?
*/
tf.map.aux.GoDBPage = function (theMap) {
    var theThis;
    function loadDBPage(pointCoords) {
        if (theMap) {
            var latitude = tf.js.GetLatitudeFrom(pointCoords[1]);
            var longitude = tf.js.GetLongitudeFrom(pointCoords[0]);
            if (latitude != 0 && longitude != 0) {
                var res = theMap.GetResolution();
                var strURL = "http://vn4.cs.fiu.edu/cgi-bin/gnis.cgi?Res=" + res + "&Lat=" + latitude + "&Long=" + longitude;
                var vidParam = theMap.GetVIDParamStr();
                var passthroughParam = theMap.GetTFPassThroughString();
                if (vidParam) { strURL += "&vid=" + vidParam; }
                if (passthroughParam) {
                    if (passthroughParam.charAt(0) == "&") { strURL += passthroughParam; }
                    else { strURL += "&" + passthroughParam; }
                }
                window.open(strURL, "_top");
            }
        }
    }
    function showHelp(errorMsg) { if (theMap) { theMap.ShowMessage(errorMsg); } }
    function geoCodeDB(Lat, Lon, ErrorMsg) {
        if (Lat == 0 || Lon == 0) {
            if (ErrorMsg == undefined || typeof ErrorMsg != "string" || ErrorMsg.length == 0) {
                ErrorMsg = tf.consts.defaultGeocoderError;
            }
            else {
                ErrorMsg = ErrorMsg.trim();
            }
            showHelp(ErrorMsg);
        }
        else if ((Lat >= -90) && (Lat <= 90) && (Lon >= -180) && (Lon <= 180)) { loadDBPage([Lon, Lat]); }
    }
/**
 * method tf.map.aux.GoDBPage.GoDBByAddress - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} addressStr - parameter description?
*/
    this.GoDBByAddress = function (addressStr) {
        if (theMap) {
            if (typeof addressStr === "string" && addressStr.length > 0) { TGetLatLngByAddress(addressStr, geoCodeDB); }
            else { theThis.GoDBByCenterCoords(); }
        }
    }
/**
 * method tf.map.aux.GoDBPage.GoDBByCoords - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} pointCoords - parameter description?
*/
    this.GoDBByCoords = function (pointCoords) { loadDBPage(pointCoords); }
/**
 * method tf.map.aux.GoDBPage.GoDBByCenterCoords - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GoDBByCenterCoords = function () { if (theMap) { theThis.GoDBByCoords(theMap.GetCenter()); } }
    function initialize() {  }
    (function actualConstructor(theMapThis) { theThis = theMapThis; initialize(); })(this);
};
/**
 * class tf.map.aux.MapDrawInteraction - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} tMap - parameter description?
 * @param {?} olMap - parameter description?
 * @param {?} olSourceVector - parameter description?
*/
tf.map.aux.MapDrawInteraction = function (tMap, olMap, olSourceVector) {
    var theThis = null;
    var styles = tf.GetStyles();
    var measureDecimals = 3;
    var olInteraction = null;
    var type = null;
    var geometryFunction = undefined;
    var maxPoints = undefined;
    var drawFeature = null;
    var pointFeatures = [];
    var boxExtent = null;
    var mapExtent = null;
    var areaOverlay = null;
    var interactionType = null;
    var savedGeom = null;
    var savedCoords = null;
    var savedStyle = null;
    var measureOverlays = [];
    var totalLenMeters = 0;
    var lastLenMeters = 0;
    var lastZIndexMeasure = 0;
    var onEndCallBack = null;
/**
 * method tf.map.aux.MapDrawInteraction.Start - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} typeSet - parameter description?
 * @param {?} onEndCallBackSet - parameter description?
*/
    this.Start = function (typeSet, onEndCallBackSet) {
        if (!!typeSet && typeof typeSet == "string") {
            interactionType = typeSet;
            switch (typeSet.toLowerCase()) {
                case 'box': return startBox(onEndCallBackSet); break;
                case 'poly': return startPoly(onEndCallBackSet); break;
                case 'lines': return startLines(onEndCallBackSet); break;
                default: interactionType = ''; break;
            }
        }
    }
/**
 * method tf.map.aux.MapDrawInteraction.GetLastIntereractionType - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetLastIntereractionType = function () { return interactionType; }
/**
 * method tf.map.aux.MapDrawInteraction.GetIsInteracting - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetIsInteracting = function () { return !!olInteraction; }
/**
 * method tf.map.aux.MapDrawInteraction.GetBoxExtent - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetBoxExtent = function () { return boxExtent; }
/**
 * method tf.map.aux.MapDrawInteraction.GetMapExtent - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetMapExtent = function () { return mapExtent; }
/**
 * method tf.map.aux.MapDrawInteraction.GetSavedGeom - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetSavedGeom = function () { return savedGeom; }
/**
 * method tf.map.aux.MapDrawInteraction.GetSavedCoords - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetSavedCoords = function () { return savedCoords; }
/**
 * method tf.map.aux.MapDrawInteraction.Restore - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.Restore = function () { return restore(); }
/**
 * method tf.map.aux.MapDrawInteraction.Cancel - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.Cancel = function () { return cancel(); }
    function drawBoxGeom(coords, geom) {
        if (!geom) { geom = new ol.geom.Polygon(null); }
        savedGeom = geom;
        var start = coords[0];
        var end = coords[1];
        var minX, maxX, minY, maxY;
        if (start[0] < end[0]) { minX = start[0]; maxX = end[0] } else { minX = end[0]; maxX = start[0]; }
        if (start[1] < end[1]) { minY = start[1]; maxY = end[1] } else { minY = end[1]; maxY = start[1]; }
        savedCoords[0] = [minX, minY];
        savedCoords[1] = [maxX, maxY];
        geom.setCoordinates([[[minX, minY], [minX, maxY], [maxX, maxY], [maxX, minY], [minX, minY]]]);
        return geom;
    }
    function boxDrawStart(e) { removeDrawFeature(); }
    function boxDrawEnd(e) {
        boxExtent = [savedCoords[0][0], savedCoords[0][1], savedCoords[1][0], savedCoords[1][1]];
        mapExtent = ol.extent.applyTransform(boxExtent, ol.proj.getTransform(tf.consts.olSystem, tf.consts.tmSystem));
        var centerMapLon = (mapExtent[0] + mapExtent[2]) / 2;
        var centerMapLat = (mapExtent[1] + mapExtent[3]) / 2;
        drawFeature = new ol.Feature({ geometry: savedGeom });
        //drawFeature.setStyle(dragBoxStyle);
        olSourceVector.addFeature(drawFeature);
        tMap.AnimatedSetCenterIfDestVisible([centerMapLon, centerMapLat]);
    }
    function startBox(onEndCallBackSet) {
        cancel();
        type = 'LineString';
        geometryFunction = drawBoxGeom;
        maxPoints = 2;
        return createAndAdd(boxDrawStart, boxDrawEnd, onEndCallBackSet);
    }
    function updateMeasures() {
        var nMeasures = measureOverlays.length;
        var nCoords = savedCoords.length;
        var lastSegmentStart = savedCoords[nCoords - 2];
        var lastSegmentEnd = savedCoords[nCoords - 1];
        var startX = lastSegmentStart[0], startY = lastSegmentStart[1];
        var endX = lastSegmentEnd[0], endY = lastSegmentEnd[1];
        var centerSegX = (startX + endX * 3) / 4;
        var centerSegY = (startY + endY * 3) / 4;
        var startMap = tf.units.OL2TM([startX, startY]);
        var endMap = tf.units.OL2TM([endX, endY]);
        var segLenMeters = tf.units.GetDistanceInMetersBetweenMapCoords(startMap, endMap);
        if (!isFinite(segLenMeters) || isNaN(segLenMeters)) { segLenMeters = 0; }
        var segKM = segLenMeters / 1000;
        var mksPartial, otherPartial;
        var useKM = (totalLenMeters + segLenMeters) > 1000 || segLenMeters > 1000;
        if (useKM) {
            mksPartial = segKM.toFixed(measureDecimals) + " km";
            otherPartial = (segKM * 0.62137).toFixed(measureDecimals) + " mi";
        }
        else {
            mksPartial = segLenMeters.toFixed(measureDecimals) + " m";
            otherPartial = tf.units.GetMetersToFeet(segLenMeters).toFixed(measureDecimals) + " ft";
        }
        var label;
        var isNewMeasure = nMeasures < nCoords - 1;
        if (totalLenMeters > 0) {
            var totalLenM = totalLenMeters + segLenMeters;
            var totalKM = totalLenM / 1000;
            var mksTotal, otherTotal;
            if (totalLenM > 1000) {
                mksTotal = totalKM.toFixed(measureDecimals) + " km";
                otherTotal = (totalKM * 0.62137).toFixed(measureDecimals) + " mi";
            }
            else {
                mksTotal = totalLenM.toFixed(measureDecimals) + " m";
                otherTotal = tf.units.GetMetersToFeet(totalLenM).toFixed(measureDecimals) + " ft";
            }
            label = mksTotal + ' [' + mksPartial + "]<br/><br/>" + otherTotal + ' [' + otherPartial + ']';
        }
        else {
            label = mksPartial + "<br/><br/>" + otherPartial;
        }
        var lastMeasureOverlay;
        if (isNewMeasure) {
            var geom = new ol.geom.Point([centerSegX, centerSegY]);
            var lastMeasureOverlay = createTextOverlay(label);
            measureOverlays.push(lastMeasureOverlay);
            olMap.addOverlay(lastMeasureOverlay.olOverlay);
            totalLenMeters += lastLenMeters;
        }
        else {
            lastMeasureOverlay = measureOverlays[nMeasures - 1];
        }
        lastLenMeters = segLenMeters;
        lastMeasureOverlay.container.innerHTML = label;
        //lastMeasureOverlay.olOverlay.setPosition([centerSegX, centerSegY]);
        lastMeasureOverlay.olOverlay.setPosition([endX, endY]);
    }
    function getCenter(geom) {
        var tx = 0, ty = 0;
        var coords = !!geom && !!geom.getCoordinates ? geom.getCoordinates() : null;
        var len = coords ? coords.length : 0;
        if (len > 0) {
            coords = coords[0];
            len = coords ? coords.length : 0;
            for (var i = 0 ; i < len ; i++) {
                tx += coords[i][0];
                ty += coords[i][1];
            }
            if (len > 0) {
                tx /= len;
                ty /= len;
            }
        }
        return [tx, ty];
    }
    function updateArea() {
        var area = !!savedGeom ? savedGeom.getArea() : 0;
        if (areaOverlay == null) {
            areaOverlay = createTextOverlay("");
            olMap.addOverlay(areaOverlay.olOverlay);
        }
        if (!!areaOverlay) {
            var center = getCenter(savedGeom);
            areaOverlay.olOverlay.setPosition(center);
            var areaSqFt = tf.units.GetSquareMetersToSquareFeet(area);
            var areaAcres = tf.units.GetAcresFromSquareMeters(area);
            areaOverlay.container.innerHTML = area.toFixed(measureDecimals) + " sq m<br/>" + areaSqFt.toFixed(measureDecimals) + " sq ft<br/>" + areaAcres.toFixed(measureDecimals) + " acres";
        }
    }
    function removeArea() {
        if (!!areaOverlay) {
            olMap.removeOverlay(areaOverlay.olOverlay);
            areaOverlay = null;
        }
    }
    function drawPolyGeom(coords, geom) {
        if (!savedGeom) {
            geom = new ol.geom.Polygon(null);
        }
        savedCoords = coords;
        savedGeom = geom;
        geom.setCoordinates(savedCoords);
        updateArea();
        return geom;
    }
    function polyDrawStart(e) {
        //removeArea();
        removePointFeatures();
        removeDrawFeature();
    }
    function polyDrawEnd(e) {
        drawFeature = new ol.Feature({ geometry: savedGeom });
        olSourceVector.addFeature(drawFeature);
        //createPointFeatures();
        savedCoords = null;
        savedGeom = null;
    }
    function startPoly(onEndCallBackSet) {
        cancel();
        type = 'Polygon';
        geometryFunction = drawPolyGeom;
        maxPoints = undefined;
        return createAndAdd(polyDrawStart, polyDrawEnd, onEndCallBackSet);
    }
    function drawLinesGeom(coords, geom) {
        if (!geom) {
            geom = new ol.geom.LineString(null);
            savedCoords[0] = coords[0];
            savedCoords[1] = coords[1];
        }
        else {
            var len = coords.length;
            var slen = savedCoords.length;
            var lastCoord = coords[len - 1];
            if (slen == len) {
                savedCoords[slen - 1] = lastCoord;
            } else {
                savedCoords.push(lastCoord);
            }
        }
        updateMeasures();
        savedGeom = geom;
        geom.setCoordinates(savedCoords);
        return geom;
    }
    function linesDrawStart(e) {
        removeArea();
        removeMeasures();
        removeDrawFeature();
        removePointFeatures();
    }
    function linesDrawEnd(e) {
        var geom = savedGeom;
        var coords = geom.getCoordinates();
        var nCoords = coords.length;
        if (nCoords > 1) {
            coords.splice(nCoords - 1, 1);
            geom.setCoordinates(coords);
            savedCoords = coords;
            var nOverlays = measureOverlays.length;
            if (nOverlays > 1) {
                olMap.removeOverlay(measureOverlays[nOverlays - 1].olOverlay);
                olMap.removeOverlay(measureOverlays[nOverlays - 2].olOverlay);
                measureOverlays.splice(nOverlays - 2, 2);
            }
        }
        drawFeature = new ol.Feature({ geometry: savedGeom });
        olSourceVector.addFeature(drawFeature);
        createPointFeatures();
        savedCoords = [];
        savedGeom = null;
    }
    function startLines(onEndCallBackSet) {
        cancel();
        type = 'LineString';
        geometryFunction = drawLinesGeom;
        maxPoints = undefined;
        return createAndAdd(linesDrawStart, linesDrawEnd, onEndCallBackSet);
    }
    function createAndAdd(onDrawStart, onDrawEnd, onEndCallBackSet) {
        savedCoords = [];
        savedGeom = null;
        onEndCallBack = typeof onEndCallBackSet === "function" ? onEndCallBackSet : null;
        olInteraction = new ol.interaction.Draw({ type: type, freehandCondition: ol.events.condition.never, geometryFunction: geometryFunction, maxPoints: maxPoints/*, source: olSourceVector*/ });
        olInteraction.on('drawstart', onDrawStart);
        olInteraction.on('drawend', onDrawEnd);
        olMap.addInteraction(olInteraction);
    }
    function restore() { if (olInteraction) { olMap.addInteraction(olInteraction); } }
    function removeMeasures() {
        totalLenMeters = 0;
        lastLenMeters = 0;
        lastZIndexMeasure = 0;
        if (!!measureOverlays) {
            var nOverlays = measureOverlays.length;
            for (var i = 0 ; i < nOverlays ; ++i) {
                olMap.removeOverlay(measureOverlays[i].olOverlay);
            }
            measureOverlays = [];
        }
    }
    function removeDrawFeature() {
        if (drawFeature) {
            olSourceVector.removeFeature(drawFeature);
            drawFeature = null;
        }
    }
    function createPointFeatures() {
        var pointGeom = new ol.geom.MultiPoint(savedCoords);
        var pointFeature = new ol.Feature({ geometry: pointGeom });
        olSourceVector.addFeature(pointFeature);
        pointFeatures.push(pointFeature);
    }
    function removePointFeatures() {
        if (!!pointFeatures) {
            var nElems = pointFeatures.length;
            for (var i = 0 ; i < nElems ; ++i) {
                olSourceVector.removeFeature(pointFeatures[i]);
            }
            pointFeatures = [];
        }
    }
    function cancel() {
        boxExtent = null; mapExtent = null;
        removeArea();
        removeDrawFeature();
        removeMeasures();
        removePointFeatures();
        if (olInteraction) {
            olMap.removeInteraction(olInteraction); olInteraction = null;
            if (!!onEndCallBack) {
                onEndCallBack.call(tMap, theThis);
            }
        }
    }
    function createOLOverlay(overlayContainer) {
        var olOverlay = new ol.Overlay({
            positioning: 'center-center',
            element: overlayContainer,
            stopEvent: false
        });
        return { olOverlay: olOverlay, container: overlayContainer };
    }
    function createTextOverlay(text) {
        var divElem = new tf.dom.Div({ cssClass: styles.mapMeasureOverlayDivClass }).GetHTMLElement();
        divElem.style.zIndex = ++lastZIndexMeasure;
        divElem.innerHTML = text;
        return createOLOverlay(divElem);
    }
    function initialize() { }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * method tf.map.ui.CreateMapButtonTextSpan - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} innerHTML - parameter description?
*/
tf.map.ui.CreateMapButtonTextSpan = function (innerHTML) {
    var span = document.createElement('span'); span.className = "ol-button-text-span";
    span.innerHTML = tf.js.GetNonEmptyString(innerHTML) ? innerHTML : "";
    return span;
}
/**
 * class tf.map.ui.CustomControl - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} tMap - parameter description?
 * @param {?} className - parameter description?
 * @param {?} innerHTML - parameter description?
 * @param {?} callBack - parameter description?
 * @param {?} opt_options - parameter description?
*/
tf.map.ui.CustomControl = function (tMap, className, innerHTML, callBack, opt_options) {
/**
 * method tf.map.ui.CustomControl.GetHTMLElement - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetHTMLElement = function () { return divElement; }
/**
 * method tf.map.ui.CustomControl.GetButton - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetButton = function () { return button; }
/**
 * method tf.map.ui.CustomControl.ChangeTitle - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} str - parameter description?
 * @param {?} tooltipStr - parameter description?
*/
    this.ChangeTitle = function (str, tooltipStr) { if (button) { button.innerHTML = str; button.title = tooltipStr; } }
/**
 * method tf.map.ui.CustomControl.ChangeToolTip - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} tooltipStr - parameter description?
*/
    this.ChangeToolTip = function (tooltipStr) { if (button) { button.title = tooltipStr; } }
    var options = tf.js.GetValidObjectFrom(opt_options);
    var tipLabel = options.tipLabel ? options.tipLabel : '';
    var imageLabel = options.imageLabel ? options.imageLabel : null;
    var button = document.createElement('button');
    var divElement = document.createElement('div');
    var onClick = null;
    button.title = tipLabel;
    if (imageLabel) { imageLabel.AppendTo(button); }
    else { button.appendChild(tf.map.ui.CreateMapButtonTextSpan(innerHTML)); }
    if (callBack) {
        new tf.events.DOMClickListener({ target: button, callBack: callBack, optionalScope: undefined, callBackSettings: undefined });
    }
    typeof className !== "string" && (className = '');
    divElement.style.zIndex = 1;
    divElement.className = className + " ol-unselectable ol-control";
    divElement.appendChild(button);
    ol.control.Control.call(this, {
        target: opt_options.target,
        hover: false, highlightOnly: false, element: divElement
    });
};
tf.js.InheritFrom(tf.map.ui.CustomControl, ol.control.Control);
/**
 * class tf.map.ui.CustomLogo - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} tMap - parameter description?
 * @param {?} className - parameter description?
 * @param {?} opt_options - parameter description?
*/
tf.map.ui.CustomLogo = function (tMap, className, opt_options) {
/**
 * method tf.map.ui.CustomLogo.GetHTMLElement - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetHTMLElement = function () { return divElement; }
    var options = tf.js.GetValidObjectFrom(opt_options);
    var imageLabel = options.imageLabel ? options.imageLabel : null;
    var divElement = document.createElement('div');
    typeof className !== "string" && (className = '') ;
    divElement.className = className + " ol-unselectable";
    if (imageLabel) { imageLabel.AppendTo(divElement); }
    ol.control.Control.call(this, { hover: false, highlightOnly: false, element: divElement });
};
tf.js.InheritFrom(tf.map.ui.CustomLogo, ol.control.Control);
/**
 * Map level ranges used by {@link tf.types.mapLayer} instances to constrain layer visibility to the given range
 * @public
 * @typedef {object} tf.types.MinMaxLevels
 * @property {tf.types.mapLevel} minLevel the minimum level at which the layer instance is displayed
 * @property {tf.types.mapLevel} maxLevel the maximum level at which the layer instance is displayed
*/
/**
 * Settings used in the creation of [Feature Layer]{@link tf.map.FeatureLayer} instances
 * @private
 * @typedef {object} tf.types.FeatureLayerSettings
 * @property {string} name - the layer name, displayed in the Map Layers popup
 * @property {string} description - the layer description
 * @property {boolean} isVisible - if <b>false</b> the layer is created invisible, defaults to <b>true</b>
 * @property {boolean} isHidden - if <b>false</b> the layer is not listed in the Map Layers popup, defaults to <b>true</b>
 * @property {number} zIndex - the layer zIndex, defaults to 0
 * @property {tf.types.opacity01} opacity - the layer opacity, defaults to 1
 * @property {tf.types.MinMaxLevels} minMaxLevels - if defined, constrains the layer's visibility to the given range, defaults to {@link void}
 * @property {boolean} useClusters - if <b>true</b> the layer can only display [Features]{@link tf.map.Feature] with [point geometries]{@link tf.types.GeoJSONGeometryType} 
 * and displays clusters of features into a single feature. Defaults to <b>void</b>
 * @property {number} clusterFeatureDistance - the distance in pixels under which [Map Features]{@link tf.map.Feature] are clustered together
 * @property {tf.types.MapFeatureStyleLike} clusterStyle - style used to display a cluster of [Map Features]{@link tf.map.Feature]
 * @property {tf.types.MapFeatureStyleSettings} clusterLabelStyle - style used to display the number of [Map Features]{@link tf.map.Feature] in a cluster
*/
/**
 * Notifications sent by {@link tf.map.FeatureLayer} instances. Properties are available in notifications that require them
 * @public
 * @typedef {object} tf.types.MapFeatureLayerEventNotification
 * @property {tf.map.FeatureLayer} sender - the instance sending the notification
 * @property {tf.types.mapFeatureLayerEventName} eventName - the name of the event
*/
/**
 * A callback function that can be passed to the function [Add Listener]{@link tf.map.FeatureLayer#AddListener} of a [Feature Layer]{@link tf.map.FeatureLayer} instance to start receiving event notifications from it
 * @public
 * @callback tf.types.MapFeatureLayerEventCallBack
 * @param {tf.types.MapFeatureLayerEventNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * @public
 * @class
 * @summary Feature Layers group map features for display on the [TerraFly HTerraMap]{@link tf.map.Map}. 
 * Instances of this class are created by calling the function [AddFeatureLayer]{@link tf.map.Map#AddFeatureLayer} of a [Map]{@link tf.map.Map} instance
 * @param {tf.types.FeatureLayerSettings} settings - feature layer creation settings
 */
tf.map.FeatureLayer = function (settings)
{
    var debug;
    var theThis, tMap, olMap, strLayerName, strLayerDesc, notifyVisibilityChange, notifyDelFeatures, isVisible, isHidden, isForcedInvisible;
    var zIndex, opacity, olSourceVector, olClusterSource, olLayerVector;
    var featuresAddWithheld, featuresDelWithheld, styleCache, textFont, keyedFeatureList;
    var useClusters, clusterFeatureDistance, clusterStyle, clusterLabelStyle;
    var clustersIconFileName, clustersIconAnchor, clustersIconScale, showClusterCount;
    var allEventDispatchers;
    /**
     * @public
     * @function
     * @summary - Adds a listener for the given map feature layer event name
     * @param {tf.types.mapFeatureLayerEventName} eventName - the name of the event
     * @param {tf.types.MapFeatureLayerEventCallBack} callBack - the callback for event notifications
     * @returns {tf.events.EventListener} - | {@link tf.events.EventListener} the event listener
    */
    this.AddListener = function (eventName, callBack) { return allEventDispatchers.AddListener(eventName, callBack); }
    /**
     * @public
     * @function
     * @summary - Retrieves the associated [Map]{@link tf.map.Map} instance
     * @returns {tf.map.Map} - | {@link tf.map.Map} the map instance
    */
    this.GetMap = function () { return tMap; }
    /**
     * @public
     * @function
     * @summary - Retrieves layer's name
     * @returns {string} - | {@link string} the name
    */
    this.GetName = function () { return strLayerName; }
    /**
     * @public
     * @function
     * @summary - Retrieves layer's description
     * @returns {string} - | {@link string} the description
    */
    this.GetDesc = function () { return strLayerDesc; }
    /**
     * @public
     * @function
     * @summary - Changes the layer's description
     * @param {string} newDescStr - the new description
     * @returns {void} - | {@link void} no return value
    */
    this.ChangeDescription = function (newDescStr) {
        if (tf.js.GetIsString(newDescStr)) { if (newDescStr != strLayerDesc) { strLayerDesc = newDescStr; doNotifyVisibilityChange(); } }
    }
    /**
     * @public
     * @function
     * @summary - Checks if the layer is hidden from the Layers Popup
     * @returns {boolean} - | {@link boolean} <b>true</b> if hidden, <b>false</b> otherwise
    */
    this.GetIsHidden = function () { return isHidden; }
    /**
     * @public
     * @function
     * @summary - Changes the layer's opacity
     * @param {tf.types.opacity01} opacity - the new opacity
     * @returns {void} - | {@link void} no return value
    */
    this.SetOpacity = function (opacity) { return setOpacity(opacity); }
    /**
     * @public
     * @function
     * @summary - Retrieves the layer's opacity
     * @returns {tf.types.opacity01} - | {@link tf.types.opacity01} the opacity
    */
    this.GetOpacity = function () { return getOpacity(); }
    /**
     * @public
     * @function
     * @summary - Changes the layer's zIndex
     * @param {number} zindex - the new zIndex
     * @returns {void} - | {@link void} no return value
    */
    this.SetZIndex = function (zindex) { return setZIndex(zindex); }
    /**
     * @public
     * @function
     * @summary - Retrieves the layer's zIndex
     * @returns {number} - | {@link number} the zIndex
    */
    this.GetZIndex = function () { return getZIndex(); }
    /**
     * @private
     * @function
     * @summary - Sets the minumum and maximum map levels at which this layer instance is displayed
     * @param {tf.types.mapLevel} minLevel the minimum level
     * @param {tf.types.mapLevel} maxLevel the maximum level
     * @returns {void} - | {@link void} no return value
    */
    this.SetMinMaxLevels = function (minLevel, maxLevel) { return setMinMaxLevels(minLevel, maxLevel); }
    this.SetIsForcedInvisible = function (bool) {
        if (isForcedInvisible != (bool = tf.js.GetBoolFromValue(bool))) {
            isForcedInvisible = bool;
            updateLayerVisibility();
        }
    }
    this.GetIsForcedInvisible = function () { return isForcedInvisible; }
    /**
     * @public
     * @function
     * @summary - Shows or hides the layer
     * @param {boolean} bool - <b>true</b> to show, <b>false</b> to hide
     * @returns {void} - | {@link void} no return value
    */
    this.SetVisible = function (bool) {
        if (isVisible != (bool = tf.js.GetBoolFromValue(bool))) {
            isVisible = bool;
            updateLayerVisibility();
            doNotifyVisibilityChange();
        }
    }
    /**
     * @public
     * @function
     * @summary - Checks if the layer is visible
     * @returns {boolean} - | {@link boolean} <b>true</b> if visible, <b>false</b> otherwise
    */
    this.GetIsVisible = function () { return /*olLayerVector.getVisible();*/ isVisible; }
    /**
     * @public
     * @function
     * @summary - Toggles layers's visibility state
     * @returns {void} - | {@link void} no return value
    */
    this.ToggleIsVisible = function () { return theThis.SetVisible(!isVisible); }
    /**
     * @public
     * @function
     * @summary - Adds all features that were withheld for group / bulk addition
     * @returns {void} - | {@link void} no return value
    */
    this.AddWithheldFeatures = function () {
        if (featuresAddWithheld.length) { olSourceVector.addFeatures(featuresAddWithheld); }
        featuresAddWithheld = [];
    }
    /**
     * @public
     * @function
     * @summary - Removes all features that were withheld for group / bulk removal
     * @returns {void} - | {@link void} no return value
    */
    this.DelWithheldFeatures = function () {
        if (featuresDelWithheld.length) {
            if (!!notifyDelFeatures) { notifyDelFeatures(featuresDelWithheld); }
            for (var i in featuresDelWithheld) {
                olSourceVector.removeFeature(featuresDelWithheld[i]);
            }
        }
        featuresDelWithheld = [];
    }
    /**
     * @public
     * @function
     * @summary - Adds one keyed feature to the layer
     * @param {tf.map.KeyedFeature} keyedFeature - the feature
     * @param {string} styleName - optional feature style name
     * @param {boolean} withHoldAddFeature - if <b>true</b> the feature is effectively added only when the function [AddWithheldFeatures]{@link tf.map.FeatureLayer#AddWithheldFeatures} 
     * is called, to improve performance when adding a large number of features in sequence. if <b>false</b> the feature is immediately added
     * @returns {void} - | {@link void} no return value
    */
    this.AddKeyedFeature = function (keyedFeature, styleName, withHoldAddFeature) { return addKeyedFeature(keyedFeature, styleName, withHoldAddFeature); }
    /**
     * @public
     * @function
     * @summary - Checks if the layer contains the given keyed feature
     * @param {tf.map.KeyedFeature} keyedFeature - the keyed feature
     * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
    */
    this.ContainsKeyedFeature = function (keyedFeature) { return containsKeyedFeature(keyedFeature); }
    /**
     * @public
     * @function
     * @summary - Removes one keyed feature from the layer
     * @param {tf.map.KeyedFeature} keyedFeature - the feature
     * @param {boolean} withHoldDelFeature - if <b>true</b> the feature is effectively deleted only when the function [DelWithheldFeatures]{@link tf.map.FeatureLayer#DelWithheldFeatures} 
     * is called, to improve performance when removing a large number of features in sequence. if <b>false</b> the feature is immediately removed
     * @returns {void} - | {@link void} no return value
    */
    this.DelKeyedFeature = function (keyedFeature, withHoldDelFeature) { return delKeyedFeature(keyedFeature, withHoldDelFeature); }
    /**
     * @public
     * @function
     * @summary - Adds one map feature to the layer
     * @param {tf.map.Feature} mapFeature - the feature
     * @param {boolean} withHoldAddFeature - if <b>true</b> the feature is effectively added only when the function [AddWithheldFeatures]{@link tf.map.FeatureLayer#AddWithheldFeatures} 
     * is called, to improve performance when adding a large number of features in sequence. if <b>false</b> the feature is immediately added
     * @returns {void} - | {@link void} no return value
    */
    this.AddMapFeature = function (mapFeature, withHoldAddFeature) { return addMapFeature(mapFeature, withHoldAddFeature); }
    /**
     * @public
     * @function
     * @summary - Removes one map feature from the layer
     * @param {tf.map.Feature} mapFeature - the feature
     * @param {boolean} withHoldDelFeature - if <b>true</b> the feature is effectively deleted only when the function [DelWithheldFeatures]{@link tf.map.FeatureLayer#DelWithheldFeatures} 
     * is called, to improve performance when removing a large number of features in sequence. if <b>false</b> the feature is immediately removed
     * @returns {void} - | {@link void} no return value
    */
    this.DelMapFeature = function (mapFeature, withholdDelFeature) { return delMapFeature(mapFeature, withholdDelFeature) }
    /**
     * @public
     * @function
     * @summary - Determines if the this layer contains the given feature
     * @param {tf.map.Feature} mapFeature - the feature
     * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
    */
    this.ContainsMapFeature = function (mapFeature) {
        return !!olSourceVector && tf.js.GetIsInstanceOf(mapFeature, tf.map.Feature) && !!olSourceVector.getFeatureById(mapFeature.getAPIFeature().getId());
    }
    /**
     * @public
     * @function
     * @summary - Removes all features from the layer
     * @returns {void} - | {@link void} no return value
    */
    this.RemoveAllFeatures = function () {
        if (!!notifyDelFeatures) { notifyDelFeatures(olSourceVector.getFeatures()) };
        keyedFeatureList = {};
        createSourceVector();
    }
    function updateLayerVisibility() { if (!!olLayerVector) { olLayerVector.setVisible(isVisible && !isForcedInvisible); } }
    function notifyListeners(eventName) { allEventDispatchers.Notify(eventName, { sender: theThis, eventName: eventName }); }
    function doNotifyVisibilityChange() {
        if (!!notifyVisibilityChange) { notifyVisibilityChange.call(tMap, this); }
        notifyListeners(tf.consts.mapFeatureLayerVisibilityChangeEvent);
    }
    function getOpacity() { return olLayerVector.getOpacity(); }
    function setOpacity(opacitySet) {
        opacitySet = tf.js.GetFloatNumberInRange(opacitySet, 0, 1, 1);
        if (opacity != opacitySet) {
            opacity = opacitySet;
            if (!!olLayerVector) { olLayerVector.setOpacity(opacity); }
        }
    }
    function getZIndex() { return zIndex; /*olLayerVector.getZIndex();*/ }
    function setZIndex(zIndexSet) {
        zIndexSet = tf.js.GetFloatNumber(zIndexSet, 0);
        if (zIndex != zIndexSet) {
            zIndex = zIndexSet;
            if (!!olLayerVector) { olLayerVector.setZIndex(zIndex); }
        }
    }
    function addMapFeature(mapFeature, withholdAddFeature) {
        if (mapFeature instanceof tf.map.Feature) {
            var APIFeature = mapFeature.getAPIFeature();
            if (!!withholdAddFeature) { featuresAddWithheld.push(APIFeature); } else { olSourceVector.addFeature(APIFeature); }
        }
    }
    function delMapFeature(mapFeature, withholdDelFeature) {
        if (mapFeature instanceof tf.map.Feature) {
            var APIFeature = mapFeature.getAPIFeature();
            if (!!withholdDelFeature) { featuresDelWithheld.push(APIFeature); } else {
                if (!!notifyDelFeatures) { notifyDelFeatures(APIFeature); }
                olSourceVector.removeFeature(APIFeature);
            }
        }
    }
    function addKeyedFeature(keyedFeature, styleName, withHoldAddFeature) {
        if (keyedFeature instanceof tf.map.KeyedFeature) {
            var keyedFeatureKey = keyedFeature.GetFeatureKey();
            var listItem = keyedFeatureList[keyedFeatureKey];
            if (!listItem) {
                keyedFeatureList[keyedFeatureKey] = { keyedFeature: keyedFeature, styleName: styleName };
                addMapFeature(keyedFeature.GetMapFeature(styleName), withHoldAddFeature);
            }
            /*else { tf.GetDebug().LogIfTest('adding double keyed!'); }*/
        }
    }
    function containsKeyedFeature(keyedFeature) {
        return keyedFeature instanceof tf.map.KeyedFeature && keyedFeatureList[keyedFeature.GetFeatureKey()] !== undefined;
    }
    function delKeyedFeature(keyedFeature, withHoldDelFeature) {
        if (keyedFeature instanceof tf.map.KeyedFeature) {
            var keyedFeatureKey = keyedFeature.GetFeatureKey();
            var listItem = keyedFeatureList[keyedFeatureKey];
            if (!!listItem) {
                var styleName = listItem.styleName;
                delete keyedFeatureList[keyedFeatureKey];
                delMapFeature(keyedFeature.GetMapFeature(styleName), withHoldDelFeature);
            }
            /*else { tf.GetDebug().LogIfTest('deleting unexisting key!'); }*/
        }
    }
    function removeFromOLMap() { if (olLayerVector) { olMap.removeLayer(olLayerVector); olLayerVector = null; } }
    function clusterStyleFunction(feature, resolution) {
        var features = feature.get('features');
        var size = features.length;
        var style = null;
        if (size == 1) {
            var props = features [0].getProperties();
            if (props != null) { var mapFeature = props.mapFeature; if (mapFeature) { style = mapFeature.getAPIStyle(); } }
        }
        if (!style) {
            style = styleCache[size];
            if (!style) {
                if (!!clusterStyle) {
                    if (!!clusterLabelStyle) {
                        clusterLabelStyle = tf.js.ShallowMerge(clusterLabelStyle, { label: size.toString() });
                        if (tf.js.GetIsArray(clusterStyle)) {
                            var allStyle = clusterStyle.slice(0); allStyle.push(clusterLabelStyle) ;
                            var clusterS = tf.map.GetOrCreateFeatureStyle(allStyle);
                            style = clusterS.getAPIStyle();
                        }
                        else {
                            var allStyle = [clusterStyle, clusterLabelStyle];
                            var clusterS = tf.map.GetOrCreateFeatureStyle(allStyle);
                            style = clusterS.getAPIStyle();
                        }
                    }
                    else {
                        var clusterS = tf.map.GetOrCreateFeatureStyle(clusterStyle);
                        style = clusterS.getAPIStyle();
                    }
                }
                else { style = [new ol.style.Style({ text: new ol.style.Text({ text: size.toString(), font: textFont, fill: new ol.style.Fill({ color: '#000' }) }) })]; }
                styleCache[size] = style;
            }
        }
        return style;
    }
    function createSourceVector() {
        var newLayerVector = !olLayerVector;
        olSourceVector = new ol.source.Vector();
        if (useClusters) {
            (typeof clustersIconFileName === "string" && clustersIconFileName.length > 0) || (clustersIconFileName = null);
            olClusterSource = new ol.source.Cluster({ distance: clusterFeatureDistance, source: olSourceVector });
            if (newLayerVector) {
                olLayerVector = new ol.layer.Vector({
                    source: olClusterSource, visible: isVisible, style: clusterStyleFunction, zIndex: zIndex, opacity: opacity,
                    updateWhileAnimating: true, updateWhileInteracting: true
                });
            }
            else {
                olLayerVector.setStyle(clusterStyleFunction);
                olLayerVector.setSource(olClusterSource);
            }
        }
        else {
            if (newLayerVector) {
                olLayerVector = new ol.layer.Vector({
                    source: olSourceVector, visible: isVisible, zIndex: zIndex, opacity: opacity,
                    updateWhileAnimating: true, updateWhileInteracting: true
                });
            }
            else {
                olLayerVector.setSource(olSourceVector);
            }
        }
        if (newLayerVector) { olMap.addLayer(olLayerVector); }
    }
    function setMinMaxLevels(minLevel, maxLevel) {
        var minMaxLevels = tf.js.GetMinMaxLevelsFrom(minLevel, maxLevel);
        minLevel = minMaxLevels.minLevel;
        maxLevel = minMaxLevels.maxLevel;
        var minRes = tf.units.GetResolutionByLevel(minLevel);
        var maxRes = tf.units.GetResolutionByLevel(maxLevel);
        olLayerVector.setMinResolution(minRes);
        olLayerVector.setMaxResolution(maxRes);
    }
    function initialize() {
        zIndex = 0;
        opacity = 1;
        featuresAddWithheld = [];
        featuresDelWithheld = [];
        styleCache = {};
        keyedFeatureList = {};
        isForcedInvisible = false;
        allEventDispatchers = new tf.events.MultiEventNotifier({ eventNames: tf.consts.allMapFeatureLayerEventNames });
        textFont = tf.GetStyles().GetSubStyles().markerFontFamily;
        strLayerName = tf.js.GetNonEmptyString(settings.name, '');
        strLayerDesc = tf.js.GetNonEmptyString(settings.description, '');
        isVisible = tf.js.GetBoolFromValue(settings.isVisible, true);
        isHidden = tf.js.GetBoolFromValue(settings.isHidden, false);
        if (settings.zIndex !== undefined) { setZIndex(settings.zIndex); }
        if (settings.opacity !== undefined) { setOpacity(settings.opacity); }
        tMap = tf.js.GetMapFrom(settings.map);
        olMap = settings.olMap;
        notifyDelFeatures = tf.js.GetFunctionOrNull(settings.notifyDelFeatures);
        notifyVisibilityChange = tf.js.GetFunctionOrNull(settings.notifyVisibilityChange);
        useClusters = tf.js.GetBoolFromValue(settings.useClusters, false);
        clusterFeatureDistance = tf.js.GetIntNumberInRange(settings.clusterFeatureDistance, 5, 1000, 24);
        clusterStyle = tf.js.GetIsValidObject(settings.clusterStyle) ? settings.clusterStyle : null;
        clusterLabelStyle = tf.js.GetIsValidObject(settings.clusterLabelStyle) ? settings.clusterLabelStyle : null;
        if (tf.js.GetFunctionOrNull(settings.setDeleteCmdCallBack)) { settings.setDeleteCmdCallBack.call(tMap, theThis, removeFromOLMap); }
        createSourceVector();
        if (tf.js.GetIsValidObject(settings.minMaxLevels)) { setMinMaxLevels(settings.minMaxLevels.minLevel, settings.minMaxLevels.maxLevel); }
    }
    (function actualConstructor(theLayerThis) { theThis = theLayerThis; initialize(); })(this);
};
/**
 * A {@link string} defining an arbitrary number of semi-colon delimited properties in the format: "A=VA;B=VB...", where "A" and "B" are property names and "VA" and "VB" are their respective values
 * @public
 * @typedef {string} deprecatedPropertyString
 * @see {@link tf.js.ParseLegacyFormatString}
 */
/**
 * @public
 * @function
 * @summary - Converts the given [property string]{@link deprecatedPropertyString} into an {@link object}
 * @param {deprecatedPropertyString} formatStr - the format string
 * @returns {object} - | {@link object} an object with the specified properties
 * @deprecated use {@link tf.types.MapFeatureStyleSettings} instead
*/
tf.js.ParseLegacyFormatString = function (formatStr) {
    var formatObj = {};
    if (!!formatStr && typeof formatStr == "string") {
        var settings = formatStr.split(';');
        for (var i = 0; i < settings.length; i++) {
            var items = settings[i].split('=');
            if (items !== undefined && items.length > 0) {
                formatObj[items[0].trim().toLowerCase()] = items[1] ? items[1].trim() : "";
            }
        }
    }
    return formatObj;
}
/**
 * @public
 * @function
 * @summary - Auxiliary method for TLayer class
 * @param {string} strPoints - a string containing map coordinates
 * @returns {tf.types.GeoJSONGeometryCoordinates} - | {@link tf.types.GeoJSONGeometryCoordinates} map coordinates
 * @deprecated
*/
tf.helpers.GetCoordsFromLatLonString = function (strPoints) {
    var coordinates = [];
    var strPointsUse = tf.js.GetNonEmptyString(strPoints);
    if (strPointsUse) {
        if (strPointsUse)
            var pointList = strPointsUse.split(';');
        try {
            for (var i in pointList) { var latLon = pointList[i].split(','); if (latLon.length == 2) { coordinates.push([tf.js.GetLongitudeFrom(latLon[1]), tf.js.GetLatitudeFrom(latLon[0])]); } }
        }
        catch (e) { coordinates = [] };
    }
    return coordinates;
}
/**
 * @public
 * @function
 * @summary - Auxiliary method for TLayer class
 * @param {string} strPoints - a string containing map coordinates
 * @returns {tf.types.GeoJSONGeometryCoordinates} - | {@link tf.types.GeoJSONGeometryCoordinates} map coordinates
 * @deprecated
*/
tf.helpers.GetMultiCoordsFromLatLonString = function (strPoints) {
    var coordinates = [];
    var strPointsUse = tf.js.GetNonEmptyString(strPoints);
    if (strPointsUse) {
        if (strPointsUse.charAt(0) == '(') {
            var multilineStrings = strPointsUse.split('(').slice(1);
            for (var i in multilineStrings) {
                if (multilineStrings[i].length > 0 && multilineStrings[i].charAt(0) == '(') {
                    tf.GetDebug().LogIfTest('double parenthesis in strPoints');
                }
                coordinates.push([tf.helpers.GetCoordsFromLatLonString(multilineStrings[i])]);
            }
        }
        else { coordinates = tf.helpers.GetCoordsFromLatLonString(strPoints); }
    }
    return coordinates;
}
/**
 * @public
 * @function
 * @summary - Calculates the minimum distance between given map coordinates and a given segment defined by an array of map coordinates
 * @param {array<deprecatedMapCoords3>} mapCoordinatesArray - the array of map coordinates defining a segment
 * @param {tf.types.latitude} ptLat - the latitude
 * @param {tf.types.longitude} ptLon - the longitude
 * @returns {tf.types.HitTestCoordinatesArrayResult} - | {@link tf.types.HitTestCoordinatesArrayResult} the result
 * @deprecated see {@link tf.helpers.HitTestMapCoordinatesArray}
*/
tf.helpers.HitTestLatLonArray = function (latLonArray, ptLat, ptLon) {
    var minDistance = -1;
    var minDistanceIndex = -1;
    if (!!latLonArray && typeof latLonArray === "object" && !!latLonArray.length) {
        var nInPath = latLonArray.length;
        var prevEnd = latLonArray[0];
        var time = 0;
        for (var i = 1 ; i < nInPath ; ++i) {
            var start = prevEnd, end = latLonArray[i];
            var thisDistance = 0;
            var latPtToStart = ptLat - start.lat;
            var lonPtToStart = ptLon - start.lon;
            if (start.lat == end.lat && start.lon == end.lon) { thisDistance = (latPtToStart * latPtToStart + lonPtToStart * lonPtToStart); }
            else {
                var latEndToStart = end.lat - start.lat;
                var lonEndToStart = end.lon - start.lon;
                var distEndStartSq = Math.sqrt(latEndToStart * latEndToStart + lonEndToStart * lonEndToStart);
                var latPtToEnd = ptLat - end.lat;
                var lonPtToEnd = ptLon - end.lon;
                var proj = (lonPtToStart * lonEndToStart + latPtToStart * latEndToStart) / distEndStartSq;
                if (proj < 0) { thisDistance = (latPtToStart * latPtToStart + lonPtToStart * lonPtToStart); }
                else if (proj > 1) { thisDistance = (latPtToEnd * latPtToEnd + lonPtToEnd * lonPtToEnd); }
                else {
                    var segPtLat = start.lat + latEndToStart * proj;
                    var segPtLon = start.lon + lonEndToStart * proj;
                    var segPtToPtLat = segPtLat - ptLat;
                    var segPtToPtLon = segPtLon - ptLon;
                    thisDistance = (segPtToPtLat * segPtToPtLat + segPtToPtLon * segPtToPtLon);
                }
            }
            if (minDistance < 0 || thisDistance < minDistance) { minDistance = thisDistance; minDistanceIndex = i - 1; }
            prevEnd = end;
        }
    }
    return { minDistance: minDistance, minDistanceIndex: minDistanceIndex };
};
/**
 * @public
 * @function
 * @summary - Auxiliary function for MVideo application
 * @param {?} path - ?
 * @param {?} times - ?
 * @param {?} ptLat - ?
 * @param {?} ptLon - ?
 * @returns {?} - ?
 * @deprecated
*/
tf.helpers.HitTestRoute = function (path, times, ptLat, ptLon) {
    var hitTestResult = tf.helpers.HitTestLatLonArray(path, ptLat, ptLon);
    var minDistanceIndex = hitTestResult.minDistanceIndex;
    var time = 0;
    if (minDistanceIndex >= 0) {
        var lastTime = times[path.length - 1].indexPath;
        time = times[minDistanceIndex].indexPath / lastTime;
    }
    return { time01: time, index: minDistanceIndex };
}
/**
 * @public
 * @function
 * @summary - Auxiliary method for MVideo application
 * @param {?} times - ?
 * @returns {?} - ?
 * @deprecated
*/
tf.helpers.CreateTimesWithoutGap = function (times) {
    var newTimes = [];
    if (!!times && typeof times == "object" && times.length > 0) {
        var ngaps = 0;
        var ntimes = times.length, i;
        if (ntimes > 0) {
            var lastTime = 0, lastIndex = 0;
            for (var i = 0 ; i < ntimes ; ++i) {
                var thisTime = times[i];
                if (thisTime > lastTime) {
                    while (lastTime < thisTime - 1) {
                        newTimes.push({ indexPath: lastIndex, hasGPS: false });
                        ++lastTime;
                        ++ngaps;
                    }
                    lastTime = thisTime;
                    lastIndex = i;
                    newTimes.push({ indexPath: lastIndex, hasGPS: true });
                }
                /*else if (thisTime < lastTime) { tf.GetDebug().LogIfTest("timeline out of sequence"); }*/
            }
            while (lastTime < ntimes) {
                newTimes.push({ indexPath: lastIndex, hasGPS: false });
                ++lastTime;
                ++ngaps;
            }
        }
    }
    return newTimes;
};
/**
 * @public
 * @function
 * @summary - Auxiliary method for MVideo application
 * @param {?} fromLatLon - parameter description?
 * @param {?} toLatLon - parameter description?
 * @returns {?} - method returns?
*/
tf.units.GetMapRadAngleFromLatLonVector = function (fromLatLon, toLatLon) {
    return tf.units.GetMapHeading([fromLatLon.lon, fromLatLon.lat], [toLatLon.lon, toLatLon.lat]);
}
/**
 * @public
 * @function
 * @summary - Auxiliary method for MVideo application
 * @param {?} latLonArray - ?
 * @returns {?} - ?
 * @deprecated
*/
tf.helpers.CalcDirectionsLatLonArray = function (latLonArray) {
    var directions = [];
    var nInlatLonArray = latLonArray ? latLonArray.length : 0;
    if (nInlatLonArray > 1) {
        var getMapRadAngleFromLatLonVector = tf.units.GetMapRadAngleFromLatLonVector;
        var startAngle = undefined;
        var start = latLonArray[0];
        for (var i = 1 ; startAngle == undefined && i < nInlatLonArray ; ++i) {
            var thisItem = latLonArray[i];
            if (start.lat != thisItem.lat || start.lon != thisItem.lon) {
                startAngle = getMapRadAngleFromLatLonVector(start, thisItem);
            }
        }
        if (startAngle != undefined) {
            var lastAngle = startAngle;
            var current = latLonArray[1];
            var last = latLonArray[nInlatLonArray - 1];
            directions.push(startAngle);
            for (var i = 1 ; i < nInlatLonArray - 1 ; ++i) {
                var thisItem = latLonArray[i];
                var nextItem = latLonArray[i + 1];
                if (thisItem.lat != nextItem.lat || thisItem.lon != nextItem.lon) {
                    directions.push(lastAngle = getMapRadAngleFromLatLonVector(thisItem, nextItem));
                }
                else {
                    directions.push(lastAngle);
                }
            }
            directions.push(lastAngle);
        }
        else {
            for (var i = 0 ; i < nInlatLonArray ; ++i) {
                directions.push(0);
            }
        }
    }
    else {
        directions.push(0);
    }
    return directions;
}
/**
 * @public
 * @function
 * @summary - Auxiliary method for MVideo application
 * @param {?} path - ?
 * @returns {?} - ?
 * @deprecated
*/
tf.helpers.CalcMinMaxSpeedAlt = function (path) {
    var maxAlt = 0, minAlt = 0, maxSpeed = 0, minSpeed = 0, altRange = 0, speedRange = 0;
    if (!!path && typeof path === "object" && path.length > 0 && path[0].speed !== undefined && path[0].altitude !== undefined) {
        if (path.length > 0) {
            maxAlt = minAlt = path[0].altitude; maxSpeed = minSpeed = path[0].speed;
            for (var i in path) {
                var thisInPath = path[i], thisSpeed = thisInPath.speed, thisAlt = thisInPath.altitude;
                if (thisSpeed < minSpeed) { minSpeed = thisSpeed; } if (thisSpeed > maxSpeed) { maxSpeed = thisSpeed; }
                if (thisAlt < minAlt) { minAlt = thisAlt; } if (thisAlt > maxAlt) { maxAlt = thisAlt; }
            }
            altRange = maxAlt - minAlt; speedRange = maxSpeed - minSpeed;
        }
    }
    return { minAlt: minAlt, maxAlt: maxAlt, altRange: altRange, minSpeed: minSpeed, maxSpeed: maxSpeed, speedRange: speedRange };
};
/**
 * @public
 * @function
 * @summary - Auxiliary method for MVideo application
 * @param {?} latLonArray - parameter description?
 * @returns {?} - method returns?
 * @deprecated
*/
tf.helpers.GetCoordinatesFromLatLonArray = function (latLonArray) {
    var coordinates = [];
    try {
        if (typeof latLonArray === "object" && latLonArray.length > 0 && latLonArray[0].lat !== undefined && latLonArray[0].lon !== undefined) {
            for (var i in latLonArray) { var thisPoint = latLonArray[i]; coordinates.push([tf.js.GetLongitudeFrom(thisPoint.lon), tf.js.GetLatitudeFrom(thisPoint.lat)]); }
        }
    }
    catch (e) { coordinates = [] };
    return coordinates;
}
/**
 * A callback function that can be passed to the global function {@link TDownloadRequest}
 * @public
 * @callback TDownloadRequestCallBack
 * @param {object} httpRequest - the request object
 * @param {number} status - the request status
 * @param {object} requestID - the object passed in the call to {@link TDownloadRequest}
 * @returns {void} - | {@link void} no return value
 */
/**
 * @public
 * @class
 * @summary Create an instance of this class to retrieve data from a given url pointing to a service or data file
 * @param {string} urlToDownload - the desired url
 * @param {TDownloadRequestCallBack} callBack - the callback function
 * @param {object} requestID - parameter that will be passed back to the callback function
 * @extends {tf.ajax.GetRequest}
 * @deprecated This global function will soon be removed: use {@link tf.ajax.GetRequest} instead
*/
var TDownloadRequest = function (urlToDownload, callBack, requestID) {
    var theThis, callBackUse;
    /**
     * @public
     * @function
     * @summary - Cancels the request if it is in progress
     * @returns {void} - | {@link void} no return value
     * @deprecated Use [Cancel]{@link tf.ajax.GetRequest#Cancel} instead
    */
    this.Abort = function () { return theThis.Cancel(); }
    function onDataLoaded(notification) {
        callBackUse(notification.httpRequest, notification.httpRequest.status, notification.requestProps);
    }
    function initialize() {
        if (callBackUse = tf.js.GetFunctionOrNull(callBack)) {
            tf.ajax.GetRequest.call(theThis, { url: urlToDownload, onDataLoaded: onDataLoaded, requestProps: requestID, autoSend: false });
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(TDownloadRequest, tf.ajax.GetRequest);
/**
 * @public
 * @class
 * @summary Instances of this class are used by deprecated functions in the TerraFly API
 * @param {tf.types.latitude} latitude - the latitude
 * @param {tf.types.longitude} longitude - the longitude
 * @property {tf.types.latitude} latitude - the latitude
 * @property {tf.types.longitude} longitude - the longitude
 * @deprecated This format will soon be removed along with functions that support it. TerraFly applications should replace the 
 * use of these functions with current API functions that use the {@link tf.types.mapCoordinates} format
*/
var tLatLng = function (latitude, longitude) {
    var theThis = this;
    /**
     * @public
     * @function
     * @summary - Obtain the corresponding map coordinates
     * @returns {tf.types.mapCoordinates} - | {@link tf.types.mapCoordinates} the corresponding map coordinates
    */
    this.GetMapCoords = function () { return [longitude, latitude]; }
    theThis.latitude = latitude; theThis.longitude = longitude;
};
/**
 * @public
 * @class
 * @summary An instance of this class is passed to callBack functions specified in calls to the {@link TGetAddressByLatLng} function
 * @param {string} address - component part of the address
 * @param {string} housenumber - component part of the address
 * @param {string} range_from - component part of the address
 * @param {string} range_to - component part of the address
 * @param {string} street - component part of the address
 * @param {string} city - component part of the address
 * @param {string} state - component part of the address
 * @param {string} zip - component part of the address
 * @param {string} latitude - component part of the address
 * @param {string} longitude - component part of the address
 * @param {string} distance - component part of the address
 * @param {string} compass_direction - component part of the address
 * @param {string} offset - component part of the address
 * @param {string} streetc - component part of the address
 * @property {string} address - component part of the address
 * @property {string} housenumber - component part of the address
 * @property {string} range_from - component part of the address
 * @property {string} range_to - component part of the address
 * @property {string} street - component part of the address
 * @property {string} city - component part of the address
 * @property {string} state - component part of the address
 * @property {string} zip - component part of the address
 * @property {string} latitude - component part of the address
 * @property {string} longitude - component part of the address
 * @property {string} distance - component part of the address
 * @property {string} compass_direction - component part of the address
 * @property {string} offset - component part of the address
 * @property {string} streetc - component part of the address
 * @property {number} GGeoAddressAccuracy - the TerraFly geo location accuracy code associated with this address
 * @deprecated A replacement for this class will soon be available in the {@link tf.services} namespace
*/
var TAddressReturnObject = function (address, housenumber, range_from, range_to, street, city, state, zip, latitude, longitude, distance, compass_direction, offset, streetc) {
    this.address = address;
    this.housenumber = housenumber;
    this.range_from = range_from;
    this.range_to = range_to;
    this.street = street;
    this.city = city;
    this.state = state;
    this.zip = zip;
    this.latitude = latitude;
    this.longitude = longitude;
    this.distance = distance;
    this.compass_direction = compass_direction;
    this.offset = offset;
    this.streetc = streetc;
    if (this.distance <= 10) { this.GGeoAddressAccuracy = 9; }
    else if (this.distance <= 50) { this.GGeoAddressAccuracy = 8; }
    else if (this.distance <= 100) { this.GGeoAddressAccuracy = 7; }
    else if (this.distance <= 200) { this.GGeoAddressAccuracy = 6; }
    else if (this.distance <= 500) { this.GGeoAddressAccuracy = 5; }
    else { this.GGeoAddressAccuracy = 4; }
    /**
     * @public
     * @function
     * @summary - Obtains the full address
     * @returns {string} - | {@link string} the full address composed from its individual parts
    */
    this.toString = function () {
        var addressString = this.address + ", " + this.city + ", " + this.state + ", " + this.zip;
        if (addressString == null)
            throw ("Error in TAddressReturnObject toString method");
        return addressString;
    }
    /**
     * @public
     * @function
     * @summary - Obtains a string describing the accuracy of the address geo location represented by the desired accuracy code
     * @param {number} GGeoAddressAccuracy - the desired accuracy code
     * @returns {string} - | {@link string} the accuracy description associated with the the given code
    */
    this.GetAccuracyDescription = function (GGeoAddressAccuracy) {
        if (GGeoAddressAccuracy === undefined) { GGeoAddressAccuracy = this.GGeoAddressAccuracy; }
        var descriptions = [
                "Country level accuracy",
                "Region (state, province, prefecture, etc.) level accuracy",
                "Sub-region (county, municipality, etc.) level accuracy",
                "Town (city, village) level accuracy",
                "Post code (zip code) level accuracy",
                "Street level accuracy",
                "Intersection level accuracy",
                "Address level accuracy",
                "Premise level accuracy"
        ];
        var descriptionsCount = descriptions.length;
        return (GGeoAddressAccuracy >= 1 && GGeoAddressAccuracy <= descriptionsCount) ? descriptions[GGeoAddressAccuracy - 1] : "Unknown location";
    }
};
/**
 * @public
 * @typedef {array} ResourceArray - an array of instances of {@link Resources}
 */
/**
 * @public
 * @class
 * @property {string} name - the name of the resource
 * @property {string} produceDate - an array of dates
 * @property {array} resolutionList - array of resolutions
 * @property {array} notchList - array of notches
 * @summary An array of instances of this class is passed to callBack functions specified in calls to the {@link TGetAerialImagerySources_UTM} and {@link TGetAerialImagerySources} functions
 * @deprecated A replacement for this class is now available: {@link tf.types.RasterSourceListResult} used with the [Raster Source List Service]{@link tf.services.RasterSourceList} service
*/
var Resources = function () {
    this.name = null;
    this.produceDate = null;
    this.resolutionList = null;
    this.notchList = null;
    /**
     * @public
     * @function
     * @summary - Sets the dates of the resource
     * @param {string} workString - comma separated date values 
     * @returns {void} - | {@link void} no return value
    */
    this.SetDate = function (workString) {
        this.produceDate = workString.split(",").slice(0, -1);
        //if (this.produceDate.length > 1) { tf.GetDebug().LogIfTest('Resource: more than one date' + this.produceDate); }
        for (var i in this.produceDate) {
            var thisProduceDate = this.produceDate[i];
            var year = thisProduceDate.substring(0, 4);
            var month = thisProduceDate.substring(4, 6);
            var day = thisProduceDate.substring(6, 8);
            this.produceDate[i] = new Date(year, month - 1, day);
        }
    }
    /**
     * @public
     * @function
     * @summary - Creates a list of resolutions
     * @param {string} workString - comma separated resolution values
     * @returns {void} - | {@link void} no return value
    */
    this.CreateList = function (workString) {
        this.resolutionList = workString.split(",").slice(0, -1);
        for (var i in this.resolutionList) { this.resolutionList[i] = parseFloat(this.resolutionList[i]); }
    }
    /**
     * @public
     * @function
     * @summary - Creates a list of notches
     * @param {string} workString - comma separated notch values
     * @returns {void} - | {@link void} no return value
    */
    this.CreateNotchList = function (workString) { this.notchList = workString.split(",").slice(0, -1) }
    /**
     * @public
     * @function
     * @summary - Sorts the resource
     * @returns {void} - | {@link void} no return value
    */
    this.Sort = function () {
        var temp;
        var tempNotch;
        //if (this.resolutionList.length > 1) { tf.GetDebug().LogIfTest('Resource: more than one resolution');}
        for (var i = 1; i < this.resolutionList.length; i++) {
            for (var j = this.resolutionList.length - 1; j > 0; j--) {
                if (this.resolutionList[j] < this.resolutionList[j - 1]) {
                    temp = this.resolutionList[j];
                    tempNotch = this.notchList[j];
                    this.resolutionList[j] = this.resolutionList[j - 1];
                    this.notchList[j] = this.notchList[j - 1];
                    this.resolutionList[j - 1] = temp;
                    this.notchList[j - 1] = tempNotch;
                }
            }
        }
    }
};
/**
 * @public
 * @global
 * @function
 * @summary - Obtains the map level corresponding to the given map resolution
 * @param {tf.types.mapResolution} resolution - the given map resolution
 * @returns {tf.types.mapLevel} - | {@link tf.types.mapLevel} the corresponding map level
 * @deprecated This global function will soon be removed: use {@link tf.units.GetLevelByResolution} instead
*/
function TGetLevelByResolution(resolution) { return tf.units.GetLevelByResolution(resolution); }
/**
 * @public
 * @global
 * @function
 * @summary - Obtains the map resolution corresponding to the given map level
 * @param {tf.types.mapLevel} level - the given map level
 * @returns {tf.types.mapResolution} - | {@link tf.types.mapResolution} the corresponding map resolution
 * @deprecated This global function will soon be removed: use {@link tf.units.GetResolutionByLevel} instead
*/
function TGetResolutionByLevel(level) { return tf.units.GetResolutionByLevel(level); }
/**
 * @public
 * @global
 * @function
 * @summary - Obtains the minimum map level required to display the given map extent
 * @param {deprecatedMapCoords1} pointNW - the left top corner of the extent
 * @param {deprecatedMapCoords1} pointSE - the right bottom corner of the extent
 * @returns {tf.types.mapLevel} - | {@link tf.types.mapLevel} the minimum map level required to display the given map extent
 * @deprecated This global function will soon be removed: use {@link tf.units.GetBoundsZoomLevel} instead, with an updated map coordinate format
*/
function TGetBoundsZoomLevel(pointNW, pointSE, width, height) { return tf.units.GetBoundsZoomLevel([pointNW.longitude, pointNW.latitude], [pointSE.longitude, pointSE.latitude], width, height); }
/**
 * @public
 * @global
 * @function
 * @summary - Provides information about the Browser being used
 * @returns {tf.browser.Type} - | {@link tf.browser.Type} information about the browser being used
 * @deprecated This global function will soon be removed: use {@link tf.browser.Type} instead
*/
function TGetBrowserType() { return tf.browser.Type; }
/**
 * @public
 * @global
 * @function
 * @summary - Tests if the Browser being used is compatible with the TerraFly API
 * @returns {boolean} - | {@link boolean } <b>true</b> if the Browser is compatible, <b>false</b> otherwise
 * @deprecated This global function will soon be removed: use {@link tf.browser.IsCompatible} instead
*/
function TBrowserIsCompatible() { return tf.browser.IsCompatible(); }
/**
 * @public
 * @function
 * @summary - Helper function
 * @param {string} serviceUrl - the service url
 * @param {tf.types.latitude} Lat - the desired latitude
 * @param {tf.types.longitude} Lng - the desired longitude
 * @param {TAddressReturnAddressArrayCallback | TAddressReturnObjectCallback} callBack - the callback function, of a type compatible with the service being used
 * @returns {void} - | {@link void} no return value
 * @deprecated  This global function will soon be removed: use {@link tf.services.ReverseGeocoder} instead
*/
tf.helpers.GetAddressFromServiceByLatLng = function (serviceUrl, Lat, Lng, callBack) {
    var url = serviceUrl + "Lat=" + encodeURIComponent(Lat) + "&Lng=" + encodeURIComponent(Lng);
    return tf.js.RemoteScriptCall(url, callBack);
}
/**
 * A callback function that can be passed to the global function {@link TGetAddressByLatLngPro}
 * @public
 * @callback TAddressReturnAddressArrayCallback
 * @param {array} addressArray- an array of addresses
 * @param {string} errorMsg - an empty string when {@link TGetAddressByLatLngPro} is successful, otherwise an error message
 * @returns {void} - | {@link void} no return value
 */
/**
 * @public
 * @global
 * @function
 * @summary - Accesses a TerraFly service to obtain the address corresponding to the given latitude and longitude coordinates; calls the given call back function to report results
 * @param {tf.types.latitude} Lat - the desired latitude
 * @param {tf.types.longitude} Lng - the desired longitude
 * @param {TAddressReturnAddressArrayCallback} callBack - the callback function
 * @returns {void} - | {@link void} no return value
 * @deprecated  This global function will soon be removed: use {@link tf.services.ReverseGeocoder} instead
*/
function TGetAddressesByLatLngPro(Lat, Lng, callBack) {
    var strServer = "http://tfservice.cs.fiu.edu/AddByCoordinate/Default.aspx?";
    return tf.helpers.GetAddressFromServiceByLatLng(strServer, Lat, Lng, callBack);
}
/**
 * A callback function that can be passed to the global function {@link TGetAddressByLatLng}
 * @public
 * @callback TAddressReturnObjectCallback
 * @param {TAddressReturnObject} addressObject - the address object obtained from the remote service
 * @returns {void} - | {@link void} no return value
 */
/**
 * @public
 * @global
 * @function
 * @summary - Accesses a TerraFly service to obtain the address corresponding to the given latitude and longitude coordinates; calls the given call back function to report results
 * @param {tf.types.latitude} Lat - the desired latitude
 * @param {tf.types.longitude} Lng - the desired longitude
 * @param {TAddressReturnObjectCallback} callBack - the callback function
 * @returns {void} - | {@link void} no return value
 * @deprecated  This global function will soon be removed: use {@link tf.services.ReverseGeocoder} instead
*/
function TGetAddressByLatLng(Lat, Lng, callBack) {
    var strServer = "http://tfservice.cs.fiu.edu/AddByCoordinate/Compact.aspx?";
    return tf.helpers.GetAddressFromServiceByLatLng(strServer, Lat, Lng, callBack);
}
/**
 * A callback function that can be passed to the global function {@link TGetLatLngByAddress}
 * @public
 * @callback TGetLatLngByAddressCallBack
 * @param {tf.types.latitude} lat - the obtained latitude
 * @param {tf.types.longitude} lon - the obtained longitude
 * @param {string} errorMsg - an empty string when {@link TGetLatLngByAddress} is successful, otherwise an error message
 * @param {number} errorMsg - an empty string when {@link TGetLatLngByAddress} is successful, otherwise an error message
 * @returns {void} - | {@link void} no return value
 */
/**
 * @public
 * @global
 * @function
 * @summary - Accesses a TerraFly service to obtain the latitude and longitude coordinates corresponding to the given address; calls the given call back function to report results
 * @param {string} addressFull - the desired address
 * @param {TGetLatLngByAddressCallBack} callBack - the callback function
 * @returns {void} - | {@link void} no return value
 * @deprecated  This global function will soon be removed: use {@link tf.services.Geocoder} instead
*/
function TGetLatLngByAddress(addressFull, callBack) {
    /*var strServer = "http://tfservice.cs.fiu.edu/coordinatebyadd/Default.aspx?";
    var url = strServer + "street=" + encodeURIComponent(addressFull);
    //tf.GetDebug().LogIfTest(url);
    url = "http://vn4.cs.fiu.edu/cgi-bin/geocoder.cgi?street=hollywood%20fl";
    return tf.js.RemoteScriptCall(url, callBack);*/
    if (!!(callBack = tf.js.GetFunctionOrNull(callBack))) {
        new tf.services.Geocoder({
            address: addressFull, callBack: function (data) {
                var pointCoords = !!data ? data.pointCoords : [0, 0];
                callBack(pointCoords[1], pointCoords[0], data.errormsg, data.geocoderlevel);
            }
        });
    }
}
/**
 * A callback function that can be passed to the global functions {@link TGetAerialImagerySources_UTM} and {@link TGetAerialImagerySources}
 * @public
 * @callback TGetAerialImagerySourcesCallBack
 * @param {ResourceArray} resources - the obtained resources
 * @param {string} errorMsg - an empty string when {@link TGetAerialImagerySources_UTM} or {@link TGetAerialImagerySources} are successful, otherwise an error message
 * @returns {void} - | {@link void} no return value
 */
/**
 * @public
 * @global
 * @function
 * @summary - Accesses a TerraFly service to obtain information about the availability of TerraFly aerial image resources 
 * (see {@link Resources}) corresponding to the given UTM coordinates amd map resolution; calls the given call back function to report results
 * @param {number} X - the desired UTM X coordinate
 * @param {number} Y - the desired UTM Y coordinate
 * @param {number} utm - the desired UTM zone
 * @param {tf.types.mapResolution} res - the given map resolution
 * @param {TGetAerialImagerySourcesCallBack} callBack - the callback function
 * @returns {void} - | {@link void} no return value
 * @deprecated A replacement for this function is now available through the [Raster Source List Service]{@link tf.services.RasterSourceList} service
*/
function TGetAerialImagerySources_UTM(X, Y, utm, res, callBack) {
    var strServer = "http://tfcore.cs.fiu.edu/GetAerialImagerySources/Stage/default.aspx?";
    var url = strServer;
    url = url + "X=" + encodeURIComponent(X) + "";
    url = url + "&Y=" + encodeURIComponent(Y) + "";
    url = url + "&utm=" + encodeURIComponent(utm) + "";
    url = url + "&res=" + encodeURIComponent(res) + "";
    return tf.js.RemoteScriptCall(url, callBack);
}
/**
 * @public
 * @global
 * @function
 * @summary - Accesses a TerraFly service to obtain information about the availability of TerraFly aerial image resources 
 * (see {@link Resources}) corresponding to the given UTM coordinates amd map resolution; calls the given call back function to report results
 * @param {tf.types.longitude} lng - the desired longitude
 * @param {tf.types.latitude} lat - the desired latitude
 * @param {tf.types.mapResolution} res - the given map resolution
 * @param {TGetAerialImagerySourcesCallBack} callBack - the callback function
 * @returns {void} - | {@link void} no return value
 * @deprecated A replacement for this function is now available through the [Raster Source List Service]{@link tf.services.RasterSourceList} service
*/
function TGetAerialImagerySources(lng, lat, res, callBack) {
    var utm = tf.units.GdcToUtm([lng, lat]); TGetAerialImagerySources_UTM(utm[0], utm[1], utm[2], res, callBack);
}
/**
 * @public
 * @class
 * @summary Instances of this class are automatically created to receive data returned by remote services called via script insertion
 * @param {object} headElement - the script element 
 * @param {object} key - a unique identifier
 * @param {string} baseUrl - an url
 * @param {function} callBack - the callback function that will receive the data returned by the service
 * @deprecated Services using script injection are being updated, a replacement for this class will soon be available in the {@link tf.services} namespace
 */
tf.js.RemoteScriptCallReceiver = function (headElement, key, baseUrl, callBack) {
    var theThis = null;
    var theCallBack = null;
    var scriptID = null;
    var script = null;
    /**
     * @public
     * @function
     * @summary - Receives the response from the remote service
     * @param {...object} parameters - the parameters to be passed to the callback function
     * @returns {void} - | {@link void} no return value
    */
    this.ReceiveScriptResponse = function () { return receiveScriptResponse.apply(theThis, arguments); }
    function receiveScriptResponse() { removeScript(); if (!!theCallBack) { theCallBack.apply(null, arguments); } }
    function removeScript() {
        if (!!script) { var parentElem = script.parentNode; parentElem && (parentElem.removeChild(script)); }
    }
    function initialize() {
        if (!!(theCallBack = tf.js.GetFunctionOrNull(callBack)) && !!key && !!headElement) {
            var localCallBackStr = 'tf.js.GetRemoteScriptCallDispatcher().ReceiveScriptResponse(' + key + ')';
            script = document.createElement("script");
            script.id = scriptID = "TFScriptCallBack_" + key;
            script.defer = true;
            script.type = "text/javascript";
            script.src = baseUrl + "&CallBackFun=" + encodeURIComponent(localCallBackStr) + ("&SCRIPT_ID=" + scriptID) + "&a=" + Math.random();
            //tf.GetDebug().LogIfTest('calling remote service by script id:' + scriptID + ' url: ' + script.src);
            headElement.appendChild(script);
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * @public
 * @class
 * @summary A singleton instance of this class (see {@link tf.js.GetRemoteScriptCallDispatcher}) is used to dispatch requests to remote services using script insertion
 * @deprecated Services using script injection are being updated, a replacement for this class will soon be available in the {@link tf.services} namespace
 */
tf.js.RemoteScriptCallDispatcher = function () {
    var theThis = null;
    var headElement = null;
    var currentKey;
    var scriptCallResponseReceivers = null;
    /**
     * @public
     * @function
     * @summary - Initiates a request to a remove service via script insertion
     * @param {string} url - an url pointing to the remote service
     * @param {function} callBack - the callback function that will receive the data returned by the service
     * @returns {void} - | {@link void} no return value
    */
    this.DoScriptCall = function (url, callBack) {
        if (!!headElement) {
            scriptCallResponseReceivers[tf.js.MakeObjectKey(currentKey)] = new tf.js.RemoteScriptCallReceiver(headElement, currentKey, url, callBack);
            ++currentKey;
        }
    }
    /**
     * @public
     * @function
     * @summary - Receives the response from the remote service
     * @param {object} key - a unique identifier
     * @returns {void} - | {@link void} no return value
    */
    this.ReceiveScriptResponse = function (key) {
        var actualKey = tf.js.MakeObjectKey(key);
        var scriptCallResponseReceiver = scriptCallResponseReceivers[actualKey];
        if (!!scriptCallResponseReceiver) {
            delete scriptCallResponseReceivers[actualKey];
            return scriptCallResponseReceiver.ReceiveScriptResponse;
        }
        return dummyResponse;
    }
    function dummyResponse() { }
    function initialize() {
        headElement = document.getElementsByTagName("HEAD").item(0);
        scriptCallResponseReceivers = {};
        currentKey = 1;
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * @public
 * @function
 * @summary - Obtains the singleton instance of {@link tf.js.RemoteScriptCallDispatcher}
 * @returns {tf.js.RemoteScriptCallDispatcher} - | {@link tf.js.RemoteScriptCallDispatcher} the singleton instance
 * @deprecated Services using script injection are being updated, a replacement for this class will soon be available in the {@link tf.services} namespace
*/
tf.js.GetRemoteScriptCallDispatcher = function () { if (!tf.g_scriptCallDispatcher) { tf.g_scriptCallDispatcher = new tf.js.RemoteScriptCallDispatcher(); } return tf.g_scriptCallDispatcher; }
/**
 * @public
 * @function
 * @summary - Initiates a remote request via script insertion
 * @param {string} url - an url pointing to the remote service
 * @param {function} callBack - the callback function that will receive the data returned by the service
 * @returns {void} - | {@link void} no return value
 * @deprecated Services using script injection are being updated, a replacement for this class will soon be available in the {@link tf.services} namespace
*/
tf.js.RemoteScriptCall = function (url, callBack) { return tf.js.GetRemoteScriptCallDispatcher().DoScriptCall(url, callBack); }
/**
 * class TFHelpers
 * @public
 * @class
 * @namespace
 * @description TFHelpers is a deprecated namespace that will soon be removed.
*/
var TFHelpers = {};
/**
 * @public
 * @class
 * @summary An instance of this class is created to parse url parameters
 * @param {function} callBack - a callback function that will receive the parser url parameters
 * @param {string} url - a string containing an url with parameters, like <b>"http://server.fiu.edu/#a=1&b=2&c=test"</b>
 * @param {string} defaults - a string containing default url parameters
 * @deprecated This class has been superseeded by classes and functions available in the {@link tf.urlapi} namespace, and will soon be removed.
 */
TFHelpers.UrlParser = function (callBack, url, defaults) {
    var processingParamNum = 0;
    var parameters = null;
    /**
     * @private
     * @function
     * @summary - Retrieves the parsed parameters object
     * @returns {object} - | {@link object} the parsed parameters object
    */
    this.GetParameters = function () { return parameters; }
    function parseParameters() {
        parameters = defaults ? defaults : [];
        var indexSep;
        var urlParamString =
            ((indexSep = url.indexOf("?")) != -1) ? url.slice(indexSep + 1) :
                (((indexSep = url.indexOf("#")) != -1) ? url.slice(indexSep + 1) : "");
        var paramStringArray = urlParamString.split("&");
        var paramStringArrayLen = paramStringArray.length;
        var skipRemoteCalls = false;
        if (paramStringArrayLen) {
            for (var i = 0; i < paramStringArrayLen; ++i) {
                var equalIndex = paramStringArray[i].indexOf("=");
                if (equalIndex != -1) {
                    var key = paramStringArray[i].substring(0, equalIndex).toLowerCase();
                    var value = paramStringArray[i].substring(equalIndex + 1, paramStringArray[i].length);
                    parameters[key] = unescape(value);
                }
            }
            if (!skipRemoteCalls) {
                var paramsWithDDURLDD = [
                    TFConsts.paramNameLegend,
                    tf.consts.paramNameLegendH,
                    tf.consts.paramNameLegendM
                ];
                var paramsWithDDURLDDCount = paramsWithDDURLDD.length;
                if (paramsWithDDURLDDCount) {
                    for (var i = 0 ; i < paramsWithDDURLDDCount ; i++) {
                        var thisParamName = paramsWithDDURLDD[i];
                        var thisParam = parameters[thisParamName];
                        if (thisParam) {
                            processingParamNum++;
                            new tf.urlapi.URLPartsLoader(thisParamName, thisParam, onLoadedParamParts);
                        }
                    }
                }
                else { doCallBack(); }
            }
            else { doCallBack(); }
        }
    }
    function onLoadedParamParts(paramName, param) {
        parameters[paramName] = param;
        if (! --processingParamNum) { doCallBack(); }
    }
    function doCallBack() { setTimeout(doActualCallBack, 10); }
    function doActualCallBack() { callBack(parameters); }
    (function construct() { parseParameters(); })();
};
/**
 * @public
 * @typedef {object} deprecatedMapCoords1
 * @property {tf.types.latitude} latitude - the latitude
 * @property {tf.types.longitude} longitude - the longitude
 * @deprecated This format will soon be removed along with functions that support it. TerraFly applications should replace the 
 * use of these functions with current API functions that use the {@link tf.types.mapCoordinates} format
 */
/**
 * @public
 * @typedef {object} deprecatedMapCoords2
 * @property {tf.types.latitude} Lat - the latitude
 * @property {tf.types.longitude} Lon - the longitude
 * @deprecated This format will soon be removed along with functions that support it. TerraFly applications should replace the 
 * use of these functions with current API functions that use the {@link tf.types.mapCoordinates} format
 */
/**
 * @public
 * @typedef {object} deprecatedMapCoords3
 * @property {tf.types.latitude} lat - the latitude
 * @property {tf.types.longitude} lon - the longitude
 * @deprecated This format will soon be removed along with functions that support it. TerraFly applications should replace the 
 * use of these functions with current API functions that use the {@link tf.types.mapCoordinates} format
 */
/**
 * @public
 * @typedef {object} deprecatedMapCoords4
 * @property {tf.types.latitude} Latitude - the latitude
 * @property {tf.types.longitude} Longitude - the longitude
 * @deprecated This format will soon be removed along with functions that support it. TerraFly applications should replace the 
 * use of these functions with current API functions that use the {@link tf.types.mapCoordinates} format
 */
/**
 * @public
 * @typedef {object} deprecatedPixelCoords1
 * @property {number} X - horizontal pixel coordinate
 * @property {number} Y - vertical pixel coordinate
 * @deprecated This format will soon be removed along with functions that support it. TerraFly applications should replace the 
 * use of these functions with current API functions that use the {@link tf.types.mapCoordinates} format
 */
/**
 * Map extent format used by legacy MAP-API {@link TMap} instances
 * @public
 * @typedef {object} deprecatedMapExtent
 * @property {tf.types.longitude} longitude1 - the minimum longitude
 * @property {tf.types.latitude} latitude1 - the maximum latitude
 * @property {tf.types.longitude} longitude2 - the maximum longitude
 * @property {tf.types.latitude} latitude2 - the minimum latitude
 * @deprecated This format will soon be removed along with functions that support it. TerraFly applications should replace the 
 * use of these functions with current API functions that use the {@link tf.types.mapExtent} format
 */
/**
 * A callback function that can be passed to certain deprecated {@link TMap} AddOn... listener functions
 * @public
 * @callback TMapLatLonCallBack
 * @param {tf.types.latitude} latitude - the map latitude where the event occurred
 * @param {tf.types.longitude} longitude - the map longitude where the event occurred
 * @returns {void} - | {@link void} no return value
 */
/**
 * A callback function that can be passed to certain deprecated {@link TMap} AddOn... listener functions
 * @public
 * @callback TMapLevelCallBack
 * @param {tf.types.mapLevel} level - the map level associated with the event
 * @returns {void} - | {@link void} no return value
 */
/**
 * A callback function that can be passed to certain deprecated {@link TMap} AddOn... listener functions
 * @public
 * @callback TMapTypeCallBack
 * @param {tf.types.mapType} type - the map type associated with the event
 * @returns {void} - | {@link void} no return value
 */
/**
 * @public
 * @global
 * @class
 * @summary This is the <b>legacy MAP-API TMap class</b>, which has been replaced by the {@link tf.map.Map} class, and will soon be removed
 * @param {HTMLElementLike} container - the HTML container where the map is created
 * @param {tf.types.latitude} latitude - the initial map center latitude, defaults to {@link tf.consts.defaultLatitude}
 * @param {tf.types.longitude} longitude - the initial map center longitude, defaults to {@link tf.consts.defaultLongitude}
 * @param {tf.types.mapLevel} level - the initial map level, defaults to {@link tf.consts.defaultLevel}
 * @param {function} onCreatedCallBack - called when map creation is complete
 * @param {void} deprecated1 - legacy parameter placeholder
 * @param {void} deprecated2 - legacy parameter placeholder
 * @param {tf.types.mapEngine} mapEngine - the Vector Tile engine, defaults to {@link tf.consts.mapnik2Engine}
 * @param {tf.types.mapType} initMapType - the initial map type, defaults to {@link tf.consts.typeNameHybrid}
 * @param {tf.types.mapAerialSource} mapAerialSource - the source of aerial tiles used by the map, defaults to {@link tf.consts.sourceName_best_available}
 * @param {void} deprecated3 - legacy parameter placeholder
 * @deprecated  This global class will soon be removed: use {@link tf.map.Map} instead
 * @extends {tf.map.Map}
*/
var TMap = function (
    container,
    latitude,
    longitude,
    level,
    onCreatedCallBack,
    deprecated1,
    deprecated2,
    mapEngine,
    initMapType,
    mapAerialSource,
    deprecated3) {
    var theThis = null, onCallBackCall = null, msgContents = '', allOldListeners = null;
    /**
     * @public
     * @function
     * @summary - Shows or hides a map panel
     * @param {tf.types.mapPanelName} strPanel - the map panel
     * @param {tf.types.mapPanelVisibilityState} strVis - the desired visibility state
     * @returns {void} - | {@link void} no return value
     * @deprecated  This function will soon be removed: use [ShowPanel]{@link tf.map.Map#ShowPanel} instead
    */
    this.SetPanelVisibility = function (strPanel, strVis) {
        if (tf.js.GetIsNonEmptyString(strVis)) {
            var isHidden = tf.consts.strHidePanel.toLowerCase() == strVis.toLowerCase();
            theThis.ShowPanel(strPanel, !isHidden);
        }
    }
    /**
     * @public
     * @function
     * @summary - Retrieves the current visibility state of a map panel
     * @param {tf.types.mapPanelName} strPanel - the map panel
     * @returns {boolean} - | {@link boolean} <b>true</b> if the panel is visible, <b>false</b> otherwise
     * @deprecated  This function will soon be removed: use [IsPanelShowing]{@link tf.map.Map#IsPanelShowing} instead
    */
    this.GetPanelVisibility = function (strPanel) { return theThis.IsPanelShowing(strPanel); }
    /**
     * @public
     * @function
     * @summary - Sets a the value of a string used by the map when interacting with some TerraFly services
     * @param {string} tfPassThroughString - the string value
     * @returns {void} - | {@link void} no return value
     * @deprecated There is a misspelling in this function's name and it will soon be removed: use [SetTFPassThroughString]{@link tf.map.Map#SetTFPassThroughString} instead
    */
    this.SetTFPassTroughString = function (tfPassThroughString) { return theThis.SetTFPassThroughString(tfPassThroughString); }
    /**
     * @public
     * @function
     * @summary - Sets the map type 
     * @param {tf.types.mapType} type - the map type
     * @returns {void} - | {@link void} no return value
     * @deprecated This function will soon be removed: use [SetMapType]{@link tf.map.Map#SetMapType} instead
    */
    this.MapMode = function (type) { theThis.SetMapType(type); }
    /**
     * @public
     * @function
     * @summary - Adds a listener for the {@link tf.consts.mapMoveEndEvent} event
     * @param {TMapLatLonCallBack} callBack - the callback for event notifications
     * @returns {tf.events.EventListener} - | {@link tf.events.EventListener} the event listener
     * @deprecated Individual listener creation will soon be removed, use [AddListener]{@link tf.map.Map#AddListener} or [AddListeners]{@link tf.map.Map#AddListeners} instead
    */
    this.AddOnMoveEndListener = function (callBack) { return addOldFormatListener(tf.consts.mapMoveEndEvent, callBack); }
    /**
     * @public
     * @function
     * @summary - Adds a listener for the {@link tf.consts.mapMouseMoveEvent} event
     * @param {TMapLatLonCallBack} callBack - the callback for event notifications
     * @returns {tf.events.EventListener} - | {@link tf.events.EventListener} the event listener
     * @deprecated Individual listener creation will soon be removed, use [AddListener]{@link tf.map.Map#AddListener} or [AddListeners]{@link tf.map.Map#AddListeners} instead
    */
    this.AddOnRollOverListener = function (callBack) { return addOldFormatListener(tf.consts.mapMouseMoveEvent, callBack); }
    /**
     * @public
     * @function
     * @summary - Adds a listener for the {@link tf.consts.mapClickEvent} event
     * @param {TMapLatLonCallBack} callBack - the callback for event notifications
     * @returns {tf.events.EventListener} - | {@link tf.events.EventListener} the event listener
     * @deprecated Individual listener creation will soon be removed, use [AddListener]{@link tf.map.Map#AddListener} or [AddListeners]{@link tf.map.Map#AddListeners} instead
    */
    this.AddOnClickListener = function (callBack) { return addOldFormatListener(tf.consts.mapClickEvent, callBack); }
    /**
     * @public
     * @function
     * @summary - Adds a listener for the {@link tf.consts.mapDblClickEvent} event
     * @param {TMapLatLonCallBack} callBack - the callback for event notifications
     * @returns {tf.events.EventListener} - | {@link tf.events.EventListener} the event listener
     * @deprecated Individual listener creation will soon be removed, use [AddListener]{@link tf.map.Map#AddListener} or [AddListeners]{@link tf.map.Map#AddListeners} instead
    */
    this.AddOnDoubleClickListener = function (callBack) { return addOldFormatListener(tf.consts.mapDblClickEvent, callBack); }
    /**
     * @public
     * @function
     * @summary - Adds a listener for the {@link tf.consts.mapLevelChangeEvent} event
     * @param {TMapLevelCallBack} callBack - the callback for event notifications
     * @returns {tf.events.EventListener} - | {@link tf.events.EventListener} the event listener
     * @deprecated Individual listener creation will soon be removed, use [AddListener]{@link tf.map.Map#AddListener} or [AddListeners]{@link tf.map.Map#AddListeners} instead
    */
    this.AddOnZoomEndListener = function (callBack) { return addOldFormatListener(tf.consts.mapLevelChangeEvent, callBack); }
    /**
     * @public
     * @function
     * @summary - Adds a listener for the {@link tf.consts.mapTypeChangeEvent} event
     * @param {TMapTypeCallBack} callBack - the callback for event notifications
     * @returns {tf.events.EventListener} - | {@link tf.events.EventListener} the event listener
     * @deprecated Individual listener creation will soon be removed, use [AddListener]{@link tf.map.Map#AddListener} or [AddListeners]{@link tf.map.Map#AddListeners} instead
    */
    this.AddOnModeChangeListener = function (callBack) { return addOldFormatListener(tf.consts.mapTypeChangeEvent, callBack); }
    /**
     * @public
     * @function
     * @summary - Adds a listener for the {@link tf.consts.mapFullScreenEvent} event
     * @param {TMapLatLonCallBack} callBack - the callback for event notifications
     * @returns {tf.events.EventListener} - | {@link tf.events.EventListener} the event listener
     * @deprecated Individual listener creation will soon be removed, use [AddListener]{@link tf.map.Map#AddListener} or [AddListeners]{@link tf.map.Map#AddListeners} instead
    */
    this.AddOnFullScreenListener = function (callBack) { return addOldFormatListener(tf.consts.mapFullScreenEvent, callBack); }
    /**
     * @public
     * @function
     * @summary - Removes an event listener
     * @param {tf.events.EventListener} theListener - the event listener to be removed
     * @returns {void} - | {@link void} no return value
     * @deprecated To remove an instance of {@link tf.events.EventListener} call the instance's [OnDelete]{@link tf.events.EventListener#OnDelete} function directly
    */
    this.RemoveListener = function (theListener) { if (theListener instanceof tf.events.EventListener) { theListener.OnDelete(); } }
    /**
     * @public
     * @function
     * @summary - This type of event listener is no longer available
     * @param {function} callBack - the callback for event notifications
     * @returns {null} - | {@link null} an invalid event listener
     * @deprecated
    */
    this.AddOnFlyEndListener = function (callBack) { return addOldFormatListener(tf.consts.mapAnimationEndEvent, callBack); }
    /**
     * @public
     * @function
     * @summary - This type of event listener is no longer available
     * @param {function} callBack - the callback for event notifications
     * @returns {null} - | {@link null} an invalid event listener
     * @deprecated
    */
    this.AddOnLegendChangeListener = function (callBack) { return null; }
    /**
     * @public
     * @function
     * @summary - This type of event listener is no longer available
     * @param {function} callBack - the callback for event notifications
     * @returns {null} - | {@link null} an invalid event listener
     * @deprecated
    */
    this.AddOnFlyCrashedListener = function (callBack) { return null; }
    /**
     * @public
     * @function
     * @summary - This type of event listener is no longer available
     * @param {function} callBack - the callback for event notifications
     * @returns {null} - | {@link null} an invalid event listener
     * @deprecated
    */
    this.AddOnTileAddedListener = function (callBack) { return null; }
    /**
     * @public
     * @function
     * @summary - This type of event listener is no longer available
     * @param {function} callBack - the callback for event notifications
     * @returns {null} - | {@link null} an invalid event listener
     * @deprecated
    */
    this.AddOnTileRemovedListener = function (callBack) { return null; }
    /**
     * @public
     * @function
     * @summary - This type of event listener is no longer available
     * @param {function} callBack - the callback for event notifications
     * @returns {null} - | {@link null} an invalid event listener
     * @deprecated
    */
    this.AddDebugListener = function (callBack) { return null; }
    /**
     * @public
     * @function
     * @summary - Shows the Information Popup
     * @param {tf.types.latitude} latitude - the latitude associated with the popup
     * @param {tf.types.longitude} longitude - the longitude associated with the popup
     * @param {void} deprecated1 - ignored
     * @param {string} title - Title of the popup
     * @param {HTMLContent} content - Content of the popup
     * @returns {void} - | {@link void} no return value
     * @deprecated This function will soon be removed: use [ShowInfoPopup]{@link tf.map.Map#ShowInfoPopup} instead
    */
    this.ShowInfoWindow = function (latitude, longitude, deprecated1, title, content) { theThis.ShowInfoPopup(title, content, [longitude, latitude]); }
    /**
     * @public
     * @function
     * @summary - Hides the Information Popup
     * @returns {void} - | {@link void} no return value
     * @deprecated This function will soon be removed: use [HideInfoPopup]{@link tf.map.Map#HideInfoPopup} instead
    */
    this.HideInfoWindow = function () { return theThis.HideInfoPopup(); }
    /**
     * @public
     * @function
     * @summary - This function is no longer available
     * @returns {void} - | {@link void} no return value
     * @deprecated This function is no longer available
    */
    this.ShowInfoWindowTabs = function () { }
    /**
     * @public
     * @function
     * @summary - This function is no longer available
     * @returns {void} - | {@link void} no return value
     * @deprecated This function is no longer available
    */
    this.ViewDebugPanel = function () { }
    /**
     * @public
     * @function
     * @summary - This function is no longer available
     * @returns {void} - | {@link void} no return value
     * @deprecated This function is no longer available
    */
    this.ViewTileURL = function () { }
    /**
     * @public
     * @function
     * @summary - This function is no longer available
     * @returns {void} - | {@link void} no return value
     * @deprecated This function is no longer available
    */
    this.ShowAreaSelector = function () { }
    /**
     * @public
     * @function
     * @summary - This function is no longer available
     * @returns {void} - | {@link void} no return value
     * @deprecated This function is no longer available
    */
    this.HideAreaSelector = function () { }
    /**
     * @public
     * @function
     * @summary - This function is no longer available
     * @returns {void} - | {@link void} no return value
     * @deprecated This function is no longer available
    */
    this.GetOverlayComposite = function () { }
    /**
     * @public
     * @function
     * @summary - This function is no longer available
     * @returns {void} - | {@link void} no return value
     * @deprecated This function is no longer available
    */
    this.GetColorByLatLng = function () { }
    /**
     * @public
     * @function
     * @summary - This function is no longer available
     * @returns {void} - | {@link void} no return value
     * @deprecated This function is no longer available
    */
    this.SetMapOnAreaSelectedListener = function () { }
    /**
     * @public
     * @function
     * @summary - This function is no longer available
     * @returns {void} - | {@link void} no return value
     * @deprecated This function is no longer available
    */
    this.SetBorderVisibility = function () { }
    /**
     * @public
     * @function
     * @summary - This function is no longer available
     * @returns {void} - | {@link void} no return value
     * @deprecated This function is no longer available
    */
    this.SetPanelPosition = function () { }
    /**
     * @public
     * @function
     * @summary - This function is no longer available
     * @returns {void} - | {@link void} no return value
     * @deprecated This function is no longer available
    */
    this.SetZoomPanelMode = function () { }
    /**
     * @public
     * @function
     * @summary - This function is no longer available
     * @returns {void} - | {@link void} no return value
     * @deprecated This function is no longer available
    */
    this.GetFPS = function () { }
    /**
     * @public
     * @function
     * @summary - This function is no longer available
     * @returns {void} - | {@link void} no return value
     * @deprecated This function is no longer available
    */
    this.SetFPS = function () { }
    /**
     * @public
     * @function
     * @summary - This function is no longer available
     * @returns {void} - | {@link void} no return value
     * @deprecated This function is no longer available
    */
    this.SetMessageAlpha = function () { }
    /**
     * @public
     * @function
     * @summary - This function is no longer available
     * @returns {void} - | {@link void} no return value
     * @deprecated This function is no longer available
    */
    this.MBFadeAni = function () { }
    /**
     * @public
     * @function
     * @summary - This function is no longer available
     * @returns {void} - | {@link void} no return value
     * @deprecated This function is no longer available
    */
    this.MBFadeCheck = function () { }
    /**
     * @public
     * @function
     * @summary - This function is no longer available
     * @returns {void} - | {@link void} no return value
     * @deprecated This function is no longer available
    */
    this.SetFlyMode = function () { }
    /**
     * @public
     * @function
     * @summary - This function is no longer available
     * @returns {void} - | {@link void} no return value
     * @deprecated This function is no longer available
    */
    this.PauseFly = function () { }
    /**
     * @public
     * @function
     * @summary - This function is no longer available
     * @returns {void} - | {@link void} no return value
     * @deprecated This function is no longer available
    */
    this.ContinueFly = function () { }
    /**
     * @public
     * @function
     * @summary - Sets contents that will be displayed the next time the function [ShowMessageBar]{@link TMap.Map#ShowMessageBar} is called
     * @param {HTMLElementLike} contents - the contents to be displayed
     * @returns {void} - | {@link void} no return value
     * @deprecated This function will soon be removed: use [ShowMessage]{@link tf.map.Map#ShowMessage} instead
    */
    this.SetMessageText = function (contents) { msgContents = contents; }
    /**
     * @public
     * @function
     * @summary - Shows the Message Popup
     * @returns {void} - | {@link void} no return value
     * @deprecated This function will soon be removed: use [ShowMessage]{@link tf.map.Map#ShowMessage} instead
    */
    this.ShowMessageBar = function () { theThis.ShowMessage(msgContents); }
    /**
     * @public
     * @function
     * @summary - Hides the Information Popup
     * @returns {void} - | {@link void} no return value
     * @deprecated This function will soon be removed: use [HideMessage]{@link tf.map.Map#HideMessage} instead
    */
    this.HideMessageBar = function () { return theThis.HideMessage(); }
    /**
     * @public
     * @function
     * @summary - Sets the time after which the message popup automatically hides itself
     * @param {number} timeoutSecs - the time in seconds
     * @returns {void} - | {@link void} no return value
     * @deprecated This function will soon be removed: use [SetMessageTimeout]{@link tf.map.Map#SetMessageTimeout} instead
    */
    this.SetMessageBarInterval = function (timeoutSecs) { return theThis.SetMessageTimeout(timeoutSecs); }
    /**
     * @public
     * @function
     * @summary - Checks if the map is performing an animation
     * @returns {boolean} - | {@link boolean} <b>true</b> if an animation is in progress, <b>false</b> otherwise
     * @deprecated This function will soon be removed: use [GetIsAnimating]{@link tf.map.Map#GetIsAnimating} instead
    */
    this.GetFlyMode = function () { return theThis.GetIsAnimating(); }
    /**
     * @public
     * @function
     * @summary - Stops an ongoing map animation
     * @returns {void} - | {@link void} no return value
     * @deprecated This function will soon be removed: use [EndAnimation]{@link tf.map.Map#EndAnimation} instead
    */
    this.StopFly = function () { return theThis.EndAnimation(); }
    /**
     * @public
     * @function
     * @summary - Adds a legacy MAP-API [TLayer]{@link TLayer} instance
     * @param {string} strLayerName - the layer name
     * @param {string} strLayerDesc - the layer description
     * @param {boolean} isChecked - <b>true</b> to create a visible layer, <b>false</b> to create a hidden layer
     * @param {boolean} isSecret - <b>true</b> to prevent the layer name from being displayed in the Map Layers popup,<b>false</b> to display it in the popup
     * @param {color} layerColor - legacy parameter no longer used
     * @returns {TLayer} - | {@link TLayer} the legacy TLayer instance
     * @deprecated This function will soon be removed: use [AddFeatureLayer]{@link tf.map.Map#AddFeatureLayer} instead
    */
    this.AddLayer = function (strLayerName, strLayerDesc, isChecked, isSecret, layerColor) {
        return theThis.deprecatedAddLegacyLayer({
            name: strLayerName, description: strLayerDesc, isVisible: isChecked, isHidden: isSecret, color: layerColor
        });
    }
    /**
     * @public
     * @function
     * @summary - Notifies the map that its container may have been resized
     * @returns {void} - | {@link void} no return value
     * @deprecated This function will soon be removed: use [OnResize]{@link tf.map.Map#OnResize} instead
    */
    this.SetSize = function () { return theThis.OnResize(); }
    /**
     * @public
     * @function
     * @summary - Obtains the size of the map in pixels
     * @returns {deprecatedPixelCoords1} - | {@link deprecatedPixelCoords1} the map size in pixels
     * @deprecated This function will soon be removed: use [OnResize]{@link tf.map.Map#GetPixelSize} instead
    */
    this.GetSize = function () { var pixelSize = theThis.GetPixelSize(); return { X: pixelSize[0], Y: pixelSize[1] }; }
    /**
     * @public
     * @function
     * @summary - Adds a legacy MAP-API [TButton]{@link TButton} instance
     * @param {number} buttonX - horizontal pixel coordinates
     * @param {number} buttonY - vertical pixel coordinates
     * @param {string} buttonIconURL - url to button image background
     * @returns {TButton} - | {@link TButton} the legacy TButton instance
     * @deprecated This function will soon be removed: use instances of [Map HTML Controls]{@link tf.map.HTMLControl} instead
    */
    this.AddCustomizedButton = function (buttonX, buttonY, buttonIconURL) { return addCustomizedButton(buttonX, buttonY, buttonIconURL); }
    /**
     * @public
     * @function
     * @summary - Recenters the map to the given coordinates
     * @param {tf.types.latitude} latitude - the new map center latitude
     * @param {tf.types.longitude} longitude - the new map center longitude
     * @returns {void} - | {@link void} no return value
     * @deprecated This function will soon be removed: use [SetCenter]{@link tf.map.Map#SetCenter} instead
    */
    this.PanTo = function (latitude, longitude) { return theThis.SetCenter([longitude, latitude]); }
    /**
     * @public
     * @function
     * @summary - Incrementally recenters the map to the given coordinates 
     * @param {tf.types.latitude} latitude - the new map center latitude
     * @param {tf.types.longitude} longitude - the new map center longitude
     * @param {number} speed - the duration of the animation, in milliseconds
     * @param {TMapLatLonCallBack} callBack - if defined, receives a notification when the animation ends
     * @returns {void} - | {@link void} no return value
     * @deprecated This function will soon be removed: use [AnimatedSetCenter]{@link tf.map.Map#AnimatedSetCenter} instead
    */
    this.PanToAni = function (latitude, longitude, speed, callBack) {
        function sendDeprecatedNotification(notification) { callBack(notification.eventCoords[1], notification.eventCoords[0]); }
        if (!(callBack = tf.js.GetFunctionOrNull(callBack))) { sendDeprecatedNotification = null; }
        return theThis.AnimatedSetCenter([longitude, latitude], sendDeprecatedNotification, speed, true, tf.units.EaseLinear);
    }
    /**
     * @public
     * @function
     * @summary - Recenters the map to the given coordinates and changes the map level to the given level
     * @param {tf.types.latitude} latitude - the new map center latitude
     * @param {tf.types.longitude} longitude - the new map center longitude
     * @param {tf.types.mapLevel} level - the new map level
     * @returns {void} - | {@link void} no return value
     * @deprecated This function will soon be removed: use [SetCenterAndLevel]{@link tf.map.Map#SetCenterAndLevel} instead
    */
    this.CenterTo = function (latitude, longitude, level) { return theThis.SetCenterAndLevel([longitude, latitude], level); }
    /**
     * @public
     * @function
     * @summary - Sets the map level
     * @param {tf.types.mapLevel} level - the desired map level
     * @returns {void} - | {@link void} no return value
     * @deprecated This function will soon be removed: use [SetLevel]{@link tf.map.Map#SetLevel} instead
    */
    this.ZoomTo = function (level) { theThis.SetLevel(level); }
    /**
     * @public
     * @function
     * @summary - Incrementally changes the map level to the given level
     * @param {tf.mapLevel} newLevel - the desired new level
     * @param {TMapLevelCallBack} callBack - to receive a notification when the animation ends
     * @returns {void} - | {@link void} no return value
     * @deprecated This function will soon be removed: use [AnimatedSetLevel]{@link tf.map.Map#AnimatedSetLevel} instead
    */
    this.ZoomToAni = function (newLevel, callBack) {
        function sendDeprecatedNotification(notification) { callBack(notification.level); }
        if (!(callBack = tf.js.GetFunctionOrNull(callBack))) { sendDeprecatedNotification = null; }
        return theThis.AnimatedSetLevel(newLevel, sendDeprecatedNotification, undefined, true, tf.units.EaseLinear);
    }
    /**
     * @public
     * @function
     * @summary - Moves the map center by a pixel offset
     * @param {number} xPixel - horizontal pixel offset
     * @param {number} yPixel - vertical pixel offset
     * @returns {void} - | {@link void} no return value
     * @deprecated This function will soon be removed: use [PanByPixelOffset]{@link tf.map.Map#PanByPixelOffset} instead
    */
    this.MoveOffsetPixel = function (xPixel, yPixel) { theThis.PanByPixelOffset([xPixel, yPixel]); }
    /**
     * @public
     * @function
     * @summary - Translates the given pixel coordinates into map coordinates
     * @param {number} xPixel - horizontal pixel coordinate
     * @param {number} yPixel - vertical pixel coordinate
     * @returns {deprecatedMapCoords2} - | {@link deprecatedMapCoords2} the map coordinates
     * @deprecated This function will soon be removed: use [PixelToMapCoords]{@link tf.map.Map#PixelToMapCoords} instead
    */
    this.ScreenToGlobal = function (xPixel, yPixel) {
        var obj = theThis.PixelToMapCoords([xPixel, yPixel]);
        if (!!obj) {
            obj.Lat = obj[1];
            obj.Lon = obj[0];
        }
        return obj;
    }
    /**
     * @public
     * @function
     * @summary - Translates the given map coordinates into pixel coordinates
     * @param {tf.types.latitude} Lat - map latitude coordinate
     * @param {tf.types.longitude} Lng - map longitude coordinate
     * @returns {deprecatedPixelCoords1} - | {@link deprecatedPixelCoords1} the pixel coordinates
     * @deprecated This function will soon be removed: use [MapToPixelCoords]{@link tf.map.Map#MapToPixelCoords} instead
    */
    this.GlobalToScreen = function (Lat, Lng) { var pixelCoords = theThis.MapToPixelCoords([Lng, Lat]); return { X: pixelCoords[0], Y: pixelCoords[1] }; }
    /**
     * @public
     * @function
     * @summary - Retrieves the visible map extent
     * @returns {deprecatedMapExtent} - | {@link deprecatedMapExtent} the map extent
     * @deprecated This function will soon be removed: use [GetVisibleExtent]{@link tf.map.Map#GetVisibleExtent} instead
    */
    this.GetBounds = function () { var extent = theThis.GetVisibleExtent(); return { longitude1: extent[0], latitude1: extent[3], longitude2: extent[2], latitude2: extent[1] }; }
    /**
     * @public
     * @function
     * @summary - Sets the visible map extent
     * @param {deprecatedMapExtent} extent - the new map extent
     * @returns {void} - | {@link void} no return value
     * @deprecated This function will soon be removed: use [SetVisibleExtent]{@link tf.map.Map#SetVisibleExtent} instead
    */
    this.SetBounds = function (extent) { if (tf.js.GetIsValidObject(extent)) { theThis.SetVisibleExtent([extent.longitude1, extent.latitude2, extent.longitude2, extent.latitude1]); } }
    function onCallBack() { onCallBackCall(theThis); }
    function addCustomizedButton(buttonX, buttonY, buttonIconURL) {
        var newElement = document.createElement('img');
        newElement.style.left = buttonX + "px";
        newElement.style.top = buttonY + "px";
        newElement.style.position = 'absolute';
        newElement.style.zIndex = zIndex + 5;
        newElement.src = buttonIconURL;
        mapContainerAll.appendChild(newElement);
        return new TButton(newElement);
    }
    function onOldNotificationListener(eventName, notification) {
        switch (eventName) {
            case tf.consts.mapMoveEndEvent:
            case tf.consts.mapMouseMoveEvent:
            case tf.consts.mapClickEvent:
            case tf.consts.mapDblClickEvent:
                allOldListeners.Notify(eventName, notification.eventCoords[1], notification.eventCoords[0], notification.sender);
                break;
            case tf.consts.mapTypeChangeEvent:
                allOldListeners.Notify(eventName, notification.newType, notification.sender);
                break;
            case tf.consts.mapLevelChangeEvent:
                allOldListeners.Notify(eventName, notification.level, notification.sender);
                break;
            case tf.consts.mapFullScreenEvent:
                allOldListeners.Notify(notification.sender);
                break;
            default:
                tf.GetDebug().LogIfTest("deprecated map notification for unsupported event: " + eventName);
                break;
        }
    }
    function useOldListenerForEvent(eventName) {
        var useOldListener = false;
        switch (eventName) {
            case tf.consts.mapMoveEndEvent:
            case tf.consts.mapMouseMoveEvent:
            case tf.consts.mapClickEvent:
            case tf.consts.mapDblClickEvent:
            case tf.consts.mapTypeChangeEvent:
            case tf.consts.mapLevelChangeEvent:
            case tf.consts.mapFullScreenEvent:
                useOldListener = true;
                break;
            default: break;
        }
        return useOldListener;
    }
    function addOldFormatListener(eventName, callbackFunction) {
        var listener = null;
        var useOldListener = useOldListenerForEvent(eventName);
        if (useOldListener) {
            if (tf.js.GetIsNonEmptyString(eventName) && tf.js.GetFunctionOrNull(callbackFunction)) {
                var listenerSet = allOldListeners.GetNotifier(eventName);
                if (!!listenerSet) { listener = listenerSet.Add(callbackFunction); }
            }
        }
        else { listener = theThis.AddListener(eventName, callbackFunction); }
        return listener;
    }
    function makeOldNotificationCallBack(eventName) { return function (notification) { return onOldNotificationListener(eventName, notification) }; }
    function initialize() {
        var allMapEventNames = tf.consts.allMapEventNames;
        allOldListeners = new tf.events.MultiEventNotifier({ eventNames: allMapEventNames });
        var settings = {
            container: container,
            center: [longitude, latitude],
            mapType: initMapType,
            mapAerialSource: mapAerialSource,
            mapEngine: mapEngine
        };
        if (level > 0) { settings.level = level; } else { settings.resolution = -level; }
        tf.map.Map.call(theThis, settings);
        var eventNamesAndCallBacks = {};
        for (var i in allMapEventNames) {
            var thisEventName = allMapEventNames[i];
            if (useOldListenerForEvent(thisEventName)) {
                eventNamesAndCallBacks[thisEventName] = makeOldNotificationCallBack(thisEventName);
            }
        }
        theThis.AddListeners(eventNamesAndCallBacks);
        if (onCallBackCall = tf.js.GetFunctionOrNull(onCreatedCallBack)) { setTimeout(onCallBack, 100); }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(TMap, tf.map.Map);
/**
 * @public
 * @typedef {object} deprecatedPolygonCoords
 * A string containing Polygon vertex coordinates in the format: "Lat1,Lon1;Lat2,Lon2;...LatN,LonN", optionally grouped and nested inside paranthesis: ((Lat1,Lon1;Lat2,Lon2;...LatM,LonM),(Lat1,Lon1;Lat2,Lon2;...LatN,LonN))
 * @deprecated This format will soon be removed along with the legacy MAP-API [TPolygon]{@link TPolygon] class. TerraFly applications
 * should use [Map Features]{@link tf.map.Feature} instead
 */
/**
 * @public
 * @global
 * @class
 * @summary This is the <b>legacy MAP-API TLayer class</b>, which has been replaced by the {@link tf.map.FeatureLayer} class, and will soon be removed. 
 * Instances of this class are created by calling the function [AddLayer]{@link TMap#AddLayer} of a [TMap]{@link TMap} instance
 * @deprecated  This global class will soon be removed: use {@link tf.map.FeatureLayer} instead
 * @extends {tf.map.FeatureLayer}
*/
var TLayer = function (settings) {
    var theThis, debug, markers, polygons, groundTiles;
    var hasEnclosureRegExp = new RegExp(/ENCLOSURE=TRUE/i);
    /**
     * @public
     * @function
     * @summary - Adds a legacy MAP-API [TMarker]{@link TMarker} instance
     * @param {tf.types.latitude} latitude - the latitude
     * @param {tf.types.longitude} longitude - the longitude
     * @param {string} label - the label to be displayed on the map at the marker's coordinates
     * @param {tf.types.MapFeatureStyleSettings|deprecatedPropertyString} strStyleOrObj - map feature style settings
     * @returns {TMarker} - | {TMarker} the added instance
     * @deprecated This function will soon be removed: use [AddMapFeature]{@link tf.map.FeatureLayer#AddMapFeature} instead
    */
    this.AddMarker = function (latitude, longitude, label, strStyleOrObj) {
        (!label || typeof label !== "string" || !label.length) && (label = '');
        return addMarker(latitude, longitude, { marker: true, label: label }, strStyleOrObj);
    }
    /**
     * @public
     * @function
     * @summary - Adds a legacy MAP-API [TMarker]{@link TMarker} instance
     * @param {tf.types.latitude} latitude - the latitude
     * @param {tf.types.longitude} longitude - the longitude
     * @param {string} url - the url to an image to be displayed on the map at the marker's coordinates
     * @param {tf.types.MapFeatureStyleSettings|deprecatedPropertyString} strStyleOrObj - map feature style settings
     * @returns {TMarker} - | {TMarker} the added instance
     * @deprecated This function will soon be removed: use [AddMapFeature]{@link tf.map.FeatureLayer#AddMapFeature} instead
    */
    this.AddImgMarker = function (latitude, longitude, url, strStyleOrObj) {
        if (!tf.js.GetIsNonEmptyString(url)) { return theThis.AddMarker(latitude, longitude, null); }
        return addMarker(latitude, longitude, { icon: true, icon_url: url }, strStyleOrObj);
    }
    /**
     * @public
     * @function
     * @summary - Updates the style of all markers
     * @param {tf.types.MapFeatureStyleSettings|deprecatedPropertyString} strStyleOrObj - map feature style settings
     * @returns {void} - | {@link void} no return value
    */
    this.SetAllMarkersStyle = function (strStyleOrObj) { if (typeof strStyleOrObj == "string" || typeof strStyleOrObj === "object") { for (var i in markers) { markers[i].SetMarkerStyle(strStyleOrObj); } } }
    /**
     * @public
     * @function
     * @summary - Removes the marker
     * @param {TMarker} marker - the marker
     * @returns {void} - | {@link void} no return value
    */
    this.RemoveMarker = function (marker) { if (marker) { var indexOf = markers.indexOf(marker); if (indexOf != -1) { marker.SetVisible(false); markers.splice(indexOf, 1); } } }
    /**
     * @public
     * @function
     * @summary - Adds a legacy MAP-API [TPolygon]{@link TPolygon} instance
     * @param {deprecatedPolygonCoords} strPoints - parameter description?
     * @param {tf.types.MapFeatureStyleSettings|deprecatedPropertyString} strStyleOrObj - map feature style settings
     * @returns {TPolygon} - | {TPolygon} the added instance
     * @deprecated This function will soon be removed: use [AddMapFeature]{@link tf.map.FeatureLayer#AddMapFeature} instead
    */
    this.AddPolygon = function (strPoints, strStyleOrObj) { return addPolygon(strPoints, tf.helpers.GetMultiCoordsFromLatLonString(strPoints), strStyleOrObj); }
    /**
     * @public
     * @function
     * @summary - Removes the polygon
     * @param {TPolygon} polygon - the polygon
     * @returns {void} - | {@link void} no return value
    */
    this.RemovePolygon = function (polygon) { if (polygon instanceof TPolygon) { var indexOf = polygons.indexOf(polygon); if (indexOf != -1) { polygon.SetVisible(false); polygons.splice(indexOf, 1); } } }
    /**
     * @public
     * @function
     * @summary - Adds a legacy MAP-API [TGroundTile]{@link TGroundTile} instance
     * @param {string} url - the url to an image to be displayed on the map bounded by the given map coordinates
     * @param {tf.types.latitude} latitudeLT - left top latitude
     * @param {tf.types.longitude} longtitudeLT - left top longitude
     * @param {tf.types.latitude} latitudeRB - right bottom latitude
     * @param {tf.types.longitude} longtitudeRB - right bottom longitude
     * @returns {TGroundTile} - | {TGroundTile} the added instance
     * @deprecated This function will soon be removed: use [AddMapFeature]{@link tf.map.FeatureLayer#AddMapFeature} instead
    */
    this.AddGroundTile = function (url, latitudeLT, longtitudeLT, latitudeRB, longtitudeRB) { return new TGroundTile(theThis.GetMap(), theThis, url, latitudeLT, longtitudeLT, latitudeRB, longtitudeRB); }
    /**
     * @public
     * @function
     * @summary - Removes the ground tile
     * @param {TGroundTile} groundTile - the ground tile
     * @returns {void} - | {@link void} no return value
    */
    this.RemoveGroundTile = function (groundTile) { if (groundTile) { var indexOf = groundTiles.indexOf(groundTile); if (indexOf != -1) { groundTile.SetVisible(false); groundTiles.splice(indexOf, 1); } } }
    /**
     * @public
     * @function
     * @summary - Removes all features from the layer
     * @returns {void} - | {@link void} no return value
    */
    this.Clean = function () { theThis.RemoveAllFeatures(); markers = []; polygons = []; groundTiles = []; }
    function addMarker(latitude, longitude, settings, strStyleOrObj) {
        longitude = tf.js.GetLongitudeFrom(longitude);
        latitude = tf.js.GetLatitudeFrom(latitude);
        if (!tf.js.GetIsValidObject(strStyleOrObj)) { strStyleOrObj = tf.js.GetIsNonEmptyString(strStyleOrObj) ? tf.js.ParseLegacyFormatString(strStyleOrObj) : {}; }
        var mapFeature = new tf.map.Feature({ type: "point", coordinates: [longitude, latitude], style: tf.js.ShallowMerge(strStyleOrObj, settings) });
        var tMarker = new TMarker(theThis, mapFeature);
        theThis.AddMapFeature(mapFeature, false);
        markers.push(tMarker);
        return tMarker;
    }
    function getPolyGeometryType(strPoints, strStyleOrObj) {
        var isEnclosure = typeof strStyleOrObj === "string" ? hasEnclosureRegExp.test(strStyleOrObj) : (typeof strStyleOrObj === "object" ? !!strStyleOrObj.enclosure : false);
        var strPointsUse = tf.js.GetNonEmptyString(strPoints);
        var isMultiLine = !!strPointsUse ? strPointsUse.charAt(0) == '(' : false;
        var isMultiPoly = false;
        if (isMultiLine) { isMultiPoly = (strPointsUse.length > 1 && strPointsUse.charAt(1) == '('); }
        return { typeName: isEnclosure ? "polygon" : isMultiLine ? "multipolygon" : "linestring", isEnclosure: isEnclosure, isMultiLine: isMultiLine, isMultiPoly: isMultiPoly };
    }
    function addPolygon(strPoints, dataArray, strStyleOrObj) {
        var polyGeometryType = getPolyGeometryType(strPoints, strStyleOrObj);
        if (polyGeometryType.isMultiLine) { if (polyGeometryType.isEnclosure) { if (!!debug) { debug.LogIfTest('multiEnclosure'); } } }
        else if (polyGeometryType.isMultiPoly) { if (!!debug) { debug.LogIfTest('multiEnclosure'); } }
        var style = { line: true, fill: polyGeometryType.isEnclosure || polyGeometryType.isMultiLine };
        if (polyGeometryType.isEnclosure) { dataArray = [dataArray]; }
        if (!tf.js.GetIsValidObject(strStyleOrObj)) { strStyleOrObj = tf.js.GetIsNonEmptyString(strStyleOrObj) ? tf.js.ParseLegacyFormatString(strStyleOrObj) : {}; }
        var mapFeature = new tf.map.Feature({ type: polyGeometryType.typeName, coordinates: dataArray, style: tf.js.ShallowMerge(strStyleOrObj, style) });
        var tPolygon = new TPolygon(theThis, mapFeature);
        theThis.AddMapFeature(mapFeature, false);
        polygons.push(tPolygon);
        return tPolygon;
    }
    function initialize() {
        debug = null;//tf.GetDebug();
        markers = []; polygons = []; groundTiles = [];
        tf.map.FeatureLayer.call(theThis, settings);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(TLayer, tf.map.FeatureLayer);
/**
 * @public
 * @global
 * @class
 * @summary This is the <b>legacy MAP-API TMarker class</b>, which has been replaced by the {@link tf.map.Feature} class, and will soon be removed. 
 * Instances of this class are created by calling the functions [AddMarker]{@link TLayer#AddMarker} or [AddImgMarker]{@link TLayer#AddImgMarker} of a [TLayer]{@link TLayer} instance
 * @deprecated  This global class will soon be removed: use {@link tf.map.Feature} instead
 * @extends {tf.map.Feature}
*/
var TMarker = function (tLayer, mapFeature) {
    var theThis, onClickListener, onRollOverListener, isVisible;
    /**
     * @public
     * @function
     * @summary - Retrieves the associated legacy MAP-API [TLayer]{@link TLayer} instance
     * @returns {TLayer} - | {@link TLayer} the layer instance
    */
    this.GetLayer = function () { return tLayer; }
    /**
     * @public
     * @function
     * @summary - Sets a callback for mouse move notifications
     * @param {function} callBack - the callback
     * @returns {void} - | {@link void} no return value
    */
    this.SetOnRolloverListener = function (callBack) { onRollOverListener = tf.js.GetFunctionOrNull(callBack); }
    /**
     * @public
     * @function
     * @summary - Sets a callback for mouse click notifications
     * @param {function} callBack - the callback
     * @returns {void} - | {@link void} no return value
    */
    this.SetOnClickListener = function (callBack) { onClickListener = tf.js.GetFunctionOrNull(callBack); }
    /**
     * @public
     * @function
     * @summary - Changes the marker's label
     * @param {string} strLabel - the new label
     * @returns {void} - | {@link void} no return value
    */
    this.SetLabel = function (strLabel) { return mapFeature.ChangeStyle({ label: strLabel }); }
    /**
     * @public
     * @function
     * @summary - Changes the marker's style
     * @param {tf.types.MapFeatureStyleSettings|deprecatedPropertyString} strStyleOrObj - map feature style settings
     * @returns {void} - | {@link void} no return value
    */
    this.SetMarkerStyle = function (strStyleOrObj) { return mapFeature.ChangeStyle(strStyleOrObj); }
    /**
     * @public
     * @function
     * @summary - Shows or hides the marker
     * @param {boolean} bool - Set to <b>true</b> to show, <b>false</b> to hide
     * @returns {void} - | {@link void} no return value
    */
    this.SetVisible = function (bool) {
        if ((bool = !!bool) != isVisible) { if (isVisible = bool) { if (!!tLayer) { tLayer.AddMapFeature(mapFeature, false); } } else { if (!!tLayer) { tLayer.DelMapFeature(mapFeature, false); } } }
    }
    /**
     * @public
     * @function
     * @summary - Determines if the marker is visible
     * @returns {boolean} - | {@link boolean} <b>true</b> if visible, <b>false</b> otherwise
    */
    this.GetVisible = function () { return isVisible; }
    /**
     * @public
     * @function
     * @summary - Changes the marker's position
     * @param {tf.types.latitude} latitude - the new latitude
     * @param {tf.types.longitude} longitude - the new longitude
     * @returns {void} - | {@link void} no return value
    */
    this.MoveTo = function (latitude, longitude) { return moveTo(latitude, longitude); }
    /**
     * @public
     * @function
     * @summary - Incrementally changes the marker's position
     * @param {tf.types.latitude} latitude - the new latitude
     * @param {tf.types.longitude} longitude - the new longitude
     * @param {number} speed - duration of the animation
     * @param {function} moveEndCallback - called when the animation ends
     * @returns {void} - | {@link void} no return value
    */
    this.MoveToAni = function (latitude, longitude, speed, moveEndCallback) {
        moveTo(latitude, longitude);
        if (!!(moveEndCallback = tf.js.GetFunctionOrNull(moveEndCallback))) { if ((speed = tf.js.GetFloatNumber(speed, 10)) <= 0) { speed = 10; } setTimeout(moveEndCallback, speed); }
    }
    /**
     * @public
     * @function
     * @summary - Retrieves the marker's position
     * @returns {deprecatedMapCoords1} - | {@link deprecatedMapCoords1} the position
    */
    this.GetPosition = function () { var position = mapFeature.GetPointCoords(); return { latitude: position[1], longitude: position[0] }; }
    /**
     * @public
     * @function
     * @summary - Shows the Information Popup
     * @param {void} deprecated1 - ignored
     * @param {string} title - Title of the popup
     * @param {HTMLContent} content - Content of the popup
     * @returns {void} - | {@link void} no return value
    */
    this.ShowInfoWindow = function (deprecataed1, title, content) {
        if (!!tLayer) { var map = tLayer.GetMap(); if (!!map) { var pos = theThis.GetPosition(); map.ShowInfoWindow(pos.latitude, pos.longitude, null, title, content); } }
    }
    /**
     * @public
     * @function
     * @summary - This function is no longer available
     * @returns {void} - | {@link void} no return value
     * @deprecated This function is no longer available
    */
    this.SetGroundTileStyle = function () { }
    /**
     * @public
     * @function
     * @summary - This function is no longer available
     * @returns {void} - | {@link void} no return value
     * @deprecated This function is no longer available
    */
    this.ShowInfoWindowTabs = function () { }
    function moveTo(latitude, longitude) { mapFeature.SetPointCoords([tf.js.GetLongitudeFrom(longitude), tf.js.GetLatitudeFrom(latitude)]); }
    function notify(notification, callBackFunction) { if (!!callBackFunction) { callBackFunction(notification.eventCoords[1], notification.eventCoords[0]); } }
    function onMouseMove(notification) { return notify(notification, onRollOverListener); }
    function onClick(notification) { return notify(notification, onClickListener); }
    function initialize() {
        isVisible = true;
        mapFeature.SetOnMouseMoveListener(onMouseMove);
        mapFeature.SetOnClickListener(onClick);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * @public
 * @global
 * @class
 * @summary This is the <b>legacy MAP-API TPolygon class</b>, which has been replaced by the {@link tf.map.Feature} class, and will soon be removed. 
 * Instances of this class are created by calling the functions [AddPolygon]{@link TLayer#AddMarker} of a [TLayer]{@link TLayer} instance
 * @deprecated  This global class will soon be removed: use {@link tf.map.Feature} instead
 * @extends {tf.map.Feature}
*/
var TPolygon = function (tLayer, mapFeature) {
    var theThis, isVisible;
    /**
     * @public
     * @function
     * @summary - Retrieves the associated legacy MAP-API [TLayer]{@link TLayer} instance
     * @returns {TLayer} - | {@link TLayer} the layer instance
    */
    this.GetLayer = function () { return tLayer; }
    /**
     * @public
     * @function
     * @summary - Sets a callback for mouse click notifications
     * @param {function} callBack - the callback
     * @returns {void} - | {@link void} no return value
    */
    this.SetOnClickListener = function (callBack) { mapFeature.SetOnClickListener(callBack); }
    /**
     * @public
     * @function
     * @summary - Shows or hides the polygon
     * @param {boolean} bool - Set to <b>true</b> to show, <b>false</b> to hide
     * @returns {void} - | {@link void} no return value
    */
    this.SetVisible = function (bool) {
        if ((bool = !!bool) != isVisible) { if (isVisible = bool) { if (!!tLayer) { tLayer.AddMapFeature(mapFeature, false); } } else { if (!!tLayer) { tLayer.DelMapFeature(mapFeature, false); } } }
    }
    /**
     * @public
     * @function
     * @summary - Determines if the polygon is visible
     * @returns {boolean} - | {@link boolean} <b>true</b> if visible, <b>false</b> otherwise
    */
    this.GetIsVisible = function () { return isVisible; }
    /**
     * @public
     * @function
     * @summary - Changes the polygon's style
     * @param {tf.types.MapFeatureStyleSettings|deprecatedPropertyString} strStyleOrObj - map feature style settings
     * @returns {void} - | {@link void} no return value
    */
    this.UpdateStyle = function (strStyleOrObj) { return mapFeature.ChangeStyle(strStyleOrObj); }
    function initialize() {
        isVisible = true;
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * @public
 * @global
 * @class
 * @summary This is the <b>legacy MAP-API TButton class</b>, which has been replaced by the {@link tf.map.HTMLControl} class, and will soon be removed. 
 * Instances of this class are created by calling the functions [AddCustomizedButton]{@link TMap#AddCustomizedButton} of a [TMap]{@link TMap} instance
 * @deprecated  This global class will soon be removed: use {@link tf.map.HTMLControl} instead
*/
var TButton = function (htmlButtonElement) {
    var theThis, theClickCallBack;
    /**
     * @public
     * @function
     * @summary - Sets a callback for mouse click notifications
     * @param {function} callBack - the callback
     * @returns {void} - | {@link void} no return value
    */
    this.SetOnClickListener = function (callBack) { theClickCallBack = tf.js.GetFunctionOrNull(callBack); }
    function doOnClickCallBack() { if (!!theClickCallBack) { theClickCallBack(); } }
    function initialize() {
        htmlButtonElement.onclick = function () { doOnClickCallBack(); };
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * @public
 * @global
 * @class
 * @summary - This legacy MAP-API class is no longer available
 * @deprecated This class is no longer available
*/
var TTabObject = function () {
    /**
     * @public
     * @function
     * @summary - This function is no longer available
     * @returns {void} - | {@link void} no return value
     * @deprecated This function is no longer available
    */
    this.GetLabel = function () { }
    /**
     * @public
     * @function
     * @summary - This function is no longer available
     * @returns {void} - | {@link void} no return value
     * @deprecated This function is no longer available
    */
    this.GetContent = function () { }
};
/**
 * @public
 * @global
 * @class
 * @summary This is the <b>legacy MAP-API TGroundTile class</b>, which has been replaced by the {@link tf.map.Feature} class, and will soon be removed. 
 * Instances of this class are created by calling the functions [AddGroundTile]{@link TLayer#AddGroundTile} of a [TLayer]{@link TLayer} instance,
 * or directly by using a valid tMap parameter and null tLayer parameter. The image pointed by the url parameter must be pre-loaded.
 * @param {TMap} tMap - the [TMap]{@link TMap} instance where the ground tile will be shown
 * @param {TLayer} tLayer - the [TLayer]{@link TLayer} instance associated with the ground tile
 * @param {string} url - the url to an image to be displayed on the map bounded by the given map coordinates
 * @param {tf.types.latitude} latitudeLT - left top latitude
 * @param {tf.types.longitude} longtitudeLT - left top longitude
 * @param {tf.types.latitude} latitudeRB - right bottom latitude
 * @param {tf.types.longitude} longtitudeRB - right bottom longitude
 * @deprecated  This global class will soon be removed: use {@link tf.map.Feature} instead
 * @see {@link tf.dom.ImgsPreLoader}
*/
var TGroundTile = function (tMap, tLayer, url, latitudeLT, longtitudeLT, latitudeRB, longtitudeRB) {
    var theThis, mapFeature, myStrStyle;
    var centerLat, centerLon, width;
    var img, isVisible, isLoaded;
    /**
     * @public
     * @function
     * @summary - Retrieves the associated legacy MAP-API [TLayer]{@link TLayer} instance, if any
     * @returns {TLayer} - | {@link TLayer} the layer instance
    */
    this.GetLayer = function () { return tLayer; }
    /**
     * @public
     * @function
     * @summary - Shows the ground tile immediately during a map post render event. The ground tile's image must have been loaded before calling this function.
     * @param {tf.types.MapShowFeatureImmediately} showFeatureImmediately - Set to <b>true</b> to show, <b>false</b> to hide
     * @returns {void} - | {@link void} no return value
    */
    this.ShowImmediately = function (showFeatureImmediately) { if (!!mapFeature && !!isLoaded) { return showFeatureImmediately(mapFeature); } }
    /**
     * @public
     * @function
     * @summary - Determines if the ground tile image is loaded. The function [ShowImmediately]{@link TGroundTile#ShowImmediately} cannot be called before image loading is complete.
     * @returns {boolean} - | {@link boolean} <b>true</b> if loaded, <b>false</b> otherwise
    */
    this.GetIsLoaded = function () { return isLoaded; }
    /**
     * @public
     * @function
     * @summary - Shows or hides the ground tile on the associated [TLayer]{@link TLayer} instance, if any
     * @param {boolean} bool - Set to <b>true</b> to show, <b>false</b> to hide
     * @returns {void} - | {@link void} no return value
    */
    this.SetVisible = function (bool) {
        bool = !!bool;
        if (bool != isVisible) {
            isVisible = bool;
            if (mapFeature) {
                if (tLayer) {
                    if (isVisible) { tLayer.AddMapFeature(mapFeature); }
                    else { tLayer.DelMapFeature(mapFeature); }
                }
            }
        }
    }
    /**
     * @public
     * @function
     * @summary - Changes the ground tile's style
     * @param {tf.types.MapFeatureStyleSettings|deprecatedPropertyString} strStyleOrObj - map feature style settings
     * @returns {void} - | {@link void} no return value
    */
    this.SetGroundTileStyle = function (strStyle) { myStrStyle = strStyle; if (mapFeature) { mapFeature.ChangeStyle(myStrStyle); } }
    function createFromImg() {
        var geom = new tf.map.FeatureGeom({ type: "point", coordinates: [centerLon, centerLat] });
        var scale = width !== undefined ? width / img.width : 1;
        scale *= tf.browser.GetDevicePixelRatio();
        var styleSpecs = { icon: true, icon_anchor: [0.5, 0.5], scale: scale, zindex: 1, icon_img: img, icon_size: [img.width, img.height], snaptopixel: false, rotate_with_map: true };
        var style = new tf.map.FeatureSubStyle(styleSpecs);
        mapFeature = new tf.map.Feature({ geom: geom, style: style, hoverStyle: style });
        if (myStrStyle) {
            mapFeature.ChangeStyle(myStrStyle);
        }
        if (isVisible) { if (tLayer) { tLayer.AddMapFeature(mapFeature); } }
    }
    function onImageLoaded() { img.onload = undefined; createFromImg(); isLoaded = true; }
    function initialize() {
        isVisible = true;
        isLoaded = false;
        (!tLayer || !(tLayer instanceof TLayer)) && (tLayer = null);
        tMap = tf.js.GetMapFrom(tMap);
        centerLat = (latitudeLT + latitudeRB) / 2;
        centerLon = (longtitudeLT + longtitudeRB) / 2;
        if (tMap) { width = Math.round(tMap.GetPixelDistance([longtitudeLT, centerLat], [longtitudeRB, centerLat])); }
        else { width = undefined; }
        if (url instanceof tf.dom.Img) {
            img = url.GetHTMLElement();
            createFromImg();
            isLoaded = true;
        }
        else {
            img = document.createElement('img');
            img.onload = onImageLoaded;
            img.src = url;
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * class tf.map.aux.LegendDecoder - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} legendStr - parameter description?
*/
tf.map.aux.LegendDecoder = function (legendStr) {
    legendStr = typeof legendStr == "string" ? legendStr : tf.consts.defaultLegend;
    var groupSetRootName = "tf-mapi-lgrt";
    var decodedLegend = decodeLegend(legendStr);
/**
 * method tf.map.aux.LegendDecoder.GetGroupSetRootName - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetGroupSetRootName = function () { return groupSetRootName ;}
/**
 * method tf.map.aux.LegendDecoder.GetLegendSet - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetLegendSet = function () { return decodedLegend.legendSet; }
/**
 * method tf.map.aux.LegendDecoder.GetGroupSetNames - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetGroupSetNames = function () { return decodedLegend.groupSetNames; }
/**
 * method tf.map.aux.LegendDecoder.GetGroupSet - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetGroupSet = function () { return decodedLegend.groupSet; }
    function decodeLegend(legendStr) {
        //tf.GetDebug().LogIfTest("decoding legend string :\n" + legendStr);
        //clean legendSet
        var legendSet = [];
        var grSet = {};
        // get GROUP information 
        var legendString = unescape(legendStr);
        var arrLegendGroupString = legendString.split(";");
        //tf.GetDebug().LogIfTest(arrLegendGroupString);
        var rawLegendGroup;// a raw string with {, ::, and group set info
        var pureLegendGroup;// a pure legend string with group set info removed
        var i;
        var swap;
        var groupSetName = "";
        var groupSetDesc = "";
        var isInGroupSet = false;
        for (i = 0; i < arrLegendGroupString.length; i++) {
            rawLegendGroup = arrLegendGroupString[i];
            //tf.GetDebug().LogIfTest("Raw legend group is :", rawLegendGroup);
            // is group set begin
            if (rawLegendGroup.substr(0, 1) == "{") {
                // A GroupSet Begins, the beginning section
                //tf.GetDebug().LogIfTest("{ found");
                isInGroupSet = true;
                rawLegendGroup = rawLegendGroup.substr(1);
                var tempArray = rawLegendGroup.split("::");
                if (tempArray.length > 1) {
                    groupSetName = tempArray[0];
                    pureLegendGroup = tempArray[1];
                    //
                    tempArray = groupSetName.split(":");
                    groupSetName = tempArray[0];
                    if (tempArray.length == 2) {
                        groupSetDesc = tempArray[1];
                    }
                    else {
                        groupSetDesc = tempArray[0];
                    }
                    //tf.GetDebug().LogIfTest("groupSetName", groupSetName, "groupSetDesc", groupSetDesc);
                }
                else {
                    // Not in a GroupSet
                    groupSetName = "";
                    groupSetDesc = "";
                    pureLegendGroup = rawLegendGroup;
                }
            }
            else if (isInGroupSet) {
                // In a GroupSet, not the beginning section
                pureLegendGroup = rawLegendGroup;
            }
            else {
                // Not in a GroupSet
                groupSetName = "";
                groupSetDesc = "";
                pureLegendGroup = rawLegendGroup;
            }
            // // is group set end
            if (pureLegendGroup.substr(pureLegendGroup.length - 1, 1) == "}") {
                //tf.GetDebug().LogIfTest("} found");
                pureLegendGroup = pureLegendGroup.substr(0, pureLegendGroup.length - 1);
                isInGroupSet = false;
            }
            //tf.GetDebug().LogIfTest("\nPure legend group is:", pureLegendGroup);
            //tempArray = arrLegendGroupString[i].split("@");
            tempArray = pureLegendGroup.split("@");
            var groupLabelAndDesc = tempArray[0];
            // group LABEL, DESC and IS_CHECK
            var group = {};
            group.ISCHECK = false;
            group.LABEL = "";
            group.DESC = "";
            group.VALUE = "";
            group.GRSET = groupSetName;
            group.GRDESC = groupSetDesc;
            /*
            group.MAX_LVL = -1; // Max level
            group.MIN_LVL = 99; // Min level
            */
            group.MAX_RES = -1.0; // Max resolution
            group.MIN_RES = 10e10; // Min resolution
            group.COMPOSITES = []; // Container of composite parts
            //tf.GetDebug().LogIfTest(groupLabelAndDesc);
            // is check
            if (groupLabelAndDesc.substr(0, 1) == "~") {
                group.ISCHECK = true;
                groupLabelAndDesc = groupLabelAndDesc.substr(1, groupLabelAndDesc.length);
            }
            // get label and description
            var index = groupLabelAndDesc.indexOf(":");
            if (index > 0)
                // has both label and description
            {
                group.LABEL = groupLabelAndDesc.substring(0, index);
                group.DESC = groupLabelAndDesc.substring(index + 1, groupLabelAndDesc.length);
            }
                // label only, description = label
            else {
                group.LABEL = groupLabelAndDesc;
                group.DESC = group.LABEL;
            }
            // replace "_" in label
            index = group.LABEL.indexOf("_");
            var spaceReplace;
            var j;
            if (index >= 0) {
                spaceReplace = group.LABEL.split("_");
                group.LABEL = "";
                for (j = 0; j < spaceReplace.length ; j++) {
                    //tf.GetDebug().LogIfTest(spaceReplace[j]);
                    group.LABEL = group.LABEL + spaceReplace[j] + " ";
                }
            }
            index = group.DESC.indexOf("_");
            if (index >= 0) {
                spaceReplace = group.DESC.split("_");
                group.DESC = "";
                for (j = 0; j < spaceReplace.length ; j++) {
                    //tf.GetDebug().LogIfTest(spaceReplace[j]);
                    group.DESC = group.DESC + spaceReplace[j] + " ";
                }
            }
            //tf.GetDebug().LogIfTest("LABEL:\t", group.LABEL);
            //tf.GetDebug().LogIfTest("DESC:\t", group.DESC);
            //tf.GetDebug().LogIfTest("GRSET:\t", group.GRSET);
            // group VALUE
            //var groupValueRaw:Array = groupParameters[1].split("%2B");
            //tf.GetDebug().LogIfTest("VALUE:\t", tempArray[1]);
            if (tempArray.length > 1) {
                var arrGroupLayerString = (tempArray[1]).split("+");
                for (j = 0; j < arrGroupLayerString.length; j++) {
                    var currentPartString = arrGroupLayerString[j];
                    var currentParts = currentPartString.split("-");
                    var partsCount = currentParts.length;
                    var composite = new Object;
                    composite.MODE = "";
                    composite.PREFIX = "";
                    composite.VALUE = "";
                    composite.SUFFIX_M = "";
                    composite.SUFFIX_H = "";
                    composite.MIN = 10e10;
                    composite.MAX = -1;
                    if (partsCount == 1)
                        // e.g. street.l_
                    {
                        composite.PREFIX = currentPartString;
                        composite.VALUE = currentPartString;
                        composite.MIN = -1;
                        composite.MAX = 150;
                        composite.MODE = "RES";
                    }
                    else if (partsCount == 2)
                        // downward compatible
                    {
                        //tf.GetDebug().LogIfTest("downward compatible", currentPartString);
                        composite.PREFIX = currentPartString;
                        composite.VALUE = currentPartString;
                        var digitMin = currentParts[1].substr(0, 1);
                        var digitMax = currentParts[1].substr(1, 1);
                        //tf.GetDebug().LogIfTest("downward compatible", digitMin, digitMax);
                        if (digitMin == "_") {
                            composite.MIN = 0;
                        }
                        else {
                            composite.MIN = Math.pow(2, (parseInt(digitMin, 10)));
                            if (composite.MIN > 150) composite.MIN = 150;
                        }
                        if (digitMax == "_") {
                            composite.MAX = 0.999;
                        }
                        else {
                            composite.MAX = Math.pow(2, (parseInt(digitMax, 10) + 1)) - 0.001;
                            if (composite.MAX > 150) composite.MAX = 150;
                        }
                        composite.MODE = "RES";
                    }
                    else if ((partsCount == 3) || (partsCount == 4))
                        // e.g. flpropertiesyear-0-0.15
                    {
                        // prefix
                        composite.PREFIX = currentParts[0] + "-" + currentParts[1] + "-" + currentParts[2] + "-";
                        composite.VALUE = currentParts[0];
                        // min
                        composite.MODE = "RES";
                        composite.MIN = parseFloat(currentParts[1]);
                        composite.MAX = parseFloat(currentParts[2]);
                        if (composite.MIN > composite.MAX) {
                            swap = composite.MIN;
                            composite.MIN = composite.MAX;
                            composite.MAX = swap;
                        }
                        // suffix
                        if (partsCount == 4) {
                            var suffixs = currentParts[3].split("||");
                            composite.SUFFIX_H = suffixs[0];
                            composite.SUFFIX_M = (suffixs.length == 2) ? suffixs[1] : suffixs[0];
                        }
                        else {
                            composite.SUFFIX_H = composite.SUFFIX_M = "";
                        }
                    }
                    else {
                        //tf.GetDebug().LogIfTest("error", currentPartString);
                    }
                    //tf.GetDebug().LogIfTest(composite.MODE, composite.MIN, composite.MAX, composite.PREFIX, composite.SUFFIX_H, composite.SUFFIX_M);
                    group.MAX_RES = (composite.MAX > group.MAX_RES) ? composite.MAX : group.MAX_RES; // Max resolution
                    group.MIN_RES = (composite.MIN < group.MIN_RES) ? composite.MIN : group.MIN_RES; // Min resolution
                    if (group.VALUE == "") {
                        group.VALUE = composite.VALUE;
                    }
                    else {
                        group.VALUE += ("%2B" + composite.VALUE);
                    }
                    group.COMPOSITES.push(composite);
                } //end of loop j
                legendSet.push(group);
            }
        } // end of loop (i)
        legendSet.reverse();
        var legendSetLen = legendSet.length;
        var groupSetNames = [];
        for (var i = 0 ; i < legendSetLen ; i++) {
            var thisItem = legendSet[i];
            var groupSetName = thisItem.GRSET;
            if (groupSetName === "") {
                groupSetName = groupSetRootName;
            }
            var thisGRSet = grSet[groupSetName];
            if (!thisGRSet) { grSet[groupSetName] = {}; thisGRSet = grSet[groupSetName]; groupSetNames.push(groupSetName); }
            if (!thisGRSet.items) { thisGRSet.items = []; }
            thisGRSet.items.push(thisItem);
        }
        return {
            "legendSet": legendSet,
            "groupSet": grSet,
            "groupSetNames": groupSetNames
        }
    }
}
/**
 * class tf.map.ui.Mapnik2Popup - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} container - parameter description?
 * @param {?} tMap - parameter description?
 * @param {?} callBackStringChange - parameter description?
 * @param {?} callBackOptionChange - parameter description?
 * @param {?} rectProvider - parameter description?
 * @param {?} debug - parameter description?
*/
tf.map.ui.Mapnik2Popup = function (container, tMap, callBackStringChange, callBackOptionChange, rectProvider, debug) {
    var theThis = null;
    var styles = tf.GetStyles();
    var popup = null;
    var divOptions = null;
    var showingCurrent = true, showingHybrid = true;
    var currentHString = "", currentMString = "";
    var legendOptionsH = null, legendOptionsM = null;
    var showingHybridVal = "hybrid";
    var showingMapVal = "map";
    var currentRadioVal = "current";
    var allRadioVal = "all";
    var dashStarFind = new RegExp('-.*');
/**
 * method tf.map.ui.Mapnik2Popup.Show - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} bool - parameter description?
*/
    this.Show = function (bool) { if (popup) { popup.Show(bool); } }
/**
 * method tf.map.ui.Mapnik2Popup.IsShowing - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.IsShowing = function () { return popup ? popup.IsShowing() : false; }
/**
 * method tf.map.ui.Mapnik2Popup.Toggle - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.Toggle = function () { this.Show(!this.IsShowing()); }
/**
 * method tf.map.ui.Mapnik2Popup.OnResolutionChange - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.OnResolutionChange = function (newRes) { return onResolutionChange(newRes); }
/**
 * method tf.map.ui.Mapnik2Popup.GetHasLegend - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetHasLegend = function () { return legendOptionsH.GetHasLegend() || legendOptionsM.GetHasLegend(); }
/**
 * method tf.map.ui.Mapnik2Popup.GetHasLegendH - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetHasLegendH = function () { return legendOptionsH.GetHasLegend(); }
/**
 * method tf.map.ui.Mapnik2Popup.GetHasLegendM - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetHasLegendM = function () { return legendOptionsM.GetHasLegend(); }
/**
 * method tf.map.ui.Mapnik2Popup.OnContainerResize - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.OnContainerResize = function () { onContainerResize(); }
/**
 * method tf.map.ui.Mapnik2Popup.SetLegend - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} tLegendSetH - parameter description?
 * @param {?} tLegendSetM - parameter description?
*/
    this.SetLegend = function (tLegendSetH, tLegendSetM) { legendOptionsH.SetLegend(tLegendSetH); legendOptionsM.SetLegend(tLegendSetM); }
/**
 * method tf.map.ui.Mapnik2Popup.GetHybridString - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetHybridString = function () { return currentHString; }
/**
 * method tf.map.ui.Mapnik2Popup.GetMapString - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetMapString = function () { return currentMString; }
    function onResolutionChange(newRes) { if (tMap) { legendOptionsH.SetResolution(newRes); legendOptionsM.SetResolution(newRes); } }
    function showCurrent(bool) { showingCurrent = !!bool; legendOptionsH.SetShowCurrent(showingCurrent); legendOptionsM.SetShowCurrent(showingCurrent); }
    function showHybrid(bool) {
        var showOptions = (showingHybrid = !!bool) ? legendOptionsH : legendOptionsM;
        divOptions.ClearContent();
        showOptions.AppendTo(divOptions);
        onContainerResize();
    }
    function setLegendStrings(newHString, newMString) {
        if (currentHString != newHString || currentMString != newMString) {
            currentHString = newHString; currentMString = newMString;
            if (callBackStringChange) { callBackStringChange.call(tMap, currentHString, currentMString); }
        }
    }
    function onContainerResize() { if (popup) { popup.OnContainerResize(); } }
    function onOptionChange() { if (callBackOptionChange) { callBackOptionChange.call(tMap); } }
    function onCompositesChange(legendOptions, composites) {
        var newString = "", strSeparator = '';
        for (var i in composites) {
            var thisComposite = composites[i];
            var thisPrefix = thisComposite.PREFIX.replace(dashStarFind, "");
            newString += strSeparator + thisPrefix; strSeparator = ',';
        }
        var newHString, newMString;
        if (legendOptions == legendOptionsH) { newHString = newString; newMString = currentMString; }
        else { newHString = currentHString; newMString = newString; }
        setLegendStrings(newHString, newMString)
    }
    function createAllOrCurrentSection() {
        var radioButtonList = new tf.ui.RadioButtonList();
        var radioCurrent = radioButtonList.AddRadioButton("Current Resolution", currentRadioVal, showingCurrent, "Base Layers Visible at Current Resolution", true);
        var radioAll = radioButtonList.AddRadioButton("All Resolutions", allRadioVal, !showingCurrent, "Base Layers Visible at All Resolutions", true);
        var selectCurrent = function (theRadio, bool) { return function () { theRadio.SetIsChecked(true); showCurrent(bool); } }(radioCurrent, true);
        var selectAll = function (theRadio, bool) { return function () { theRadio.SetIsChecked(true); showCurrent(bool); } }(radioAll, false);
        radioCurrent.SetOnClick(selectCurrent, theThis);
        radioAll.SetOnClick(selectAll, theThis);
        popup.AddContent(radioButtonList);
    }
    function createHybridOrMapSection() {
        var radioButtonList = new tf.ui.RadioButtonList();
        var radioHybrid = radioButtonList.AddRadioButton("Hybrid Display", showingHybridVal, showingHybrid, "Base Layers Visible on Hybrid Display Type", true);
        var radioMap = radioButtonList.AddRadioButton("Map Display", showingMapVal, !showingHybrid, "Base Layers Visible on Map Display Type", true);
        var selectHybrid= function (theRadio, bool) { return function () { theRadio.SetIsChecked(true); showHybrid(bool); } }(radioHybrid, true);
        var selectMap = function (theRadio, bool) { return function () { theRadio.SetIsChecked(true); showHybrid(bool); } }(radioMap, false);
        radioHybrid.SetOnClick(selectHybrid, theThis);
        radioMap.SetOnClick(selectMap, theThis);
        popup.AddContent(radioButtonList);
    }
    function createPopupContent() {
        createHybridOrMapSection();
        createAllOrCurrentSection();
        divOptions = new tf.dom.Div({ cssClass: styles.GetUnPaddedDivClassNames(false, false) });
        legendOptionsH.AppendTo(divOptions);
        popup.AddContent(divOptions);
    }
    function initialize() {
        popup = new tf.ui.Popup({
            container: container,
            titleStr: tf.consts.baseMapLayersName,
            rectProvider: rectProvider
        });
        legendOptionsH = new tf.map.ui.LegendOptions({
            debug: debug,
            callBackOptionChange: onOptionChange,
            callBackCompositesChange: onCompositesChange,
            checkPositionAndSizeCallBack: onContainerResize
        });
        legendOptionsM = new tf.map.ui.LegendOptions({
            debug: debug,
            callBackOptionChange: onOptionChange,
            callBackCompositesChange: onCompositesChange,
            checkPositionAndSizeCallBack: onContainerResize
        });
        createPopupContent();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
}
/**
 * class tf.map.ui.Mapnik1Popup - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} container - parameter description?
 * @param {?} tMap - parameter description?
 * @param {?} callBackStringChange - parameter description?
 * @param {?} callBackOptionChange - parameter description?
 * @param {?} rectProvider - parameter description?
 * @param {?} debug - parameter description?
*/
tf.map.ui.Mapnik1Popup = function (container, tMap, callBackStringChange, callBackOptionChange, rectProvider, debug) {
    var theThis = null;
    var popup = null;
    var showingCurrent = true;
    var currentHString = "", currentMString = "";
    var legendOptions = null;
    var currentRadioVal = "current";
    var allRadioVal = "all";
/**
 * method tf.map.ui.Mapnik1Popup.Show - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} bool - parameter description?
*/
    this.Show = function (bool) { if (popup) { popup.Show(bool); } }
/**
 * method tf.map.ui.Mapnik1Popup.IsShowing - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.IsShowing = function () { return popup ? popup.IsShowing() : false; }
/**
 * method tf.map.ui.Mapnik1Popup.Toggle - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.Toggle = function () { this.Show(!this.IsShowing()); }
/**
 * method tf.map.ui.Mapnik1Popup.OnResolutionChange - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.OnResolutionChange = function (newRes) { return onResolutionChange(newRes); }
/**
 * method tf.map.ui.Mapnik1Popup.GetHasLegend - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetHasLegend = function () { return legendOptions.GetHasLegend(); }
/**
 * method tf.map.ui.Mapnik1Popup.OnContainerResize - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.OnContainerResize = function () { onContainerResize(); }
/**
 * method tf.map.ui.Mapnik1Popup.SetLegend - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} tLegendSet - parameter description?
*/
    this.SetLegend = function (tLegendSet) { return legendOptions.SetLegend(tLegendSet); }
/**
 * method tf.map.ui.Mapnik1Popup.GetHybridString - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetHybridString = function () { return currentHString; }
/**
 * method tf.map.ui.Mapnik1Popup.GetMapString - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetMapString = function () { return currentMString; }
    function onResolutionChange(newRes) { if (tMap) { legendOptions.SetResolution(newRes); } }
    function showCurrent(bool) { legendOptions.SetShowCurrent(showingCurrent = !!bool); }
    function setLegendStrings(newHString, newMString) {
        if (currentHString != newHString || currentMString != newMString) {
            currentHString = newHString; currentMString = newMString;
            if (callBackStringChange) { callBackStringChange.call(tMap, currentHString, currentMString); }
        }
    }
    function onContainerResize() { if (popup) { popup.OnContainerResize(); } }
    function onOptionChange() { if (callBackOptionChange) { callBackOptionChange.call(tMap); } }
    function onCompositesChange(legendOptions, composites) {
        var newHString = "", newMString = "", addedStr = false;
        for (var i in composites) {
            var thisComposite = composites[i];
            var compositeHString = thisComposite.PREFIX + thisComposite.SUFFIX_H;
            var compositeMString = thisComposite.PREFIX + thisComposite.SUFFIX_M;
            if (addedStr) { newHString += "+" + compositeHString; newMString += "+" + compositeMString; }
            else { addedStr = true; newHString = compositeHString; newMString = compositeMString; }
        }
        setLegendStrings(newHString, newMString)
    }
    function createPopupContent() {
        var radioButtonList = new tf.ui.RadioButtonList();
        var radioCurrent = radioButtonList.AddRadioButton("Current Resolution", currentRadioVal, showingCurrent, "Base Layers Visible at Current Resolution", true);
        var radioAll = radioButtonList.AddRadioButton("All Resolutions", allRadioVal, !showingCurrent, "Base Layers Visible at All Resolutions", true);
        var selectCurrent = function (theRadio, bool) { return function () { theRadio.SetIsChecked(true); showCurrent(bool); } }(radioCurrent, true);
        var selectAll = function (theRadio, bool) { return function () { theRadio.SetIsChecked(true); showCurrent(bool); } }(radioAll, false);
        radioCurrent.SetOnClick(selectCurrent, theThis);
        radioAll.SetOnClick(selectAll, theThis);
        popup.AddContent(radioButtonList);
        popup.AddContent(legendOptions);
    }
    function initialize() {
        popup = new tf.ui.Popup({
            container: container, titleStr: tf.consts.baseMapLayersName, rectProvider: rectProvider
        });
        legendOptions = new tf.map.ui.LegendOptions({
            debug: debug,
            callBackOptionChange: onOptionChange,
            callBackCompositesChange: onCompositesChange,
            checkPositionAndSizeCallBack: onContainerResize
        });
        createPopupContent();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * class tf.map.ui.LegendOptions - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} settings - parameter description?
*/
tf.map.ui.LegendOptions = function (settings) {
    var theThis, styles, debug;
    var callBackOptionChange, callBackCompositesChange, checkPositionAndSizeCallBack, currentResolution ;
    var tLegend, hasLegend, domObj, domElement, lastOpenedClickOnClosed, isShowingCurrent;
    var groupCheckBoxes, checkBoxes, tolerance, bgColorSubDiv, colorTextInRes, colorTextNotInRes;
    var regularClass, lastClass;
/**
 * method tf.map.ui.LegendOptions.SetLegend - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} tLegendSet - parameter description?
*/
    this.SetLegend = function (tLegendSet) { tLegend = (tLegendSet instanceof tf.map.aux.LegendDecoder) ? tLegendSet : null; fillDomElement(); }
/**
 * method tf.map.ui.LegendOptions.GetHasLegend - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetHasLegend = function () { return hasLegend; }
/**
 * method tf.map.ui.LegendOptions.SetShowCurrent - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} bool - parameter description?
*/
    this.SetShowCurrent = function (bool) { return setShowCurrent(bool); }
/**
 * method tf.map.ui.LegendOptions.GetIsShowingCurrent - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetIsShowingCurrent = function () { return isShowingCurrent; }
/**
 * method tf.map.ui.LegendOptions.SetResolution - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} currentResolutionSet - parameter description?
*/
    this.SetResolution = function (currentResolutionSet) { setResolution (currentResolutionSet); }
    function onContainerResize() { if (!!checkPositionAndSizeCallBack) { checkPositionAndSizeCallBack(); } }
    function setResolution(currentResolutionSet) { currentResolution = tf.js.GetFloatNumber(currentResolutionSet, tf.consts.defaultRes); onResolutionChange(false); }
    function setShowCurrent(bool) { isShowingCurrent = !!bool; onResolutionChange(false); }
    function fillDomElement() {
        hasLegend = false;
        tf.dom.RemoveAllChildren(domElement);
        if (!!tLegend) {
            var groupSetNames = tLegend.GetGroupSetNames();
            var groupSet = tLegend.GetGroupSet();
            var groupSetRootName = tLegend.GetGroupSetRootName();
            var len = groupSetNames.length;
            var divClasses = styles.GetUnPaddedDivClassNames(false, false);
            groupCheckBoxes = [];
            checkBoxes = [];
            lastOpenedClickOnClosed = null;
            if (hasLegend = len > 0) {
                var checkBoxList = new tf.ui.CheckBoxList(false);
                var lastGroupSetIndex = len - 1;
                var nSubgroups = 0;
                for (var i = 0 ; i < len ; i++) {
                    var thisGroupSetName = groupSetNames[i];
                    var thisGroupSet = groupSet[thisGroupSetName];
                    var thisGroupSetItems = thisGroupSet.items;
                    var nItems = thisGroupSetItems.length;
                    var checkBoxListForItems = checkBoxList;
                    var thisEnclosingGroup = null;
                    var closeImgObj = null;
                    var divToChangeColor = null;
                    var isSubGroup = thisGroupSetName !== groupSetRootName;
                    if (isSubGroup) {
                        var isLast = lastGroupSetIndex == nSubgroups;
                        var checkBoxWithClickOnClose = checkBoxList.AddCheckBoxWithLabelAndOpenClose(thisGroupSetName, true, "", isLast);
                        var checkBoxObj = checkBoxWithClickOnClose.GetCheckBox();
                        nSubgroups++;
                        closeImgObj = checkBoxWithClickOnClose.GetClickOpenClose();
                        checkBoxListForItems = new tf.ui.CheckBoxList();
                        checkBoxList.AddContent(checkBoxListForItems, true);
                        thisEnclosingGroup = { div: checkBoxWithClickOnClose, checkbox: checkBoxObj, subChecks: [] };
                        groupCheckBoxes.push(thisEnclosingGroup);
                        var enclosingCallBack = function (theCheckBoxObj) {
                            return function () { setTimeout(function () { checkGroupOf(theCheckBoxObj); }, 100); }
                        }(checkBoxObj);
                        checkBoxObj.SetOnClick(enclosingCallBack, theThis);
                        divToChangeColor = checkBoxWithClickOnClose.GetParentNode();
                    }
                    if (nItems > 0) {
                        var lastItem = nItems - 1;
                        for (var j = 0 ; j < nItems ; j++) {
                            var isLast = isSubGroup ? j == lastItem : i == lastGroupSetIndex;
                            var thisItem = thisGroupSetItems[j];
                            var thisItemLabel = thisItem.LABEL;
                            var thisItemDesc = thisItem.DESC;
                            var isChecked = !!thisItem.ISCHECK;
                            thisItemDesc += '(maxRes: ' + thisItem.MAX_RES + ', minRes: ' + thisItem.MIN_RES + ')';
                            var checkBoxObj = checkBoxListForItems.AddCheckBox(thisItemLabel, isChecked, thisItemDesc, !isLast);
                            var debugText = !!debug ? JSON.stringify(thisItem) : null;
                            var onCheckBoxClick = function (theCheckBox, theText) {
                                return function () {
                                    if (!!theText) { debug.LogIfTest(theText); } setTimeout(function () { calcValidComposites(true); }, 100);
                                }
                            }(checkBoxObj, debugText);
                            checkBoxObj.SetOnClick(onCheckBoxClick, theThis);
                            var thisCheckBox = { div: checkBoxObj, checkbox: checkBoxObj, item: thisItem };
                            checkBoxes.push(thisCheckBox);
                            if (thisEnclosingGroup) {
                                thisEnclosingGroup.subChecks.push(thisCheckBox);
                                var thisGroupDiv = checkBoxObj.GetParentNode();
                                thisGroupDiv.style.backgroundColor = bgColorSubDiv;
                            }
                        }
                    }
                    if (closeImgObj) {
                        var theCallBack = function (theClickOnClosed) {
                            return function () {
                                if (theClickOnClosed.GetIsOpen()) {
                                    if (lastOpenedClickOnClosed) { lastOpenedClickOnClosed.SetIsOpen(false); }
                                    lastOpenedClickOnClosed = theClickOnClosed;
                                }
                                else { lastOpenedClickOnClosed = null; }
                                onContainerResize();
                            }
                        }(closeImgObj);
                        var subParent = checkBoxListForItems.GetParentNode();
                        subParent.style.display = 'none';
                        closeImgObj.SetDivOpenClose(subParent, theCallBack);
                    }
                }
                checkBoxList.AppendTo(domElement);
                onResolutionChange(true);
            }
            else {
                var divText = new tf.dom.Div({ cssClass: regularClass });
                var textElement = document.createTextNode("No Base Layers");
                var divTextdiv = divText.GetHTMLElement();
                divTextdiv.appendChild(textElement);
                divTextdiv.style.textAlign = 'center';
                divTextdiv.style.color = 'rgb(0, 0, 0)';
                divTextdiv.style.backgroundColor = 'rgb(255, 255, 0)';
                divText.AppendTo(domElement);
            }
        }
    }
    function checkGroupOf(theCheckBoxObj) {
        var nGroupCheckBoxes = groupCheckBoxes.length;
        for (var i = 0 ; i < nGroupCheckBoxes ; i++) {
            var thisGroupCheckBox = groupCheckBoxes[i];
            if (thisGroupCheckBox.checkbox == theCheckBoxObj) {
                var isChecked = theCheckBoxObj.GetIsChecked();
                var subs = thisGroupCheckBox.subChecks;
                var nSubs = subs.length;
                for (var j = 0 ; j < nSubs ; j++) {
                    var thisCheckBox = subs[j];
                    var thisCheckBoxObj = thisCheckBox.checkbox;
                    thisCheckBoxObj.SetIsChecked(isChecked);
                }
            }
        }
        calcValidComposites(true);
    }
    function hideShowGroups() {
        var nGroupCheckBoxes = groupCheckBoxes.length;
        var lastDivShown = null;
        for (var i = 0 ; i < nGroupCheckBoxes ; i++) {
            var thisGroupCheckBox = groupCheckBoxes[i];
            var thisCheckBoxObj = thisGroupCheckBox.checkbox;
            var thisGroupLabel = thisCheckBoxObj.GetLabel();
            var thisGroupDiv = thisGroupCheckBox.div.GetParentNode();
            var groupHasItemsThatWillShow = false;
            var groupWillShow = !isShowingCurrent;
            var subs = thisGroupCheckBox.subChecks;
            var nSubs = subs.length;
            for (var j = 0 ; (!groupHasItemsThatWillShow) && (j < nSubs) ; j++) {
                var thisCheckBox = subs[j];
                var thisItemDiv = thisCheckBox.div.GetParentNode();
                if (groupHasItemsThatWillShow = (thisItemDiv.style.display === 'block')) { groupWillShow = true; }
            }
            thisGroupLabel.style.color = groupHasItemsThatWillShow ? colorTextInRes : colorTextNotInRes;
            thisGroupDiv.style.display = groupWillShow ? 'block' : 'none';
            if (groupWillShow) {
                tf.dom.AddCSSClass(thisGroupDiv, regularClass);
                lastDivShown = thisGroupDiv;
            }
        }
        if (lastDivShown) {
            tf.dom.ReplaceCSSClass(lastDivShown, regularClass, lastClass);
        }
    }
    function onResolutionChange(optionChanged) {
        if (hasLegend) {
            var nCheckboxes = checkBoxes.length;
            for (var i = 0 ; i < nCheckboxes ; i++) {
                var thisCheckBox = checkBoxes[i];
                var thisCheckBoxObj = thisCheckBox.checkbox;
                var thisItem = thisCheckBox.item;
                var thisItemMinRes = thisItem.MIN_RES - tolerance;
                var thisItemMaxRes = thisItem.MAX_RES + tolerance;
                var thisCheckInResRange = thisItemMinRes <= currentResolution && thisItemMaxRes >= currentResolution;
                var thisItemLabel = thisCheckBoxObj.GetLabel();
                var thisItemDiv = thisCheckBox.div.GetParentNode();
                if (thisCheckInResRange) {
                    thisItemLabel.style.color = colorTextInRes;
                    thisItemDiv.style.display = 'block';
                }
                else {
                    thisItemLabel.style.color = colorTextNotInRes;
                    thisItemDiv.style.display = isShowingCurrent ? 'none' : 'block';
                }
            }
            hideShowGroups();
            calcValidComposites(optionChanged);
        }
        onContainerResize();
    }
    function calcValidComposites(optionChanged) {
        var nCheckboxes = checkBoxes.length;
        var composites = [];
        for (var i = 0 ; i < nCheckboxes ; i++) {
            var thisCheckBox = checkBoxes[i];
            var thisCheckBoxObj = thisCheckBox.checkbox;
            if (thisCheckBoxObj.GetIsChecked()) {
                var thisItem = thisCheckBox.item;
                var thisItemMinRes = thisItem.MIN_RES - tolerance;
                var thisItemMaxRes = thisItem.MAX_RES + tolerance;
                var thisCheckInResRange = thisItemMinRes <= currentResolution && thisItemMaxRes >= currentResolution;
                if (thisCheckInResRange) {
                    var thisItemComposites = thisItem.COMPOSITES;
                    var thisItemNComposites = thisItemComposites.length;
                    for (var ci = 0 ; ci < thisItemNComposites ; ci++) {
                        var thisComposite = thisItemComposites[ci];
                        var thisCompositeMinRes = thisComposite.MIN - tolerance;
                        var thisCompositeMaxRes = thisComposite.MAX + tolerance;
                        var thisCompositeInResRange = thisCompositeMinRes <= currentResolution && thisCompositeMaxRes >= currentResolution;
                        if (thisCompositeInResRange) { composites.push(thisComposite); }
                    }
                }
            }
        }
        if (optionChanged) { if (!!callBackOptionChange) { callBackOptionChange(theThis); } }
        if (!!callBackCompositesChange) { callBackCompositesChange(theThis, composites); }
    }
    function initialize() {
        isShowingCurrent = true;
        currentResolution = 0;
        debug = settings.debug;
        styles = tf.GetStyles();
        var subStyles = styles.GetSubStyles();
        groupCheckBoxes = [];
        checkBoxes = [];
        tolerance = 0.00001;
        bgColorSubDiv = subStyles.mapSubLegendBkColor;
        colorTextInRes = subStyles.darkTextColor;
        colorTextNotInRes = subStyles.disabledTextColor;
        regularClass = styles.GetPaddedDivClassNames(false, false);
        lastClass = styles.GetPaddedDivClassNames(false, true);
        callBackOptionChange = tf.js.GetFunctionOrNull(settings.callBackOptionChange);
        callBackCompositesChange = tf.js.GetFunctionOrNull(settings.callBackCompositesChange);
        checkPositionAndSizeCallBack = tf.js.GetFunctionOrNull(settings.checkPositionAndSizeCallBack);
        domElement = (domObj = new tf.dom.Div({ cssClass: styles.GetUnPaddedDivClassNames(false, false) })).GetHTMLElement();
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: domElement });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
}
tf.js.InheritFrom(tf.map.ui.LegendOptions, tf.dom.Insertable);
/**
 * class tf.map.ui.LayersPopup - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} container - parameter description?
 * @param {?} tMap - parameter description?
 * @param {?} theHasLegendCallBack - parameter description?
 * @param {?} rectProvider - parameter description?
 * @param {?} showMapBaseLayers - parameter description?
 * @param {?} getLayers - parameter description?
*/
tf.map.ui.LayersPopup = function (container, tMap, theHasLegendCallBack, rectProvider, showMapBaseLayers, getLayers) {
    var theThis = null;
    var popup = null;
    var layerCheckBoxes = [];
/**
 * method tf.map.ui.LayersPopup.Show - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} bool - parameter description?
*/
    this.Show = function (bool) { if (popup) { popup.Show(bool); } }
/**
 * method tf.map.ui.LayersPopup.IsShowing - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.IsShowing = function () { return popup ? popup.IsShowing() : false; }
/**
 * method tf.map.ui.LayersPopup.Toggle - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.Toggle = function () { this.Show(!this.IsShowing()); }
/**
 * method tf.map.ui.LayersPopup.OnContainerResize - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.OnContainerResize = function () { onContainerResize(); }
/**
 * method tf.map.ui.LayersPopup.RefreshContent - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.RefreshContent = function () { return refreshContent(); }
/**
 * method tf.map.ui.LayersPopup.UpdateLayerVisibilityFromMap - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.UpdateLayerVisibilityFromMap = function () {
        var nCheckboxes = layerCheckBoxes.length;
        for (var i = 0 ; i < nCheckboxes ; i++) {
            var thisLayerCheckBox = layerCheckBoxes [i] ;
            var thisLayer = thisLayerCheckBox.layer;
            var thisCheckObj = thisLayerCheckBox.checkBox;
            var thisCheck = thisCheckObj.GetCheckBox();
            var thisLayerVisible = thisLayer.GetIsVisible () ;
            if (thisLayerVisible != thisCheck.checked) {
                thisCheck.checked = thisLayerVisible;
            }
        }
    }
    function refreshContent() {
        popup.ClearContent();
        layerCheckBoxes = [];
        divFillElem(this);
    }
    function divFillElem(theThis) {
        var layers = getLayers();
        var nLayers = layers.length;
        var hasLayers = nLayers > 0;
        var hasLegend = theHasLegendCallBack ? theHasLegendCallBack.call(tMap) : false;
        if (hasLayers) {
            var checkBoxList = new tf.ui.CheckBoxList(false);
            var lastIndex = nLayers - 1;
            for (var i = 0 ; i < nLayers ; i++) {
                var isLast = i == lastIndex && ! hasLegend;
                var thisLayer = layers[i];
                var thisLayerName = thisLayer.GetName();
                var thisLayerDesc = thisLayer.GetDesc();
                var thisLayerCheck = thisLayer.GetIsVisible();
                //var thisLayerColor = tf.js.GetHexColorStr(thisLayer.GetLayerColor());
                if (thisLayerDesc == null || typeof thisLayerDesc != "string" || thisLayerDesc == "") { thisLayerDesc = thisLayerName; }
                var checkBoxObj = checkBoxList.AddCheckBox(thisLayerName, thisLayerCheck, /*"toggle " + */thisLayerDesc, !isLast);
                var checkToggleLayerVisible = function (theCheckBox, theLayer) {
                    return function () {
                        setTimeout( function() { theLayer.SetVisible(theCheckBox.GetIsChecked()); }, 100 );
                    }
                }(checkBoxObj, thisLayer);
                layerCheckBoxes.push({ layer: thisLayer, checkBox: checkBoxObj });
                checkBoxObj.SetOnClick(checkToggleLayerVisible, theThis, [thisLayer]);
            }
            popup.AddContent(checkBoxList);
        }
        else {
            var divText = new tf.dom.Div({ cssClass: tf.GetStyles().paddedBlockDivClass });
            var textElement = document.createTextNode("Map has no Data Layers");
            var divTextdiv = divText.GetHTMLElement();
            divTextdiv.appendChild(textElement);
            divTextdiv.style.align = 'center';
            divTextdiv.style.color = 'rgb(0, 0, 0)';
            divTextdiv.style.backgroundColor = 'rgb(255, 255, 0)';
            popup.AddContent(divText);
        }
        if (hasLegend) {
            var styles = tf.GetStyles();
            var subStyles = styles.GetSubStyles();
            var row = new tf.dom.Div({ cssClass: styles.paddedBlockDivClass });
            //var buttonDim = subStyles.mapButtonDimEmNumber + "em";
            //var buttonDim = subStyles.mapControlFontSizeEmNumber + "em";
            var toolTipStr = tf.consts.baseMapLayersToolTip;
            var buttonFunction = function () { showMapBaseLayers(); };
            var button = styles.AddButtonDivMargins(new tf.ui.TextBtn({ style: styles.mapTextBtnClass, label: tf.consts.baseMapLayersName, onClick: buttonFunction, tooltip: toolTipStr, dim: "1.2em" }));
            row.GetHTMLElement().style.textAlign = "center";
            button.AppendTo(row);
            popup.AddContent(row);
        }
        onContainerResize();
    }
    function onContainerResize() { if (popup) { popup.OnContainerResize(); } }
    function initialize() {
        popup = new tf.ui.Popup({
            container: container,
            titleStr: tf.consts.mapLayersName,
            rectProvider: rectProvider
        });
        refreshContent();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
}
/**
 * class tf.map.ui.TypesPopup - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} container - parameter description?
 * @param {?} tMap - parameter description?
 * @param {?} theMapSetModeCallBack - parameter description?
 * @param {?} rectProvider - parameter description?
*/
tf.map.ui.TypesPopup = function (container, tMap, theMapSetModeCallBack, rectProvider) {
    var theThis, popup, radioButtons;
/**
 * method tf.map.ui.TypesPopup.Show - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} bool - parameter description?
*/
    this.Show = function (bool) { if (popup) { popup.Show(bool); } }
/**
 * method tf.map.ui.TypesPopup.IsShowing - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.IsShowing = function () { return popup ? popup.IsShowing() : false; }
/**
 * method tf.map.ui.TypesPopup.Toggle - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.Toggle = function () { this.Show(!this.IsShowing()); }
/**
 * method tf.map.ui.TypesPopup.UpdateModeFromMap - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.UpdateModeFromMap = function () {
        var currentMode = tMap.GetMapType();
        for (var i in radioButtons) {
            var theButton = radioButtons[i];
            var theRadioButton = theButton.GetRadioButton();
            var theValue = theRadioButton.value;
            if (theValue == currentMode) {
                var isChecked = theRadioButton.checked ;
                if (! isChecked) { theRadioButton.checked = true; }
                break;
            }
        }
    }
/**
 * method tf.map.ui.TypesPopup.OnContainerResize - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.OnContainerResize = function () { onContainerResize(); }
    function onContainerResize() { if (popup) { popup.OnContainerResize(); } }
    function divFillElem(theThis) {
        var currentMode = tMap.GetMapType();
        var radioButtonList = new tf.ui.RadioButtonList();
        var popupRadioHybrid = radioButtonList.AddRadioButton(tf.consts.mapTypesHybridLabel, tf.consts.typeNameHybrid, tf.consts.typeNameHybrid == currentMode, tf.consts.mapTypesHybridTip, true);
        var popupRadioAerial = radioButtonList.AddRadioButton(tf.consts.mapTypesAerialLabel, tf.consts.typeNameAerial, tf.consts.typeNameAerial == currentMode, tf.consts.mapTypesAerialTip, true);
        var popupRadioMap = radioButtonList.AddRadioButton(tf.consts.mapTypesMapLabel, tf.consts.typeNameMap, tf.consts.typeNameMap == currentMode, tf.consts.mapTypesMapTip, false);
        radioButtons = [popupRadioHybrid, popupRadioAerial, popupRadioMap];
        for (var i in radioButtons) {
            var thisRadio = radioButtons[i];
            var changeType = function (theRadio) {
                return function () {
                    theRadio.SetIsChecked(true);
                    var value = theRadio.GetRadioButton().value; theMapSetModeCallBack.call(tMap, value);
                }
            }(thisRadio);
            thisRadio.SetOnClick(changeType, theThis);
        }
        popup.SetContent(radioButtonList);
        onContainerResize();
    }
    function initialize() {
        popup = new tf.ui.Popup({
            container: container,
            titleStr: tf.consts.mapTypesName,
            rectProvider: rectProvider
        });
        divFillElem(this);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
}
/**
 * class tf.map.ui.SourcesPopup - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} container - parameter description?
 * @param {?} tMap - parameter description?
 * @param {?} theMapSetSourceCallBack - parameter description?
 * @param {?} rectProvider - parameter description?
*/
tf.map.ui.SourcesPopup = function (container, tMap, theMapSetSourceCallBack, rectProvider) {
    var theThis, popup, radioButtons;
    /*var mapSources = [
        tf.consts.sourceName_best_available, tf.consts.sourceName_naip_1m, tf.consts.sourceName_usgs_toop_r, tf.consts.sourceName_county_1ft,
        tf.consts.sourceName_landsat7_321, tf.consts.sourceName_usgs_1m, tf.consts.sourceName_country_3inch, tf.consts.sourceName_usgs_ap_cir,
        tf.consts.sourceName_usgs_ap_r, tf.consts.sourceName_dor_1ft
    ];*/
    var mapSources = [
        "Best_Available",
        "AIRPHOTO_C",
        "AIRPHOTO2FT",
        "COUNTY_1FT",
        "COUNTY_1M",
        "COUNTY_2FT",
        "COUNTY_3INCH",
        "COUNTY_6INCH",
        "COUNTY_CIR_1FT",
        "COUNTY_CIR_30CM",
        "COUNTY_CLR_10CM",
        "COUNTY_CLR_30CM",
        "DOR_1FT",
        "GEOEYE-1_CLR_1M",
        "GEOEYE-1_CLR_50CM",
        "IKONOS_1M",
        "IKONOS_2001",
        "IKONOS_4M",
        "IKONOS_BW_1M",
        "IKONOS_C",
        "IKONOS_GEOEYE-1_1M",
        "IKONOS-1_0.5M",
        "KOMPSAT-2_CIR_1M",
        "LANDSAT7_321",
        "LANDSAT7_321_28.5M",
        "LANDSAT7_432",
        "LANDSAT7_432_28.5M",
        "LANDSAT7_742",
        "LANDSAT7_PS_C",
        "NAIP_1M",
        "SPOT_CIR_2.5M",
        "SRTM",
        "TRILLIUM",
        "USGS_15CM",
        "USGS_1FT_CITIES",
        "USGS_1M",
        "USGS_20CM",
        "USGS_30CM",
        "USGS_65CM",
        "USGS_75CM",
        "USGS_AP_BW",
        "USGS_AP_CIR",
        "USGS_BW_15CM",
        "USGS_BW_30CM",
        "WV01_BW_50CM",
        "WV02_50CM",
        "BMNG",
        "USGS_BW_3INCH",
        "USGS_60CM",
        "I3"
];
/**
 * method tf.map.ui.SourcesPopup.Show - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} bool - parameter description?
*/
    this.Show = function (bool) { if (popup) { popup.Show(bool); } }
/**
 * method tf.map.ui.SourcesPopup.IsShowing - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.IsShowing = function () { return popup ? popup.IsShowing() : false; }
/**
 * method tf.map.ui.SourcesPopup.Toggle - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.Toggle = function () { this.Show(!this.IsShowing()); }
/**
 * method tf.map.ui.SourcesPopup.UpdateSourceFromMap - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.UpdateSourceFromMap = function () {
        var currentValue = tMap.GetSource ();
        for (var i in radioButtons) {
            var theButton = radioButtons[i];
            var theRadioButton = theButton.GetRadioButton();
            var theValue = theRadioButton.value;
            if (theValue == currentValue) {
                var isChecked = theRadioButton.checked;
                if (!isChecked) { theRadioButton.checked = true; }
                break;
            }
        }
    }
/**
 * method tf.map.ui.SourcesPopup.OnContainerResize - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.OnContainerResize = function () { onContainerResize(); }
    function onContainerResize() { if (popup) { popup.OnContainerResize(); } }
    function changeType(theRadioButton) { theMapSetSourceCallBack.call(tMap, theRadioButton.GetRadioButton().value); }
    function divFillElem(theThis) {
        var nMapSources = mapSources.length;
        var currentSource = tMap.GetSource();
        radioButtons = [];
        var radioButtonList = new tf.ui.RadioButtonList();
        var lastIndex = nMapSources - 1;
        for (var i in mapSources) {
            var thisMapSource = mapSources[i];
            var isLast = i == lastIndex;
            var thisRadioButton = radioButtonList.AddRadioButton(thisMapSource, thisMapSource, thisMapSource == currentSource, tf.consts.mapSourcesItemTip + "\"" + thisMapSource + "\"", !isLast);
            var changeTypeCB = function (theButton) { return function () { theButton.SetIsChecked(true); changeType(theButton); } }(thisRadioButton);
            thisRadioButton.SetOnClick(changeTypeCB, theThis);
            radioButtons.push(thisRadioButton);
        }
        popup.SetContent(radioButtonList);
        onContainerResize();
    }
    function initialize() {
        popup = new tf.ui.Popup({
            container: container,
            titleStr: tf.consts.mapSourcesName,
            rectProvider: rectProvider
        });
        divFillElem(this);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
}
/**
 * class tf.map.ui.InfoPopup - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} container - parameter description?
*/
tf.map.ui.InfoPopup = function (container) {
    var theThis = null;
    var colorInfo = null;
    var popup = null;
    var divTitle = null;
    var colorPopupSaved = null;
    var divContainerElem = null;
/**
 * method tf.map.ui.InfoPopup.ShowTitleColorInfo - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} bool - parameter description?
*/
    this.ShowTitleColorInfo = function (bool) {
        if (!!divTitle) {
            bool = !!bool;
            var colorUse = bool ? colorInfo : colorPopupSaved;
            divTitle.style.backgroundColor = colorUse;
            popup.SetTitleToolTip(bool? "Unpin" : "Pin");
        }
    }
/**
 * method tf.map.ui.InfoPopup.SetOnClickTitle - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} callBack - parameter description?
 * @param {?} optionalScope - parameter description?
*/
    this.SetOnClickTitle = function (callBack, optionalScope) { if (popup) { popup.SetOnClickTitle(callBack, optionalScope); } }
/**
 * method tf.map.ui.InfoPopup.SetZIndex - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} zIndex - parameter description?
*/
    this.SetZIndex = function (zIndex) { popup && popup.SetZIndex (zIndex) ; }
/**
 * method tf.map.ui.InfoPopup.GetZIndex - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetZIndex = function () { return popup ? popup.GetZIndex() : 0;}
/**
 * method tf.map.ui.InfoPopup.SetOnClose - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} callBack - parameter description?
 * @param {?} optionalScope - parameter description?
*/
    this.SetOnClose = function (callBack, optionalScope) { popup.SetOnClose(callBack, optionalScope); }
/**
 * method tf.map.ui.InfoPopup.SetTitle - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} titleStr - parameter description?
*/
    this.SetTitle = function (titleStr) { popup && popup.ChangeTitle(titleStr); }
/**
 * method tf.map.ui.InfoPopup.SetContent - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} content - parameter description?
*/
    this.SetContent = function (content) { if (popup) { return popup.SetContent(content); } }
/**
 * method tf.map.ui.InfoPopup.Show - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} bool - parameter description?
*/
    this.Show = function (bool) { if (popup) { popup.Show(bool); } }
/**
 * method tf.map.ui.InfoPopup.IsShowing - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.IsShowing = function () { return popup ? popup.IsShowing() : false; }
/**
 * method tf.map.ui.InfoPopup.Toggle - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.Toggle = function () { this.Show(!this.IsShowing()); }
/**
 * method tf.map.ui.InfoPopup.OnContainerResize - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.OnContainerResize = function () { onContainerResize(); }
    function onContainerResize() { if (popup) { popup.OnContainerResize(); } }
    function initialize() {
        var styles = tf.GetStyles();
        var subStyles = styles.GetSubStyles();
        popup = new tf.ui.Popup({
            //bkColor: "rgba(10, 10, 10, 0.5)",
            container: container,
            titleStr: "Information",
            marginHor: (4 * subStyles.mapButtonMarginEmNumber + subStyles.mapButtonDimEmNumber) + "em",
            marginVer: (1 * subStyles.mapButtonMarginEmNumber + subStyles.mapButtonDimEmNumber) + "em",
            maxHeight: "50%",
            horPos: "left",
            verPos: "bottom",
            fontSize: subStyles.infoPopupContentFontSizeEmNumber + "em"
        });
        divTitle = popup.GetTitleContainer();
        divContainerElem = tf.dom.GetHTMLElementFrom(container);
        popup.SetTitleToolTip("Pin");
        colorInfo = "rgba(251,127,0,1)";
        colorPopupSaved = divTitle.style.backgroundColor;
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
}
/**
 * class tf.map.ui.LocationPopup - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} container - parameter description?
*/
tf.map.ui.LocationPopup = function (container) {
    var theThis = null;
    var popup = null;
    var divTitle = null;
    var divContainerElem = null;
    var colorLocInfo = null;
    var colorPopupSaved = null;
/**
 * method tf.map.ui.LocationPopup.ShowTitleColorInfo - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} bool - parameter description?
*/
    this.ShowTitleColorInfo = function (bool) {
        if (!!divTitle) {
            bool = !!bool;
            var colorUse = !!bool ? colorLocInfo : colorPopupSaved;
            divTitle.style.backgroundColor = colorUse;
            //popup.SetTitleToolTip(bool ? "Unpin" : "Pin");
        }
    }
/**
 * method tf.map.ui.LocationPopup.SetOnClickTitle - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} callBack - parameter description?
 * @param {?} optionalScope - parameter description?
*/
    this.SetOnClickTitle = function (callBack, optionalScope) { if (popup) { popup.SetOnClickTitle(callBack, optionalScope); } }
/**
 * method tf.map.ui.LocationPopup.SetZIndex - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} zIndex - parameter description?
*/
    this.SetZIndex = function (zIndex) { popup && popup.SetZIndex(zIndex); }
/**
 * method tf.map.ui.LocationPopup.GetZIndex - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetZIndex = function () { return popup ? popup.GetZIndex() : 0; }
/**
 * method tf.map.ui.LocationPopup.SetOnClose - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} callBack - parameter description?
 * @param {?} optionalScope - parameter description?
*/
    this.SetOnClose = function (callBack, optionalScope) { popup.SetOnClose(callBack, optionalScope); }
/**
 * method tf.map.ui.LocationPopup.SetTitle - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} titleStr - parameter description?
*/
    this.SetTitle = function (titleStr) { popup && popup.ChangeTitle(titleStr); }
/**
 * method tf.map.ui.LocationPopup.SetContent - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} content - parameter description?
*/
    this.SetContent = function (content) { if (popup) { return popup.SetContent(content); } }
/**
 * method tf.map.ui.LocationPopup.Show - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} bool - parameter description?
*/
    this.Show = function (bool) { if (popup) { popup.Show(bool); } }
/**
 * method tf.map.ui.LocationPopup.IsShowing - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.IsShowing = function () { return popup ? popup.IsShowing() : false; }
/**
 * method tf.map.ui.LocationPopup.Toggle - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.Toggle = function () { this.Show(!this.IsShowing()); }
/**
 * method tf.map.ui.LocationPopup.OnContainerResize - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.OnContainerResize = function () { onContainerResize(); }
    function onContainerResize() { if (popup) { popup.OnContainerResize(); } }
    function initialize() {
        var styles = tf.GetStyles();
        var subStyles = styles.GetSubStyles();
        popup = new tf.ui.Popup({
            container: container,
            noTitle: true,
            titleStr: "Map Center",
            marginHor: (6 * subStyles.mapButtonMarginEmNumber + subStyles.mapButtonDimEmNumber) + "em",
            marginVer: subStyles.mapLocationButtonTopEmNumber + "em",
            maxHeight: "50%",
            maxWidth: "100%",
            horPos: "right",
            verPos: "top",
            fontSize: subStyles.locationPopupContentFontSizeEmNumber + "em",
            textAlign: "right"
        });
        divTitle = popup.GetTitleContainer();
        divContainerElem = tf.dom.GetHTMLElementFrom(container);
        //popup.SetTitleToolTip("Pin");
        colorLocInfo = "rgba(2,249,15,1.0)";
        colorPopupSaved = !!divTitle ? divTitle.style.backgroundColor : colorLocInfo;
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
}
/**
 * class tf.map.ui.MessagePopup - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} container - parameter description?
*/
tf.map.ui.MessagePopup = function (container) {
    var theThis = null;
    var colorMsgPin = null;
    var colorTextPin = null;
    var popup = null;
    var divTitle = null;
    var colorPopupSaved = null;
/**
 * method tf.map.ui.MessagePopup.SetOnClickTitle - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} callBack - parameter description?
 * @param {?} optionalScope - parameter description?
*/
    this.SetOnClickTitle = function (callBack, optionalScope) { if (popup) { popup.SetOnClickTitle(callBack, optionalScope); } }
/**
 * method tf.map.ui.MessagePopup.ShowTitleColorInfo - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} bool - parameter description?
*/
    this.ShowTitleColorInfo = function (bool) {
        if (!!divTitle) {
            bool = !!bool;
            var colorUse = !!bool ? colorMsgPin : colorPopupSaved;
            divTitle.style.backgroundColor = colorUse;
            popup.SetTitleToolTip(bool ? "Close" : "Pin");
        }
    }
/**
 * method tf.map.ui.MessagePopup.SetZIndex - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} zIndex - parameter description?
*/
    this.SetZIndex = function (zIndex) { popup && popup.SetZIndex(zIndex); }
/**
 * method tf.map.ui.MessagePopup.GetZIndex - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetZIndex = function () { return popup ? popup.GetZIndex() : 0; }
/**
 * method tf.map.ui.MessagePopup.SetOnClose - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} callBack - parameter description?
 * @param {?} optionalScope - parameter description?
*/
    this.SetOnClose = function (callBack, optionalScope) { popup.SetOnClose(callBack, optionalScope); }
/**
 * method tf.map.ui.MessagePopup.SetTitle - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} titleStr - parameter description?
*/
    this.SetTitle = function (titleStr) { popup && popup.ChangeTitle(titleStr); }
/**
 * method tf.map.ui.MessagePopup.SetContent - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} content - parameter description?
*/
    this.SetContent = function (content) { if (popup) { return popup.SetContent(content); } }
/**
 * method tf.map.ui.MessagePopup.Show - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} bool - parameter description?
*/
    this.Show = function (bool) { if (popup) { popup.Show(bool); } }
/**
 * method tf.map.ui.MessagePopup.IsShowing - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.IsShowing = function () { return popup ? popup.IsShowing() : false; }
/**
 * method tf.map.ui.MessagePopup.Toggle - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.Toggle = function () { this.Show(!this.IsShowing()); }
/**
 * method tf.map.ui.MessagePopup.OnContainerResize - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.OnContainerResize = function () { onContainerResize(); }
    function onContainerResize() { if (popup) { popup.OnContainerResize(); } }
    function initialize() {
        var styles = tf.GetStyles(), subStyles = styles.GetSubStyles();
        popup = new tf.ui.Popup({
            container: container,
            titleStr: "Message",
            horPos: "center",
            verPos: "center",
            fontSize: subStyles.infoPopupContentFontSizeEmNumber + "em"
        });
        divTitle = popup.GetTitleContainer();
        popup.SetTitleToolTip("Pin");
        colorMsgPin = "#ddd"
        colorTextPin = subStyles.darkTextColor;
        colorPopupSaved = divTitle.style.backgroundColor;
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
}
/**
 * class tf.map.ui.AddressBar - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} container - parameter description?
 * @param {?} tMap - parameter description?
 * @param {?} rectProvider - parameter description?
*/
tf.map.ui.AddressBar = function (container, tMap, rectProvider) {
    var theThis, tBarPopup, inputObj, input, styles, subStyles, goMapButton, goDBButton, goHelpButton, inputListItem, buttonDim, geoLocation, addressBarHelpStr;
/**
 * method tf.map.ui.AddressBar.Show - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} bool - parameter description?
*/
    this.Show = function (bool) { return show (bool) ; }
/**
 * method tf.map.ui.AddressBar.IsShowing - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.IsShowing = function () { return isShowing(); }
/**
 * method tf.map.ui.AddressBar.Toggle - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.Toggle = function () { return toggle(); }
/**
 * method tf.map.ui.AddressBar.OnContainerResize - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.OnContainerResize = function () { return onContainerResize(); }
/**
 * method tf.map.ui.AddressBar.SetAddressBarText - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} addressBarText - parameter description?
*/
    this.SetAddressBarText = function (addressBarText) { return setAddressBarText(addressBarText); }
/**
 * method tf.map.ui.AddressBar.GetAddressBarText - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetAddressBarText = function () { return getAddressBarText(); }
/**
 * method tf.map.ui.AddressBar.SetAddressBarHelp - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} addressBarHelpStr - parameter description?
*/
    this.SetAddressBarHelp = function (addressBarHelpStr) { return setAddressBarHelp(addressBarHelpStr); }
    function show(bool) {
        return tBarPopup ? tBarPopup.Show(bool) : false;
    }
    function isShowing () { return tBarPopup ? tBarPopup.IsShowing() : false; }
    function toggle () {return tBarPopup ? tBarPopup.Toggle() : false; }
    function setAddressBarHelp(addressBarHelpStrSet) { addressBarHelpStr = tf.js.GetNonEmptyString(addressBarHelpStrSet, tf.consts.defaultHelp); }
    function setAddressBarText(addressBarText) { inputObj.SetValue(addressBarText); }
    function getAddressBarText() { return inputObj.GetValue(); }
    function getKeyNumFromEvent(e) { return (typeof e === "object") ? (window.event && e.keyCode) ? e.keyCode : (e.which ? e.which : 0) : 0; }
    function handleKeyPressed(e) {
        if (isShowing ()) {
            var key = getKeyNumFromEvent (e) ;
            if (key == 13) { goMap(); }
        }
    }
    function goMap() {
        var address = getAddressBarText();
        if (address.length > 0) { tMap.FlyToAddress(address); }
        else if (!!geoLocation) { geoLocation.getCurrentPosition(successGeoLoc, failedGeoLoc); }
    }
    function successGeoLoc(position) {
        /*setAddressBarText (position.coords.latitude + "," + position.coords.longitude) ;*/
        //tMap.PanTo(position.coords.latitude, position.coords.longitude);
        tMap.SetCenter(position.coords);
    }
    function successGeoLocDB(position) { tMap.GoDBByCoords(position);}
    function failedGeoLoc(err) {
        /*if (err.code == 1) { error("The user denied the request for location information.") } 
        else if (err.code == 2) { error("Your location information is unavailable.") } 
        else if (err.code == 3) { error("The request to get your location timed out.") } 
        else { error("An unknown error occurred while requesting your location.") }*/
    }
    function goDB() {
        var address = getAddressBarText();
        if (address.length > 0) { tMap.GoDBByAddress(address); }
        else if (!!geoLocation) { geoLocation.getCurrentPosition(successGeoLocDB, failedGeoLoc); }
    }
    function goHelp() { tMap.ShowMessage(addressBarHelpStr); }
    function onContainerResize() {
        /*var buttons = [goMapButton, goDBButton, goHelpButton];
        for (var button in buttons) {
            var style = buttons[button].GetHTMLElement().style;
            style.display = 'inline-block' ;
        }*/
        /*var listItemHeight = inputListItem.GetHTMLElement().clientHeight;
        var barHeight = tBarPopup.GetHTMLElement().clientHeight;
        var showButtons = listItemHeight * 1.1 > barHeight;
        if (!showButtons) {
            for (var button in buttons) {
                var style = buttons[button].GetHTMLElement().style;
                style.display = showButtons ? 'inline-block' : 'none';
            }
        }*/
    }
    function initialSetup() {
        geoLocation = navigator.geolocation;
        styles = tf.GetStyles();
        subStyles = styles.GetSubStyles();
        buttonDim = subStyles.mapButtonDimEmNumber + "em";
        addressBarHelpStr = tf.consts.defaultHelp;
        tBarPopup = new tf.ui.ToolBarPopup(container, rectProvider);
        inputListItem = new tf.dom.Div({ cssClass: tf.GetStyles().GetPaddedDivClassNames(true, false) });
        inputObj = new tf.dom.TextInput({ label: "Enter an address or a place", value: "", tooltip: "Type in an address, or lat/lon coordinates" });
        input = inputObj.GetHTMLElement();
        var onKeyPress = function () { var evt = arguments[0] || event; return handleKeyPressed(evt); }
        tf.events.AddDOMEventListener(input, "keyup", onKeyPress);
        //input.size = 30;
        input.size = 24;
        input.style.fontSize = subStyles.addressBarFontSize;
        inputObj.AppendTo(inputListItem);
        var useLight = false;
        useLight = styles.mapSvgGlyphInPopupClass;
        var closeButton = styles.AddButtonDivLeftRightMargins(
            new tf.ui.SvgGlyphBtn({ style: useLight, glyph: tf.styles.SvgGlyphMagnifyingLensName, onClick: toggle, tooltip: "Close address bar", dim: buttonDim }));
        goMapButton = styles.AddButtonDivLeftMargin(
            new tf.ui.SvgGlyphBtn({ style: useLight, glyph: tf.styles.SvgGlyphMapPinName, onClick: goMap, tooltip: "Move the Map to this Address", dim: buttonDim }));
        goDBButton = styles.AddButtonDivLeftMargin(
            new tf.ui.SvgGlyphBtn({ style: useLight, glyph: tf.styles.SvgGlyphInfoName, onClick: goDB, tooltip: "Get Local Reports for this Address", dim: buttonDim }));
        goHelpButton = styles.AddButtonDivLeftMargin(
            new tf.ui.SvgGlyphBtn({ style: useLight, glyph: tf.styles.SvgGlyphQuestionMarkName, onClick: goHelp, tooltip: "Get Help Information", dim: buttonDim }));
        //inputListItem.GetHTMLElement().title = "hello, world.";
        tBarPopup.AddContent(closeButton, false);
        tBarPopup.AddContent(inputListItem, true);
        inputListItem.AddContent(goMapButton, goDBButton, goHelpButton);
        //tBarPopup.AddContent(goMapButton);
        //tBarPopup.AddContent(goDBButton);
        //tBarPopup.AddContent(goHelpButton, true);
        //tBarPopup.SetFocusElem(inputObj);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialSetup(); })(this);
};
/**
 * class tf.map.ui.DownloadBar - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} container - parameter description?
 * @param {?} tMap - parameter description?
 * @param {?} rectProvider - parameter description?
 * @param {?} onCloseCallBack - parameter description?
 * @param {?} onDownloadCallBack - parameter description?
 * @param {?} theThisOnCallBack - parameter description?
*/
tf.map.ui.DownloadBar = function (container, tMap, rectProvider, onCloseCallBack, onDownloadCallBack, theThisOnCallBack) {
/**
 * method tf.map.ui.DownloadBar.Show - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} bool - parameter description?
*/
    this.Show = function (bool) { return show(bool); }
/**
 * method tf.map.ui.DownloadBar.IsShowing - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.IsShowing = function () { return isShowing(); }
/**
 * method tf.map.ui.DownloadBar.Toggle - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.Toggle = function () { return toggle(); }
    var theThis = null;
    var tBarPopup = null;
    function show(bool) { return tBarPopup ? tBarPopup.Show(bool) : false; }
    function isShowing() { return tBarPopup ? tBarPopup.IsShowing() : false; }
    function toggle() { return tBarPopup ? tBarPopup.Toggle() : false; }
    function onClickDownload() {
        if (typeof onDownloadCallBack == "function") {
            onDownloadCallBack.call(theThisOnCallBack, theThis);
        }
    }
    function initialSetup() {
        tBarPopup = new tf.ui.ToolBarPopup(container, rectProvider);
        var inputListItem = new tf.dom.Div({ cssClass: tf.GetStyles().GetPaddedDivClassNames(false, false) });
        var contentSpan = new tf.dom.Span();
        var styles = tf.GetStyles();
        var subStyles = styles.GetSubStyles();
        var buttonDim = subStyles.mapControlFontSizeEmNumber + "em";
        var downloadButton = new tf.ui.TextBtn({ style: styles.mapTextBtnClass, label: "Download", onClick: onClickDownload, tooltip: "Click here to download", dim: buttonDim });
        contentSpan.AddContent("Select map area to ")
        contentSpan.GetHTMLElement().style.fontSize = buttonDim;//subStyles.mapControlFontSize;
        styles.ApplyStyleProperties(contentSpan, subStyles.textShadowStyle);
        inputListItem.AddContent(contentSpan, downloadButton);
        var closeButton = styles.CloseXButtonForPopup(false, onCloseCallBack, buttonDim);
        closeButton.GetHTMLElement().style.transform = "";
        closeButton = styles.AddButtonDivRightMargin(closeButton);
        tBarPopup.AddContent(closeButton, false, false);
        tBarPopup.AddContent(inputListItem, true);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialSetup(); })(this);
};
/**
 * class tf.map.ui.MeasureBar - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} container - parameter description?
 * @param {?} tMap - parameter description?
 * @param {?} rectProvider - parameter description?
 * @param {?} onCloseCallBack - parameter description?
 * @param {?} onChangeTypeCallBack - parameter description?
 * @param {?} theThisOnCallBack - parameter description?
*/
tf.map.ui.MeasureBar = function (container, tMap, rectProvider, onCloseCallBack, onChangeTypeCallBack, theThisOnCallBack) {
/**
 * method tf.map.ui.MeasureBar.Show - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} bool - parameter description?
*/
    this.Show = function (bool) { return show(bool); }
/**
 * method tf.map.ui.MeasureBar.IsShowing - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.IsShowing = function () { return isShowing(); }
/**
 * method tf.map.ui.MeasureBar.Toggle - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.Toggle = function () { return toggle(); }
/**
 * method tf.map.ui.MeasureBar.OnContainerResize - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.OnContainerResize = function () { return onContainerResize(); }
/**
 * method tf.map.ui.MeasureBar.GetIsMeasuringDistances - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetIsMeasuringDistances = function () { return measuringDistances; }
    var theThis = null;
    var tBarPopup = null;
    var measureTypeButton = null;
    var measuringDistances = true;
    var distancesName = "Distances";
    var areasName = "Areas";
    function show(bool) { return tBarPopup ? tBarPopup.Show(bool) : false; }
    function isShowing() { return tBarPopup ? tBarPopup.IsShowing() : false; }
    function toggle() { return tBarPopup ? tBarPopup.Toggle() : false; }
    function onClickType() {
        if (measuringDistances = !measuringDistances) {
            measureTypeButton.SetText(distancesName);
        }
        else {
            measureTypeButton.SetText(areasName);
        }
        if (typeof onChangeTypeCallBack == "function") {
            onChangeTypeCallBack.call(theThisOnCallBack, theThis);
        }
    }
    function onContainerResize() {
        //var popup = tBarPopup.GetHTMLElement();
        //popup.style.width = popup.style.height = "0px";
        //popup.style.width = popup.style.height = "auto";
    }
    function initialSetup() {
        tBarPopup = new tf.ui.ToolBarPopup(container, rectProvider);
        var inputListItem = new tf.dom.Div({ cssClass: tf.GetStyles().GetPaddedDivClassNames(false, false) });
        var contentSpan = new tf.dom.Span();
        var styles = tf.GetStyles();
        var subStyles = styles.GetSubStyles();
        var buttonDim = subStyles.mapControlFontSizeEmNumber + "em";
        measureTypeButton = new tf.ui.TextBtn({ style: styles.mapTextBtnClass, label: measuringDistances ? distancesName : areasName, onClick: onClickType, tooltip: "Click or touch the map to measure", dim: buttonDim });
        contentSpan.AddContent("Measuring ");
        contentSpan.GetHTMLElement().style.fontSize = buttonDim;//subStyles.mapControlFontSize;
        styles.ApplyStyleProperties(contentSpan, subStyles.textShadowStyle);
        inputListItem.AddContent(contentSpan, measureTypeButton);
        var closeButton = styles.CloseXButtonForPopup(false, onCloseCallBack, buttonDim);
        closeButton.GetHTMLElement().style.transform = "";
        closeButton = styles.AddButtonDivRightMargin(closeButton);
        tBarPopup.AddContent(closeButton, false, false);
        tBarPopup.AddContent(inputListItem, true);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialSetup(); })(this);
};
/**
 * A callback function to receive the notification that a [Single Map App]{@link tf.urlapi.SingleMap} has finalized its creation process
 * @public
 * @callback tf.types.SingleMapAppCreationCallBack
 * @param {object} notification - the notification
 * @param {tf.urlapi.SingleMapApp} notification.sender - the instance sending the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * @public
 * @class
 * @summary A Single Map App creates and configures a [Map]{@link tf.map.Map} instance based on given url parameters and 
 * adds it to a given container; it also creates an [App Container Sizer]{@link tf.layout.AppContainerSizer}
 * to keeps the map and the given layout container correctly sized. Depending on url parameters,
 * a [DLayer List]{@link tf.urlapi.DLayerList} instance may be created
 * @param {object} settings - creation settings
 * @param {HTMLElementLike} settings.layout - used as Single Map App's layout
 * @param {HTMLElementLike} settings.mapContainer - container where the single map instance is created, may be the same as <b>layout</b>
 * @param {HTMLElementLike} settings.parentContainer - if defined, <b>layout</b> is appended to it, if undefined <b>layout</b> becomes the top application layout
 * @param {HTMLElementLike} settings.fullScreenContainer - defines the container to be displayed in fullscreen, if not defined, <b>document.body</b> is displayed in fullscreen
 * @param {string} settings.documentTitle - if defined, sets the title of the HTML page
 * @param {boolean} settings.allowDLayers - set to <b>false</b> to prevent the creation of a [DLayer List]{@link tf.urlapi.DLayerList} specified by [URL Parameters]{@link tf.types.URLParameters}, defaults to <b>true</b>
 * @param {function} settings.dLayersPreProcessDataItem - passed to [DLayer List]{@link tf.urlapi.DLayerList}, defaults to {@link void} 
 * @param {function} settings.dLayersPreProcessServiceData - passed to [DLayer List]{@link tf.urlapi.DLayerList}, defaults to {@link void} 
 * @param {tf.types.SingleMapAppCreationCallBack} settings.onCreated - optional callback to receive a notification when the creation process of this instance is complete
 * @param {tf.types.AppContainerSizerCallBack} settings.onResize - optional callback passed to [App Container Sizer]{@link tf.layout.AppContainerSizer}
 * @param {tf.types.URLParameters} settings.fullURL - optional parameters to initialize the map, dlayers
 * @see [Single Map Single Pane App]{@link tf.urlapi.SingleMapSinglePaneApp}
 */
tf.urlapi.SingleMapApp = function (settings) {
    var theThis, map, dLayers, parameters, appContainerSizer, appContainerLayout, createdCallBack, perspectiveMap, perspectiveDLayers;
    /**
     * @public
     * @function
     * @summary - Retrieves the application's [URLParameters Object]{@link tf.types.URLParametersObject}
     * @returns {tf.types.URLParametersObject} - | {@link tf.types.URLParametersObject} the url parameters object
    */
    this.GetParameters = function () { return parameters; }
    /**
     * @public
     * @function
     * @summary - Retrieves the layout instance set in the creation of this Single Map App instance
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the url parameters object
    */
    this.GetAppContainerLayout = function () { return appContainerLayout; }
    /**
     * @public
     * @function
     * @summary - Retrieves the [App Container Sizer]{@link tf.layout.AppContainerSizer} instance created by this Single Map App instance
     * @returns {tf.layout.AppContainerSizer} - | {@link tf.layout.AppContainerSizer} the instance
    */
    this.GetAppContainerSizer = function () { return appContainerSizer; }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Map]{@link tf.map.Map} instance created by this Single Map App instance
     * @returns {tf.layout.AppContainerSizer} - | {@link tf.layout.AppContainerSizer} the instance
    */
    this.GetMap = function () { return map; }
    /**
     * @public
     * @function
     * @summary - Retrieves the [DLayer List]{@link tf.urlapi.DLayerList} instance created by this Single Map App instance, if any
     * @returns {tf.urlapi.DLayerList} - | {@link tf.urlapi.DLayerList} the instance
    */
    this.GetDLayers = function () { return dLayers; }
    this.GetPerspectiveMap = function () { return perspectiveMap; }
    this.GetPerspectiveDLayers = function () { return perspectiveDLayers; }
    /**
     * @public
     * @function
     * @summary - Triggers a resize event
     * @returns {void} - | {@link void} no return value
    */
    this.Resize = function () { if (!!appContainerSizer) { appContainerSizer.OnResize(); } }
    /**
     * @public
     * @function
     * @summary - Updates the size of the map
     * @returns {void} - | {@link void} no return value
    */
    this.UpdateMapSize = function () { if (!!appContainerSizer) { appContainerSizer.UpdateMapSizes(); } }
    function onMapCreated(notification) {
        appContainerSizer.AddMap(map = notification.maps[0]);
        dLayers = notification.dLayers[0];
        perspectiveMap = notification.perspectiveMaps[0];
        perspectiveDLayers = notification.perspectiveDLayers[0];
        parameters = notification.parameters;
        if (!!createdCallBack) { setTimeout(function () { createdCallBack({ sender: theThis }); }, 1); }
        appContainerSizer.OnResize();
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.dom.GetHTMLElementFrom(settings.layout)) {
            var documentTitle = tf.js.GetNonEmptyString(settings.documentTitle, tf.consts.URLAPIDocumentTitle);
            var parentContainerUse = tf.dom.GetHTMLElementFrom(settings.parentContainer);
            var fitContainerToWindow = !parentContainerUse;
            appContainerLayout = settings.layout;
            if (!parentContainerUse) { parentContainerUse = document.body; }
            createdCallBack = tf.js.GetFunctionOrNull(settings.onCreated);
            appContainerLayout.AppendTo(parentContainerUse);
            appContainerSizer = new tf.layout.AppContainerSizer({
                documentTitle: documentTitle, onResize: settings.onResize, container: appContainerLayout, fitContainerToWindow: fitContainerToWindow,
                useUpdateSizesInterval: settings.useUpdateSizesInterval
            });
            tf.urlapi.CreateURLAPIMaps({
                optionalScope: theThis, onCreated: onMapCreated, mapContainers: [settings.mapContainer],
                fullScreenContainer: settings.fullScreenContainer,
                parameters: settings.fullURL,
                allowDLayers: tf.js.GetBoolFromValue(settings.allowDLayers, true), 
                dLayersPreProcessDataItem: settings.dLayersPreProcessDataItem,
                dLayersPreProcessServiceData: settings.dLayersPreProcessServiceData
            });
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * @public
 * @class
 * @summary A Single Map Single Pane App combines a [Single Map App]{@link tf.urlapi.SingleMapApp} with a [Single Pane Layout]{@link tf.layout.SinglePane}
 * and provides a complete framework for applications that display a single map on a single pane using [URL Parameters]{tf.types.URLParameters}
 * @param {object} settings - creation settings
 * @param {HTMLElementLike} settings.parentContainer - if defined, <b>layout</b> is appended to it, if undefined the <b>Single Pane Layout</b> becomes the top application layout
 * @param {string} settings.documentTitle - if defined, sets the title of the HTML page
 * @param {boolean} settings.allowDLayers - set to <b>false</b> to prevent the creation of a [DLayer List]{@link tf.urlapi.DLayerList} specified by [URL Parameters]{@link tf.types.URLParameters}, defaults to <b>true</b>
 * @param {function} settings.dLayersPreProcessDataItem - passed to [DLayer List]{@link tf.urlapi.DLayerList}, defaults to {@link void} 
 * @param {function} settings.dLayersPreProcessServiceData - passed to [DLayer List]{@link tf.urlapi.DLayerList}, defaults to {@link void} 
 * @param {tf.types.SingleMapAppCreationCallBack} settings.onCreated - optional callback to receive a notification when the creation process of this instance is complete
 * @param {tf.types.AppContainerSizerCallBack} settings.onResize - optional callback passed to [App Container Sizer]{@link tf.layout.AppContainerSizer}
 * @param {tf.types.URLParameters} settings.fullURL - optional parameters to initialize the map, dlayers
 * @extends {tf.urlapi.SingleMapApp}
 * @see [Single Pane Layout]{@link tf.layout.SinglePane}
 */
tf.urlapi.SingleMapSinglePaneApp = function (settings) {
    var theThis = null;
    /**
     * @public
     * @function
     * @summary - Retrieves the [Single Pane Layout]{@link tf.layout.SinglePane} instance associated with this Single Map Single Pane App instance
     * @returns {tf.layout.SinglePane} - | {@link tf.layout.SinglePane} the instance
    */
    this.GetSinglePaneLayout = function () { return theThis.GetAppContainerLayout(); }
    function initialize() {
        //tf.GetStyles(tf.styles.GetGraphiteAPIStyleSpecifications());
        var localSettings = tf.js.ShallowMerge(settings);
        localSettings.mapContainer = localSettings.layout = new tf.layout.SinglePane();
        tf.urlapi.SingleMapApp.call(theThis, localSettings);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
}
tf.js.InheritFrom(tf.urlapi.SingleMapSinglePaneApp, tf.urlapi.SingleMapApp);
/**
 * @public
 * @class
 * @summary A Single Map Content On The Side App combines a [Single Map App]{@link tf.urlapi.SingleMapApp} with a [Left Separator Right Layout]{@link tf.layout.LeftSeparatorRight}
 * @param {object} settings - creation settings
 * @param {HTMLElementLike} settings.parentContainer - if defined, <b>layout</b> is appended to it, if undefined the <b>Single Pane Layout</b> becomes the top application layout
 * @param {string} settings.documentTitle - if defined, sets the title of the HTML page
 * @param {boolean} settings.allowDLayers - set to <b>false</b> to prevent the creation of a [DLayer List]{@link tf.urlapi.DLayerList} specified by [URL Parameters]{@link tf.types.URLParameters}, defaults to <b>true</b>
 * @param {function} settings.dLayersPreProcessDataItem - passed to [DLayer List]{@link tf.urlapi.DLayerList}, defaults to {@link void} 
 * @param {function} settings.dLayersPreProcessServiceData - passed to [DLayer List]{@link tf.urlapi.DLayerList}, defaults to {@link void} 
 * @param {tf.types.SingleMapAppCreationCallBack} settings.onCreated - optional callback to receive a notification when the creation process of this instance is complete
 * @param {tf.types.AppContainerSizerCallBack} settings.onResize - optional callback passed to [App Container Sizer]{@link tf.layout.AppContainerSizer}
 * @param {tf.types.URLParameters} settings.fullURL - optional parameters to initialize the map, dlayers
 * @param {tf.types.LeftSeparatorRightCallBack} settings.onLayoutChange - optional callback to receive layout change notifications
 * @param {tf.types.CSSStyleSpecs} settings.separatorStyle - optional CSS style specifications to be applied to the vertical separator
 * @extends {tf.urlapi.SingleMapApp}
 * @see [Left Separator Right Layout]{@link tf.layout.LeftSeparatorRight}
 */
tf.urlapi.SingleMapContentOnTheSide = function (settings) {
    var theThis, leftSeparatorRightLayout, onLayoutChangeCallBack;
    /**
     * @public
     * @function
     * @summary - Retrieves the [Left Separator Right Layout]{@link tf.layout.LeftSeparatorRight} instance associated with this Single Map Single Pane App instance
     * @returns {tf.layout.LeftSeparatorRight} - | {@link tf.layout.LeftSeparatorRight} the instance
    */
    this.GetLeftSeparatorRightLayout = function () { return theThis.GetAppContainerLayout(); }
    /**
     * @public
     * @function
     * @summary - Triggers a layout change event
     * @returns {void} - | {@link void} no return value
    */
    this.OnLayoutChange = function () { return onLayoutChange(); }
    function onResize(notification) { onLayoutChange(notification); }
    function onLayoutChange(notification) {
        theThis.UpdateMapSize();
        if (!!onLayoutChangeCallBack) {
            if (!tf.js.GetIsValidObject(notification)) { notification = { sender: theThis }; }
            onLayoutChangeCallBack(notification);
        }
    }
    function initialize() {
        var localSettings = tf.js.ShallowMerge(settings);
        onLayoutChangeCallBack = tf.js.GetFunctionOrNull(localSettings.onLayoutChange);
        localSettings.layout = leftSeparatorRightLayout = new tf.layout.LeftSeparatorRight({
            optionalScope: theThis, onLayoutChange: onLayoutChange, separatorStyle: localSettings.separatorStyle,
            initiallyCollapsed: localSettings.initiallyCollapsed
        });
        if (!localSettings.noMap) { localSettings.mapContainer = localSettings.layout.GetLeft(); }
        tf.urlapi.SingleMapApp.call(theThis, localSettings);
        theThis.GetAppContainerSizer().AddResizeListener(onResize);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.urlapi.SingleMapContentOnTheSide, tf.urlapi.SingleMapApp);
/**
 * @public
 * @class
 * @summary A Single Map HCF On The Side App combines a [Single Map App]{@link tf.urlapi.SingleMapApp} with a [Left Separator Right Layout]{@link tf.layout.LeftSeparatorRight} 
 * containing a [Header Content Footer]{@link tf.layout.HeaderContentFooter} sub-layout and provides a complete framework for applications that display a single map and
 * tables on the side
 * @param {object} settings - creation settings
 * @param {HTMLElementLike} settings.parentContainer - if defined, <b>layout</b> is appended to it, if undefined the <b>Single Pane Layout</b> becomes the top application layout
 * @param {string} settings.documentTitle - if defined, sets the title of the HTML page
 * @param {boolean} settings.allowDLayers - set to <b>false</b> to prevent the creation of a [DLayer List]{@link tf.urlapi.DLayerList} specified by [URL Parameters]{@link tf.types.URLParameters}, defaults to <b>true</b>
 * @param {function} settings.dLayersPreProcessDataItem - passed to [DLayer List]{@link tf.urlapi.DLayerList}, defaults to {@link void} 
 * @param {function} settings.dLayersPreProcessServiceData - passed to [DLayer List]{@link tf.urlapi.DLayerList}, defaults to {@link void} 
 * @param {tf.types.SingleMapAppCreationCallBack} settings.onCreated - optional callback to receive a notification when the creation process of this instance is complete
 * @param {tf.types.AppContainerSizerCallBack} settings.onResize - optional callback passed to [App Container Sizer]{@link tf.layout.AppContainerSizer}
 * @param {tf.types.URLParameters} settings.fullURL - optional parameters to initialize the map, dlayers
 * @param {tf.types.HeaderContentFooterCallBack} settings.onLayoutChange - optional callback to receive layout change notifications
 * @param {tf.types.CSSStyleSpecs} settings.separatorStyle - optional CSS style specifications to be applied to the vertical separator
 * @param {string} settings.appLogoImgStr - optional url to an application defined logo image to be displayed with the TerraFly logo in the Header pane
 * @param {color} settings.logoBkColor - optional background color used on the logo subcontainer of the Header pane, ignored if <b>logoStyle</b> is defined
 * @param {tf.types.CSSStyleSpecs} settings.logoStyle - optional CSS style specifications to be applied to the logo subcontainer of the Header pane
 * @param {tf.types.CSSStyleSpecs} settings.pageStyle - optional CSS style specifications to be applied to layout container
 * @param {tf.types.CSSStyleSpecs} settings.headerStyle - optional CSS style specifications to be applied to the Header pane
 * @param {tf.types.CSSStyleSpecs} settings.contentStyle - optional CSS style specifications to be applied to the Content pane
 * @param {tf.types.CSSStyleSpecs} settings.footerStyle - optional CSS style specifications to be applied to the Footer pane
 * @see [Single Map App]{@link tf.urlapi.SingleMapApp}
 * @see [Left Separator Right Layout]{@link tf.layout.LeftSeparatorRight}
 * @see [Header Content Footer Layout]{@link tf.layout.HeaderContentFooter}
 */
tf.urlapi.SingleMapHCFOnTheSideApp = function (settings) {
    var theThis = null, singleAppContentOnTheSide = null, HCFLayout = null;
    /**
     * @public
     * @function
     * @summary - Retrieves the [Single Map App]{@link tf.urlapi.SingleMapApp} instance associated with this Single Map Single Pane App instance
     * @returns {tf.urlapi.SingleMapApp} - | {@link tf.urlapi.SingleMapApp} the instance
    */
    this.GetSingleAppMapContentOnTheSide = function () { return singleAppContentOnTheSide; }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Header Content Footer Layout]{@link tf.layout.HeaderContentFooter} instance associated with this Single Map Single Pane App instance
     * @returns {tf.layout.HeaderContentFooter} - | {@link tf.layout.HeaderContentFooter} the instance
    */
    this.GetHCFLayout = function () { return HCFLayout; }
    function onAppLayoutChange() {
        if (HCFLayout) { HCFLayout.OnResize(); }
    }
    function onHCFLayoutChange() {
        if (singleAppContentOnTheSide) { singleAppContentOnTheSide.OnLayoutChange(); }
    }
    function initialize() {
        var localSettings = tf.js.ShallowMerge(settings);
        localSettings.onLayoutChange = onAppLayoutChange;
        localSettings.useUpdateSizesInterval = true;
        singleAppContentOnTheSide = new tf.urlapi.SingleMapContentOnTheSide(localSettings);
        singleAppContentOnTheSide.GetLeftSeparatorRightLayout().GetRight().AddContent(
            HCFLayout = new tf.layout.HeaderContentFooter({
                onLayoutChange: onHCFLayoutChange, appLogoImgStr: localSettings.appLogoImgStr, logoBkColor: localSettings.logoBkColor,
                pageStyle: localSettings.pageStyle, contentStyle: localSettings.contentStyle, headerStyle: localSettings.headerStyle,
                footerStyle: localSettings.footerStyle, logoStyle: localSettings.logoStyle
            }));
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * @public
 * @function
 * @summary - Examines the URL parameters and creates either a [Single Map Single Pane App]{@link tf.urlapi.SingleMapSinglePaneApp} instance implementing the URL-API,
 * or one of the applications that are nativelly supported by the TerraFly API
 * @param {object} settings - creation settings
 * @param {tf.types.URLParameters} settings.fullURL - optional parameters to initialize the map, dlayers
 * @returns {tf.urlapi.SingleMapSinglePaneApp} - | {@link tf.urlapi.SingleMapSinglePaneApp} the instance
*/
tf.urlapi.CreateURLAPIApp = function (settings) {
    var urlapiApp = null;
    settings = tf.js.GetValidObjectFrom(settings);
    var params = tf.urlapi.ParseURLAPIParameters(settings.fullURL);
    var appSpecs = params[tf.consts.paramNameAppSpecs];
    if (tf.js.GetIsValidObject(appSpecs) || tf.js.GetNonEmptyString(appSpecs)) {
        settings.fullURL = params; urlapiApp = new tf.urlapi.AppFromSpecs(settings);
    }
    if (!urlapiApp) {
        tf.GetStyles(tf.styles.GetGraphiteAPIStyleSpecifications());
        //urlapiApp = new tf.urlapi.SingleMapSinglePaneApp(settings);
        urlapiApp = new tf.urlapi.URLAPIApp(settings);
    }
    return urlapiApp;
}
/**
 * class tf.urlapi.AppFromSpecs - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} settings - parameter description?
*/
tf.urlapi.AppFromSpecs = function (settings) {
    var theThis, styles, subStyles, singleAppHCFOnTheSide, singleAppMapContentOnTheSide, twoHorPaneLayout, HCFLayout, appSpecs, dLayers;
    var tables, toolBar, curTableIndex, titleDiv, titleObj, appSizer, tablesByDLayerIndex, map, settingsOnRefresh, settingsInitTables;
    var className = "AppFromSpecs";
    this.GotoTable = function (tableIndex) { return gotoTable(tableIndex); }
    this.GetCurTableIndex = function () { return curTableIndex; }
    this.UpdateCurTableFooter = function () { return updateCurTableFooter(); }
    this.AddToToolBar = function (elem) { if (!!elem) { toolBar.AddContent(elem); } }
    this.GetToolBarButtonDim = function () { return getToolBarButtonDim(); }
    this.GetToolBarSvgButtonStyle = function () { return getToolBarSvgButtonStyle(); }
    this.GetSingleAppHCFOnTheSide = function () { return singleAppHCFOnTheSide; }
/**
 * method tf.urlapi.AppFromSpecs.GetAppSpecs - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetAppSpecs = function () { return appSpecs; }
    this.AddListenersToMap = function (map) { return addListenersToMap(map); }
    function onLayoutChange() { if (singleAppHCFOnTheSide) { singleAppHCFOnTheSide.OnLayoutChange(); } }
    function getRowContent(notification) {
        var keyedItem = notification.keyedItem;
        var rowContentData = notification.properties;
        var content = null;
        if (!!keyedItem && !!rowContentData) {
            var props = keyedItem.GetData().properties;
            var dLayerIndex = rowContentData.dLayerIndex;
            var rowContentSpecs = appSpecs["dlayerrowcontent" + dLayerIndex];
            if (tf.js.GetIsValidObject(rowContentSpecs)) {
                content = new tf.dom.Div({ cssClass: tf.GetStyles().dLayerInfoClass });
                for (var i in rowContentSpecs) {
                    var thisContent = rowContentSpecs[i];
                    if (tf.js.GetIsString(thisContent)) { content.AddContent(tf.js.ReplaceWithValues(thisContent, props)); }
                    else if (tf.js.GetIsValidObject(thisContent) && tf.js.GetIsNonEmptyString(thisContent.type)) {
                        var hRef, src;
                        switch (thisContent.type) {
                            case 'image':
                                src = tf.js.ReplaceWithValues(thisContent.src, props);
                                if (tf.js.GetIsNonEmptyString(src)) { content.AddContent(tf.urlapi.CreateInfoWindowImg(src)); }
                                break;
                            case 'link':
                                hRef = tf.js.ReplaceWithValues(thisContent.href, props);
                                if (tf.js.GetIsNonEmptyString(hRef)) {
                                    content.AddContent(tf.urlapi.CreateInfoWindowLink(
                                        hRef,
                                        tf.js.ReplaceWithValues(thisContent.label, props, 'link'),
                                        tf.js.ReplaceWithValues(thisContent.tooltip, props, 'click to follow link'),
                                        tf.js.ReplaceWithValues(thisContent.target, props, '_top')));
                                }
                                break;
                            case 'imagelink':
                                hRef = tf.js.ReplaceWithValues(thisContent.href, props);
                                src = tf.js.ReplaceWithValues(thisContent.src, props);
                                if (tf.js.GetIsNonEmptyString(hRef) && tf.js.GetIsNonEmptyString(src)) {
                                    var link = tf.urlapi.CreateInfoWindowLink(
                                        hRef,
                                        null,
                                        tf.js.ReplaceWithValues(thisContent.tooltip, props, 'click to follow link'),
                                        tf.js.ReplaceWithValues(thisContent.target, props, '_top'));
                                    link.AddContent(tf.urlapi.CreateInfoWindowImg(src));
                                    content.AddContent(link);
                                }
                                break;
                            default:
                                break;
                        }
                    }
                }
            }
            else {
                content = props.Display_Label;
                if (content == '.') {
                    content = props.Display_Summary_Longer_Text;
                }
            }
        }
        appSizer.UpdateMapSizes();
        return { sender: theThis, content: content };
    }
    function updateCurTableFooter() {
        updateFooter(tables[curTableIndex].table, tables[curTableIndex].dLayer);
    }
    function onRefresh() {
        if (!!settingsOnRefresh) { settingsOnRefresh(); }
        if (dLayers) {
            dLayers.RefreshAll();
            updateCurTableFooter();
            appSizer.UpdateMapSizes();
        }
    }
    function onPrevTable() { gotoTable(curTableIndex - 1); }
    function onNextTable() { gotoTable(curTableIndex + 1); }
    function gotoTable(newTableIndex) {
        if (newTableIndex >= tables.length) { newTableIndex = 0; }
        else if (newTableIndex < 0) { newTableIndex = tables.length - 1; }
        if (curTableIndex === undefined || curTableIndex != newTableIndex) {
            var table = tables[curTableIndex = newTableIndex], strTitle;
            HCFLayout.SetContent(table.table);
            if (!!table.dLayer) {
                strTitle = table.dLayer.GetName();
                dLayers.MoveToTopZIndex(table.dLayer);
            }
            else {
                strTitle = tf.js.GetIsNonEmptyString(table.title) ? table.title : "";
            }
            titleDiv.innerHTML = strTitle;
            updateFooter(table.table, table.dLayer);
        }
        appSizer.UpdateMapSizes();
    }
    function getToolBarButtonDim() { return subStyles.mapButtonDimEmNumber + "em" }
    function getToolBarSvgButtonStyle() { return true; }
    function createToolBar() {
        var glyphLib = tf.ui.GetSvgGlyphLib();
        var buttonDim = getToolBarButtonDim();
        var refreshButton = null, nextTableButton, prevTableButton, useLight = getToolBarSvgButtonStyle();
        //useLight = styles.CreateSvgGlyphClasses("#000", "#fff", "#ff0", "#00F");
        toolBar = HCFLayout.CreateUnPaddedDivForHeader();
        styles.AddBorderTop(toolBar, true);
        styles.AddBorderBottom(toolBar, true);
        toolBar.GetHTMLElement().style.textAlign = 'left';
        toolBar.AddContent(refreshButton = styles.AddButtonDivMargins(
            new tf.ui.SvgGlyphBtn({ style: useLight, glyph: tf.styles.SvgGlyphRefreshName, onClick: onRefresh, tooltip: "Refresh", dim: buttonDim })
            ));
        if (tables.length > 1) {
            toolBar.AddContent(prevTableButton = styles.AddButtonDivMargins(
                new tf.ui.SvgGlyphBtn({ style: useLight, glyph: tf.styles.SvgGlyphLeftArrowName, onClick: onPrevTable, toolip: "Prev", dim: buttonDim })
                ));
            toolBar.AddContent(nextTableButton = styles.AddButtonDivMargins(
                new tf.ui.SvgGlyphBtn({ style: useLight, glyph: tf.styles.SvgGlyphRightArrowName, onClick: onNextTable, tooltip: "Next", dim: buttonDim })
                ));
        }
        HCFLayout.AddToHeader(toolBar);
    }
    function updateFooter(table, dLayer) {
        var footerStrHtml = '', hasRecords = true;
        if (!!dLayer) { if (dLayer.GetIsRefreshing()) { footerStrHtml = "Searching..."; hasRecords = false; } }
        if (hasRecords) {
            var nRecords = table.GetKeyedList().GetItemCount();
            if (nRecords == 0) { footerStrHtml = "No records found"; }
            else {
                var recordStr = nRecords > 1 ? " records " : " record ";
                footerStrHtml = nRecords + recordStr + "found";
            }
        }
        HCFLayout.SetFooter(footerStrHtml);
    }
    function panToFeature(map, mapFeature) { map.AnimatedSetCenterIfDestVisible(mapFeature.GetPointCoords()); }
    function onRowSelect(notification) {
        var table = notification.keyedTable;
        var props = table.GetProperties();
        if (props.index == curTableIndex) {
            if (notification.selected !== notification.prevSelected || notification.isClick) {
                var dLayer = props.dLayer;
                var map = dLayer.GetMap();
                var featureList = dLayer.GetFeatureList();
                if (!!featureList) {
                    var keyedItem = notification.selected.GetKeyedItem();
                    if (!!keyedItem) {
                        var mapFeature = featureList.GetFeature(keyedItem.GetKey());
                        if (!!mapFeature) {
                            panToFeature(map, mapFeature);
                            tf.urlapi.ShowdLayerInfoWindow(mapFeature.GetMapFeature());
                        }
                    }
                }
            }
        }
    }
    function onTableChanged(notification) {
        appSizer.UpdateMapSizes();
        var table = notification.sender;
        var props = table.GetProperties();
        if (props.index == curTableIndex) {
            updateFooter(table, props.dLayer);
        }
    }
    function onFeatureHoverInOut(notification) {
        if (notification.isInHover) {
            var props = tf.js.GetObjProperty(notification.mapFeature, tf.consts.DLayerProperty);
            if (tf.js.GetIsValidObject(props)) {
                if (!props.map.IsInfoPopupPinned()) {
                    var dLayer = props.dLayer;
                    var table = getTableForDLayer(dLayer);
                    if (!!table) {
                        if (table.index == curTableIndex) {
                            var keyedFeature = notification.keyedFeature;
                            var keyedItem = keyedFeature.GetKeyedItem();
                            table.table.GetRowFromKeyedItem(keyedItem).Select(true, true);
                        }
                    }
                }
            }
        }
    }
    function onFeatureClick(notification) {
        var props = tf.js.GetObjProperty(notification.mapFeature, tf.consts.DLayerProperty);
        if (tf.js.GetIsValidObject(props)) {
            var dLayer = props.dLayer;
            var table = getTableForDLayer(dLayer);
            if (!!table) {
                var keyedFeature = notification.keyedFeature;
                //new tf.services.Routing({ fromCoords: [tf.consts.defaultLongitude, tf.consts.defaultLatitude], toCoords: keyedFeature.GetPointCoords(), callBack: onRoute, optionalScope: theThis});
                var keyedItem = keyedFeature.GetKeyedItem();
                gotoTable(table.index);
                if (props.map.IsInfoPopupPinned()) {
                    props.map.ToggleInfoPopupPin();
                    tf.urlapi.ShowdLayerInfoWindow(notification.mapFeature);
                }
                setTimeout(function () { table.table.GetRowFromKeyedItem(keyedItem).Select(true, true); }, 100);
            }
        }
    }
    function getTableForDLayer(dLayer) { return tablesByDLayerIndex[dLayer.GetIndex()]; }
    function addListenersToMap(map) {
        if (!!(map = tf.js.GetMapFrom(map))) {
            var mapEventSettings = {};
            var mapMonitor;
            mapEventSettings[tf.consts.mapFeatureHoverInOutEvent] = onFeatureHoverInOut;
            mapEventSettings[tf.consts.mapFeatureClickEvent] = onFeatureClick;
            mapMonitor = map.AddListeners(mapEventSettings);
        }
    }
    function createTables() {
        var nDLayers = !!dLayers ? dLayers.GetCount() : 0;
        addListenersToMap(map);
        tables = !!settingsInitTables ? settingsInitTables() : [];
        tablesByDLayerIndex = {};
        //createGuestTable();
        //createShuttleTable();
        for (var i = 0 ; i < nDLayers ; i++) {
            var dLayer = !!dLayers ? dLayers.Get(i) : null;
            var dLayerIndex = i + 1;
            if (dLayer) {
                var tableSettings = appSpecs["dlayertablestyle" + dLayerIndex];
                if (!!tableSettings) {
                    var selectOnHover = appSpecs["dlayerselectonhover" + dLayerIndex];
                    tableSettings = tf.js.ShallowMerge(tableSettings, { selectOnHover: selectOnHover, onSelect: onRowSelect });
                    var table = dLayer.CreateKeyedTable({
                        optionalScope: theThis,
                        onContentChange: onTableChanged,
                        tableSettings: tableSettings,
                        rowSettings: { style: appSpecs['dlayerrowstyle' + dLayerIndex], selectedStyle: appSpecs['dlayerrowhover' + dLayerIndex] },
                        properties: { dLayer: dLayer, dLayerIndex: dLayerIndex, index: tables.length },
                        getRowContent: getRowContent
                    });
                    var tableElem = { table: table, dLayer: dLayer, index: tables.length };
                    tablesByDLayerIndex[dLayer.GetIndex()] = tableElem;
                    tables.push(tableElem);
                }
            }
        }
        if (tf.js.GetIsArrayWithMinLength(tables, 1)) {
            titleObj = HCFLayout.CreateUnPaddedDivForHeader();
            titleDiv = titleObj.GetHTMLElement();
            createToolBar();
            styles.ApplyTextAlignCenterStyle(titleObj);
            titleDiv.style.verticalAlign = "middle";
            titleDiv.style.paddingTop = titleDiv.style.paddingBottom = "2px";
            if (tf.js.GetIsValidObject(appSpecs.titleStyle)) {
                styles.ApplyStyleProperties(titleObj, appSpecs.titleStyle);
            }
            HCFLayout.AddToHeader(titleObj);
            gotoTable(0);
        }
    }
    function onMapCreated() {
        twoHorPaneLayout = (singleAppMapContentOnTheSide = singleAppHCFOnTheSide.GetSingleAppMapContentOnTheSide()).GetLeftSeparatorRightLayout();
        HCFLayout = singleAppHCFOnTheSide.GetHCFLayout();
        map = singleAppMapContentOnTheSide.GetMap();
        dLayers = singleAppMapContentOnTheSide.GetDLayers();
        appSizer = singleAppMapContentOnTheSide.GetAppContainerSizer();
        twoHorPaneLayout.SetRightSideCollapsed(false);
        createTables();
        if (tf.js.GetFunctionOrNull(settings.onCreated)) { settings.onCreated({ sender: theThis }); }
    }
    var propsRecorded = true;
    var settingsFilterDLayerRecord;
    var recordFiltered = false;
    function filterDLayerRecord(props) {
        if (!recordFiltered) {
            recordFiltered = true;
            if (props.UC_X1 !== undefined) {
                var UC_X1 = tf.js.GetLongitudeFrom(props.UC_X1);
                var UC_X2 = tf.js.GetLongitudeFrom(props.UC_X2);
                var UC_X3 = tf.js.GetLongitudeFrom(props.UC_X3);
                var UC_X4 = tf.js.GetLongitudeFrom(props.UC_X4);
                var UC_Y1 = tf.js.GetLatitudeFrom(props.UC_Y1);
                var UC_Y2 = tf.js.GetLatitudeFrom(props.UC_Y2);
                var UC_Y3 = tf.js.GetLatitudeFrom(props.UC_Y3);
                var UC_Y4 = tf.js.GetLatitudeFrom(props.UC_Y4);
                var v1 = [UC_X1, UC_Y1], v2 = [UC_X2, UC_Y2], v3 = [UC_X3, UC_Y3], v4 = [UC_X4, UC_Y4];
                props.additionalFeatureSpecs = [
                    {
                        type: "linestring", coordinates: [v1, v2, v3, v4, v1],
                        style: [{ line: true, line_color: "#fff", line_width: 4 }, { line: true, line_color: "#000", line_width: 2 }]
                    }
                ];
                props.hoverFeatureSpecs = [
                    {
                        type: "polygon", coordinates: [[v1, v2, v3, v4]],
                        style: { line: true, line_color: "#00a", line_width: 4, fill: true, fill_color: "#fff", fill_opacity: 40, zindex: 2 }
                    },
                    { type: "point", coordinates: v1, style: { marker: true, label: "v1" } },
                    { type: "point", coordinates: v2, style: { marker: true, label: "v2" } },
                    { type: "point", coordinates: v3, style: { marker: true, label: "v3" } },
                    { type: "point", coordinates: v4, style: { marker: true, label: "v4" } }
                ];
            }
            if (!propsRecorded) {
                tf.GetDebug().FileLog("alta", props);
                propsRecorded = true;
            }
        }
        if (!!settingsFilterDLayerRecord) { settingsFilterDLayerRecord(props); }
    }
    function onFontLoaded() {
        styles = tf.GetStyles(appSpecs.APIStyleSpecs); subStyles = styles.GetSubStyles();
        settingsFilterDLayerRecord = tf.js.GetFunctionOrNull(settings.dLayersPreProcessDataItem);
        settingsOnRefresh = tf.js.GetFunctionOrNull(settings.onRefresh);
        settingsInitTables = tf.js.GetFunctionOrNull(settings.initTables);
        appSpecs.fullURL = tf.js.ShallowMerge(settings.fullURL, appSpecs.replaceURLParams);
        appSpecs.onCreated = onMapCreated;
        appSpecs.initiallyCollapsed = appSpecs.initiallyCollapsed;
        appSpecs.dLayersPreProcessDataItem = tf.js.GetBoolFromValue(appSpecs.filterDLayerRecord, false) ? filterDLayerRecord : settingsFilterDLayerRecord;
        //appSpecs.dLayersPreProcessDataItem = filterDLayerRecord;
        appSpecs.dLayersPreProcessServiceData = tf.js.GetFunctionOrNull(settings.dLayersPreProcessServiceData);
        if (tf.js.GetFunctionOrNull(settings.onAppSpecsLoaded)) { settings.onAppSpecsLoaded(appSpecs); }
        singleAppHCFOnTheSide = new tf.urlapi.SingleMapHCFOnTheSideApp(appSpecs);
    }
    function onAppSpecsLoaded(appSpecsSet) {
        if (tf.js.GetIsValidObject(appSpecs = appSpecsSet)) {
            var loadFonts = false;
            if (tf.js.GetIsValidObject(appSpecs.APIStyleSpecs)) {
                if (tf.js.GetIsNonEmptyString(appSpecs.APIStyleSpecs.googleFonts)) {
                    loadFonts = true;
                    tf.dom.AddLink("http://fonts.googleapis.com/css?family=" + appSpecs.APIStyleSpecs.googleFonts, "stylesheet", "text/css", onFontLoaded);
                }
            }
            if (!loadFonts) { onFontLoaded(); }
            //appSpecs.APIStyleSpecs.fontFamily = "Roboto Condensed";
            //appSpecs.APIStyleSpecs.markerFontFamily = "Roboto Condensed";
            //onFontLoaded();
        }
        else {
            tf.GetDebug().LogIfTest("AppFromSpecs: invalid file specs content");
        }
    }
    function onSettingsLoaded(notification) { onAppSpecsLoaded(notification.data); }
    function initialize() {
        var debugStr;
        if (tf.js.GetIsValidObject(settings)) {
            if (tf.js.GetIsValidObject(settings.fullURL)) {
                var specsURL = settings.fullURL[tf.consts.paramNameAppSpecs];
                if (tf.js.GetIsValidObject(specsURL)) { onAppSpecsLoaded(specsURL); }
                else if (tf.js.GetNonEmptyString(specsURL)) {
                    var downloadObj = new tf.ajax.JSONGet();
                    downloadObj.Request(specsURL, onSettingsLoaded, theThis, null, false);
                }
                else { debugStr = "'settings." + tf.consts.paramNameAppSpecs + "' are missing"; }
            }
            else { debugStr = "'settings.fullURL' must be an object"; }
        }
        else { debugStr = "invalid 'settings'"; }
        if (!!debugStr) { tf.GetDebug().LogIfTest(className + ": " + debugStr); }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.urlapi.URLAPIApp = function (settings) {
    var theThis, onCreatedCallBack;
    function onMapCreated(notification) {
        if (!!onCreatedCallBack) { onCreatedCallBack(notification); }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        onCreatedCallBack = tf.js.GetFunctionOrNull(settings.onCreated);
        var params = tf.urlapi.ParseURLAPIParameters(settings.fullURL);
        settings.fullURL = params;
        //settings.fullURL[tf.consts.mapLayerSourceName] = 'http://tile.openstreetmap.org/{z}/{x}/{y}.png';
        settings.onCreated = onMapCreated;
        tf.urlapi.SingleMapSinglePaneApp.call(theThis, settings);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.urlapi.URLAPIApp, tf.urlapi.SingleMapSinglePaneApp);
tf.consts.DemoCommonLastNames = [
"SMITH",
"JOHNSON",
"WILLIAMS",
"JONES",
"BROWN",
"DAVIS",
"MILLER",
"WILSON",
"MOORE",
"TAYLOR",
"ANDERSON",
"THOMAS",
"JACKSON",
"WHITE",
"HARRIS",
"MARTIN",
"THOMPSON",
"GARCIA",
"MARTINEZ",
"ROBINSON",
"CLARK",
"RODRIGUEZ",
"LEWIS",
"LEE",
"WALKER",
"HALL",
"ALLEN",
"YOUNG",
"HERNANDEZ",
"KING",
"WRIGHT",
"LOPEZ",
"HILL",
"SCOTT",
"GREEN",
"ADAMS",
"BAKER",
"GONZALEZ",
"NELSON",
"CARTER",
"MITCHELL",
"PEREZ",
"ROBERTS",
"TURNER",
"PHILLIPS",
"CAMPBELL",
"PARKER",
"EVANS",
"EDWARDS",
"COLLINS",
"STEWART",
"SANCHEZ",
"MORRIS",
"ROGERS",
"REED",
"COOK",
"MORGAN",
"BELL",
"MURPHY",
"BAILEY",
"RIVERA",
"COOPER",
"RICHARDSON",
"COX",
"HOWARD",
"WARD",
"TORRES",
"PETERSON",
"GRAY",
"RAMIREZ",
"JAMES",
"WATSON",
"BROOKS",
"KELLY",
"SANDERS",
"PRICE",
"BENNETT",
"WOOD",
"BARNES",
"ROSS",
"HENDERSON",
"COLEMAN",
"JENKINS",
"PERRY",
"POWELL",
"LONG",
"PATTERSON",
"HUGHES",
"FLORES",
"WASHINGTON",
"BUTLER",
"SIMMONS",
"FOSTER",
"GONZALES",
"BRYANT",
"ALEXANDER",
"RUSSELL",
"GRIFFIN",
"DIAZ",
"HAYES",
"MYERS",
"FORD",
"HAMILTON",
"GRAHAM",
"SULLIVAN",
"WALLACE",
"WOODS",
"COLE",
"WEST",
"JORDAN",
"OWENS",
"REYNOLDS",
"FISHER",
"ELLIS",
"HARRISON",
"GIBSON",
"MCDONALD",
"CRUZ",
"MARSHALL",
"ORTIZ",
"GOMEZ",
"MURRAY",
"FREEMAN",
"WELLS",
"WEBB",
"SIMPSON",
"STEVENS",
"TUCKER",
"PORTER",
"HUNTER",
"HICKS",
"CRAWFORD",
"HENRY",
"BOYD",
"MASON",
"MORALES",
"KENNEDY",
"WARREN",
"DIXON",
"RAMOS",
"REYES",
"BURNS",
"GORDON",
"SHAW",
"HOLMES",
"RICE",
"ROBERTSON",
"HUNT",
"BLACK",
"DANIELS",
"PALMER",
"MILLS",
"NICHOLS",
"GRANT",
"KNIGHT",
"FERGUSON",
"ROSE",
"STONE",
"HAWKINS",
"DUNN",
"PERKINS",
"HUDSON",
"SPENCER",
"GARDNER",
"STEPHENS",
"PAYNE",
"PIERCE",
"BERRY",
"MATTHEWS",
"ARNOLD",
"WAGNER",
"WILLIS",
"RAY",
"WATKINS",
"OLSON",
"CARROLL",
"DUNCAN",
"SNYDER",
"HART",
"CUNNINGHAM",
"BRADLEY",
"LANE",
"ANDREWS",
"RUIZ",
"HARPER",
"FOX",
"RILEY",
"ARMSTRONG",
"CARPENTER",
"WEAVER",
"GREENE",
"LAWRENCE",
"ELLIOTT",
"CHAVEZ",
"SIMS",
"AUSTIN",
"PETERS",
"KELLEY",
"FRANKLIN",
"LAWSON",
"FIELDS",
"GUTIERREZ",
"RYAN",
"SCHMIDT",
"CARR",
"VASQUEZ",
"CASTILLO",
"WHEELER",
"CHAPMAN",
"OLIVER",
"MONTGOMERY",
"RICHARDS",
"WILLIAMSON",
"JOHNSTON",
"BANKS",
"MEYER",
"BISHOP",
"MCCOY",
"HOWELL",
"ALVAREZ",
"MORRISON",
"HANSEN",
"FERNANDEZ",
"GARZA",
"HARVEY",
"LITTLE",
"BURTON",
"STANLEY",
"NGUYEN",
"GEORGE",
"JACOBS",
"REID",
"KIM",
"FULLER",
"LYNCH",
"DEAN",
"GILBERT",
"GARRETT",
"ROMERO",
"WELCH",
"LARSON",
"FRAZIER",
"BURKE",
"HANSON",
"DAY",
"MENDOZA",
"MORENO",
"BOWMAN",
"MEDINA",
"FOWLER",
"BREWER",
"HOFFMAN",
"CARLSON",
"SILVA",
"PEARSON",
"HOLLAND",
"DOUGLAS",
"FLEMING",
"JENSEN",
"VARGAS",
"BYRD",
"DAVIDSON",
"HOPKINS",
"MAY",
"TERRY",
"HERRERA",
"WADE",
"SOTO",
"WALTERS",
"CURTIS",
"NEAL",
"CALDWELL",
"LOWE",
"JENNINGS",
"BARNETT",
"GRAVES",
"JIMENEZ",
"HORTON",
"SHELTON",
"BARRETT",
"OBRIEN",
"CASTRO",
"SUTTON",
"GREGORY",
"MCKINNEY",
"LUCAS",
"MILES",
"CRAIG",
"RODRIQUEZ",
"CHAMBERS",
"HOLT",
"LAMBERT",
"FLETCHER",
"WATTS",
"BATES",
"HALE",
"RHODES",
"PENA",
"BECK",
"NEWMAN",
"HAYNES",
"MCDANIEL",
"MENDEZ",
"BUSH",
"VAUGHN",
"PARKS",
"DAWSON",
"SANTIAGO",
"NORRIS",
"HARDY",
"LOVE",
"STEELE",
"CURRY",
"POWERS",
"SCHULTZ",
"BARKER",
"GUZMAN",
"PAGE",
"MUNOZ",
"BALL",
"KELLER",
"CHANDLER",
"WEBER",
"LEONARD",
"WALSH",
"LYONS",
"RAMSEY",
"WOLFE",
"SCHNEIDER",
"MULLINS",
"BENSON",
"SHARP",
"BOWEN",
"DANIEL",
"BARBER",
"CUMMINGS",
"HINES",
"BALDWIN",
"GRIFFITH",
"VALDEZ",
"HUBBARD",
"SALAZAR",
"REEVES",
"WARNER",
"STEVENSON",
"BURGESS",
"SANTOS",
"TATE",
"CROSS",
"GARNER",
"MANN",
"MACK",
"MOSS",
"THORNTON",
"DENNIS",
"MCGEE",
"FARMER",
"DELGADO",
"AGUILAR",
"VEGA",
"GLOVER",
"MANNING",
"COHEN",
"HARMON",
"RODGERS",
"ROBBINS",
"NEWTON",
"TODD",
"BLAIR",
"HIGGINS",
"INGRAM",
"REESE",
"CANNON",
"STRICKLAND",
"TOWNSEND",
"POTTER",
"GOODWIN",
"WALTON",
"ROWE",
"HAMPTON",
"ORTEGA",
"PATTON",
"SWANSON",
"JOSEPH",
"FRANCIS",
"GOODMAN",
"MALDONADO",
"YATES",
"BECKER",
"ERICKSON",
"HODGES",
"RIOS",
"CONNER",
"ADKINS",
"WEBSTER",
"NORMAN",
"MALONE",
"HAMMOND",
"FLOWERS",
"COBB",
"MOODY",
"QUINN",
"BLAKE",
"MAXWELL",
"POPE",
"FLOYD",
"OSBORNE",
"PAUL",
"MCCARTHY",
"GUERRERO",
"LINDSEY",
"ESTRADA",
"SANDOVAL",
"GIBBS",
"TYLER",
"GROSS",
"FITZGERALD",
"STOKES",
"DOYLE",
"SHERMAN",
"SAUNDERS",
"WISE",
"COLON",
"GILL",
"ALVARADO",
"GREER",
"PADILLA",
"SIMON",
"WATERS",
"NUNEZ",
"BALLARD",
"SCHWARTZ",
"MCBRIDE",
"HOUSTON",
"CHRISTENSEN",
"KLEIN",
"PRATT",
"BRIGGS",
"PARSONS",
"MCLAUGHLIN",
"ZIMMERMAN",
"FRENCH",
"BUCHANAN",
"MORAN",
"COPELAND",
"ROY",
"PITTMAN",
"BRADY",
"MCCORMICK",
"HOLLOWAY",
"BROCK",
"POOLE",
"FRANK",
"LOGAN",
"OWEN",
"BASS",
"MARSH",
"DRAKE",
"WONG",
"JEFFERSON",
"PARK",
"MORTON",
"ABBOTT",
"SPARKS",
"PATRICK",
"NORTON",
"HUFF",
"CLAYTON",
"MASSEY",
"LLOYD",
"FIGUEROA",
"CARSON",
"BOWERS",
"ROBERSON",
"BARTON",
"TRAN",
"LAMB",
"HARRINGTON",
"CASEY",
"BOONE",
"CORTEZ",
"CLARKE",
"MATHIS",
"SINGLETON",
"WILKINS",
"CAIN",
"BRYAN",
"UNDERWOOD",
"HOGAN",
"MCKENZIE",
"COLLIER",
"LUNA",
"PHELPS",
"MCGUIRE",
"ALLISON",
"BRIDGES",
"WILKERSON",
"NASH",
"SUMMERS",
"ATKINS",
"WILCOX",
"PITTS",
"CONLEY",
"MARQUEZ",
"BURNETT",
"RICHARD",
"COCHRAN",
"CHASE",
"DAVENPORT",
"HOOD",
"GATES",
"CLAY",
"AYALA",
"SAWYER",
"ROMAN",
"VAZQUEZ",
"DICKERSON",
"HODGE",
"ACOSTA",
"FLYNN",
"ESPINOZA",
"NICHOLSON",
"MONROE",
"WOLF",
"MORROW",
"KIRK",
"RANDALL",
"ANTHONY",
"WHITAKER",
"OCONNOR",
"SKINNER",
"WARE",
"MOLINA",
"KIRBY",
"HUFFMAN",
"BRADFORD",
"CHARLES",
"GILMORE",
"DOMINGUEZ",
"ONEAL",
"BRUCE",
"LANG",
"COMBS",
"KRAMER",
"HEATH",
"HANCOCK",
"GALLAGHER",
"GAINES",
"SHAFFER",
"SHORT",
"WIGGINS",
"MATHEWS",
"MCCLAIN",
"FISCHER",
"WALL",
"SMALL",
"MELTON",
"HENSLEY",
"BOND",
"DYER",
"CAMERON",
"GRIMES",
"CONTRERAS",
"CHRISTIAN",
"WYATT",
"BAXTER",
"SNOW",
"MOSLEY",
"SHEPHERD",
"LARSEN",
"HOOVER",
"BEASLEY",
"GLENN",
"PETERSEN",
"WHITEHEAD",
"MEYERS",
"KEITH",
"GARRISON",
"VINCENT",
"SHIELDS",
"HORN",
"SAVAGE",
"OLSEN",
"SCHROEDER",
"HARTMAN",
"WOODARD",
"MUELLER",
"KEMP",
"DELEON",
"BOOTH",
"PATEL",
"CALHOUN",
"WILEY",
"EATON",
"CLINE",
"NAVARRO",
"HARRELL",
"LESTER",
"HUMPHREY",
"PARRISH",
"DURAN",
"HUTCHINSON",
"HESS",
"DORSEY",
"BULLOCK",
"ROBLES",
"BEARD",
"DALTON",
"AVILA",
"VANCE",
"RICH",
"BLACKWELL",
"YORK",
"JOHNS",
"BLANKENSHIP",
"TREVINO",
"SALINAS",
"CAMPOS",
"PRUITT",
"MOSES",
"CALLAHAN",
"GOLDEN",
"MONTOYA",
"HARDIN",
"GUERRA",
"MCDOWELL",
"CAREY",
"STAFFORD",
"GALLEGOS",
"HENSON",
"WILKINSON",
"BOOKER",
"MERRITT",
"MIRANDA",
"ATKINSON",
"ORR",
"DECKER",
"HOBBS",
"PRESTON",
"TANNER",
"KNOX",
"PACHECO",
"STEPHENSON",
"GLASS",
"ROJAS",
"SERRANO",
"MARKS",
"HICKMAN",
"ENGLISH",
"SWEENEY",
"STRONG",
"PRINCE",
"MCCLURE",
"CONWAY",
"WALTER",
"ROTH",
"MAYNARD",
"FARRELL",
"LOWERY",
"HURST",
"NIXON",
"WEISS",
"TRUJILLO",
"ELLISON",
"SLOAN",
"JUAREZ",
"WINTERS",
"MCLEAN",
"RANDOLPH",
"LEON",
"BOYER",
"VILLARREAL",
"MCCALL",
"GENTRY",
"CARRILLO",
"KENT",
"AYERS",
"LARA",
"SHANNON",
"SEXTON",
"PACE",
"HULL",
"LEBLANC",
"BROWNING",
"VELASQUEZ",
"LEACH",
"CHANG",
"HOUSE",
"SELLERS",
"HERRING",
"NOBLE",
"FOLEY",
"BARTLETT",
"MERCADO",
"LANDRY",
"DURHAM",
"WALLS",
"BARR",
"MCKEE",
"BAUER",
"RIVERS",
"EVERETT",
"BRADSHAW",
"PUGH",
"VELEZ",
"RUSH",
"ESTES",
"DODSON",
"MORSE",
"SHEPPARD",
"WEEKS",
"CAMACHO",
"BEAN",
"BARRON",
"LIVINGSTON",
"MIDDLETON",
"SPEARS",
"BRANCH",
"BLEVINS",
"CHEN",
"KERR",
"MCCONNELL",
"HATFIELD",
"HARDING",
"ASHLEY",
"SOLIS",
"HERMAN",
"FROST",
"GILES",
"BLACKBURN",
"WILLIAM",
"PENNINGTON",
"WOODWARD",
"FINLEY",
"MCINTOSH",
"KOCH",
"BEST",
"SOLOMON",
"MCCULLOUGH",
"DUDLEY",
"NOLAN",
"BLANCHARD",
"RIVAS",
"BRENNAN",
"MEJIA",
"KANE",
"BENTON",
"JOYCE",
"BUCKLEY",
"HALEY",
"VALENTINE",
"MADDOX",
"RUSSO",
"MCKNIGHT",
"BUCK",
"MOON",
"MCMILLAN",
"CROSBY",
"BERG",
"DOTSON",
"MAYS",
"ROACH",
"CHURCH",
"CHAN",
"RICHMOND",
"MEADOWS",
"FAULKNER",
"ONEILL",
"KNAPP",
"KLINE",
"BARRY",
"OCHOA",
"JACOBSON",
"GAY",
"AVERY",
"HENDRICKS",
"HORNE",
"SHEPARD",
"HEBERT",
"CHERRY",
"CARDENAS",
"MCINTYRE",
"WHITNEY",
"WALLER",
"HOLMAN",
"DONALDSON",
"CANTU",
"TERRELL",
"MORIN",
"GILLESPIE",
"FUENTES",
"TILLMAN",
"SANFORD",
"BENTLEY",
"PECK",
"KEY",
"SALAS",
"ROLLINS",
"GAMBLE",
"DICKSON",
"BATTLE",
"SANTANA",
"CABRERA",
"CERVANTES",
"HOWE",
"HINTON",
"HURLEY",
"SPENCE",
"ZAMORA",
"YANG",
"MCNEIL",
"SUAREZ",
"CASE",
"PETTY",
"GOULD",
"MCFARLAND",
"SAMPSON",
"CARVER",
"BRAY",
"ROSARIO",
"MACDONALD",
"STOUT",
"HESTER",
"MELENDEZ",
"DILLON",
"FARLEY",
"HOPPER",
"GALLOWAY",
"POTTS",
"BERNARD",
"JOYNER",
"STEIN",
"AGUIRRE",
"OSBORN",
"MERCER",
"BENDER",
"FRANCO",
"ROWLAND",
"SYKES",
"BENJAMIN",
"TRAVIS",
"PICKETT",
"CRANE",
"SEARS",
"MAYO",
"DUNLAP",
"HAYDEN",
"WILDER",
"MCKAY",
"COFFEY",
"MCCARTY",
"EWING",
"COOLEY",
"VAUGHAN",
"BONNER",
"COTTON",
"HOLDER",
"STARK",
"FERRELL",
"CANTRELL",
"FULTON",
"LYNN",
"LOTT",
"CALDERON",
"ROSA",
"POLLARD",
"HOOPER",
"BURCH",
"MULLEN",
"FRY",
"RIDDLE",
"LEVY",
"DAVID",
"DUKE",
"ODONNELL",
"GUY",
"MICHAEL",
"BRITT",
"FREDERICK",
"DAUGHERTY",
"BERGER",
"DILLARD",
"ALSTON",
"JARVIS",
"FRYE",
"RIGGS",
"CHANEY",
"ODOM",
"DUFFY",
"FITZPATRICK",
"VALENZUELA",
"MERRILL",
"MAYER",
"ALFORD",
"MCPHERSON",
"ACEVEDO",
"DONOVAN",
"BARRERA",
"ALBERT",
"COTE",
"REILLY",
"COMPTON",
"RAYMOND",
"MOONEY",
"MCGOWAN",
"CRAFT",
"CLEVELAND",
"CLEMONS",
"WYNN",
"NIELSEN",
"BAIRD",
"STANTON",
"SNIDER",
"ROSALES",
"BRIGHT",
"WITT",
"STUART",
"HAYS",
"HOLDEN",
"RUTLEDGE",
"KINNEY",
"CLEMENTS",
"CASTANEDA",
"SLATER",
"HAHN",
"EMERSON",
"CONRAD",
"BURKS",
"DELANEY",
"PATE",
"LANCASTER",
"SWEET",
"JUSTICE",
"TYSON",
"SHARPE",
"WHITFIELD",
"TALLEY",
"MACIAS",
"IRWIN",
"BURRIS",
"RATLIFF",
"MCCRAY",
"MADDEN",
"KAUFMAN",
"BEACH",
"GOFF",
"CASH",
"BOLTON",
"MCFADDEN",
"LEVINE",
"GOOD",
"BYERS",
"KIRKLAND",
"KIDD",
"WORKMAN",
"CARNEY",
"DALE",
"MCLEOD",
"HOLCOMB",
"ENGLAND",
"FINCH",
"HEAD",
"BURT",
"HENDRIX",
"SOSA",
"HANEY",
"FRANKS",
"SARGENT",
"NIEVES",
"DOWNS",
"RASMUSSEN",
"BIRD",
"HEWITT",
"LINDSAY",
"LE",
"FOREMAN",
"VALENCIA",
"ONEIL",
"DELACRUZ",
"VINSON",
"DEJESUS",
"HYDE",
"FORBES",
"GILLIAM",
"GUTHRIE",
"WOOTEN",
"HUBER",
"BARLOW",
"BOYLE",
"MCMAHON",
"BUCKNER",
"ROCHA",
"PUCKETT",
"LANGLEY",
"KNOWLES",
"COOKE",
"VELAZQUEZ",
"WHITLEY",
"NOEL",
"VANG"];
tf.consts.DemoCommonFemaleFirstNames = [
"MARY",
"PATRICIA",
"LINDA",
"BARBARA",
"ELIZABETH",
"JENNIFER",
"MARIA",
"SUSAN",
"MARGARET",
"DOROTHY",
"LISA",
"NANCY",
"KAREN",
"BETTY",
"HELEN",
"SANDRA",
"DONNA",
"CAROL",
"RUTH",
"SHARON",
"MICHELLE",
"LAURA",
"SARAH",
"KIMBERLY",
"DEBORAH",
"JESSICA",
"SHIRLEY",
"CYNTHIA",
"ANGELA",
"MELISSA",
"BRENDA",
"AMY",
"ANNA",
"REBECCA",
"VIRGINIA",
"KATHLEEN",
"PAMELA",
"MARTHA",
"DEBRA",
"AMANDA",
"STEPHANIE",
"CAROLYN",
"CHRISTINE",
"MARIE",
"JANET",
"CATHERINE",
"FRANCES",
"ANN",
"JOYCE",
"DIANE",
"ALICE",
"JULIE",
"HEATHER",
"TERESA",
"DORIS",
"GLORIA",
"EVELYN",
"JEAN",
"CHERYL",
"MILDRED",
"KATHERINE",
"JOAN",
"ASHLEY",
"JUDITH",
"ROSE",
"JANICE",
"KELLY",
"NICOLE",
"JUDY",
"CHRISTINA",
"KATHY",
"THERESA",
"BEVERLY",
"DENISE",
"TAMMY",
"IRENE",
"JANE",
"LORI",
"RACHEL",
"MARILYN",
"ANDREA",
"KATHRYN",
"LOUISE",
"SARA",
"ANNE",
"JACQUELINE",
"WANDA",
"BONNIE",
"JULIA",
"RUBY",
"LOIS",
"TINA",
"PHYLLIS",
"NORMA",
"PAULA",
"DIANA",
"ANNIE",
"LILLIAN",
"EMILY",
"ROBIN",
"PEGGY",
"CRYSTAL",
"GLADYS",
"RITA",
"DAWN",
"CONNIE",
"FLORENCE",
"TRACY",
"EDNA",
"TIFFANY",
"CARMEN",
"ROSA",
"CINDY",
"GRACE",
"WENDY",
"VICTORIA",
"EDITH",
"KIM",
"SHERRY",
"SYLVIA",
"JOSEPHINE",
"THELMA",
"SHANNON",
"SHEILA",
"ETHEL",
"ELLEN",
"ELAINE",
"MARJORIE",
"CARRIE",
"CHARLOTTE",
"MONICA",
"ESTHER",
"PAULINE",
"EMMA",
"JUANITA",
"ANITA",
"RHONDA",
"HAZEL",
"AMBER",
"EVA",
"DEBBIE",
"APRIL",
"LESLIE",
"CLARA",
"LUCILLE",
"JAMIE",
"JOANNE",
"ELEANOR",
"VALERIE",
"DANIELLE",
"MEGAN",
"ALICIA",
"SUZANNE",
"MICHELE",
"GAIL",
"BERTHA",
"DARLENE",
"VERONICA",
"JILL",
"ERIN",
"GERALDINE",
"LAUREN",
"CATHY",
"JOANN",
"LORRAINE",
"LYNN",
"SALLY",
"REGINA",
"ERICA",
"BEATRICE",
"DOLORES",
"BERNICE",
"AUDREY",
"YVONNE",
"ANNETTE",
"JUNE",
"SAMANTHA",
"MARION",
"DANA",
"STACY",
"ANA",
"RENEE",
"IDA",
"VIVIAN",
"ROBERTA",
"HOLLY",
"BRITTANY",
"MELANIE",
"LORETTA",
"YOLANDA",
"JEANETTE",
"LAURIE",
"KATIE",
"KRISTEN",
"VANESSA",
"ALMA",
"SUE",
"ELSIE",
"BETH",
"JEANNE",
"VICKI",
"CARLA",
"TARA",
"ROSEMARY",
"EILEEN",
"TERRI",
"GERTRUDE",
"LUCY",
"TONYA",
"ELLA",
"STACEY",
"WILMA",
"GINA",
"KRISTIN",
"JESSIE",
"NATALIE",
"AGNES",
"VERA",
"WILLIE",
"CHARLENE",
"BESSIE",
"DELORES",
"MELINDA",
"PEARL",
"ARLENE",
"MAUREEN",
"COLLEEN",
"ALLISON",
"TAMARA",
"JOY",
"GEORGIA",
"CONSTANCE",
"LILLIE",
"CLAUDIA",
"JACKIE",
"MARCIA",
"TANYA",
"NELLIE",
"MINNIE",
"MARLENE",
"HEIDI",
"GLENDA",
"LYDIA",
"VIOLA",
"COURTNEY",
"MARIAN",
"STELLA",
"CAROLINE",
"DORA",
"JO",
"VICKIE",
"MATTIE",
"TERRY",
"MAXINE",
"IRMA",
"MABEL",
"MARSHA",
"MYRTLE",
"LENA",
"CHRISTY",
"DEANNA",
"PATSY",
"HILDA",
"GWENDOLYN",
"JENNIE",
"NORA",
"MARGIE",
"NINA",
"CASSANDRA",
"LEAH",
"PENNY",
"KAY",
"PRISCILLA",
"NAOMI",
"CAROLE",
"BRANDY",
"OLGA",
"BILLIE",
"DIANNE",
"TRACEY",
"LEONA",
"JENNY",
"FELICIA",
"SONIA",
"MIRIAM",
"VELMA",
"BECKY",
"BOBBIE",
"VIOLET",
"KRISTINA",
"TONI",
"MISTY",
"MAE",
"SHELLY",
"DAISY",
"RAMONA",
"SHERRI",
"ERIKA",
"KATRINA",
"CLAIRE"
];
tf.consts.DemoCommonMaleFirstNames = [
"JAMES",
"JOHN",
"ROBERT",
"MICHAEL",
"WILLIAM",
"DAVID",
"RICHARD",
"CHARLES",
"JOSEPH",
"THOMAS",
"CHRISTOPHER",
"DANIEL",
"PAUL",
"MARK",
"DONALD",
"GEORGE",
"KENNETH",
"STEVEN",
"EDWARD",
"BRIAN",
"RONALD",
"ANTHONY",
"KEVIN",
"JASON",
"MATTHEW",
"GARY",
"TIMOTHY",
"JOSE",
"LARRY",
"JEFFREY",
"FRANK",
"SCOTT",
"ERIC",
"STEPHEN",
"ANDREW",
"RAYMOND",
"GREGORY",
"JOSHUA",
"JERRY",
"DENNIS",
"WALTER",
"PATRICK",
"PETER",
"HAROLD",
"DOUGLAS",
"HENRY",
"CARL",
"ARTHUR",
"RYAN",
"ROGER",
"JOE",
"JUAN",
"JACK",
"ALBERT",
"JONATHAN",
"JUSTIN",
"TERRY",
"GERALD",
"KEITH",
"SAMUEL",
"WILLIE",
"RALPH",
"LAWRENCE",
"NICHOLAS",
"ROY",
"BENJAMIN",
"BRUCE",
"BRANDON",
"ADAM",
"HARRY",
"FRED",
"WAYNE",
"BILLY",
"STEVE",
"LOUIS",
"JEREMY",
"AARON",
"RANDY",
"HOWARD",
"EUGENE",
"CARLOS",
"RUSSELL",
"BOBBY",
"VICTOR",
"MARTIN",
"ERNEST",
"PHILLIP",
"TODD",
"JESSE",
"CRAIG",
"ALAN",
"SHAWN",
"CLARENCE",
"SEAN",
"PHILIP",
"CHRIS",
"JOHNNY",
"EARL",
"JIMMY",
"ANTONIO",
"DANNY",
"BRYAN",
"TONY",
"LUIS",
"MIKE",
"STANLEY",
"LEONARD",
"NATHAN",
"DALE",
"MANUEL",
"RODNEY",
"CURTIS",
"NORMAN",
"ALLEN",
"MARVIN",
"VINCENT",
"GLENN",
"JEFFERY",
"TRAVIS",
"JEFF",
"CHAD",
"JACOB",
"LEE",
"MELVIN",
"ALFRED",
"KYLE",
"FRANCIS",
"BRADLEY",
"JESUS",
"HERBERT",
"FREDERICK",
"RAY",
"JOEL",
"EDWIN",
"DON",
"EDDIE",
"RICKY",
"TROY",
"RANDALL",
"BARRY",
"ALEXANDER",
"BERNARD",
"MARIO",
"LEROY",
"FRANCISCO",
"MARCUS",
"MICHEAL",
"THEODORE",
"CLIFFORD",
"MIGUEL",
"OSCAR",
"JAY",
"JIM",
"TOM",
"CALVIN",
"ALEX",
"JON",
"RONNIE",
"BILL",
"LLOYD",
"TOMMY",
"LEON",
"DEREK",
"WARREN",
"DARRELL",
"JEROME",
"FLOYD",
"LEO",
"ALVIN",
"TIM",
"WESLEY",
"GORDON",
"DEAN",
"GREG",
"JORGE",
"DUSTIN",
"PEDRO",
"DERRICK",
"DAN",
"LEWIS",
"ZACHARY",
"COREY",
"HERMAN",
"MAURICE",
"VERNON",
"ROBERTO",
"CLYDE",
"GLEN",
"HECTOR",
"SHANE",
"RICARDO",
"SAM",
"RICK",
"LESTER",
"BRENT",
"RAMON",
"CHARLIE",
"TYLER",
"GILBERT",
"GENE",
"MARC",
"REGINALD",
"RUBEN",
"BRETT",
"ANGEL",
"NATHANIEL",
"RAFAEL",
"LESLIE",
"EDGAR",
"MILTON",
"RAUL",
"BEN",
"CHESTER",
"CECIL",
"DUANE",
"FRANKLIN",
"ANDRE",
"ELMER",
"BRAD",
"GABRIEL",
"RON",
"MITCHELL",
"ROLAND",
"ARNOLD",
"HARVEY",
"JARED",
"ADRIAN",
"KARL",
"CORY",
"CLAUDE",
"ERIK",
"DARRYL",
"JAMIE",
"NEIL",
"JESSIE",
"CHRISTIAN",
"JAVIER",
"FERNANDO",
"CLINTON",
"TED",
"MATHEW",
"TYRONE",
"DARREN",
"LONNIE",
"LANCE",
"CODY",
"JULIO",
"KELLY",
"KURT",
"ALLAN",
"NELSON",
"GUY",
"CLAYTON",
"HUGH",
"MAX",
"DWAYNE",
"DWIGHT",
"ARMANDO",
"FELIX",
"JIMMIE",
"EVERETT",
"JORDAN",
"IAN",
"WALLACE",
"KEN",
"BOB",
"JAIME",
"CASEY",
"ALFREDO",
"ALBERTO",
"DAVE",
"IVAN",
"JOHNNIE",
"SIDNEY",
"BYRON",
"JULIAN",
"ISAAC",
"MORRIS",
"CLIFTON",
"WILLARD",
"DARYL",
"ROSS",
"VIRGIL",
"ANDY",
"MARSHALL",
"SALVADOR",
"PERRY",
"KIRK",
"SERGIO",
"MARION",
"TRACY",
"SETH",
"KENT",
"TERRANCE",
"RENE",
"EDUARDO",
"TERRENCE",
"ENRIQUE",
"FREDDIE",
"WADE"
];
/**
 * @public
 * @function
 * @summary - Retrieves a random common American female first name
 * @returns {string} - | {@link string} the name
*/
tf.helpers.GetRandomFemaleFirstName = function () { return tf.js.GetRandomArrayElement(tf.consts.DemoCommonFemaleFirstNames); }
/**
 * @public
 * @function
 * @summary - Retrieves a random common American male first name
 * @returns {string} - | {@link string} the name
*/
tf.helpers.GetRandomMaleFirstName = function () { return tf.js.GetRandomArrayElement(tf.consts.DemoCommonMaleFirstNames); }
/**
 * @public
 * @function
 * @summary - Retrieves a random common American first name
 * @returns {string} - | {@link string} the name
*/
tf.helpers.GetRandomFirstName = function () { return Math.random() < 0.5 ? tf.helpers.GetRandomMaleFirstName() : tf.helpers.GetRandomFemaleFirstName(); }
/**
 * @public
 * @function
 * @summary - Retrieves a random common American last name
 * @returns {string} - | {@link string} the name
*/
tf.helpers.GetRandomLastName = function () { return tf.js.GetRandomArrayElement(tf.consts.DemoCommonLastNames); }
/**
 * @public
 * @function
 * @summary - Retrieves a random common American first and last name combination
 * @returns {string} - | {@link string} the name
*/
tf.helpers.GetRandomFirstLastName = function () {
    return tf.js.CapitaliseFirstLetterOnly(tf.helpers.GetRandomFirstName()) + ' ' + tf.js.CapitaliseFirstLetterOnly(tf.helpers.GetRandomLastName());
}
tf.math.Vector3 = function (settings) {
    var theThis;
    this.length = function() { return 3; }
    this.Update = function (x, y, z) { return update(x, y, z); }
    this.GetSettings = function () { return { x: theThis[0], y: theThis[1], z: theThis[2] }; }
    this.GetAsJSArray = function () { return [x, y, z]; }
    this.GetAsFloat32Array = function () { return new Float32Array(theThis.GetAsJSArray()); }
    this.CopyFrom = function (otherVector3) {
        /*if (otherVector3 instanceof tf.math.Vector3) {*/ theThis[0] = otherVector3[0]; theThis[1] = otherVector3[1]; theThis[2] = otherVector3[2]; /*}*/
        if (!!otherVector3) { theThis[0] = otherVector3[0]; theThis[1] = otherVector3[1]; theThis[2] = otherVector3[2]; }
        return theThis;
    }
    this.CopyTo = function (otherVector3) {
        if (!!otherVector3){ otherVector3[0] = theThis[0]; otherVector3[1] = theThis[1]; otherVector3[2] = theThis[2]; }
        ///*if (otherVector3 instanceof tf.math.Vector3) {*/ otherVector3[0] = theThis[0]; otherVector3[1] = theThis[1]; otherVector3[2] = theThis[2]; /*}*/
        //return theThis;
        return otherVector3;
    }
    this.GetMagnitude = function () { return theThis[0] * theThis[0] + theThis[1] * theThis[1] + theThis[2] * theThis[2]; }
    this.GetLength = function () { return Math.sqrt(theThis.GetMagnitude()); }
    this.Normalize = function () { var mag = theThis.GetMagnitude(); if (mag != 0 && mag != 1) { theThis.MultByScalar(1 / Math.sqrt(mag)); } return theThis; }
    this.MultByScalar = function (scalar) { if (typeof scalar == 'number' && scalar != 1) { theThis[0] *= scalar; theThis[1] *= scalar; theThis[2] *= scalar; } return theThis; }
    this.MultByMatrix = function (matrix) {
        if (!!matrix){
            var x = theThis[0], y = theThis[1], z = theThis[2], m = matrix.getMatrix();
            var w = m.m44 + x * m.m14 + y * m.m24 + z * m.m34;
            theThis[0] = m.m41 + x * m.m11 + y * m.m21 + z * m.m31;
            theThis[1] = m.m42 + x * m.m12 + y * m.m22 + z * m.m32;
            theThis[2] = m.m43 + x * m.m13 + y * m.m23 + z * m.m33;
            if (w != 1 && w != 0) { w = 1 / w; theThis[0] *= w; theThis[1] *= w; theThis[2] *= w; }
        }
        return theThis;
    }
    this.MultDirectionByMatrix = function (matrix) {
        if (!!matrix) {
            var x = theThis[0], y = theThis[1], z = theThis[2], m = matrix.getMatrix();
            theThis[0] = x * m.m11 + y * m.m21 + z * m.m31;
            theThis[1] = x * m.m12 + y * m.m22 + z * m.m32;
            theThis[2] = x * m.m13 + y * m.m23 + z * m.m33;
        }
        return theThis;
    }
    this.Dot = function (otherVector3) {
        //return otherVector3 instanceof tf.math.Vector3 ? theThis[0] * otherVector3[0] + theThis[1] * otherVector3[1] + theThis[2] * otherVector3[2] : 0;
        return !!otherVector3 ? theThis[0] * otherVector3[0] + theThis[1] * otherVector3[1] + theThis[2] * otherVector3[2] : 0;
        //return theThis[0] * otherVector3[0] + theThis[1] * otherVector3[1] + theThis[2] * otherVector3[2];
    }
    this.Cross = function (otherVector3) {
        //if (otherVector3 instanceof tf.math.Vector3) {
            var x = theThis[1] * otherVector3[2] - theThis[2] * otherVector3[1];
            var y = -theThis[0] * otherVector3[2] + theThis[2] * otherVector3[0];
            theThis[2] = theThis[0] * otherVector3[1] - theThis[1] * otherVector3[0];
            theThis[0] = x; theThis[1] = y;
        //}
        return theThis;
    }
    this.CrossRight = function (otherVector3) {
        //if (otherVector3 instanceof tf.math.Vector3) {
        var x = otherVector3[1] * theThis[2] - otherVector3[2] * theThis[1];
        var y = -otherVector3[0] * theThis[2] + otherVector3[2] * theThis[0];
        theThis[2] = otherVector3[0] * theThis[1] - otherVector3[1] * theThis[0];
        theThis[0] = x; theThis[1] = y;
        //}
        return theThis;
    }
    this.Add = function (otherVector3) { if (!!otherVector3/*otherVector3 instanceof tf.math.Vector3*/) { theThis[0] += otherVector3[0]; theThis[1] += otherVector3[1]; theThis[2] += otherVector3[2]; } return theThis; }
    this.Sub = function (otherVector3) { if (!!otherVector3/*otherVector3 instanceof tf.math.Vector3*/) { theThis[0] -= otherVector3[0]; theThis[1] -= otherVector3[1]; theThis[2] -= otherVector3[2]; } return theThis; }
    function update(xSet, ySet, zSet) {
        if (tf.js.GetIsValidObject(xSet)) {
            if (tf.js.GetIsArrayWithMinLength(xSet, 3)) { zSet = xSet[2]; ySet = xSet[1], xSet = xSet[0]; }
            else { zSet = xSet.z; ySet = xSet.y; xSet = xSet.x; }
        }
        theThis[0] = tf.js.GetFloatNumber(xSet, 0);
        theThis[1] = tf.js.GetFloatNumber(ySet, 0);
        theThis[2] = tf.js.GetFloatNumber(zSet, 0);
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (!!settings.vector/*settings.vector instanceof tf.math.Vector3*/) { theThis.CopyFrom(settings.vector); }
        else { update(settings); }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.math.GetDeterminant2x2 = function(a, b, c, d) { return a * d - b * c; }
tf.math.GetDeterminant3x3 = function (a1, a2, a3, b1, b2, b3, c1, c2, c3) {
    return a1 * tf.math.GetDeterminant2x2(b2, b3, c2, c3) - b1 * tf.math.GetDeterminant2x2(a2, a3, c2, c3) + c1 * tf.math.GetDeterminant2x2(a2, a3, b2, b3);
}
tf.math.GetDeterminant4x4 = function (a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4) {
    return a1 * tf.math.GetDeterminant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4) - b1 * tf.math.GetDeterminant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4) +
        c1 * tf.math.GetDeterminant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4) - d1 * tf.math.GetDeterminant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);
}
tf.math.GetCSSMatrixInfo = function () {
    if (tf.math.hasCSSMatrix == undefined) {
        if (tf.math.hasCSSMatrix = ("WebKitCSSMatrix" in window && ("media" in window && window.media.matchMedium("(-webkit-transform-3d)")) ||
            ("styleMedia" in window && window.styleMedia.matchMedium("(-webkit-transform-3d)")))) {
            tf.math.hasCSSMatrixCopy = "copy" in WebKitCSSMatrix.prototype;
        }
        else { tf.math.hasCSSMatrixCopy = false; }
        //tf.math.hasCSSMatrix = tf.math.hasCSSMatrixCopy = false;
        //tf.math.hasCSSMatrixCopy = false;
    }
    return { hasCSSMatrix: tf.math.hasCSSMatrix, hasCSSMatrixCopy: tf.math.hasCSSMatrixCopy };
}
tf.math.Matrix4 = function (settings) {
    var theThis, matrix;
    this.GetInStaticFloat32Array = function () {
        if (tf.math.Matrix4.staticFloat32Array  == undefined) { tf.math.Matrix4.staticFloat32Array = new Float32Array(16); }
        if (tf.math.hasCSSMatrixCopy)
            matrix.copy(tf.math.Matrix4.staticFloat32Array);
        else {
            if (tf.math.Matrix4.staticJSArray == undefined) { tf.math.Matrix4.staticJSArray = new Array(16); }
            tf.math.Matrix4.staticJSArray[0] = matrix.m11; tf.math.Matrix4.staticJSArray[1] = matrix.m12;
            tf.math.Matrix4.staticJSArray[2] = matrix.m13; tf.math.Matrix4.staticJSArray[3] = matrix.m14;
            tf.math.Matrix4.staticJSArray[4] = matrix.m21; tf.math.Matrix4.staticJSArray[5] = matrix.m22;
            tf.math.Matrix4.staticJSArray[6] = matrix.m23; tf.math.Matrix4.staticJSArray[7] = matrix.m24;
            tf.math.Matrix4.staticJSArray[8] = matrix.m31; tf.math.Matrix4.staticJSArray[9] = matrix.m32;
            tf.math.Matrix4.staticJSArray[10] = matrix.m33; tf.math.Matrix4.staticJSArray[11] = matrix.m34;
            tf.math.Matrix4.staticJSArray[12] = matrix.m41; tf.math.Matrix4.staticJSArray[13] = matrix.m42;
            tf.math.Matrix4.staticJSArray[14] = matrix.m43; tf.math.Matrix4.staticJSArray[15] = matrix.m44;
            tf.math.Matrix4.staticFloat32Array.set(tf.math.Matrix4.staticJSArray);
        }
        return tf.math.Matrix4.staticFloat32Array;
    }
    this.GetAsJSArray = function () { return getAsJSArray(); }
    this.GetAsFloat32Array = function () { return getAsFloat32Array(); }
    this.CopyTo = function (otherMatrix) { return copyTo(otherMatrix); }
    this.CopyFrom = function (otherMatrix) { return copyFrom(otherMatrix); }
    function copyFrom(otherMatrix) {
        if (otherMatrix instanceof tf.math.Matrix4) {
            var otherMat = otherMatrix.getMatrix();
            matrix.m11 = otherMat.m11; matrix.m12 = otherMat.m12; matrix.m13 = otherMat.m13; matrix.m14 = otherMat.m14;
            matrix.m21 = otherMat.m21; matrix.m22 = otherMat.m22; matrix.m23 = otherMat.m23; matrix.m24 = otherMat.m24;
            matrix.m31 = otherMat.m31; matrix.m32 = otherMat.m32; matrix.m33 = otherMat.m33; matrix.m34 = otherMat.m34;
            matrix.m41 = otherMat.m41; matrix.m42 = otherMat.m42; matrix.m43 = otherMat.m43; matrix.m44 = otherMat.m44;
        }
        else if (tf.js.GetIsArrayWithMinLength(otherMatrix, 16)) {
            var i = 0;
            /*matrix.m11 = otherMatrix[i++]; matrix.m12 = otherMatrix[i++]; matrix.m13 = otherMatrix[i++]; matrix.m14 = otherMatrix[i++];
            matrix.m21 = otherMatrix[i++]; matrix.m22 = otherMatrix[i++]; matrix.m23 = otherMatrix[i++]; matrix.m24 = otherMatrix[i++];
            matrix.m31 = otherMatrix[i++]; matrix.m32 = otherMatrix[i++]; matrix.m33 = otherMatrix[i++]; matrix.m34 = otherMatrix[i++];
            matrix.m41 = otherMatrix[i++]; matrix.m42 = otherMatrix[i++]; matrix.m43 = otherMatrix[i++]; matrix.m44 = otherMatrix[i++];*/
            matrix.m11 = otherMatrix[0]; matrix.m21 = otherMatrix[1]; matrix.m31 = otherMatrix[2]; matrix.m41 = otherMatrix[3];
            matrix.m12 = otherMatrix[4]; matrix.m22 = otherMatrix[5]; matrix.m32 = otherMatrix[6]; matrix.m42 = otherMatrix[7];
            matrix.m13 = otherMatrix[8]; matrix.m23 = otherMatrix[9]; matrix.m33 = otherMatrix[10]; matrix.m43 = otherMatrix[11];
            matrix.m14 = otherMatrix[12]; matrix.m24 = otherMatrix[13]; matrix.m34 = otherMatrix[14]; matrix.m44 = otherMatrix[15];
        }
        return theThis;
    }
    function copyTo(otherMatrix) { if (otherMatrix instanceof tf.math.Matrix4) { otherMatrix.CopyFrom(theThis); } return theThis; }
    this.ToIdentity = function () { return toIdentity(); }
    this.ToTransposed = function () { return toTransposed(); }
    this.ToInverse = function () { return toInverse(); }
    this.ToAdjoint = function () { return toAdjoint; }
    this.MultByMatrix = function (otherMatrix) { return multByMatrix(otherMatrix); }
    this.MultByScalar = function (scalar) { return multByScalar(scalar); }
    this.GetDeterminant = function () { return getDeterminant(); }
    this.getMatrix = function () { return matrix; }
    this.setMatrix = function (otherMatrix) { if (!!otherMatrix) { matrix = otherMatrix; } }
    function getAsJSArray() {
        return [matrix.m11, matrix.m12, matrix.m13, matrix.m14, matrix.m21, matrix.m22, matrix.m23, matrix.m24,
            matrix.m31, matrix.m32, matrix.m33, matrix.m34, matrix.m41, matrix.m42, matrix.m43, matrix.m44];
    }
    function getAsFloat32Array() {
        var array;
        if (tf.math.hasCSSMatrix) { array = new Float32Array(16); matrix.copy(array); }
        else { array = new Float32Array(getAsJSArray()); }
        return array;
    }
    function toIdentity() {
        matrix.m11 = 1; matrix.m12 = 0; matrix.m13 = 0; matrix.m14 = 0;
        matrix.m21 = 0; matrix.m22 = 1; matrix.m23 = 0; matrix.m24 = 0;
        matrix.m31 = 0; matrix.m32 = 0; matrix.m33 = 1; matrix.m34 = 0;
        matrix.m41 = 0; matrix.m42 = 0; matrix.m43 = 0; matrix.m44 = 1;
        return theThis;
    }
    function toTransposed () {
        var tmp = matrix.m12; matrix.m12 = matrix.m21; matrix.m21 = tmp;
        tmp = matrix.m13; matrix.m13 = matrix.m31; matrix.m31 = tmp;
        tmp = matrix.m14; matrix.m14 = matrix.m41; matrix.m41 = tmp;
        tmp = matrix.m23; matrix.m23 = matrix.m32; matrix.m32 = tmp;
        tmp = matrix.m24; matrix.m24 = matrix.m42; matrix.m42 = tmp;
        tmp = matrix.m34; matrix.m34 = matrix.m43; matrix.m43 = tmp;
        return theThis;
    }
    function toInverse() {
        if (tf.math.hasCSSMatrix) { try { matrix = matrix.inverse(); } catch (e) { } }
        else { var det = getDeterminant(); if (Math.abs(det) >= 1e-8) { toAdjoint(); multByScalar(1 / det); } }
        return theThis;
    }
    function toAdjoint() {
        var a1 = matrix.m11, b1 = matrix.m12, c1 = matrix.m13, d1 = matrix.m14;
        var a2 = matrix.m21, b2 = matrix.m22, c2 = matrix.m23, d2 = matrix.m24;
        var a3 = matrix.m31, b3 = matrix.m32, c3 = matrix.m33, d3 = matrix.m34;
        var a4 = matrix.m41, b4 = matrix.m42, c4 = matrix.m43, d4 = matrix.m44;
        matrix.m11 = tf.math.GetDeterminant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4);
        matrix.m21 = -tf.math.GetDeterminant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4);
        matrix.m31 = tf.math.GetDeterminant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4);
        matrix.m41 = -tf.math.GetDeterminant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);
        matrix.m12 = -tf.math.GetDeterminant3x3(b1, b3, b4, c1, c3, c4, d1, d3, d4);
        matrix.m22 = tf.math.GetDeterminant3x3(a1, a3, a4, c1, c3, c4, d1, d3, d4);
        matrix.m32 = -tf.math.GetDeterminant3x3(a1, a3, a4, b1, b3, b4, d1, d3, d4);
        matrix.m42 = tf.math.GetDeterminant3x3(a1, a3, a4, b1, b3, b4, c1, c3, c4);
        matrix.m13 = tf.math.GetDeterminant3x3(b1, b2, b4, c1, c2, c4, d1, d2, d4);
        matrix.m23 = -tf.math.GetDeterminant3x3(a1, a2, a4, c1, c2, c4, d1, d2, d4);
        matrix.m33 = tf.math.GetDeterminant3x3(a1, a2, a4, b1, b2, b4, d1, d2, d4);
        matrix.m43 = -tf.math.GetDeterminant3x3(a1, a2, a4, b1, b2, b4, c1, c2, c4);
        matrix.m14 = -tf.math.GetDeterminant3x3(b1, b2, b3, c1, c2, c3, d1, d2, d3);
        matrix.m24 = tf.math.GetDeterminant3x3(a1, a2, a3, c1, c2, c3, d1, d2, d3);
        matrix.m34 = -tf.math.GetDeterminant3x3(a1, a2, a3, b1, b2, b3, d1, d2, d3);
        matrix.m44 = tf.math.GetDeterminant3x3(a1, a2, a3, b1, b2, b3, c1, c2, c3);
        return theThis;
    }
    function multByScalar(scalar) {
        if (typeof scalar == 'number' && scalar != 1) {
            matrix.m11 *= scalar; matrix.m12 *= scalar; matrix.m13 *= scalar; matrix.m14 *= scalar;
            matrix.m21 *= scalar; matrix.m22 *= scalar; matrix.m23 *= scalar; matrix.m24 *= scalar;
            matrix.m31 *= scalar; matrix.m32 *= scalar; matrix.m33 *= scalar; matrix.m34 *= scalar;
            matrix.m41 *= scalar; matrix.m42 *= scalar; matrix.m43 *= scalar; matrix.m44 *= scalar;
        }
        return theThis;
    }
    function multByMatrix(otherMatrix) {
        if (otherMatrix instanceof tf.math.Matrix4) {
            var otherMat = otherMatrix.getMatrix();
            if (tf.math.hasCSSMatrix) { matrix = matrix.multiply(otherMat); }
            else {
                var m11 = otherMat.m11 * matrix.m11 + otherMat.m12 * matrix.m21 + otherMat.m13 * matrix.m31 + otherMat.m14 * matrix.m41;
                var m12 = otherMat.m11 * matrix.m12 + otherMat.m12 * matrix.m22 + otherMat.m13 * matrix.m32 + otherMat.m14 * matrix.m42;
                var m13 = otherMat.m11 * matrix.m13 + otherMat.m12 * matrix.m23 + otherMat.m13 * matrix.m33 + otherMat.m14 * matrix.m43;
                var m14 = otherMat.m11 * matrix.m14 + otherMat.m12 * matrix.m24 + otherMat.m13 * matrix.m34 + otherMat.m14 * matrix.m44;
                var m21 = otherMat.m21 * matrix.m11 + otherMat.m22 * matrix.m21 + otherMat.m23 * matrix.m31 + otherMat.m24 * matrix.m41;
                var m22 = otherMat.m21 * matrix.m12 + otherMat.m22 * matrix.m22 + otherMat.m23 * matrix.m32 + otherMat.m24 * matrix.m42;
                var m23 = otherMat.m21 * matrix.m13 + otherMat.m22 * matrix.m23 + otherMat.m23 * matrix.m33 + otherMat.m24 * matrix.m43;
                var m24 = otherMat.m21 * matrix.m14 + otherMat.m22 * matrix.m24 + otherMat.m23 * matrix.m34 + otherMat.m24 * matrix.m44;
                var m31 = otherMat.m31 * matrix.m11 + otherMat.m32 * matrix.m21 + otherMat.m33 * matrix.m31 + otherMat.m34 * matrix.m41;
                var m32 = otherMat.m31 * matrix.m12 + otherMat.m32 * matrix.m22 + otherMat.m33 * matrix.m32 + otherMat.m34 * matrix.m42;
                var m33 = otherMat.m31 * matrix.m13 + otherMat.m32 * matrix.m23 + otherMat.m33 * matrix.m33 + otherMat.m34 * matrix.m43;
                var m34 = otherMat.m31 * matrix.m14 + otherMat.m32 * matrix.m24 + otherMat.m33 * matrix.m34 + otherMat.m34 * matrix.m44;
                var m41 = otherMat.m41 * matrix.m11 + otherMat.m42 * matrix.m21 + otherMat.m43 * matrix.m31 + otherMat.m44 * matrix.m41;
                var m42 = otherMat.m41 * matrix.m12 + otherMat.m42 * matrix.m22 + otherMat.m43 * matrix.m32 + otherMat.m44 * matrix.m42;
                var m43 = otherMat.m41 * matrix.m13 + otherMat.m42 * matrix.m23 + otherMat.m43 * matrix.m33 + otherMat.m44 * matrix.m43;
                var m44 = otherMat.m41 * matrix.m14 + otherMat.m42 * matrix.m24 + otherMat.m43 * matrix.m34 + otherMat.m44 * matrix.m44;
                matrix.m11 = m11; matrix.m12 = m12; matrix.m13 = m13; matrix.m14 = m14;
                matrix.m21 = m21; matrix.m22 = m22; matrix.m23 = m23; matrix.m24 = m24;
                matrix.m31 = m31; matrix.m32 = m32; matrix.m33 = m33; matrix.m34 = m34;
                matrix.m41 = m41; matrix.m42 = m42; matrix.m43 = m43; matrix.m44 = m44;
            }
        }
        return theThis;
    }
    function getDeterminant() {
        return tf.math.GetDeterminant4x4(
            matrix.m11, matrix.m12, matrix.m13, matrix.m14, matrix.m21, matrix.m22, matrix.m23, matrix.m24,
            matrix.m31, matrix.m32, matrix.m33, matrix.m34, matrix.m41, matrix.m42, matrix.m43, matrix.m44);
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        tf.math.GetCSSMatrixInfo();
        matrix = tf.math.hasCSSMatrix ? new WebKitCSSMatrix : {};
        if (settings.matrix instanceof tf.math.Matrix4 || tf.js.GetIsArrayWithMinLength(settings.matrix, 16)) { copyFrom(settings.matrix); }
        else if (!settings.noInit) { toIdentity(); }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.math.ScaleMatrix4 = function (settings) {
    var theThis, sx, sy, sz;
    this.SetScale = function (sx, sy, sz) { return setScale(sx, sy, sz); }
    this.GetScale = function () { return { sx: sx, sy: sy, sz: sz }; }
    function setScale(sxSet, sySet, szSet) {
        var copied;
        if (tf.js.GetIsValidObject(sxSet)) {
            if (copied = sxSet instanceof tf.math.Matrix4) { theThis.CopyFrom(sxSet); }
            else { szSet = sxSet.sz; sySet = sxSet.sy; sxSet = sxSet.sx; }
        }
        if (!copied) {
            var matrix = theThis.getMatrix();
            matrix.m11 = sx = tf.js.GetFloatNumber(sxSet, 1);
            matrix.m22 = sy = tf.js.GetFloatNumber(sySet, 1);
            matrix.m33 = sz = tf.js.GetFloatNumber(szSet, 1);
        }
        return theThis;
    }
    function initialize() {
        tf.math.Matrix4.call(theThis);
        setScale(settings = tf.js.GetValidObjectFrom(settings));
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.math.ScaleMatrix4, tf.math.Matrix4);
tf.math.RotateMatrix4 = function (settings) {
    var theThis, angle, axisx, axisy, axisz;
    this.SetRotateAngleAxis = function (angle, axisx, axisy, axisz) { return setRotateAngleAxis(angle, axisx, axisy, axisz); }
    this.GetRotate = function () { return { angle: angle, axisx: axisx, axisy: axisy, axisz: axisz }; }
    function setRotateAngleAxis(angleSet, axisxSet, axisySet, axiszSet) {
        var copied;
        if (tf.js.GetIsValidObject(angleSet)) {
            if (copied = angleSet instanceof tf.math.Matrix4) { theThis.CopyFrom(angleSet); }
            else { axiszSet = angleSet.axisz; axisySet = angleSet.axisy; axisxSet = angleSet.axisx; angleSet = angleSet.angle; }
        }
        if (!copied) {
            var matrix = theThis.getMatrix();
            theThis.ToIdentity();
            angle = tf.js.GetFloatNumber(angleSet, 0);
            axisx = tf.js.GetFloatNumber(axisxSet, 0);
            axisy = tf.js.GetFloatNumber(axisySet, 0);
            axisz = tf.js.GetFloatNumber(axiszSet, 0);
            if (angle != 0 && (axisx != 0 || axisy != 0 || axisz != 0)) {
                if (tf.math.hasCSSMatrix) {
                    theThis.setMatrix(matrix.rotateAxisAngle(axisx, axisy, axisz, angle * 180 / Math.PI));
                }
                else {
                    angle /= 2;
                    var sinA = Math.sin(angle);
                    var cosA = Math.cos(angle);
                    var sinA2 = sinA * sinA;
                    var x = axisx, y = axisy, z = axisz;
                    var len = Math.sqrt(x * x + y * y + z * z);
                    if (len == 0) { x = 0; y = 0; z = 1; } else if (len != 1) { x /= len; y /= len; z /= len; }
                    if (x == 1 && y == 0 && z == 0) {
                        matrix.m11 = 1;
                        matrix.m12 = matrix.m13 = matrix.m21 = matrix.m31 = 0;
                        matrix.m22 = 1 - 2 * sinA2;
                        matrix.m23 = 2 * sinA * cosA;
                        matrix.m32 = -2 * sinA * cosA;
                        matrix.m33 = 1 - 2 * sinA2;
                    } else if (x == 0 && y == 1 && z == 0) {
                        matrix.m11 = 1 - 2 * sinA2;
                        matrix.m12 = matrix.m21 = matrix.m23 = matrix.m32 = 0;
                        matrix.m13 = -2 * sinA * cosA;
                        matrix.m22 = 1;
                        matrix.m31 = 2 * sinA * cosA;
                        matrix.m33 = 1 - 2 * sinA2;
                    } else if (x == 0 && y == 0 && z == 1) {
                        matrix.m11 = 1 - 2 * sinA2;
                        matrix.m12 = 2 * sinA * cosA;
                        matrix.m13 = matrix.m23 = matrix.m31 = matrix.m32 = 0;
                        matrix.m21 = -2 * sinA * cosA;
                        matrix.m22 = 1 - 2 * sinA2;
                        matrix.m33 = 1;
                    } else {
                        var x2 = x * x, y2 = y * y, z2 = z * z;
                        matrix.m11 = 1 - 2 * (y2 + z2) * sinA2;
                        matrix.m12 = 2 * (x * y * sinA2 + z * sinA * cosA);
                        matrix.m13 = 2 * (x * z * sinA2 - y * sinA * cosA);
                        matrix.m21 = 2 * (y * x * sinA2 - z * sinA * cosA);
                        matrix.m22 = 1 - 2 * (z2 + x2) * sinA2;
                        matrix.m23 = 2 * (y * z * sinA2 + x * sinA * cosA);
                        matrix.m31 = 2 * (z * x * sinA2 + y * sinA * cosA);
                        matrix.m32 = 2 * (z * y * sinA2 - x * sinA * cosA);
                        matrix.m33 = 1 - 2 * (x2 + y2) * sinA2;
                    }
                    matrix.m14 = matrix.m24 = matrix.m34 = matrix.m41 = matrix.m42 = matrix.m43 = 0;
                    matrix.m44 = 1;
                }
            }
        }
        return theThis;
    }
    function initialize() {
        tf.math.Matrix4.call(theThis, { noInit: true });
        setRotateAngleAxis(settings = tf.js.GetValidObjectFrom(settings));
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.math.RotateMatrix4, tf.math.Matrix4);
tf.math.TranslateMatrix4 = function (settings) {
    var theThis, tx, ty, tz;
    this.SetTranslate = function (tx, ty, tz) { return setTranslate(tx, ty, tz); }
    this.GetTranslate = function () { return { tx: tx, ty: ty, tz: tz }; }
    function setTranslate(txSet, tySet, tzSet) {
        var copied;
        if (tf.js.GetIsValidObject(txSet)) {
            if (copied = txSet instanceof tf.math.Matrix4) { theThis.CopyFrom(txSet); }
            else { tzSet = txSet.tz; tySet = txSet.ty; txSet = txSet.tx; }
        }
        if (!copied) {
            var matrix = theThis.getMatrix();
            matrix.m41 = tx = tf.js.GetFloatNumber(txSet, 0);
            matrix.m42 = ty = tf.js.GetFloatNumber(tySet, 0);
            matrix.m43 = tz = tf.js.GetFloatNumber(tzSet, 0);
        }
        return theThis;
    }
    function initialize() {
        tf.math.Matrix4.call(theThis);
        setTranslate(settings = tf.js.GetValidObjectFrom(settings));
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.math.TranslateMatrix4, tf.math.Matrix4);
tf.math.WorldMatrix4 = function (settings) {
    var theThis, matScale, matRotate, matTranslate;
    this.UpdateWorld = function (settings) { return updateWorld(settings); }
    this.GetScale = function () { return matScale; }
    this.GetTranslate = function () { return matTranslate; }
    this.GetRotate = function () { return matRotate; }
    function updateWorld(settings) {
        var isCopy;
        if (tf.js.GetIsValidObject(settings)) {
            if (! (isCopy = tf.js.GetIsValidObject(settings.matrix))) {
                if (tf.js.GetIsValidObject(settings.scale)) {
                    if (matScale === undefined) { matScale = new tf.math.ScaleMatrix4(settings.scale); }
                    else { matScale.SetScale(settings.scale); }
                }
                if (tf.js.GetIsValidObject(settings.rotate)) {
                    if (matRotate === undefined) { matRotate = new tf.math.RotateMatrix4(settings.rotate); }
                    else { matRotate.SetRotateAngleAxis(settings.rotate); }
                }
                if (tf.js.GetIsValidObject(settings.translate)) {
                    if (matTranslate === undefined) { matTranslate = new tf.math.TranslateMatrix4(settings.translate); }
                    else { matTranslate.SetTranslate(settings.translate); }
                }
            }
        }
        if (!!isCopy) { theThis.CopyFrom(settings.matrix); }
        else {
            theThis.ToIdentity();
            if (matTranslate !== undefined) { theThis.MultByMatrix(matTranslate); }
            if (matRotate !== undefined) { theThis.MultByMatrix(matRotate); }
            if (matScale !== undefined) { theThis.MultByMatrix(matScale); }
        }
        return theThis;
    }
    function initialize() {
        tf.math.Matrix4.call(theThis, { noInit: true });
        updateWorld(tf.js.GetValidObjectFrom(settings));
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
}
tf.js.InheritFrom(tf.math.WorldMatrix4, tf.math.Matrix4);
tf.math.ViewMatrix4 = function (settings) {
    var theThis, inverse, vFrom, vTo, vUp, vUnitTo, vUnitUp, vUnitRight;
    this.GetInverse = function () { return inverse; }
    this.UpdateView = function (settings) { return updateView(settings); }
    this.GetView = function () { return { vFrom: vFrom, vTo: vTo, vUp: vUp, vUnitTo: vUnitTo, vUnitUp: vUnitUp, vUnitRight: vUnitRight}; }
    function updateView(settings) {
        settings = tf.js.GetValidObjectFrom(settings);
        vFrom = tf.js.GetIsArrayWithMinLength(settings.vFrom, 3) ? settings.vFrom : [0, 0, 1];
        vTo = settings.vTo !== undefined ? settings.vTo : [0, 0, 0];
        vUp = settings.vUp !== undefined ? settings.vUp : [0, 1, 0];
        var eyex = vFrom[0], eyey = vFrom[1], eyez = vFrom[2], atx = vTo[0], aty = vTo[1], atz = vTo[2], upx = vUp[0], upy = vUp[1], upz = vUp[2]
        var zAxisX = eyex - atx, zAxisY = eyey - aty, zAxisZ = eyez - atz;
        var mag = Math.sqrt(zAxisX * zAxisX + zAxisY * zAxisY + zAxisZ * zAxisZ);
        if (mag != 0 && mag != 1) { mag = 1 / mag; zAxisX *= mag; zAxisY *= mag; zAxisZ *= mag; }
        vUnitTo = [zAxisX, zAxisY, zAxisZ];
        var yAxisX = upx, yAxisY = upy, yAxisZ = upz;
        mag = Math.sqrt(yAxisX * yAxisX + yAxisY * yAxisY + yAxisZ * yAxisZ);
        if (mag != 0 && mag != 1) { mag = 1 / mag; yAxisX *= mag; yAxisY *= mag; yAxisZ *= mag; }
        var xAxisX = yAxisY * zAxisZ - yAxisZ * zAxisY, xAxisY = yAxisZ * zAxisX - yAxisX * zAxisZ, xAxisZ = yAxisX * zAxisY - yAxisY * zAxisX;
        mag = Math.sqrt(xAxisX * xAxisX + xAxisY * xAxisY + xAxisZ * xAxisZ);
        if (mag != 0 && mag != 1) { mag = 1 / mag; xAxisX *= mag; xAxisY *= mag; xAxisZ *= mag; }
        vUnitRight = [xAxisX, xAxisY, xAxisZ];
        yAxisX = zAxisY * xAxisZ - zAxisZ * xAxisY; yAxisY = zAxisZ * xAxisX - zAxisX * xAxisZ; yAxisZ = zAxisX * xAxisY - zAxisY * xAxisX;
        mag = Math.sqrt(yAxisX * yAxisX + yAxisY * yAxisY + yAxisZ * yAxisZ);
        if (mag != 0 && mag != 1) { mag = 1 / mag; yAxisX *= mag; yAxisY *= mag; yAxisZ *= mag; }
        vUnitUp = [yAxisX, yAxisY, yAxisZ];
        var xAxisDot = xAxisX * eyex + xAxisY * eyey + xAxisZ * eyez;
        var yAxisDot = yAxisX * eyex + yAxisY * eyey + yAxisZ * eyez;
        var zAxisDot = zAxisX * eyex + zAxisY * eyey + zAxisZ * eyez;
        var matrix = inverse.getMatrix();
        matrix.m14 = matrix.m24 = matrix.m34 = 0;
        matrix.m44 = 1;
        matrix.m11 = xAxisX; matrix.m12 = xAxisY; matrix.m13 = xAxisZ; 
        matrix.m21 = yAxisX; matrix.m22 = yAxisY; matrix.m23 = yAxisZ; 
        matrix.m31 = zAxisX; matrix.m32 = zAxisY; matrix.m33 = zAxisZ; 
        matrix.m41 = eyex; matrix.m42 = eyey; matrix.m43 = eyez; 
        theThis.CopyFrom(inverse);
        theThis.ToInverse();
        return theThis;
    }
    function initialize() {
        var noInit = { noInit: true };
        inverse = new tf.math.Matrix4(noInit);
        tf.math.Matrix4.call(theThis, noInit);
        updateView(settings);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
}
tf.js.InheritFrom(tf.math.ViewMatrix4, tf.math.Matrix4);
tf.math.FrustumMatrix4 = function (settings) {
    var theThis, left, right, bottom, top, near, far, halfWidth, halfHeight;
    this.UpdateFrustum = function (settings) { return updateFrustum(settings); }
    this.GetFrustum = function () { return { left: left, right: right, top: top, bottom: bottom, near: near, far: far, halfWidth: halfWidth, halfHeight: halfHeight }; }
    function updateFrustum(settings) {
        settings = tf.js.GetValidObjectFrom(settings);
        left = tf.js.GetFloatNumber(settings.left, -1);
        right = tf.js.GetFloatNumber(settings.right, 1);
        bottom = tf.js.GetFloatNumber(settings.bottom, -1);
        top = tf.js.GetFloatNumber(settings.top, 1);
        near = tf.js.GetFloatNumber(settings.near, 1);
        far = tf.js.GetFloatNumber(settings.far, 1000);
        var near2 = near + near;
        var W = right - left;
        var invW = W == 0 ? 1 : 1 / W;
        var H = top - bottom;
        var invH = H == 0 ? 1 : 1 / H;
        var D = near - far;
        var invD = D == 0 ? 1 : 1 / D;
        var matrix = theThis.getMatrix();
        halfWidth = W / 2;
        halfHeight = H / 2;
        matrix.m12 = matrix.m13 = matrix.m14 = matrix.m21 = matrix.m23 = matrix.m24 = matrix.m41 = matrix.m42 = matrix.m44 = 0;
        matrix.m34 = -1;
        matrix.m11 = near2 * invW;
        matrix.m22 = near2 * invH;
        matrix.m31 = (right + left) * invW;
        matrix.m32 = (top + bottom) * invH;
        matrix.m33 = (far + near) * invD;
        matrix.m43 = (far * near2) * invD;
        return theThis;
    }
    function initialize() {
        tf.math.Matrix4.call(theThis, { noInit: true });
        if (!tf.js.GetIsValidObject(settings) || !settings.noInit) { updateFrustum(settings); }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
}
tf.js.InheritFrom(tf.math.FrustumMatrix4, tf.math.Matrix4);
tf.math.PerspectiveFOVMatrix4 = function (settings) {
    var theThis, near, far, fovy, aspect, tangent;
    this.UpdatePerspective = function (settings) { return updatePerspective(settings); }
    this.UpdateAspect = function (aspect) { return updateAspect(aspect); }
    this.GetPerspective = function () { return { fovy: fovy, aspect: aspect, tangent: tangent, frustum: theThis.GetFrustum() }; }
    function updateAspect(aspectSet) {
        aspect = tf.js.GetFloatNumberInRange(aspectSet, 0.0000001, 99999999, 1);
        tangent = Math.tan(fovy / 2);
        var top = tangent * near, bottom = -top;
        var left = aspect * bottom, right = aspect * top;
        theThis.UpdateFrustum({ left: left, right: right, top: top, bottom: bottom, near: near, far: far });
        return theThis;
    }
    function updatePerspective(settings) {
        settings = tf.js.GetValidObjectFrom(settings);
        near = tf.js.GetFloatNumberInRange(settings.near, 0.0001, 9999999, 1);
        far = tf.js.GetFloatNumberInRange(settings.far, 0.0001, 9999999, 1);
        fovy = tf.js.GetFloatNumberInRange(settings.fovy, Math.PI / 64, Math.PI * 2, Math.PI / 6);
        return updateAspect(settings.aspect);
    }
    function initialize() {
        tf.math.FrustumMatrix4.call(theThis, { noInit: true });
        updatePerspective(settings);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
}
tf.js.InheritFrom(tf.math.PerspectiveFOVMatrix4, tf.math.FrustumMatrix4);
tf.math.OrthoMatrix4 = function (settings) {
    var theThis;
    this.UpdateOrtho = function (settings) { return updateOrtho(settings); }
    function updateOrtho(settings) {
        settings = tf.js.GetValidObjectFrom(settings);
        var left = tf.js.GetFloatNumber(settings.left, -1);
        var right = tf.js.GetFloatNumber(settings.right, 1);
        var bottom = tf.js.GetFloatNumber(settings.bottom, -1);
        var top = tf.js.GetFloatNumber(settings.top, 1);
        var near = tf.js.GetFloatNumber(settings.near, 1);
        var far = tf.js.GetFloatNumber(settings.far, 1000);
        var tx = (left + right) / (left - right);
        var ty = (top + bottom) / (top - bottom);
        var tz = (far + near) / (far - near);
        var matrix = theThis.getMatrix();
        matrix.m12 = matrix.m13 = matrix.m14 = matrix.m21 = matrix.m23 = matrix.m24 = matrix.m31 = matrix.m32 = matrix.m34 = 0;
        matrix.m44 = 1;
        matrix.m11 = 2 / (left - right);
        matrix.m22 = 2 / (top - bottom);
        matrix.m33 = -2 / (far - near);
        matrix.m41 = tx;
        matrix.m42 = ty;
        matrix.m43 = tz;
    }
    function initialize() {
        tf.math.Matrix4.call(theThis, { noInit: true });
        if (!tf.js.GetIsValidObject(settings) || !settings.noInit) { updateOrtho(settings); }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
}
tf.js.InheritFrom(tf.math.OrthoMatrix4, tf.math.Matrix4);
tf.math.Plane = function (settings) {
    var theThis, normal, d;
    this.Update = function (newSettings) {
        settings = tf.js.GetValidObjectFrom(newSettings);
        normal = new tf.math.Vector3({ vector: settings.normal });
        normal.Normalize();
        d = -normal.Dot(settings.point);
    }
    this.GetDistanceTo = function (point) { return d + normal.Dot(point); }
    function initialize() {
        theThis.Update(settings);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.math.ViewFrustum = function (settings) {
    var theThis, perspective, view, pNear, pFar, pLeft, pRight, pTop, pBot, planes, eyePos, X, Y, Z,
        nearCenter, farCenter, ptTemp, ptTemp2, halfWidth, halfHeight, far, near, tangent, aspect;
    this.GetSphereIsVisible = function (center, radius) {
        var result = { isVisible: true, intersects: 0 };
        if (!isDeleted()) {
            for (var i = 0 ; i < 6 ; ++i) {
                var dist = planes[i].GetDistanceTo(center);
                if (dist < -radius) { result.isVisible = false; break; } // sphere is outside of this plane
                else if (dist < radius) { ++result.intersects; } // sphere intersect's with this plane
            }
        }
        return result;
    }
    this.GetIsPointVisible = function (point) {
        if (!isDeleted()) {
            var pcz, pcx, pcy, aux;
            ptTemp.CopyFrom(point); ptTemp.Sub(eyePos);
            pcz = -ptTemp.Dot(Z); if (pcz > far || pcz < near) { return false; }
            pcy = ptTemp.Dot(Y);
            aux = pcz * tangent;
            if (pcy > aux || pcy < -aux) { return false; }
            pcx = ptTemp.Dot(X);
            aux *= aspect;
            if (pcx > aux || pcx < -aux) { return false; }
        }
        return true;
    }
    this.GetIsPointVisibleByPlanes = function (point) {
        if (!isDeleted()) {
            for (var i = 0 ; i < 6 ; ++i) { if (planes[i].GetDistanceTo(point) < 0) { return false; } }
            //if (pTop.GetDistanceTo(point) < 0) { return false; }
            //if (pBot.GetDistanceTo(point) < 0) { return false; }
            //if (pLeft.GetDistanceTo(point) < 0) { return false; }
            //if (pRight.GetDistanceTo(point) < 0) { return false; }
            //if (pNear.GetDistanceTo(point) < 0) { return false; }
            //if (pFar.GetDistanceTo(point) < 0) { return false; }
        }
        return true;
    }
    this.OnUpdate = function () { return onUpdate(); }
    this.OnDelete = function () { return onDelete(); }
    this.IsDeleted = function () { return isDeleted(); }
    function isDeleted() { return perspective == undefined; }
    function onDelete() {
        if (!isDeleted()) {
            perspective = view = pNear = pFar = pLeft = pRight = pTop = pBot = planes = undefined;
        }
    }
    function onUpdate() {
        if (!isDeleted()) {
            var perspectiveSettings = perspective.GetPerspective();
            var frustumSettings = perspectiveSettings.frustum;
            var viewSettings = view.GetView();
            tangent = perspectiveSettings.tangent;
            aspect = perspectiveSettings.aspect;
            near = frustumSettings.near;
            far = frustumSettings.far;
            eyePos.CopyFrom(viewSettings.vFrom);
            X.CopyFrom(viewSettings.vUnitRight);
            Y.CopyFrom(viewSettings.vUnitUp);
            Z.CopyFrom(viewSettings.vUnitTo);
            halfWidth = frustumSettings.halfWidth;
            halfHeight = frustumSettings.halfHeight;
            nearCenter.CopyFrom(eyePos);
            ptTemp.CopyFrom(Z);
            ptTemp.MultByScalar(-near);
            nearCenter.Add(ptTemp);
            farCenter.CopyFrom(eyePos);
            ptTemp.CopyFrom(Z);
            ptTemp.MultByScalar(-far);
            farCenter.Add(ptTemp);
            ptTemp.CopyFrom(Z);
            pFar.Update({ normal: ptTemp, point: farCenter });
            ptTemp.MultByScalar(-1);
            pNear.Update({ normal: ptTemp, point: nearCenter });
            ptTemp.CopyFrom(Y);
            ptTemp.MultByScalar(halfHeight);
            ptTemp.Add(nearCenter);
            ptTemp2.CopyFrom(ptTemp);
            ptTemp2.Sub(eyePos);
            ptTemp2.Normalize();
            ptTemp2.Cross(X);
            pTop.Update({ normal: ptTemp2, point: ptTemp });
            ptTemp.CopyFrom(Y);
            ptTemp.MultByScalar(-halfHeight);
            ptTemp.Add(nearCenter);
            ptTemp2.CopyFrom(ptTemp);
            ptTemp2.Sub(eyePos);
            ptTemp2.Normalize();
            ptTemp2.CrossRight(X);
            pBot.Update({ normal: ptTemp2, point: ptTemp });
            ptTemp.CopyFrom(X);
            ptTemp.MultByScalar(-halfWidth);
            ptTemp.Add(nearCenter);
            ptTemp2.CopyFrom(ptTemp);
            ptTemp2.Sub(eyePos);
            ptTemp2.Normalize();
            ptTemp2.Cross(Y);
            pLeft.Update({ normal: ptTemp2, point: ptTemp });
            ptTemp.CopyFrom(X);
            ptTemp.MultByScalar(halfWidth);
            ptTemp.Add(nearCenter);
            ptTemp2.CopyFrom(ptTemp);
            ptTemp2.Sub(eyePos);
            ptTemp2.Normalize();
            ptTemp2.CrossRight(Y);
            pRight.Update({ normal: ptTemp2, point: ptTemp });
        }
    };
    function initialize() {
        if (tf.js.GetIsValidObject(settings) &&
            tf.js.GetIsInstanceOf(settings.view, tf.math.ViewMatrix4) &&
            tf.js.GetIsInstanceOf(settings.perspective, tf.math.PerspectiveFOVMatrix4)) {
            view = settings.view;
            perspective = settings.perspective;
            pNear = new tf.math.Plane();
            pFar = new tf.math.Plane();
            pLeft = new tf.math.Plane();
            pRight = new tf.math.Plane();
            pTop = new tf.math.Plane();
            pBot = new tf.math.Plane();
            planes = [pTop, pBot, pLeft, pRight, pNear, pFar];
            X = new tf.math.Vector3();
            Y = new tf.math.Vector3();
            Z = new tf.math.Vector3();
            eyePos = new tf.math.Vector3();
            ptTemp = new tf.math.Vector3();
            ptTemp2 = new tf.math.Vector3();
            nearCenter = new tf.math.Vector3();
            farCenter = new tf.math.Vector3();
            onUpdate();
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.webgl = {
};
tf.g_WebGL = null;
tf.webgl.GetWebGL = function () { if (!tf.g_WebGL) { tf.g_WebGL = new tf.webgl.WebGL(); } return tf.g_WebGL; }
tf.webgl.WebGL = function (settings) {
    var theThis, contextName, requestAnimFrame, cancelAnimFrame;
    this.RequestAnimFrame = function (callback, element) {
        return tf.js.GetFunctionOrNull(callback) ? requestAnimFrame(callback, element) : undefined;
    }
    this.CancelAnimFrame = function (requestID) { return requestID !== undefined ? cancelAnimFrame(requestID) : undefined; }
    this.GetHasWebGL = function () { return getHasWebGL(); }
    this.GetContextName = function () { return contextName; }
    function getHasWebGL() { return contextName !== undefined; }
    function getContextName() {
        var contextNames = ['experimental-webgl', 'webgl', 'webkit-3d', 'moz-webgl'];
        var canvas = document.createElement('canvas');
        for (var i in contextNames) {
            try {
                var cn = contextNames[i], context = canvas.getContext(cn);
                if (!!context && tf.js.GetFunctionOrNull(context.getParameter)) {
                    contextName = cn;
                    break;
                }
            }
            catch (e) { }
        }
    }
    function initialize() {
        requestAnimFrame = window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                function (/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {
                    return window.setTimeout(callback, 1000 / 60);
                };
        cancelAnimFrame = window.cancelAnimationFrame ||
                window.webkitCancelAnimationFrame ||
                window.mozCancelAnimationFrame ||
                window.oCancelAnimationFrame ||
                window.msCancelAnimationFrame ||
                window.clearTimeout;
        if (window.WebGLRenderingContext) {
            getContextName();
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.webgl.Context = function (settings) {
    var theThis, webgl, context, canvas, lostListener, restoredListener, lastRequestID, frameCallBack, lostCallBack, restoredCallBack;
    var shaderSettings, textureColorFS, textureColorVS, textureColorProgram,
        textureColorPickFS, textureColorPickVS, textureColorPickProgram, materialFS, materialVS, materialProgram, WEBGL_lose_context;
    var fourColorTexture, isContextLost;
    var shaders, programs;
    var texture2sCollection, buffersCollection, frameBuffersCollection, pickCollection;
    var onePixelTransparentCanvas, onePixelTransparentTexture;
    this.RegisterTexture2 = function (texture2) { return texture2sCollection.Add(texture2); }
    this.UnRegisterTexture2 = function (textureId) { return texture2sCollection.Del(textureId); }
    this.RegisterBuffer = function (buffer) { return buffersCollection.Add(buffer); }
    this.UnRegisterBuffer = function (bufferId) { return buffersCollection.Del(bufferId); }
    this.RegisterFrameBuffer = function (frameBuffer) { return frameBuffersCollection.Add(frameBuffer); }
    this.UnRegisterFrameBuffer = function (frameBufferId) { return frameBuffersCollection.Del(frameBufferId); }
    this.RegisterForPick = function (object) { return pickCollection.Add(object); }
    this.UnRegisterForPick = function (objectId) {
        return pickCollection.Del(objectId);
    }
    this.GetPickObject = function (objectId) { return pickCollection.Get(objectId); }
    this.IsContextLost = function () { return isContextLost; }
    this.LoseContext = function () { return loseContext(); }
    this.RestoreContext = function () { return restoreContext(); }
    this.IsDeleted = function () { return isDeleted(); }
    this.OnDelete = function () { return onDelete(); }
    this.GetOnePixelTransparentCanvas = function () { return getOnePixelTransparentCanvas(); }
    this.GetOnePixelTransparentTexture = function () { return getOnePixelTransparentTexture(); }
    this.GetFourColorTexture = function () {
        if (!fourColorTexture) { fourColorTexture = createFourColorTexture(); }
        return fourColorTexture;
    }
    this.GetMaterialFS = function () {
        if (!materialFS) { materialFS = createShaderObject(tf.webgl.MaterialFS); }
        return materialFS;
    }
    this.GetMaterialVS = function () {
        if (!materialVS) { materialVS = createShaderObject(tf.webgl.MaterialVS); }
        return materialVS;
    }
    this.GetMaterialProgram = function () {
        if (!materialProgram) { materialProgram = createShaderProgram(tf.webgl.MaterialProgram); }
        return materialProgram;
    }
    this.GetTextureColorFS = function () {
        if (!textureColorFS) { textureColorFS = createShaderObject(tf.webgl.TextureColorFS); }
        return textureColorFS;
    }
    this.GetTextureColorVS = function () {
        if (!textureColorVS) { textureColorVS = createShaderObject(tf.webgl.TextureColorVS); }
        return textureColorVS;
    }
    this.GetTextureColorProgram = function () {
        if (!textureColorProgram) { textureColorProgram = createShaderProgram(tf.webgl.TextureColorProgram); }
        return textureColorProgram;
    }
    this.GetTextureColorPickFS = function () {
        if (!textureColorPickFS) { textureColorPickFS = createShaderObject(tf.webgl.TextureColorPickFS); }
        return textureColorPickFS;
    }
    this.GetTextureColorPickVS = function () {
        if (!textureColorPickVS) { textureColorPickVS = createShaderObject(tf.webgl.TextureColorPickVS); }
        return textureColorPickVS;
    }
    this.GetTextureColorPickProgram = function () {
        if (!textureColorPickProgram) { textureColorPickProgram = createShaderProgram(tf.webgl.TextureColorPickProgram); }
        return textureColorPickProgram;
    }
    this.GetContext = function () { return context; }
    this.GetCanvas = function () { return canvas; }
    this.RequestAnimFrame = function () { return requestAnimFrame(); }
    this.CancelAnimFrame = function () { return cancelAnimFrame(); }
    function isDeleted() { return context == undefined; }
    function onDelete() {
        if (!isDeleted()) {
            if (!!lostListener) { lostListener.OnDelete(); }
            if (!!restoredListener) { restoredListener.OnDelete(); }
            if (!!programs) { for (var i in programs) { programs[i].OnDelete(); } }
            if (!!onePixelTransparentTexture) { onePixelTransparentTexture.OnDelete(); }
            if (!!fourColorTexture) { fourColorTexture.OnDelete(); }
            if (!!pickCollection) { pickCollection.Empty(); }
            if (!!texture2sCollection) { texture2sCollection.Empty(); }
            if (!!buffersCollection) { buffersCollection.Empty(); }
            if (!!frameBuffersCollection) { frameBuffersCollection.Empty(); }
            pickCollection = texture2sCollection = buffersCollection = frameBuffersCollection =
                fourColorTexture = onePixelTransparentTexture = programs = lostListener = restoredListener = context = undefined;
        }
    }
    function createShaderObject(type, isProgram) {
        var shaderObject = isDeleted() ? undefined : new type(shaderSettings);
        if (shaderObject !== undefined && !isProgram) { shaders.push(shaderObject); }
        return shaderObject;
    }
    function createShaderProgram(type) {
        var shaderProgram = createShaderObject(type, true);
        if (!!shaderProgram) { programs.push(shaderProgram); }
        return shaderProgram;
    }
    function loseContext() { if (!isDeleted()) { if (!!WEBGL_lose_context) { WEBGL_lose_context.loseContext(); } } }
    function restoreContext() { if (!isDeleted()) { if (!!WEBGL_lose_context) { WEBGL_lose_context.restoreContext(); } } }
    function getOnePixelTransparentCanvas() {
        if (!isDeleted()) {
            if (!onePixelTransparentCanvas) {
                onePixelTransparentCanvas = document.createElement('canvas');
                onePixelTransparentCanvas.width = onePixelTransparentCanvas.height = 1;
                var ctx = onePixelTransparentCanvas.getContext('2d');
                ctx.beginPath(); ctx.clearRect(-1, -1, 2, 2); ctx.closePath();
            }
        }
        return onePixelTransparentCanvas;
    }
    function getOnePixelTransparentTexture() {
        if (!isDeleted()) {
            if (!onePixelTransparentTexture) {
                onePixelTransparentTexture = new tf.webgl.Texture2({ context: theThis, img: getOnePixelTransparentCanvas(), flipVerticalBool: false });
            }
        }
        return onePixelTransparentTexture;
    }
    function createFourColorTexture() {
        var texture;
        if (!isDeleted()) {
            var canvas = document.createElement('canvas');
            var ctx = canvas.getContext('2d');
            canvas.width = canvas.height = 2;
            ctx.beginPath();
            ctx.fillStyle = "#f00"; ctx.fillRect(0, 0, 1, 1);
            ctx.fillStyle = "#0f0"; ctx.fillRect(1, 0, 1, 1);
            ctx.fillStyle = "#00f"; ctx.fillRect(0, 1, 1, 1);
            ctx.fillStyle = "#ff0"; ctx.fillRect(1, 1, 1, 1);
            //ctx.strokeStyle = "#000"; ctx.strokeRect(0, 0, 1, 1);
            ctx.closePath();
            texture = new tf.webgl.Texture2({ context: theThis, img: canvas, flipVerticalBool: true });
        }
        return texture;
    }
    function requestAnimFrame() {
        if (!isDeleted()) {
            cancelAnimFrame(); lastRequestID = !!webgl ? webgl.RequestAnimFrame(frameCallBack, canvas) : undefined;
        }
    }
    function cancelAnimFrame() {
        if (!isDeleted) {
            if (!!webgl && lastRequestID !== undefined) { webgl.CancelAnimFrame(lastRequestID); lastRequestID = undefined; }
        }
    }
    function onContextLost(e) {
        e.preventDefault();
        isContextLost = true;
        cancelAnimFrame();
        var onLostDevice = function (obj) { obj.OnLostDevice(); }
        frameBuffersCollection.ForEach(onLostDevice);
        buffersCollection.ForEach(onLostDevice);
        texture2sCollection.ForEach(onLostDevice);
        for (var i in shaders) { shaders[i].OnLostDevice(); }
        for (var i in programs) { programs[i].OnLostDevice(); }
        if (!!lostCallBack) { lostCallBack({ sender: theThis }); }
    }
    function onContextRestored() {
        isContextLost = false;
        initContext();
        var onRestoredDevice = function (obj) { obj.OnRestoredDevice(); }
        frameBuffersCollection.ForEach(onRestoredDevice);
        buffersCollection.ForEach(onRestoredDevice);
        texture2sCollection.ForEach(onRestoredDevice);
        for (var i in shaders) { shaders[i].OnRestoredDevice(); }
        for (var i in programs) { programs[i].OnRestoredDevice(); }
        if (!!restoredCallBack) { restoredCallBack({ sender: theThis }); }
    }
    function initContext() {
        context = canvas.getContext(webgl.GetContextName(), settings.optionalAttributes);
        isContextLost = context.isContextLost();
        WEBGL_lose_context = context.getExtension('WEBGL_lose_context');
        context.getExtension("OES_element_index_uint");
        context.getExtension('OES_standard_derivatives');
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (webgl = tf.webgl.GetWebGL()) {
            if (webgl.GetHasWebGL()) {
                shaders = [];
                programs = [];
                pickCollection = new tf.js.Collection();
                texture2sCollection = new tf.js.Collection({ type: tf.webgl.Texture2 });
                buffersCollection = new tf.js.Collection({ type: tf.webgl.ArrayBuffer });
                frameBuffersCollection = new tf.js.Collection({ type: tf.webgl.FrameBuffer });
                shaderSettings = { context: theThis, debug: true };
                frameCallBack = tf.js.GetFunctionOrNull(settings.onFrame);
                lostCallBack = tf.js.GetFunctionOrNull(settings.onLost);
                restoredCallBack = tf.js.GetFunctionOrNull(settings.onRestored);
                canvas = document.createElement('canvas');
                lostListener = new tf.events.AddDOMEventListener(canvas, 'webglcontextlost', onContextLost);
                restoredListener = new tf.events.AddDOMEventListener(canvas, 'webglcontextrestored', onContextRestored);
                initContext();
            }
            else { webgl = undefined; }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.webgl.Material = function (settings) {
    var theThis;
    this.GetSettings = function () { return settings; }
    this.SetUniforms = function (ctx, uniformLocations) { return setUniforms(ctx, uniformLocations); }
    function setColor(ctx, colorLoc, color) {
        if (!!colorLoc) { ctx.uniform3f(colorLoc, color[0], color[1], color[2]); }
    }
    function setUniforms(ctx, uniformLocations) {
        if (tf.js.GetIsValidObject(uniformLocations) && !!ctx) {
            if (!!uniformLocations.opacityShininessLoc) {
                ctx.uniform4f(uniformLocations.opacityShininessLoc, settings.opacityF, settings.shininessF, 0, 0);
            }
            setColor(ctx, uniformLocations.ambientColor3Loc, settings.ambientColor3);
            setColor(ctx, uniformLocations.diffuseColor3Loc, settings.diffuseColor3);
            setColor(ctx, uniformLocations.emissiveColor3Loc, settings.emissiveColor3);
            setColor(ctx, uniformLocations.specularColor3Loc, settings.specularColor3);
        }
    }
    function getColor(fromColor, defaultColor) {
        var theColor;
        if (fromColor !== undefined) {
            if (tf.js.GetIsArrayWithMinLength(fromColor, 3)) {
                if (tf.js.GetFunctionOrNull(fromColor.slice)) { theColor = fromColor.slice(0); }
                else { theColor = [fromColor[0], fromColor[1], fromColor[2]]; }
            }
            else if (tf.js.GetIsValidObject(fromColor)) {
                fromColor[0] = tf.js.GetFloatNumberInRange(fromColor.r, 0, 1, defaultColor[0]);
                fromColor[1] = tf.js.GetFloatNumberInRange(fromColor.r, 0, 1, defaultColor[1]);
                fromColor[2] = tf.js.GetFloatNumberInRange(fromColor.r, 0, 1, defaultColor[2]);
            }
        }
        else { theColor = defaultColor; }
        return theColor;
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        settings.name = tf.js.GetNonEmptyString(settings.name, "unnamed");
        settings.opacityF = tf.js.GetFloatNumberInRange(settings.opacity, 0, 1, 1);
        settings.shininessF = tf.js.GetFloatNumberInRange(settings.shininess, 0, 1, 1);
        settings.ambientColor3 = getColor(settings.ambient, [1, 1, 1]);
        settings.diffuseColor3 = getColor(settings.diffuse, [0, 0, 0]);
        settings.emissiveColor3 = getColor(settings.emissive, [0, 0, 0]);
        settings.specularColor3 = getColor(settings.specular, [1, 1, 1]);
        settings.texFile = tf.js.GetNonEmptyString(settings.texFile);
        delete settings.opacity;
        delete settings.shininess;
        delete settings.ambient;
        delete settings.diffuse;
        delete settings.emissive;
        delete settings.specular;
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.webgl.ArrayBuffer = function (settings) {
    var theThis, context, buffer, data, length, bufferType, isIndices, count, glSize, glType, normalized, stride, offset, contextId;
    this.OnLostDevice = function () { return onLostDevice(); }
    this.OnRestoredDevice = function () { return onRestoredDevice(); }
    this.GetContext = function () { return context; }
    this.GetCtx = function () { return context ? context.GetContext() : undefined ; }
    this.GetLength = function () { return length; }
    this.GetCount = function () { return count; }
    this.GetType = function () { return bufferType; }
    this.IsIndices = function () { return isIndices; }
    this.GetBuffer = function () { return buffer; }
    this.Bind = function (toLocation) { return bind(toLocation); }
    this.Update = function (data) { return update(data); }
    this.GetData = function () { return data; }
    this.OnDelete = function () { return onDelete(); }
    this.IsDeleted = function () { return isDeleted(); }
    function isOperational() { return !isDeleted() && buffer !== undefined; }
    function isDeleted() { return context == undefined; }
    function onDelete() {
        if (!isDeleted()) {
            context.UnRegisterBuffer(contextId);
            contextId = bufferType = context = buffer = undefined;
            count = length = 0;
            isIndices = false;
        }
    }
    function deleteBuffer() {
        if (!isDeleted()) {
            if (buffer != undefined) { var ctx = context.GetContext(); if (!!ctx) { ctx.deleteBuffer(buffer); buffer = undefined; } }
        }
    }
    function onLostDevice() { deleteBuffer(); }
    function onRestoredDevice() {
        if (!isDeleted()) {
            var ctx = context.GetContext();
            buffer = ctx.createBuffer();
            update(settings.data);
        }
    }
    function bind(toLocation) {
        if (isOperational()) {
            var ctx = context.GetContext();
            if (isIndices) {
                ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, buffer);
            }
            else if (toLocation >= 0) {
                ctx.enableVertexAttribArray(toLocation);
                ctx.bindBuffer(ctx.ARRAY_BUFFER, buffer);
                ctx.vertexAttribPointer(toLocation, glSize, glType, normalized, stride, offset);
            }
        }
    }
    function update(data) {
        if (isOperational()) {
            var ctx = context.GetContext();
            var dataType = isIndices ? ctx.STREAM_DRAW : ctx.STATIC_DRAW;
            ctx.bindBuffer(bufferType, buffer);
            ctx.bufferData(bufferType, data, dataType);
            ctx.bindBuffer(bufferType, null);
        }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        length = 0;
        if (tf.js.GetIsNonEmptyArray(settings.data)) {
            if (tf.js.GetIsInstanceOf(settings.context, tf.webgl.Context) && !!settings.context.GetContext()) {
                context = settings.context;
                data = settings.data;
                length = data.length;
                isIndices = !!settings.isIndices;
                glSize = settings.glSize !== undefined ? tf.js.GetIntNumberInRange(settings.glSize, 1, 999999999, 1) : 1;
                normalized = settings.normalized !== undefined ? !!settings.normalized : false;
                stride = settings.stride !== undefined ? tf.js.GetIntNumberInRange(settings.stride, 0, 999999999, 0) : 0;
                offset = settings.offset !== undefined ? tf.js.GetIntNumberInRange(settings.offset, 0, 999999999, 0) : 0;
                var ctx = context.GetContext();
                bufferType = isIndices ? ctx.ELEMENT_ARRAY_BUFFER : ctx.ARRAY_BUFFER;
                if (!isIndices) {
                    glType = settings.glType !== undefined ? settings.glType : ctx.FLOAT;
                    count = Math.floor(length / glSize);
                }
                else { count = length; }
                contextId = context.RegisterBuffer(theThis);
                onRestoredDevice();
            }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.webgl.PosBuffer = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsNonEmptyArray(settings.data)) {
            settings.glSize = 3;
            if (settings.data.length % settings.glSize != 0) { tf.GetDebug().LogIfTest("tf.webgl.PosBuffer: Data length not multiple of " + settings.glSize); }
            settings.isIndices = false;
            tf.webgl.ArrayBuffer.call(theThis, settings);
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.PosBuffer, tf.webgl.ArrayBuffer);
tf.webgl.NorBuffer = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsNonEmptyArray(settings.data)) {
            settings.glSize = 3;
            if (settings.data.length % settings.glSize != 0) { tf.GetDebug().LogIfTest("tf.webgl.NorBuffer: Data length not multiple of " + settings.glSize); }
            settings.isIndices = false;
            tf.webgl.ArrayBuffer.call(theThis, settings);
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.NorBuffer, tf.webgl.ArrayBuffer);
tf.webgl.Tex2DBuffer = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsNonEmptyArray(settings.data)) {
            settings.glSize = 2;
            if (settings.data.length % settings.glSize != 0) {
                tf.GetDebug().LogIfTest("tf.webgl.Tex2DBuffer: Data length not multiple of " + settings.glSize);
            }
            settings.isIndices = false;
            tf.webgl.ArrayBuffer.call(theThis, settings);
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.Tex2DBuffer, tf.webgl.ArrayBuffer);
tf.webgl.IndexBuffer = function (settings) {
    var theThis, indexType;
    this.Draw = function (useLines) {
        if (!theThis.IsDeleted()) {
            var ctx = theThis.GetCtx();
            if (!!ctx) {
                ctx.drawElements((!!useLines ? ctx.LINES : ctx.TRIANGLES), theThis.GetLength(), indexType, 0);
                //ctx.drawElements(ctx.LINES, theThis.GetLength(), indexType, 0);
            }
        }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsNonEmptyArray(settings.data)) {
            settings.isIndices = true;
            tf.webgl.ArrayBuffer.call(theThis, settings);
            if (!theThis.IsDeleted()) {
                var ctx = theThis.GetCtx();
                if (!!settings.is8) { indexType = ctx.UNSIGNED_BYTE; }
                else if (!!settings.is16) { indexType = ctx.UNSIGNED_SHORT; }
                else if (!!settings.is32) { indexType = ctx.UNSIGNED_INT; }
                else { indexType = ctx.UNSIGNED_BYTE; }
            }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.IndexBuffer, tf.webgl.ArrayBuffer);
tf.webgl.MergeBuffers = function (vertexBuffers) {
    var mergedBuffer;
    //return;
    function addBuffers(newPos, newNor, newTex2, newIndices, v, posIndex, indexIndex) {
        var pos = v.GetPos(), ind = v.GetIndices();
        var nor = v.GetNor(), tex2 = v.GetTex2D();
        var nVertices = pos.GetLength(), nIndices = ind.GetLength();
        var posData = pos.GetData(), indexData = ind.GetData();
        var norData = !!nor ? nor.GetData() : undefined;
        for (var j = 0 ; j < nVertices ; ++j) {
            var destIndex = posIndex + j;
            newPos[destIndex] = posData[j];
            if (!!norData) { newNor[destIndex] = norData[j]; } else { newNor[destIndex] = 1; }
        }
        if (newTex2) {
            var nTex2 = Math.floor(nVertices * 2 / 3);
            var tex2Data = !!tex2 ? tex2.GetData() : undefined;
            for (var j = 0 ; j < nTex2 ; ++j) {
                var destIndex = posIndex + j;
                if (!!tex2Data) { newTex2[destIndex] = tex2Data[j]; } else { newTex2[destIndex] = 0; }
            }
        }
        var offIndex = posIndex / 3;
        for (var j = 0 ; j < nIndices ; ++j) {
            newIndices[indexIndex + j] = indexData[j] + offIndex;
        }
    }
    function addBuffer(v, actualBuffers, desiredContext) {
        var nVertices = 0, nIndices = 0, context = undefined;
        if (tf.js.GetIsInstanceOf(v, tf.webgl.VertexBuffer) && !v.IsDeleted()) {
            var pos = v.GetPos(), ind = v.GetIndices();
            if (!!pos && !!ind) {
                var thisContext = v.GetContext();
                var sameContext = desiredContext == undefined || desiredContext == thisContext;
                if (sameContext) {
                    context = thisContext;
                    nVertices = pos.GetLength(); nIndices = ind.GetLength(); actualBuffers.push(v);
                    if (!hasNor) { hasNor = !!v.GetNor(); }
                    if (!hasTex2) { hasTex2 = !!v.GetTex2D(); }
                }
            }
        }
        return { nVertices: nVertices, nIndices: nIndices, context: context };
    }
    if (tf.js.GetIsValidObject(vertexBuffers)) {
        var totalVertices = 0, totalIndices = 0, hasNor, hasTex2;
        var context;
        var actualBuffers = [];
        for (var i in vertexBuffers) {
            var addResult = addBuffer(vertexBuffers[i], actualBuffers, context);
            if (addResult.nVertices > 0) {
                totalVertices += addResult.nVertices;
                totalIndices += addResult.nIndices;
                context = addResult.context;
            }
        }
        if (!!actualBuffers.length) {
            var newPos = new Float32Array(totalVertices);
            var vertexCount = totalVertices / 3;
            var is8 = vertexCount < 256, is16 = vertexCount < 256 * 256, is32 = !is16;
            var newIndices = is8 ? new Uint8Array(totalIndices) : (is16 ? new Uint16Array(totalIndices) : new Uint32Array(totalIndices));
            var newNor = hasNor ? new Float32Array(totalVertices) : undefined;
            var newTex2 = hasTex2 ? new Float32Array(Math.floor(totalVertices * 2 / 3)) : undefined;
            var posIndex = 0, indexIndex = 0;
            for (var i in actualBuffers) {
                var v = actualBuffers[i];
                addBuffers(newPos, newNor, newTex2, newIndices, v, posIndex, indexIndex);
                posIndex += v.GetPos().GetLength();
                indexIndex += v.GetIndices().GetLength();
            }
            var newPosBuffer = new tf.webgl.PosBuffer({ context: context, data: newPos });
            var newIndexBuffer = new tf.webgl.IndexBuffer({ context: context, data: newIndices, is8: is8, is16: is16, is32: is32 });
            var newNorBuffer = !!newNor ? new tf.webgl.NorBuffer({ context: context, data: newNor }) : undefined;
            var newTex2Buffer = !!newTex2 ? new tf.webgl.Tex2DBuffer({ context: context, data: newTex2 }) : undefined;
            var foundLast;
            for (var i in newIndices) {
                var index = newIndices[i];
                if (index < 0 || index >= vertexCount) {
                    console.log('invalid index');
                }
                if (index == vertexCount - 1) {
                    foundLast = true;
                }
            }
            if (!foundLast) {
                console.log('no last index');
            }
            mergedBuffer = new tf.webgl.VertexBuffer({
                cullFrontFace: false,
                context: context, pos: newPosBuffer, nor: newNorBuffer, tex2d: newTex2Buffer, indices: newIndexBuffer
            });
        }
    }
    return mergedBuffer;
} 
tf.webgl.VertexBuffer = function (settings) {
    var theThis, context, ctx, pos, nor, tex2d, indices;
    this.OnLostDevice = function () {
        if (!isDeleted()) {
            if (!!pos) { pos.OnLostDevice(); }
            if (!!nor) { nor.OnLostDevice(); }
            if (!!tex2d) { tex2d.OnLostDevice(); }
            if (!!indices) { indices.OnLostDevice(); }
            ctx = undefined;
        }
    }
    this.OnRestoredDevice = function () {
        if (!isDeleted()) {
            if (!!pos) { pos.OnRestoredDevice(); }
            if (!!nor) { nor.OnRestoredDevice(); }
            if (!!tex2d) { tex2d.OnRestoredDevice(); }
            if (!!indices) { indices.OnRestoredDevice(); }
            ctx = context.GetContext();
        }
    }
    this.GetContext = function () { return context; }
    this.GetPos = function () { return pos; }
    this.GetNor = function () { return nor; }
    this.GetTex2D = function () { return tex2d; }
    this.GetIndices = function () { return indices; }
    this.BindBuffers = function (posLoc, norLoc, tex2dLoc) { return bindBuffers(posLoc, norLoc, tex2dLoc); }
    this.Draw = function (useLines) { return draw(useLines); }
    this.OnDelete = function (deleteSubBuffers) { return onDelete(deleteSubBuffers); }
    this.IsDeleted = function () { return isDeleted(); }
    function bindBuffers(posLoc, norLoc, tex2dLoc) {
        if (isOperational()) {
            if (posLoc >= 0) { if (!!pos) { pos.Bind(posLoc); } else { ctx.disableVertexAttribArray(posLoc); } }
            if (norLoc >= 0) { if (!!nor) { nor.Bind(norLoc); } else { ctx.disableVertexAttribArray(norLoc); } }
            if (tex2dLoc >= 0) {
                if (!!tex2d) { tex2d.Bind(tex2dLoc); } else {
                    ctx.disableVertexAttribArray(tex2dLoc);
                }
            }
            if (!!indices) { indices.Bind(); }
        }
    }
    function draw(useLines) { if (!isDeleted()) { indices.Draw(useLines); } }
    function isOperational() { return ctx != undefined; }
    function isDeleted() { return context == undefined; }
    function onDelete(deleteSubBuffers) {
        if (!isDeleted()) {
            if (!!deleteSubBuffers) {
                if (!!pos) { pos.OnDelete(); }
                if (!!nor) { nor.OnDelete(); }
                if (!!tex2d) { tex2d.OnDelete(); }
                if (!!indices) { indices.OnDelete(); }
            }
            pos = nor = tex2d = indices = ctx = context = undefined;
        }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsInstanceOf(settings.context, tf.webgl.Context) && !!settings.context.GetContext() &&
            (settings.pos == undefined || tf.js.GetIsInstanceOf(settings.pos, tf.webgl.PosBuffer)) &&
            (settings.nor == undefined || tf.js.GetIsInstanceOf(settings.nor, tf.webgl.NorBuffer)) &&
            (settings.tex2d == undefined || tf.js.GetIsInstanceOf(settings.tex2d, tf.webgl.Tex2DBuffer)) &&
            (settings.indices == undefined || tf.js.GetIsInstanceOf(settings.indices, tf.webgl.IndexBuffer))) {
            context = settings.context;
            ctx = context.GetContext();
            pos = settings.pos;
            nor = settings.nor;
            tex2d = settings.tex2d;
            if (!!pos) {
                var nPos = pos.GetLength();
                if (!!nor) { if (nor.GetLength() != nPos) { tf.GetDebug().LogIfTest('inconsistent number of pos / nor'); } }
                if (!!tex2d) { if (tex2d.GetLength() * 3 / 2 != nPos) { tf.GetDebug().LogIfTest('inconsistent number of pos / tex2d'); } }
            }
            indices = settings.indices;
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.webgl.MatTex2VertCombo = function (settings) {
    var theThis, material, texture2, normalsTexture2, vertices;
    //this.GetHasTexture2 = function () { return texture2 != undefined; }
    //this.SetTexture2 = function (texture2Set) { texture2 = texture2Set; }
    //this.SetTexture2 = function (texture2Set) { texture2 = texture2Set; }
    this.Render = function (ctx, posLoc, norLoc, tex2dLoc, renderSettings, uniformLocations) {
        if (!isDeleted()) {
            if (!!material) { material.SetUniforms(ctx, uniformLocations); }
            var hasTexture = !!texture2 ? 1 : 0, hasNormalTexture = !!normalsTexture2 ? 1 : 0;
            if (hasTexture) { texture2.Bind(); }
            if (hasNormalTexture) { normalsTexture2.Bind(); }
            if (!!uniformLocations.hasTextureLoc) { ctx.uniform1i(uniformLocations.hasTextureLoc, hasTexture); }
            if (!!uniformLocations.hasNormalTextureLoc) { ctx.uniform1i(uniformLocations.hasNormalTextureLoc, hasNormalTexture); }
            for (var i in vertices) {
                var vertex = vertices[i];
                vertex.BindBuffers(posLoc, norLoc, tex2dLoc);
                vertex.Draw(renderSettings.useLines);
            }
        }
    }
    this.GetVertCount = function () { return isDeleted() ? 0 : vertices.length; }
    this.MergeBuffers = function () {
        if (!isDeleted()) {
            if (vertices.length > 1) {
                var newVertices = tf.webgl.MergeBuffers(vertices);
                if (!!newVertices) {
                    deleteAllVertices();
                    vertices = [newVertices];
                }
            }
        }
    }
    this.AddVertexBuffer = function (vertexBuffer) { return addVertexBuffer(vertexBuffer); }
    this.OnDelete = function (deleteTexture, deleteVertices) { return onDelete(deleteTexture, deleteVertices); }
    this.IsDeleted = function () { return isDeleted(); }
    function isDeleted() { return vertices == undefined; }
    function deleteAllVertices() { if (!isDeleted) { for (var i in vertices) { vertices[i].OnDelete(); } vertices = []; } }
    function onDelete(deleteTexture, deleteVertices) {
        if (!isDeleted()) {
            if (!!deleteTexture) {
                if (!!texture2) { texture2.OnDelete(); }
                if (!!normalsTexture2) { normalsTexture2.OnDelete(); }
            }
            if (!!deleteVertices) { deleteAllVertices(); }
            material = texture2 = normalsTexture2 = vertices = undefined;
        }
    }
    function addVertexBuffer(vertexBuffer) {
        if (!isDeleted()) {
            if (tf.js.GetIsInstanceOf(vertexBuffer, tf.webgl.VertexBuffer)) { vertices.push(vertexBuffer); }
            else if (tf.js.GetIsNonEmptyArray(vertexBuffer)) { for (var i in vertexBuffer) { addVertexBuffer(vertexBuffer[i]); } }
        }
    }
    function initialize() {
        if (tf.js.GetIsValidObject(settings)) {
            if (tf.js.GetIsInstanceOf(settings.material, tf.webgl.Material)) { material = settings.material; }
            if (tf.js.GetIsInstanceOf(settings.texture2, tf.webgl.Texture2)) { texture2 = settings.texture2; }
            if (tf.js.GetIsInstanceOf(settings.normalsTexture2, tf.webgl.Texture2)) { normalsTexture2 = settings.normalsTexture2; }
            vertices = [];
            addVertexBuffer(settings.vertices);
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.webgl.MatTex2VertComboList = function (settings) {
    var theThis, list;
    this.Render = function (ctx, posLoc, norLoc, tex2dLoc, renderSettings, uniformLocations) {
        if (!isDeleted()) {
            for (var i in list) {
                list[i].Render(ctx, posLoc, norLoc, tex2dLoc, renderSettings, uniformLocations);
            }
        }
    }
    this.Add = function (matTex2VertCombo) { return add(matTex2VertCombo); }
    this.GetCount = function () { return isDeleted() ? 0 : list.length; }
    this.MergeBuffers = function () { return mergeBuffers(); }
    this.OnDelete = function (deleteItems, deleteTextures, deleteVertices) { return onDelete(deleteItems, deleteTextures, deleteVertices); }
    this.IsDeleted = function () { return isDeleted(); }
    function isDeleted() { return list == undefined; }
    function onDelete(deleteItems, deleteTextures, deleteVertices) {
        if (!isDeleted()) {
            if (!!deleteItems) { for (var i in list) { list[i].OnDelete(deleteTextures, deleteVertices); } }
            list = undefined;
        }
    }
    function add(matTex2VertCombo) {
        if (!isDeleted()) {
            if (tf.js.GetIsInstanceOf(matTex2VertCombo, tf.webgl.MatTex2VertCombo)) { list.push(matTex2VertCombo); }
            else if (tf.js.GetIsNonEmptyArray(matTex2VertCombo)) { for (var i in matTex2VertCombo) { add(matTex2VertCombo[i]); } }
        }
    }
    function mergeBuffers() {
        if (!isDeleted()) {
            var nList = list.length;
            for (var i = 0 ; i < nList ; ++i) {
                list[i].MergeBuffers();
            }
        }
    }
    function initialize() {
        list = [];
        if (tf.js.GetIsValidObject(settings)) {
            add(settings.combos);
            if (!!settings.mergeBuffers) { mergeBuffers(); }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
// quadXY
//  v1------v0
//  |       |
//  |       |
//  v2------v3
tf.webgl.QuadXY = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        var z = 0;
        var vertices = new Float32Array([0.5, 0.5, z, -0.5, 0.5, z, -0.5, -0.5, z, 0.5, -0.5, z]);
        var normals = new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);
        var texCoords = new Float32Array([1, 1, 0, 1, 0, 0, 1, 0]);
        var indices = new Uint8Array([0, 1, 2, 0, 2, 3]);
        tf.webgl.VertexBuffer.call(theThis, {
            context: settings.context,
            pos: new tf.webgl.PosBuffer({ context: settings.context, data: vertices }),
            nor: new tf.webgl.NorBuffer({ context: settings.context, data: normals }),
            tex2d: new tf.webgl.Tex2DBuffer({ context: settings.context, data: texCoords }),
            indices: new tf.webgl.IndexBuffer({ context: settings.context, data: indices, is8: true })
        });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.QuadXY, tf.webgl.VertexBuffer);
// box
//    v6----- v5
//   /|      /|
//  v1------v0|
//  | |     | |
//  | |v7---|-|v4
//  |/      |/
//  v2------v3
tf.webgl.Box = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        var dim = 0.5;
        var vertices = new Float32Array(
            [dim, dim, dim, -dim, dim, dim, -dim, -dim, dim, dim, -dim, dim,    // v0-vdim-v2-v3 front
                dim, dim, dim, dim, -dim, dim, dim, -dim, -dim, dim, dim, -dim,    // v0-v3-v4-v5 right
                dim, dim, dim, dim, dim, -dim, -dim, dim, -dim, -dim, dim, dim,    // v0-v5-v6-vdim top
                -dim, dim, dim, -dim, dim, -dim, -dim, -dim, -dim, -dim, -dim, dim,    // vdim-v6-v7-v2 left
                -dim, -dim, -dim, dim, -dim, -dim, dim, -dim, dim, -dim, -dim, dim,    // v7-v4-v3-v2 bottom
                dim, -dim, -dim, -dim, -dim, -dim, -dim, dim, -dim, dim, dim, -dim]   // v4-v7-v6-v5 back
        );
        var normals = new Float32Array(
            [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,     // v0-v1-v2-v3 front
                1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,     // v0-v3-v4-v5 right
                0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,     // v0-v5-v6-v1 top
                -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0,     // v1-v6-v7-v2 left
                0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0,     // v7-v4-v3-v2 bottom
                0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1]    // v4-v7-v6-v5 back
            );
        var texCoords = new Float32Array(
            [1, 1, 0, 1, 0, 0, 1, 0,    // v0-v1-v2-v3 front
                0, 1, 0, 0, 1, 0, 1, 1,    // v0-v3-v4-v5 right
                1, 0, 1, 1, 0, 1, 0, 0,    // v0-v5-v6-v1 top
                1, 1, 0, 1, 0, 0, 1, 0,    // v1-v6-v7-v2 left
                0, 0, 1, 0, 1, 1, 0, 1,    // v7-v4-v3-v2 bottom
                0, 0, 1, 0, 1, 1, 0, 1]   // v4-v7-v6-v5 back
            );
        var indices = new Uint8Array(
            [0, 1, 2, 0, 2, 3,    // front
                4, 5, 6, 4, 6, 7,    // right
                8, 9, 10, 8, 10, 11,    // top
                12, 13, 14, 12, 14, 15,    // left
                16, 17, 18, 16, 18, 19,    // bottom
                20, 21, 22, 20, 22, 23]   // back
            );
        tf.webgl.VertexBuffer.call(theThis, {
            context: settings.context,
            pos: new tf.webgl.PosBuffer({ context: settings.context, data: vertices }),
            nor: new tf.webgl.NorBuffer({ context: settings.context, data: normals }),
            tex2d: new tf.webgl.Tex2DBuffer({ context: settings.context, data: texCoords }),
            indices: new tf.webgl.IndexBuffer({ context: settings.context, data: indices, is8: true })
        });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.Box, tf.webgl.VertexBuffer);
tf.webgl.Sphere = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        var radius, lats, longs;
        radius = tf.js.GetFloatNumberInRange(settings.radius, 0.00001, 9999999, 0.5);
        lats = tf.js.GetIntNumberInRange(settings.nVer, 3, 100, 10);
        longs = tf.js.GetIntNumberInRange(settings.nHor, 3, 100, 10);
        var geometryData = [];
        var normalData = [];
        var texCoordData = [];
        var indexData = [];
        for (var latNumber = 0; latNumber <= lats; ++latNumber) {
            for (var longNumber = 0; longNumber <= longs; ++longNumber) {
                var theta = latNumber * Math.PI / lats;
                var phi = longNumber * 2 * Math.PI / longs;
                var sinTheta = Math.sin(theta);
                var sinPhi = Math.sin(phi);
                var cosTheta = Math.cos(theta);
                var cosPhi = Math.cos(phi);
                var x = cosPhi * sinTheta;
                var y = cosTheta;
                var z = sinPhi * sinTheta;
                var u = 1 - (longNumber / longs);
                var v = latNumber / lats;
                normalData.push(x);
                normalData.push(y);
                normalData.push(z);
                texCoordData.push(u);
                texCoordData.push(v);
                geometryData.push(radius * x);
                geometryData.push(radius * y);
                geometryData.push(radius * z);
            }
        }
        for (var latNumber = 0; latNumber < lats; ++latNumber) {
            for (var longNumber = 0; longNumber < longs; ++longNumber) {
                var first = (latNumber * (longs + 1)) + longNumber;
                var second = first + longs + 1;
                indexData.push(first);
                indexData.push(first + 1);
                indexData.push(second);
                indexData.push(second);
                indexData.push(first + 1);
                indexData.push(second + 1);
            }
        }
        tf.webgl.VertexBuffer.call(theThis, {
            context: settings.context,
            pos: new tf.webgl.PosBuffer({ context: settings.context, data: new Float32Array(geometryData) }),
            nor: new tf.webgl.NorBuffer({ context: settings.context, data: new Float32Array(normalData) }),
            tex2d: new tf.webgl.Tex2DBuffer({ context: settings.context, data: new Float32Array(texCoordData) }),
            indices: new tf.webgl.IndexBuffer({ context: settings.context, data: new Uint16Array(indexData), is16: true })
        });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.Sphere, tf.webgl.VertexBuffer);
tf.webgl.UVPrimitiveGenerator = function (settings) {
    var primitive;
    if (tf.js.GetIsValidObject(settings) && tf.js.GetIsInstanceOf(settings.context, tf.webgl.Context) && !!settings.context.GetContext()) {
        var getUVVertexCallBack;
        if (!!(getUVVertexCallBack = tf.js.GetFunctionOrNull(settings.getUVVertex))) {
            var context = settings.context;
            var defaultNQuads = 10;
            var nHorQuads = settings.nHor !== undefined ? tf.js.GetIntNumberInRange(settings.nHor, 1, 99999, defaultNQuads) : defaultNQuads;
            var nVerQuads = settings.nVer !== undefined ? tf.js.GetIntNumberInRange(settings.nVer, 1, 99999, defaultNQuads) : defaultNQuads;
            var fillCW = !!settings.fillCW;
            var nVertexRows = nVerQuads + 1;
            var nVerticesPerRow = nHorQuads + 1;
            var nFacesPerRow = 2 * nHorQuads;
            var nVertices = nVertexRows * nVerticesPerRow;
            var nVertexCoords = nVertices * 3;
            var nFaces = nFacesPerRow * nVerQuads;
            var nIndices = nFaces * 3;
            var is16 = nIndices > 255;
            var pos = new Float32Array(nVertexCoords);
            var nor = new Float32Array(nVertexCoords);
            var tex2d = new Float32Array(2 * nVertices);
            var indices = is16 ? new Uint16Array(nIndices) : new Uint8Array(nIndices);
            var vertexIndex = 0, textureIndex = 0, indexIndex = 0;
            var normalVec = new tf.math.Vector3();
            for (var iVertexRow = 0 ; iVertexRow < nVertexRows ; ++iVertexRow) {
                var tex2dY = iVertexRow / nVerQuads;
                for (var iVertexCol = 0 ; iVertexCol < nVerticesPerRow ; ++iVertexCol) {
                    var tex2dX = iVertexCol / nHorQuads;
                    var vertex = getUVVertexCallBack({col: iVertexCol, row: iVertexRow, nCols: nVerticesPerRow, nRows: nVertexRows, u: tex2dX, v: tex2dY});
                    pos[vertexIndex + 0] = vertex.pos.x;
                    pos[vertexIndex + 1] = vertex.pos.y;
                    pos[vertexIndex + 2] = vertex.pos.z;
                    normalVec.Update(vertex.nor);
                    normalVec.Normalize();
                    nor[vertexIndex++] = normalVec[0];
                    nor[vertexIndex++] = normalVec[1];
                    nor[vertexIndex++] = normalVec[2];
                    //nor[vertexIndex++] = vertex.nor.x;
                    //nor[vertexIndex++] = vertex.nor.y;
                    //nor[vertexIndex++] = vertex.nor.z;
                    tex2d[textureIndex++] = tex2dX;
                    tex2d[textureIndex++] = tex2dY;
                }
            }
            for (var row = 0; row < nVerQuads; ++row) {
                for (var col = 0; col < nHorQuads; ++col) {
                    var first = (row * (nHorQuads + 1)) + col;
                    var second = first + nHorQuads + 1;
                    if (fillCW) {
                        indices[indexIndex++] = first;
                        indices[indexIndex++] = first + 1;
                        indices[indexIndex++] = second;
                        indices[indexIndex++] = second;
                        indices[indexIndex++] = first + 1;
                        indices[indexIndex++] = second + 1;
                    }
                    else {
                        indices[indexIndex++] = first;
                        indices[indexIndex++] = second;;
                        indices[indexIndex++] = first + 1
                        indices[indexIndex++] = second;
                        indices[indexIndex++] = second + 1;
                        indices[indexIndex++] = first + 1;
                    }
                }
            }
            primitive = new tf.webgl.VertexBuffer({
                context: context,
                pos: new tf.webgl.PosBuffer({ context: context, data: pos }),
                nor: new tf.webgl.NorBuffer({ context: context, data: nor }),
                tex2d: new tf.webgl.Tex2DBuffer({ context: context, data: tex2d }),
                indices: new tf.webgl.IndexBuffer({ context: context, data: indices, is16: is16 })
            });
        }
    }
    return primitive;
};
tf.webgl.UVSphere = function (settings) {
    var primitive, radius;
    function getUVVertex(settings) {
        var verticalAngle = Math.PI * settings.v;
        var horizontalAngle = Math.PI * 2 * (1 - settings.u);
        var sinHor = Math.sin(horizontalAngle), cosHor = Math.cos(horizontalAngle);
        var sinVer = Math.sin(verticalAngle), cosVer = Math.cos(verticalAngle);
        var x = cosHor * sinVer;
        var y = cosVer;
        var z = sinHor * sinVer;
        return {
            pos: { x: x * radius, y: y * radius, z: z * radius },
            nor: { x: x, y: y, z: z }
        }
    }
    if (tf.js.GetIsValidObject(settings)) {
        radius = tf.js.GetFloatNumberInRange(settings.radius, 0.000001, 9999999, 0.5);
        primitive = new tf.webgl.UVPrimitiveGenerator({
            context: settings.context,
            isClosed: false,
            nHor: settings.nHor,
            nVer: settings.nVer,
            fillCW: settings.fillCW,
            getUVVertex: getUVVertex
        });
    }
    return primitive;
};
tf.webgl.Texture2 = function (settings) {
    var theThis, context, ctx, texture, img, flipVerticalBool, contextId, unit;
    this.GetTexture = function () { return texture; }
    this.Bind = function () { return bind(); }
    this.UpdateFromImage = function (img, flipVerticalBool) { return updateFromImage(img, flipVerticalBool); }
    this.OnLostDevice = function () { return onLostDevice(); }
    this.OnRestoredDevice = function () { return onRestoredDevice(); }
    this.OnDelete = function () { return onDelete(); }
    this.IsDeleted = function () { return isDeleted(); }
    function isDeleted() { return context == undefined; }
    function onDelete() {
        if (!isDeleted()) {
            context.UnRegisterTexture2(contextId);
            contextId = context = texture = img = undefined;
        }
    }
    function isOperational() { return !isDeleted() && texture !== undefined; }
    function onLostDevice() {
        if (!isDeleted()) {
            ctx = texture = undefined;
        }
    }
    function onRestoredDevice() {
        if (!isDeleted()) {
            ctx = context.GetContext();
            if (!!ctx) { texture = ctx.createTexture(); }
            doUpdateFromImage();
        }
    }
    function bind() {
        if (isOperational()) {
            //var ctx = context.GetContext();
            ctx.activeTexture(ctx.TEXTURE0 + unit);
            ctx.bindTexture(ctx.TEXTURE_2D, texture);
            ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE);
            ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);
            //ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.REPEAT);
            //ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.REPEAT);
            ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.LINEAR);
            ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.LINEAR);
        }
    }
    function doUpdateFromImage() {
        if (isOperational() && img !== undefined) {
            //var ctx = context.GetContext();
            ctx.activeTexture(ctx.TEXTURE0 + unit);
            ctx.bindTexture(ctx.TEXTURE_2D, texture);
            ctx.pixelStorei(ctx.UNPACK_FLIP_Y_WEBGL, !!flipVerticalBool);
            ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE);
            ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);
            ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.LINEAR);
            ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.LINEAR);
            ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, ctx.RGBA, ctx.UNSIGNED_BYTE, img);
            if (!!settings.mipMaps) { ctx.generateMipmap(ctx.TEXTURE_2D); }
            //ctx.generateMipmap(ctx.TEXTURE_2D);
            ctx.bindTexture(ctx.TEXTURE_2D, null);
        }
    }
    function setImg(imgSet, flipVerticalBoolSet) {
        img = tf.js.GetIsValidObject(imgSet) ? imgSet : undefined;
        flipVerticalBool = tf.js.GetBoolFromValue(flipVerticalBoolSet, true);
    }
    function updateFromImage(img, flipVerticalBool) { setImg(img, flipVerticalBool); doUpdateFromImage(); }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsInstanceOf(settings.context, tf.webgl.Context) && !!settings.context.GetContext()) {
            context = settings.context;
            ctx = context.GetContext();
            contextId = context.RegisterTexture2(theThis);
            unit = tf.js.GetIntNumberInRange(settings.unit, 0, 1000, 0);
            if (tf.js.GetIsNonEmptyString(settings.url)) {
                setImg(context.GetOnePixelTransparentCanvas(), settings.flipVerticalBool);
                onRestoredDevice();
                new tf.dom.Img({
                    crossOrigin: true, src: settings.url,
                    onLoad: function (imgLoaded) {
                        if (imgLoaded.GetIsValid()) {
                            setImg(imgLoaded.GetImg(), flipVerticalBool);
                            onRestoredDevice();
                        }
                    }
                });
            }
            else {
                setImg(settings.img, settings.flipVerticalBool);
                onRestoredDevice();
            }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.webgl.SceneObject = function (settings) {
    var theThis, context, program, attributes, texture, objectToSceneMatrix, useLines, subObjects, material, onPreRenderCallBack;
    var isVisible, subObjectsAreVisible, cullFaceBool, cullFrontFaceBool, useDepth, usesNonUniformScaling, pickColor, combinedWorldMatrix, comboList, renderMatrix;
    this.SetRenderMatrix = function (renderMatrixSet) { renderMatrix = renderMatrixSet; }
    this.GetRenderMatrix = function (renderMatrixSet) { return renderMatrix; }
    this.OnPreRender = function (onPreRenderSettings) { return onPreRender(onPreRenderSettings); }
    this.SeUsesNonUniformScaling = function (bool) { usesNonUniformScaling = !!bool; }
    this.GetUsesNonUniformScaling = function () { return usesNonUniformScaling; }
    this.SetUseDepth = function (bool) { useDepth = !!bool; }
    this.GetUseDepth = function () { return useDepth; }
    this.GetPickColor = function () { return pickColor; }
    this.SetPickColor = function (newPickColor) { pickColor = newPickColor; }
    this.GetIsVisible = function () { return isVisible; }
    this.SetIsVisible = function (bool) { return isVisible = !!bool; }
    this.GetAreSubObjectsVisible = function () { return subObjectsAreVisible; }
    this.SetAreSubObjectsVisible = function (bool) { return subObjectsAreVisible = !!bool; }
    this.GetAttributes = function () { return attributes; }
    this.GetComboList = function () { return comboList; }
    this.GetObjectToSceneMatrix = function () { return objectToSceneMatrix; }
    this.RenderSelf = function (renderSettings) { return renderSelf(renderSettings); }
    this.AddSubObject = function (subObject) {
        if (!theThis.IsDeleted() && tf.js.GetIsInstanceOf(subObject, tf.webgl.SceneObject)) {
            subObjects.push(subObject);
        }
    }
    this.DelSubObject = function (subObject) {
        if (!theThis.IsDeleted() && tf.js.GetIsInstanceOf(subObject, tf.webgl.SceneObject)) {
            var index = subObjects.find(subObject);
            if (index != -1) { subObject.splice(index, 1); }
        }
    }
    this.GetSubObjects = function () { return subObjects; }
    this.DelAllSubObjects = function () { if (!theThis.IsDeleted()) { subObjects = []; } }
    this.SetOnPreRender = function(onPreRenderSet) {
        onPreRenderCallBack = tf.js.GetFunctionOrNull(onPreRenderSet);
    }
    this.OnDelete = function (delSubObjects, delVertexAndTextures, delVertexSubBuffers) { return onDelete(delSubObjects, delVertexAndTextures, delVertexSubBuffers); }
    this.IsDeleted = function () { return isDeleted(); }
    function isDeleted() { return context == undefined; }
    function onDelete(delSubObjects, delVertexAndTextures, delVertexSubBuffers) {
        if (!isDeleted()) {
            if (!!delSubObjects) {
                for (var i in subObjects) { subObjects[i].OnDelete(delSubObjects, delVertexAndTextures, delVertexSubBuffers); }
            }
            if (!!delVertexAndTextures) {
                if (!!attributes) { attributes.OnDelete(delVertexSubBuffers); }
                if (!!texture) { texture.OnDelete(); }
            }
            renderMatrix = combinedWorldMatrix = subObjects = program = attributes = material = texture = objectToSceneMatrix = context = undefined;
        }
    }
    function onPreRender(onPreRenderSettings) {
        if (!isDeleted()) {
            renderMatrix = undefined;
            if (isVisible) {
                var parentObjectToSceneMatrix = onPreRenderSettings.parentObjectToSceneMatrix;
                if (!!onPreRenderCallBack) { onPreRenderCallBack(theThis); }
                combinedWorldMatrix.CopyFrom(parentObjectToSceneMatrix);
                combinedWorldMatrix.MultByMatrix(objectToSceneMatrix);
                if (!!program) {
                    var point = new tf.math.Vector3([0, 0, 0]);
                    point.MultByMatrix(combinedWorldMatrix);
                    /*var length = new tf.math.Vector3([1, 1, 1]);
                    length.MultByMatrix(combinedWorldMatrix);*/
                    var frustumVisible = onPreRenderSettings.frustum.GetIsPointVisible(point);
                    onPreRenderSettings.toRender.push({ sceneObject: theThis, objectToSceneMatrix: combinedWorldMatrix, frustumVisible: frustumVisible });
                }
                if (subObjectsAreVisible) {
                    for (var i in subObjects) {
                        onPreRenderSettings.parentObjectToSceneMatrix = combinedWorldMatrix;
                        subObjects[i].OnPreRender(onPreRenderSettings);
                    }
                    onPreRenderSettings.parentObjectToSceneMatrix = parentObjectToSceneMatrix;
                }
            }
        }
    }
    function renderSelf(renderSettings) {
        if (!isDeleted()) {
            if (isVisible) {
                var ctx = context.GetContext();
                var scene = renderSettings.scene;
                var useProgram = renderSettings.useProgram;
                var isForPick = renderSettings.isForPick;
                if (!!program) {
                    if (!isForPick || !!pickColor) {
                        if (!!cullFaceBool) { ctx.enable(ctx.CULL_FACE); if (!!cullFrontFaceBool) { ctx.cullFace(ctx.FRONT); } else { ctx.cullFace(ctx.BACK); } }
                        else { ctx.disable(ctx.CULL_FACE); }
                        if (!!useDepth) { ctx.enable(ctx.DEPTH_TEST); } else { ctx.disable(ctx.DEPTH_TEST); }
                        //ctx.disable(ctx.DEPTH_TEST);
                        //ctx.disable(ctx.CULL_FACE);
                        if (useProgram == undefined) { useProgram = program; }
                        useProgram.Render({
                            usesNonUniformScaling: usesNonUniformScaling || renderSettings.usesNonUniformScaling,
                            comboList: comboList,
                            attributes: attributes,
                            texture: texture,
                            material: material,
                            scene: scene,
                            objectToSceneMatrix: renderMatrix,
                            useLines: renderSettings.useLines || useLines,
                            //useLines: true,
                            pickColor: pickColor
                        });
                    }
                }
                if (subObjectsAreVisible && !!renderSettings.renderSubObjects) {
                    var savedUsesNonUniformScaling = renderSettings.usesNonUniformScaling;
                    renderSettings.usesNonUniformScaling |= usesNonUniformScaling;
                    for (var i in subObjects) { subObjects[i].RenderSelf(renderSettings); }
                    renderSettings.usesNonUniformScaling = savedUsesNonUniformScaling;
                }
            }
        }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsInstanceOf(settings.context, tf.webgl.Context) && !!settings.context.GetContext()) {
            objectToSceneMatrix = new tf.math.WorldMatrix4(settings);
            combinedWorldMatrix = new tf.math.WorldMatrix4();
            context = settings.context;
            subObjects = [];
            isVisible = !tf.js.GetIsFalseNotUndefined(settings.isVisible);
            subObjectsAreVisible = !tf.js.GetIsFalseNotUndefined(settings.subObjectsAreVisible);
            if (tf.js.GetIsInstanceOf(settings.program, tf.webgl.Program)) {
                cullFaceBool = settings.cullFace !== undefined ? !!settings.cullFace : true;
                cullFrontFaceBool = settings.cullFrontFace !== undefined ? !!settings.cullFrontFace : false;
                useLines = !!settings.useLines;
                useDepth = !tf.js.GetIsFalseNotUndefined(settings.useDepth);
                usesNonUniformScaling = !!settings.usesNonUniformScaling;
                program = settings.program;
                comboList = tf.js.GetIsInstanceOf(settings.comboList, tf.webgl.MatTex2VertComboList) ? settings.comboList : undefined;
                attributes = tf.js.GetIsInstanceOf(settings.attributes, tf.webgl.VertexBuffer) ? settings.attributes : undefined;
                texture = tf.js.GetIsInstanceOf(settings.texture, tf.webgl.Texture2) ? settings.texture : undefined;
                material = settings.material;
                onPreRenderCallBack = tf.js.GetFunctionOrNull(settings.onPreRender);
            }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.webgl.Scene = function (settings) {
    var theThis, context, canvas, objects, clearColor, ambientColor, clearDepth, world, view, perspective, lightDir, lightColor, viewProj, lastProgram;
    var preRenderArray, frustum;
    this.OnPreRender = function () { return onPreRender(); }
    this.GetLastProgram = function () { return lastProgram; }
    this.SetLastProgram = function (lastProgramSet) { return lastProgram = lastProgramSet; }
    this.RenderOn = function (sceneRenderSettings) { return renderOn(sceneRenderSettings); }
    this.GetViewProj = function () { return viewProj; }
    this.GetWorld = function () { return world; }
    this.GetView = function () { return view; }
    this.GetPerspective = function () { return perspective; }
    this.SetClearColor = function (color) { return setClearColor(color); }
    this.GetClearColor = function () { return clearColor.slice(0); }
    this.SetAmbientColor = function (color) { return setAmbientColor(color); }
    this.GetAmbientColor = function () { return ambientColor.slice(0); }
    this.GetLightDir = function () { return lightDir; }
    this.SetLightDir = function (lightDir) { return setLightDir(lightDir); }
    this.SetLightColor = function (color) { return setLightColor(color); }
    this.GetLightColor = function () { return lightColor.slice(0); }
    this.AddObject = function (object) {
        if (!isDeleted()) {
            if (tf.js.GetIsValidObject(object) && !!tf.js.GetFunctionOrNull(object.RenderSelf)) {
                objects.push(object);
            }
        }
    }
    this.DelObject = function (object) {
        if (!isDeleted()) {
            if (tf.js.GetIsValidObject(object)) {
                var index = objects.find(object);
                if (index != -1) { objects.splice(index, 1); }
            }
        }
    }
    this.ClearObjects = function () { return clearObjects(); }
    this.OnDelete = function () { return onDelete(); }
    this.IsDeleted = function () { return isDeleted(); }
    function clearObjects() { if (!isDeleted()) { objects = []; } }
    function isDeleted() { return context == undefined; }
    function onDelete() {
        context = canvas = undefined; objects = null;
    }
    function onPreRender() {
        if (!isDeleted()) {
            preRenderArray = [];
            frustum.OnUpdate();
            var onPreRenderSettings = {
                frustum: frustum,
                parentObjectToSceneMatrix: world,
                toRender: preRenderArray
            };
            for (var i in objects) { objects[i].OnPreRender(onPreRenderSettings); }
        }
    }
    function renderOn(sceneRenderSettings) {
        function renderImmediate(object, renderSubObjects) {
            if (tf.js.GetIsInstanceOf(object, tf.webgl.SceneObject)) {
                renderSettings.renderSubObjects = !!renderSubObjects;
                object.RenderSelf(renderSettings);
            }
        }
        if (!isDeleted()) {
            lastProgram = undefined;
            viewProj.CopyFrom(perspective);
            viewProj.MultByMatrix(view);
            var ctx = context.GetContext();
            var viewportWidth = sceneRenderSettings.viewportWidth;
            var viewportHeight = sceneRenderSettings.viewportHeight;
            ctx.viewport(0, 0, viewportWidth, viewportHeight);
            //ctx.bindFramebuffer(ctx.FRAMEBUFFER, sceneRenderSettings.frameBuffer);
            if (!!sceneRenderSettings.frameBuffer) {
                ctx.bindFramebuffer(ctx.FRAMEBUFFER, sceneRenderSettings.frameBuffer);
            }
            else {
                ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
            }
            ctx.depthRange(0.0, 1.0);
            ctx.depthFunc(ctx.LEQUAL);
            ctx.clearDepth(clearDepth);
            ctx.enable(ctx.BLEND);
            //ctx.enable(ctx.SAMPLE_COVERAGE);
            //ctx.sampleCoverage(2, false);
            ctx.blendFunc(ctx.SRC_ALPHA, ctx.ONE_MINUS_SRC_ALPHA);
            /*ctx.activeTexture(ctx.TEXTURE0 + 0);
            ctx.bindTexture(ctx.TEXTURE_2D, null);
            ctx.activeTexture(ctx.TEXTURE0 + 1);
            ctx.bindTexture(ctx.TEXTURE_2D, null);*/
            var clearColorUse = sceneRenderSettings.clearColor !== undefined ? sceneRenderSettings.clearColor : clearColor;
            ctx.clearColor(clearColorUse[0], clearColorUse[1], clearColorUse[2], clearColorUse[3]);
            ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT);
            ctx.frontFace(ctx.CCW);
            var renderSettings = {
                scene: theThis,
                renderSubObjects: false,
                parentObjectToSceneMatrix: world,
                useProgram: sceneRenderSettings.useProgram,
                isForPick: sceneRenderSettings.isForPick
            };
            var total = preRenderArray.length, visible = 0;
            for (var i in preRenderArray) {
                var pr = preRenderArray[i], so = pr.sceneObject;
                if (pr.frustumVisible) {
                    ++visible;
                    so.SetRenderMatrix(pr.objectToSceneMatrix);
                    so.RenderSelf(renderSettings);
                }
                //so.SetRenderMatrix(pr.objectToSceneMatrix);
                //so.RenderSelf(renderSettings);
            }
            //console.log('total: ' + total + ' visible: ' + visible);
            if (tf.js.GetFunctionOrNull(sceneRenderSettings.onPostCompose)) {
                sceneRenderSettings.onPostCompose({ sender: theThis, renderImmediate: renderImmediate });
            }
        }
    }
    function setLightDir(lightDirSet) {
        lightDir = tf.js.GetIsArrayWithLength(lightDirSet, 3) ? lightDirSet.slice(0) : [0, 0, 1];
    }
    function getColorFrom(color, nComponents, defaultColor) { return tf.js.GetIsArrayWithLength(color, nComponents) ? color.slice(0) : defaultColor; }
    function setClearColor(color) { clearColor = getColorFrom(color, 4, [0, 0, 0.5, 1]); }
    function setAmbientColor(color) { ambientColor = getColorFrom(color, 3, [0, 0, 0]); }
    function setLightColor(color) { lightColor = getColorFrom(color, 3, [0, 0, 0]); }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsInstanceOf(settings.context, tf.webgl.Context) && !!settings.context.GetContext()) {
            context = settings.context;
            canvas = context.GetCanvas();
            viewProj = new tf.math.Matrix4({ noInit: true });
            world = new tf.math.WorldMatrix4(settings.world);
            view = new tf.math.ViewMatrix4(settings.view);
            perspective = new tf.math.PerspectiveFOVMatrix4(settings.perspective);
            frustum = new tf.math.ViewFrustum({ perspective: perspective, view: view });
            clearDepth = typeof settings.clearDepth == 'number' ? settings.clearDepth : 1;
            setClearColor(settings.clearColor);
            setAmbientColor(settings.ambientColor);
            setLightDir(settings.lightDir);
            setLightColor(settings.lightColor);
            clearObjects();
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.webgl.SceneContainer = function (settings) {
    var theThis, styles, subStyles, context, ctx, canvas, scene, aspect, container, containerHTML;
    var renderCount, pickFrameBufferRenderCount, pickFrameBufferDim, pickFrameBuffer, pickedColor;
    var onFrameCallBack, onPostComposeCallBack;
    this.GetObjectFromPixel = function(pixelCoords) { return getObjectFromPixel(pixelCoords); }
    this.OnFrame = function () { return onFrame(); }
    this.GetContext = function () { return context; }
    this.GetScene = function () { return scene; }
    this.GetAspect = function () { return aspect; }
    this.OnDelete = function () { return onDelete(); }
    this.IsDeleted = function () { return isDeleted(); }
    function isDeleted() { return context == undefined; }
    function isOperational() { return ctx != undefined; }
    function onDelete() {
        if (!isDeleted()) {
            if (!!containerHTML && !!canvas) { containerHTML.removeChild(canvas); }
            if (!!scene) { scene.OnDelete(); }
            if (!!pickFrameBuffer) { pickFrameBuffer.OnDelete(); }
            if (!!context) { context.OnDelete(); }
            containerHTML = container = canvas = ctx = context = scene = pickFrameBuffer = undefined;
        }
    }
    function getObjectFromPixel(pixelCoords) {
        var obj;
        if (isOperational()) {
            if (!!pickFrameBuffer && tf.js.GetIsArrayWithMinLength(pixelCoords, 2)) {
                ctx.bindFramebuffer(ctx.FRAMEBUFFER, pickFrameBuffer.GetFrameBuffer());
                ctx.readPixels(pixelCoords[0], pixelCoords[1], 1, 1, ctx.RGBA, ctx.UNSIGNED_BYTE, pickedColor);
                ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
                obj = context.GetPickObject(tf.webgl.DecodeColorIntoInt(pickedColor));
            }
        }
        return obj;
    };
    function updatePerspective() {
        if (canvas.clientWidth != canvas.width || canvas.clientHeight != canvas.height) {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            aspect = canvas.clientWidth > 0 ? canvas.clientHeight / canvas.clientWidth : 1;
            scene.GetPerspective().UpdateAspect(1 / aspect);
        }
    }
    function drawFrame() {
        if (isOperational()) {
            updatePerspective();
            if (!!onFrameCallBack) { onFrameCallBack({ sender: theThis }); }
            scene.OnPreRender();
            var renderOptions = {
                onPostCompose: onPostComposeCallBack,
                viewportWidth: canvas.width, viewportHeight: canvas.height,
                isForPick: false,
                frameBuffer: undefined, clearColor: undefined, useProgram: undefined
            };
            scene.RenderOn(renderOptions);
            if (!!pickFrameBuffer) {
                if ((renderCount % pickFrameBufferRenderCount) == 0) {
                    renderOptions.viewportWidth = renderOptions.viewportHeight = pickFrameBufferDim;
                    renderOptions.isForPick = true;
                    renderOptions.frameBuffer = pickFrameBuffer.GetFrameBuffer();
                    renderOptions.clearColor = [0, 0, 0, 0];
                    renderOptions.useProgram = context.GetTextureColorPickProgram();
                    scene.RenderOn(renderOptions);
                }
            }
            renderCount++;
        }
    }
    function restoreContext() { if (!!context) { context.RestoreContext(); } }
    function onFrame() { drawFrame(); context.RequestAnimFrame(); }
    function onLost() { ctx = undefined; setTimeout(restoreContext, 1000); }
    function onRestored() { ctx = context.GetContext(); drawFrame(); }
    function createScene() {
        var viewAngle = 30 * Math.PI / 180;
        var viewRadius = 1;
        var sceneNear = 1, sceneFar = 1000, viewY, viewZ, vFrom, vTo, viewZOff = 0;
        viewY = Math.sin(viewAngle) * viewRadius;
        viewZ = Math.cos(viewAngle) * viewRadius;
        vFrom = [viewZ, viewZ, 0]; vTo = [0, 0, 0];
        var view = { vFrom: vFrom, vTo: vTo, vUp: [0, 1, 0] };
        var ambientComponent = 1;
        var lightComponent = 0.75;
        scene = new tf.webgl.Scene({
            context: context, clearColor: [0, 0, 0, 1], clearDepth: 1,
            ambientColor: [ambientComponent, ambientComponent, ambientComponent],
            lightDir: [0, 1, 0],
            lightColor: [lightComponent, lightComponent, lightComponent],
            view: view,
            perspective: { fovy: 30 * Math.PI / 180, near: sceneNear, far: sceneFar }
        });
    }
    function initialize() {
        if (tf.js.GetIsValidObject(settings) && tf.dom.GetHTMLElementFrom(settings.container)) {
            styles = tf.GetStyles(); subStyles = styles.GetSubStyles();
            aspect = 1;
            container = settings.container;
            containerHTML = container.GetHTMLElement();
            onFrameCallBack = tf.js.GetFunctionOrNull(settings.onFrame);
            onPostComposeCallBack = tf.js.GetFunctionOrNull(settings.onPostCompose);
            if (tf.webgl.GetWebGL().GetHasWebGL()) {
                var canvasStyles = { backgroundColor: "rgba(0,0,0,1)", width: "100%", height: "100%", position: 'relative', display: 'block' };
                context = new tf.webgl.Context({ optionalAttributes: { antialias: true }, onFrame: onFrame, onLost: onLost, onRestored: onRestored });
                canvas = context.GetCanvas();
                ctx = context.GetContext();
                pickedColor = new Uint8Array(4);
                renderCount = 0;
                if (!settings.noPickFrameBuffer) {
                    pickFrameBufferRenderCount = 10;
                    pickFrameBufferDim = 512;
                    pickFrameBuffer = new tf.webgl.FrameBuffer({ context: context, width: pickFrameBufferDim, height: pickFrameBufferDim });
                }
                createScene();
                styles.ApplyStyleProperties(canvas, canvasStyles);
                containerHTML.appendChild(canvas);
            }
            else { containerHTML.innerHTML = "<h3>WebGL not available</h3>"; }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.webgl.FrameBuffer = function (settings) {
    var theThis, context, frameBuffer, texture, renderBuffer, contextId;
    this.OnLostDevice = function () { return onLostDevice(); }
    this.OnRestoredDevice = function () { return onRestoredDevice(); }
    this.GetFrameBuffer = function () { return frameBuffer; }
    this.GetTexture = function () { return texture; }
    //this.Bind = function () { return bind(); }
    this.OnDelete = function () { return onDelete(); }
    this.IsDeleted = function () { return isDeleted(); }
    function isOperational() { return !isDeleted() && frameBuffer !== undefined; }
    function isDeleted() { return context == undefined; }
    function onDelete() {
        if (!isDeleted()) {
            context.UnRegisterFrameBuffer(contextId);
            if (!!texture) { texture.OnDelete(); }
            contextId = context = undefined;
        }
    }
    function onLostDevice() { if (!isDeleted()) { frameBuffer = undefined; texture.OnDelete(); texture = undefined; } }
    function onRestoredDevice() {
        if (!isDeleted()) {
            var ctx = context.GetContext();
            frameBuffer = ctx.createFramebuffer();
            ctx.bindFramebuffer(ctx.FRAMEBUFFER, frameBuffer);
            frameBuffer.width = typeof settings.width == 'number' ? settings.width : 512;
            frameBuffer.height = typeof settings.height == 'number' ? settings.height : 512;
            //texture = ctx.createTexture();
            texture = new tf.webgl.Texture2({ context: context });
            var tex = texture.GetTexture();
            //ctx.activeTexture(ctx.TEXTURE0);
            ctx.bindTexture(ctx.TEXTURE_2D, tex);
            ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.LINEAR);
            ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.LINEAR_MIPMAP_NEAREST);
            //ctx.generateMipmap(ctx.TEXTURE_2D);
            ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, frameBuffer.width, frameBuffer.height, 0, ctx.RGBA, ctx.UNSIGNED_BYTE, null);
            renderBuffer = ctx.createRenderbuffer();
            ctx.bindRenderbuffer(ctx.RENDERBUFFER, renderBuffer);
            ctx.renderbufferStorage(ctx.RENDERBUFFER, ctx.DEPTH_COMPONENT16, frameBuffer.width, frameBuffer.height);
            ctx.framebufferTexture2D(ctx.FRAMEBUFFER, ctx.COLOR_ATTACHMENT0, ctx.TEXTURE_2D, tex, 0);
            ctx.framebufferRenderbuffer(ctx.FRAMEBUFFER, ctx.DEPTH_ATTACHMENT, ctx.RENDERBUFFER, renderBuffer);
            ctx.bindTexture(ctx.TEXTURE_2D, null);
            ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);
            ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
        }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsInstanceOf(settings.context, tf.webgl.Context) && !!settings.context.GetContext()) {
            context = settings.context;
            contextId = context.RegisterFrameBuffer(theThis);
            onRestoredDevice();
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.webgl.Shader = function (settings) {
    var theThis, context, shader, shaderType;
    this.OnLostDevice = function () { return onLostDevice(); }
    this.OnRestoredDevice = function () { return onRestoredDevice(); }
    this.GetShader = function () { return shader; }
    this.GetShaderType = function () { return shaderType; }
    this.IsDeleted = function () { return isDeleted(); }
    this.OnDelete = function () { return onDelete(); }
    function isOperational() { return !isDeleted() && shader !== undefined; }
    function isDeleted() { return context == undefined; }
    function onDelete() {
        if (!isDeleted()) {
            if (!!context && !!shader) {
                var ctx = context.GetContext();
                if (!!ctx) { ctx.deleteShader(shader); }
            }
            shaderType = context = shader = undefined;
        }
    }
    function onLostDevice() { if (!isDeleted()) { shader = undefined; } }
    function onRestoredDevice() {
        if (!isDeleted()) {
            var ctx = context.GetContext();
            if (!!ctx) {
                var shaderText = tf.js.GetNonEmptyString(settings.text);
                if (!!shaderText) {
                    shaderType = tf.js.GetNonEmptyString(settings.type);
                    var glShaderType;
                    if (shaderType !== undefined) {
                        switch (shaderType = shaderType.toLowerCase()[0]) {
                            case 'f': glShaderType = ctx.FRAGMENT_SHADER; break;
                            case 'v': glShaderType = ctx.VERTEX_SHADER; break;
                            default: shaderType = undefined; break;
                        }
                    }
                    if (glShaderType !== undefined) {
                        shader = ctx.createShader(glShaderType);
                        ctx.shaderSource(shader, shaderText);
                        ctx.compileShader(shader);
                        var compiled = ctx.getShaderParameter(shader, ctx.COMPILE_STATUS);
                        if (!compiled && !ctx.isContextLost()) {
                            if (!!settings.debug) {
                                var error = ctx.getShaderInfoLog(shader);
                                tf.GetDebug().LogIfTest("*** Error compiling shader: " + error);
                            }
                            onDelete();
                        }
                    }
                }
            }
        }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsInstanceOf(settings.context, tf.webgl.Context) && !!settings.context.GetContext()) {
            context = settings.context;
            onRestoredDevice();
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.webgl.Program = function (settings) {
    var theThis, program, context, ctx, keyes, vshader, fshader, renderCallBack;
    this.GetProgram = function () { return program; }
    this.OnLostDevice = function () { return onLostDevice(); }
    this.OnRestoredDevice = function () { return onRestoredDevice(); }
    this.Render = function (renderSettings) { return render(renderSettings); }
    this.GetUniformLocation = function (name) { return getUniformLocation (name); }
    this.GetAttribLocation = function (name) { return getAttribLocation (name); }
    function render(renderSettings) {
        if (isOperational() && tf.js.GetIsValidObject(renderSettings)) {
            /*if (tf.js.GetIsInstanceOf(renderSettings.attributes, tf.webgl.VertexBuffer) &&
                tf.js.GetIsInstanceOf(renderSettings.texture, tf.webgl.Texture2) &&
                tf.js.GetIsInstanceOf(renderSettings.objectToSceneMatrix, tf.math.Matrix4) &&
                tf.js.GetIsInstanceOf(renderSettings.scene, tf.webgl.Scene)) {*/
            if (renderSettings.isNewProgram = (renderSettings.scene.GetLastProgram() != theThis)) {
                ctx.useProgram(program);
                renderSettings.scene.SetLastProgram(theThis);
            }
            //else { console.log('.'); }
            renderCallBack(renderSettings);
            //}
        }
    }
    this.OnDelete = function () { return onDelete(); }
    this.IsDeleted = function () { return isDeleted(); }
    this.IsOperational = function () { return isOperational(); }
    function getUniformLocation(name) { return !isOperational() || !tf.js.GetIsNonEmptyString(name) ? undefined : ctx.getUniformLocation(program, name); }
    function getAttribLocation(name) { return !isOperational() || !tf.js.GetIsNonEmptyString(name) ? undefined : ctx.getAttribLocation(program, name); }
    function isOperational() { return !isDeleted() && program !== undefined; }
    function isDeleted() { return context == undefined; }
    function onDelete() {
        if (!isDeleted()) {
            if (!!program && !!ctx) { ctx.deleteProgram(program); }
            context = ctx = program = vshader = fshader = undefined;
        }
    }
    function onLostDevice() { if (!isDeleted()) { ctx = undefined; program = undefined; } }
    function onRestoredDevice() {
        if (!isDeleted()) {
            ctx = context.GetContext();
            program = ctx.createProgram();
            ctx.attachShader(program, vshader.GetShader());
            ctx.attachShader(program, fshader.GetShader());
            ctx.linkProgram(program);
            var linked = ctx.getProgramParameter(program, ctx.LINK_STATUS);
            if (!linked && !ctx.isContextLost()) {
                if (!!settings.debug) {
                    var error = ctx.getProgramInfoLog(program);
                    tf.GetDebug().LogIfTest("Error in program linking: " + error);
                }
                onDelete();
            }
            else {
                if (tf.js.GetFunctionOrNull(settings.init)) { settings.init(ctx); }
            }
        }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsInstanceOf(settings.context, tf.webgl.Context) && !!settings.context.GetContext() &&
            tf.js.GetIsInstanceOf(settings.vshader, tf.webgl.Shader) && settings.vshader.GetShaderType() == 'v' &&
            tf.js.GetIsInstanceOf(settings.fshader, tf.webgl.Shader) && settings.fshader.GetShaderType() == 'f' &&
            !!(renderCallBack = tf.js.GetFunctionOrNull(settings.render))){
            context = settings.context;
            vshader = settings.vshader;
            fshader = settings.fshader;
            onRestoredDevice();
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.webgl.EncodeIntIntoColor = function (value) {
    var r = value % 256; value = value >> 8;
    var g = value % 256; value = value >> 8;
    var b = value % 256;
    var obj = [1 - r / 255, 1 - g / 255, 1 - b / 255];
    obj.rgb = { r: obj[0], g: obj[1], b: obj[2], value: value };
    return obj;
}
tf.webgl.DecodeColorIntoInt = function (color) {
    return !!color[3] ? (255 - color[0]) + 256 * (255 - color[1]) + 32768 * (255 - color[2]) : 0;
}
tf.webgl.GetTextureColorVSText = function () {
    return "uniform mat4 uModelMatrix;" + "\n" +
            "uniform mat4 uViewProjMatrix;" + "\n" +
            "attribute vec3 aPosition;" + "\n" +
            "attribute vec3 aTexCoord;" + "\n" +
            "varying vec2 vTexCoord;" + "\n" +
            "void main()" + "\n" +
            "{" + "\n" +
                "gl_Position = uViewProjMatrix * uModelMatrix * vec4(aPosition, 1.0);" + "\n" +
                "vTexCoord = aTexCoord.st;" + "\n" +
            "}";
}
tf.webgl.GetTextureColorFSText = function () {
    return "precision mediump float;" + "\n" +
        "uniform sampler2D diffuseTex;" + "\n" +
        "varying vec2 vTexCoord;" + "\n" +
        "void main()" + "\n" +
        "{" + "\n" +
            "vec4 color = texture2D(diffuseTex, vTexCoord);" + "\n" +
            "if (color.a == 0.0) discard;" + "\n" +
            "else gl_FragColor = color;" + "\n" +
            //"else gl_FragColor = vec4(color.xyz, 0.5);" + "\n" +
            //"gl_FragColor = vec4(1, 0, 0, 1);" + "\n" +
        "}";
}
tf.webgl.GetTextureColorPickVSText = function () {
    return "uniform mat4 uModelMatrix;" + "\n" +
            "uniform mat4 uViewProjMatrix;" + "\n" +
            "attribute vec3 aPosition;" + "\n" +
            "attribute vec3 aTexCoord;" + "\n" +
            "varying vec2 vTexCoord;" + "\n" +
            "void main()" + "\n" +
            "{" + "\n" +
                "gl_Position = uViewProjMatrix * uModelMatrix * vec4(aPosition, 1.0);" + "\n" +
                "vTexCoord = aTexCoord.st;" + "\n" +
            "}";
}
tf.webgl.GetTextureColorPickFSText = function () {
    return "precision mediump float;" + "\n" +
        "uniform sampler2D diffuseTex;" + "\n" +
        "varying vec2 vTexCoord;" + "\n" +
        "uniform vec3 uPickColor;" + "\n" +
        "void main()" + "\n" +
        "{" + "\n" +
            "vec4 color = texture2D(diffuseTex, vTexCoord);" + "\n" +
            "if (color.a == 0.0) discard;" + "\n" +
            "else gl_FragColor = vec4(uPickColor, 1);" + "\n" +
        "}";
}
tf.webgl.TextureColorVS = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        tf.webgl.Shader.call(theThis, {
            debug: settings.debug,
            context: settings.context,
            type: 'v',
            text: tf.webgl.GetTextureColorVSText()
    });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.TextureColorVS, tf.webgl.Shader);
tf.webgl.TextureColorFS = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        tf.webgl.Shader.call(theThis, {
            debug: settings.debug,
            context: settings.context,
            type: 'f',
            text: tf.webgl.GetTextureColorFSText()
        });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.TextureColorFS, tf.webgl.Shader);
tf.webgl.TextureColorProgram = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsInstanceOf(settings.context, tf.webgl.Context) && !!settings.context.GetContext()) {
            var context = settings.context;
            var posLoc, tex2dLoc;
            var diffuseTexLoc, uModelMatrixLoc, uViewProjMatrixLoc;
            tf.webgl.Program.call(theThis, {
                debug: settings.debug,
                context: context,
                vshader: context.GetTextureColorVS(),
                fshader: context.GetTextureColorFS(),
                init: function (ctx) {
                    posLoc = theThis.GetAttribLocation("aPosition");
                    tex2dLoc = theThis.GetAttribLocation("aTexCoord");
                    diffuseTexLoc = theThis.GetUniformLocation("diffuseTex");
                    uModelMatrixLoc = theThis.GetUniformLocation("uModelMatrix");
                    uViewProjMatrixLoc = theThis.GetUniformLocation("uViewProjMatrix");
                },
                render: function (renderSettings) {
                    var ctx = context.GetContext();
                    var scene = renderSettings.scene;
                    if (renderSettings.isNewProgram) {
                        if (!!diffuseTexLoc) { ctx.uniform1i(diffuseTexLoc, 0); }
                        ctx.uniformMatrix4fv(uViewProjMatrixLoc, false, scene.GetViewProj().GetInStaticFloat32Array());
                        //ctx.activeTexture(ctx.TEXTURE0 + 1);
                        //ctx.bindTexture(ctx.TEXTURE_2D, null);
                    }
                    ctx.uniformMatrix4fv(uModelMatrixLoc, false, renderSettings.objectToSceneMatrix.GetInStaticFloat32Array());
                    renderSettings.attributes.BindBuffers(posLoc, undefined, tex2dLoc);
                    renderSettings.texture.Bind();
                    renderSettings.attributes.Draw(renderSettings.useLines);
                }
            });
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.TextureColorProgram, tf.webgl.Program);
tf.webgl.TextureColorPickVS = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        tf.webgl.Shader.call(theThis, {
            debug: settings.debug,
            context: settings.context,
            type: 'v',
            text: tf.webgl.GetTextureColorPickVSText()
        });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.TextureColorPickVS, tf.webgl.Shader);
tf.webgl.TextureColorPickFS = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        tf.webgl.Shader.call(theThis, {
            debug: settings.debug,
            context: settings.context,
            type: 'f',
            text: tf.webgl.GetTextureColorPickFSText()
        });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.TextureColorPickFS, tf.webgl.Shader);
tf.webgl.TextureColorPickProgram = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsInstanceOf(settings.context, tf.webgl.Context) && !!settings.context.GetContext()) {
            var context = settings.context;
            var posLoc, tex2dLoc;
            var diffuseTexLoc, uModelMatrixLoc, uViewProjMatrixLoc, uPickColorLoc;
            tf.webgl.Program.call(theThis, {
                debug: settings.debug,
                context: context,
                vshader: context.GetTextureColorPickVS(),
                fshader: context.GetTextureColorPickFS(),
                init: function (ctx) {
                    posLoc = theThis.GetAttribLocation("aPosition");
                    tex2dLoc = theThis.GetAttribLocation("aTexCoord");
                    diffuseTexLoc = theThis.GetUniformLocation("diffuseTex");
                    uModelMatrixLoc = theThis.GetUniformLocation("uModelMatrix");
                    uViewProjMatrixLoc = theThis.GetUniformLocation("uViewProjMatrix");
                    uPickColorLoc = theThis.GetUniformLocation("uPickColor");
                },
                render: function (renderSettings) {
                    var ctx = context.GetContext();
                    var scene = renderSettings.scene;
                    if (renderSettings.isNewProgram) {
                        if (!!diffuseTexLoc) { ctx.uniform1i(diffuseTexLoc, 0); }
                        ctx.uniformMatrix4fv(uViewProjMatrixLoc, false, scene.GetViewProj().GetInStaticFloat32Array());
                        //ctx.activeTexture(ctx.TEXTURE0 + 1);
                        //ctx.bindTexture(ctx.TEXTURE_2D, null);
                    }
                    if (!!uPickColorLoc) { var pc = renderSettings.pickColor; ctx.uniform3f(uPickColorLoc, pc[0], pc[1], pc[2]); }
                    ctx.uniformMatrix4fv(uModelMatrixLoc, false, renderSettings.objectToSceneMatrix.GetInStaticFloat32Array());
                    renderSettings.attributes.BindBuffers(posLoc, undefined, tex2dLoc);
                    renderSettings.texture.Bind();
                    renderSettings.attributes.Draw(renderSettings.useLines);
                }
            });
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.TextureColorPickProgram, tf.webgl.Program);
tf.webgl.MaterialVS = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        tf.webgl.Shader.call(theThis, {
            debug: settings.debug,
            context: settings.context,
            type: 'v',
            text: tf.webgl.GetMaterialVSText()
        });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.MaterialVS, tf.webgl.Shader);
tf.webgl.MaterialFS = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        tf.webgl.Shader.call(theThis, {
            debug: settings.debug,
            context: settings.context,
            type: 'f',
            text: tf.webgl.GetMaterialFSText()
        });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.MaterialFS, tf.webgl.Shader);
tf.webgl.MaterialProgram = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsInstanceOf(settings.context, tf.webgl.Context) && !!settings.context.GetContext()) {
            var context = settings.context;
            var posLoc, norLoc, tex2dLoc, normalMatrix, modelViewMatrix, lightDirVec, hasTextureLoc, hasNormalTextureLoc;
            var uModelMatrixLoc, uNormalMatrixLoc, uViewProjMatrixLoc, uProjMatrixLoc, uModelViewMatrixLoc, uNormalViewMatrixLoc;
            var ambientLightLoc, cameraPosLoc, lightDirLoc, lightColorLoc, uniformLocations, diffuseTexLoc, normalTexLoc;
            tf.webgl.Program.call(theThis, {
                debug: settings.debug,
                context: context,
                vshader: context.GetMaterialVS(),
                fshader: context.GetMaterialFS(),
                init: function (ctx) {
                    posLoc = theThis.GetAttribLocation("aPosition");
                    norLoc = theThis.GetAttribLocation("aNormal");
                    tex2dLoc = theThis.GetAttribLocation("aTexCoord");
                    cameraPosLoc = theThis.GetUniformLocation("uCameraPos");
                    lightDirLoc = theThis.GetUniformLocation("uLightDir");
                    lightColorLoc = theThis.GetUniformLocation("uLightColor");
                    ambientLightLoc = theThis.GetUniformLocation("uAmbientLight");
                    hasTextureLoc = theThis.GetUniformLocation("hasTexture");
                    hasNormalTextureLoc = theThis.GetUniformLocation("hasNormalTexture");
                    diffuseTexLoc = theThis.GetUniformLocation("diffuseTex");
                    normalTexLoc = theThis.GetUniformLocation("normalTex");
                    uniformLocations = {
                        hasTextureLoc: hasTextureLoc,
                        hasNormalTextureLoc: hasNormalTextureLoc,
                        ambientColor3Loc: theThis.GetUniformLocation("uAmbientColor"),
                        diffuseColor3Loc: theThis.GetUniformLocation("uDiffuseColor"),
                        emissiveColor3Loc: theThis.GetUniformLocation("uEmissiveColor"),
                        specularColor3Loc: theThis.GetUniformLocation("uSpecularColor"),
                        opacityShininessLoc: theThis.GetUniformLocation("uOpacityShininess")
                    };
                    uModelMatrixLoc = theThis.GetUniformLocation("uModelMatrix");
                    uNormalMatrixLoc = theThis.GetUniformLocation("uNormalMatrix");
                    uViewProjMatrixLoc = theThis.GetUniformLocation("uViewProjMatrix");
                    uProjMatrixLoc = theThis.GetUniformLocation("uProjMatrix");
                    uModelViewMatrixLoc = theThis.GetUniformLocation("uModelViewMatrix");
                    uNormalViewMatrixLoc = theThis.GetUniformLocation("uNormalViewMatrix");
                    normalMatrix = new tf.math.Matrix4({ noInit: true });
                    modelViewMatrix = new tf.math.Matrix4({ noInit: true });
                    lightDirVec = new tf.math.Vector3();
                },
                render: function (renderSettings) {
                    var ctx = context.GetContext();
                    var scene = renderSettings.scene;
                    var viewMatrix = scene.GetView();
                    if (renderSettings.isNewProgram) {
                        if (!!ambientLightLoc) {
                            var ambientLight = scene.GetAmbientColor();
                            ctx.uniform3f(ambientLightLoc, ambientLight[0], ambientLight[1], ambientLight[2]);
                        }
                        if (!!cameraPosLoc) {
                            var cameraPos = viewMatrix.GetView().vFrom;
                            ctx.uniform3f(cameraPosLoc, cameraPos[0], cameraPos[1], cameraPos[2]);
                        }
                        if (!!lightDirLoc) {
                            lightDirVec.CopyFrom(scene.GetLightDir());
                            lightDirVec.MultDirectionByMatrix(viewMatrix);
                            lightDirVec.Normalize();
                            ctx.uniform3f(lightDirLoc, lightDirVec[0], lightDirVec[1], lightDirVec[2]);
                        }
                        if (!!lightColorLoc) {
                            var lightColor = scene.GetLightColor();
                            ctx.uniform3f(lightColorLoc, lightColor[0], lightColor[1], lightColor[2]);
                        }
                        if (!!uViewProjMatrixLoc) {
                            ctx.uniformMatrix4fv(uViewProjMatrixLoc, false, scene.GetViewProj().GetInStaticFloat32Array());
                        }
                        if (!!uProjMatrixLoc) {
                            ctx.uniformMatrix4fv(uProjMatrixLoc, false, scene.GetPerspective().GetInStaticFloat32Array());
                        }
                        if (!!diffuseTexLoc) { ctx.uniform1i(diffuseTexLoc, 0); }
                        if (!!normalTexLoc) { ctx.uniform1i(normalTexLoc, 1); }
                        var tTex = context.GetOnePixelTransparentTexture().GetTexture();
                        ctx.activeTexture(ctx.TEXTURE0 + 0);
                        ctx.bindTexture(ctx.TEXTURE_2D, tTex);
                        ctx.activeTexture(ctx.TEXTURE0 + 1);
                        ctx.bindTexture(ctx.TEXTURE_2D, tTex);
                    }
                    if (!!uModelMatrixLoc) {
                        ctx.uniformMatrix4fv(uModelMatrixLoc, false, renderSettings.objectToSceneMatrix.GetInStaticFloat32Array());
                    }
                    if (!!uModelViewMatrixLoc) {
                        modelViewMatrix.CopyFrom(viewMatrix);
                        modelViewMatrix.MultByMatrix(renderSettings.objectToSceneMatrix);
                        ctx.uniformMatrix4fv(uModelViewMatrixLoc, false, modelViewMatrix.GetInStaticFloat32Array());
                        if (!!uNormalViewMatrixLoc) {
                            normalMatrix.CopyFrom(modelViewMatrix);
                            if (!!renderSettings.usesNonUniformScaling) { normalMatrix.ToInverse(); normalMatrix.ToTransposed(); }
                            ctx.uniformMatrix4fv(uNormalViewMatrixLoc, false, normalMatrix.GetInStaticFloat32Array());
                        }
                    }
                    if (!!uNormalMatrixLoc) {
                        normalMatrix.CopyFrom(renderSettings.objectToSceneMatrix);
                        if (!!renderSettings.usesNonUniformScaling) { normalMatrix.ToInverse(); normalMatrix.ToTransposed(); }
                        ctx.uniformMatrix4fv(uNormalMatrixLoc, false, normalMatrix.GetInStaticFloat32Array());
                    }
                    if (tf.js.GetIsInstanceOf(renderSettings.material, tf.webgl.Material)) { renderSettings.material.SetUniforms(ctx, uniformLocations); }
                    var isComboList = tf.js.GetIsInstanceOf(renderSettings.comboList, tf.webgl.MatTex2VertComboList);
                    if (isComboList) { renderSettings.comboList.Render(ctx, posLoc, norLoc, tex2dLoc, renderSettings, uniformLocations); }
                    else if (tf.js.GetIsInstanceOf(renderSettings.attributes, tf.webgl.VertexBuffer)) {
                        if (!!hasTextureLoc) { var hasTexture = !!texture; ctx.uniform1i(hasTextureLoc, hasTexture ? 1 : 0); }
                        renderSettings.attributes.BindBuffers(posLoc, norLoc, tex2dLoc);
                        renderSettings.attributes.Draw(renderSettings.useLines);
                    }
                }
            });
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.MaterialProgram, tf.webgl.Program);
tf.webgl.GetMaterialVSText = function () {
    return "uniform mat4 uProjMatrix;" + "\n" +
            "uniform mat4 uNormalViewMatrix;" + "\n" +
            "uniform mat4 uModelViewMatrix;" + "\n" +
            "uniform bool hasTexture;" + "\n" +
            "attribute vec3 aPosition;" + "\n" +
            "attribute vec3 aNormal;" + "\n" +
            "attribute vec2 aTexCoord;" + "\n" +
            "varying vec4 vPosition;" + "\n" +
            "varying vec4 vNormal;" + "\n" +
            "varying vec2 vTexCoord;" + "\n" +
            "void main()" + "\n" +
            "{" + "\n" +
                "vPosition = uModelViewMatrix * vec4(aPosition, 1.0);" + "\n" +
                "vNormal = uNormalViewMatrix * normalize(vec4(aNormal, 0.0));" + "\n" +
                "if(hasTexture != false) { vTexCoord = aTexCoord.st; }" + "\n" +
                "gl_Position = uProjMatrix * vPosition;" + "\n" +
            "}";
}
tf.webgl.GetMaterialFSText = function () {
    return "#extension GL_OES_standard_derivatives : enable" + "\n" +
        "precision mediump float;" + "\n" +
        "uniform bool hasTexture;" + "\n" +
        "uniform bool hasNormalTexture;" + "\n" +
        "uniform sampler2D diffuseTex;" + "\n" +
        "uniform sampler2D normalTex;" + "\n" +
        "uniform vec3 uLightDir;" + "\n" +
        "uniform vec3 uLightColor;" + "\n" +
        "uniform vec3 uAmbientLight;" + "\n" +
        "uniform vec3 uAmbientColor;" + "\n" +
        "uniform vec3 uDiffuseColor;" + "\n" +
        "uniform vec3 uEmissiveColor;" + "\n" +
        "uniform vec3 uSpecularColor;" + "\n" +
        "uniform vec4 uOpacityShininess;" + "\n" +
        "varying vec4 vPosition;" + "\n" +
        "varying vec4 vNormal;" + "\n" +
        "varying vec2 vTexCoord;" + "\n" +
        "void main() {" + "\n" +
            "vec3 N = normalize(vNormal.xyz);" + "\n" +
            "vec3 V = -normalize(vPosition.xyz);" + "\n" +
            "vec4 color;" + "\n" +
            "vec3 textureColor;" + "\n" +
            "color = texture2D(diffuseTex, vTexCoord);" + "\n" +
            "if(hasTexture) { textureColor = color.xyz; color.xyz *= uAmbientLight; /*color.a *= uOpacityShininess.x;*/ }" + "\n" +
            "else { color = vec4(uEmissiveColor + uAmbientColor * uAmbientLight, uOpacityShininess.x); }" + "\n" +
            //"if(hasTexture != false) { color = vec4(0.0,0.0,1.0,1.0); }" + "\n" + "else { color = vec4(1.0,0.0,0.0,1.0); }" + "\n" +
            "if (color.a == 0.0) discard;" + "\n" +
            "else {" + "\n" +
                "float dnl = dot(N, uLightDir);" + "\n" +
                "if (dnl > 0.0) {" + "\n" +
                    "if(hasTexture) { color.xyz += uLightColor * textureColor * dnl; } else { color.xyz += uLightColor * uDiffuseColor * dnl; }" + "\n" +
                    //"color.xyz += uLightColor * uDiffuseColor * dnl;" + "\n" +
                    "vec3 R = reflect(-uLightDir, N);" + "\n" +
                    "float specular = pow(max(dot(R, V), 0.0), uOpacityShininess.y);" + "\n" +
                    "color.xyz += uSpecularColor * uLightColor * specular;" + "\n" +
                "}" + "\n" +
                "gl_FragColor = color;" + "\n" +
                //"if(hasNormalTexture) { gl_FragColor = texture2D(normalTex, vTexCoord); }" + "\n" +
            "}" + "\n" +
        "}"
}
/*tf.webgl.GetMaterialFSText = function () {
    return "#extension GL_OES_standard_derivatives : enable" + "\n" +
        "precision mediump float;" + "\n" +
        "uniform bool hasTexture;" + "\n" +
        "uniform bool hasNormalTexture;" + "\n" +
        "uniform sampler2D diffuseTex;" + "\n" +
        "uniform sampler2D normalTex;" + "\n" +
        "uniform vec3 uLightDir;" + "\n" +
        "uniform vec3 uLightColor;" + "\n" +
        "uniform vec3 uAmbientLight;" + "\n" +
        "uniform vec3 uAmbientColor;" + "\n" +
        "uniform vec3 uDiffuseColor;" + "\n" +
        "uniform vec3 uEmissiveColor;" + "\n" +
        "uniform vec3 uSpecularColor;" + "\n" +
        "uniform vec4 uOpacityShininess;" + "\n" +
        "varying vec4 vPosition;" + "\n" +
        "varying vec4 vNormal;" + "\n" +
        "varying vec2 vTexCoord;" + "\n" +
        "mat3 getLocalMat(vec3 N, vec3 p, vec2 uv) {" + "\n" +
            "vec3 dp1 = dFdx(p);" + "\n" +
            "vec3 dp2 = dFdy(p);" + "\n" +
            "vec2 duv1 = dFdx(uv);" + "\n" +
            "vec2 duv2 = dFdy(uv);" + "\n" +
            "vec3 dp2perp = cross(dp2, N);" + "\n" +
            "vec3 dp1perp = cross(N, dp1);" + "\n" +
            "vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;" + "\n" +
            "vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;" + "\n" +
            "float invmax = inversesqrt(max(dot(T,T), dot(B,B)));" + "\n" +
            "return mat3(T * invmax, B * invmax, N);" + "\n" +
        "}" + "\n" +
        "vec3 mapNormal(vec3 vMap, vec3 N, vec3 V, vec2 texcoord) {" + "\n" +
            //"vec3 vMap = texture2D(normalTex, texcoord).xyz;" + "\n" +
            "vMap = vMap * 255./127. - 128./127.;" + "\n" +
            "mat3 localMat = getLocalMat(N, -V, texcoord);" + "\n" +
            "return normalize(localMat * vMap);" + "\n" +
        "}" + "\n" +
        "void main() {" + "\n" +
            "vec3 N = normalize(vNormal.xyz);" + "\n" +
            "vec3 V = -normalize(vPosition.xyz);" + "\n" +
            "vec4 color;" + "\n" +
            "vec3 textureColor;" + "\n" +
            "vec3 vMap = texture2D(normalTex, vTexCoord).xyz;" + "\n" +
            "if(hasNormalTexture) { N = mapNormal(vMap, N, V, vTexCoord); }" + "\n" +
            "color = texture2D(diffuseTex, vTexCoord);" + "\n" +
            "if(hasTexture) { textureColor = color.xyz; color.xyz *= uAmbientLight; }" + "\n" +
            "else { color = vec4(uEmissiveColor + uAmbientColor * uAmbientLight, uOpacityShininess.x); }" + "\n" +
            //"if(hasTexture != false) { color = vec4(0.0,0.0,1.0,1.0); }" + "\n" + "else { color = vec4(1.0,0.0,0.0,1.0); }" + "\n" +
            "if (color.a == 0.0) discard;" + "\n" +
            "else {" + "\n" +
                "float dnl = dot(N, uLightDir);" + "\n" +
                "if (dnl > 0.0) {" + "\n" +
                    "if(hasTexture) { color.xyz += uLightColor * textureColor * dnl; } else { color.xyz += uLightColor * uDiffuseColor * dnl; }" + "\n" +
                    //"color.xyz += uLightColor * uDiffuseColor * dnl;" + "\n" +
                    "vec3 R = reflect(-uLightDir, N);" + "\n" +
                    "float specular = pow(max(dot(R, V), 0.0), uOpacityShininess.y);" + "\n" +
                    "color.xyz += uSpecularColor * uLightColor * specular;" + "\n" +
                "}" + "\n" +
                "gl_FragColor = color;" + "\n" +
                //"if(hasNormalTexture) { gl_FragColor = texture2D(normalTex, vTexCoord); }" + "\n" +
            "}" + "\n" +
        "}"
};*/
/*
"mat3 getLocalMat(vec3 N, vec3 p, vec2 uv) {" + "\n" +
    "vec3 dp1 = dFdx(p);" + "\n" +
    "vec3 dp2 = dFdy(p);" + "\n" +
    "vec2 duv1 = dFdx(uv);" + "\n" +
    "vec2 duv2 = dFdy(uv);" + "\n" +
    "vec3 dp2perp = cross(dp2, N);" + "\n" +
    "vec3 dp1perp = cross(N, dp1);" + "\n" +
    "vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;" + "\n" +
    "vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;" + "\n" +
    "float invmax = inversesqrt(max(dot(T,T), dot(B,B)));" + "\n" +
    "return mat3(T * invmax, B * invmax, N);" + "\n" +
"}" + "\n" +
"vec3 mapNormal(vec3 N, vec3 V, vec2 texcoord) {" + "\n" +
    "vec3 vMap = texture2D(normalTex, texcoord).xyz;" + "\n" +
    "vMap = vMap * 255./127. - 128./127.;" + "\n" +
    "mat3 localMat = getLocalMat(N, -V, texcoord);" + "\n" +
    "return normalize(localMat * vMap);" + "\n" +
"}" + "\n" +
*/
tf.webgl.CreateMaterialFrom3DSMeshMaterial = function (meshMaterial) {
    var name, opacity, shininess, ambient, diffuse, emissive, specular, texFile, normalsFile;
    if (tf.js.GetIsValidObject(meshMaterial) && tf.js.GetIsNonEmptyArray(meshMaterial.properties)) {
        var props = meshMaterial.properties;
        for (var i in props) {
            var prop = props[i];
            var key = prop.key;
            if (tf.js.GetIsStringWithMinLength(key, 2)) {
                switch (key.substr(1).toLowerCase()) {
                    case "mat.name": name = prop.value; break;
                    case "mat.opacity": opacity = prop.value; break;
                    case "mat.shininess": shininess = prop.value / 100; break;
                    case "mat.shadingm": break;
                    case "mat.shinpercent": break;
                    case "mat.bumpscaling": break;
                    case "clr.ambient": ambient = prop.value; break;
                    case "clr.diffuse": diffuse = prop.value; break;
                    case "clr.emissive": emissive = prop.value; break;
                    case "clr.specular": specular = prop.value; break;
                    case "tex.mapmodeu": break;
                    case "tex.mapmodev": break;
                    case "tex.uvtrafo": break;
                    case "tex.file": case "tex.file.diffuse": texFile = prop.value; break;
                    case "tex.file.normals": normalsFile = prop.value; break;
                    case "tex.blend": break;
                }
            }
        }
    }
    return new tf.webgl.Material({
        name: name, opacity: opacity, shininess: shininess, ambient: ambient, diffuse: diffuse, emissive: emissive, specular: specular,
        texFile: texFile, normalsFile: normalsFile
    });
}
tf.webgl.CreateVertexBufferFrom3DSMesh = function (context, mesh, scale) {
    var vertexBuffer, maxs, mins;
    if (tf.js.GetIsInstanceOf(context, tf.webgl.Context) && !!context.GetContext() &&
        tf.js.GetIsValidObject(mesh)) {
        var pos;
        scale = scale !== undefined ? tf.js.GetFloatNumber(scale) : 1;
        if (scale == 0) { scale = 1 }
        var nVertices, maxVertexIndex;
        if (mesh.vertices != undefined) {
            var verts = mesh.vertices;
            nVertices = verts.length;
            maxVertexIndex = Math.floor(nVertices / 3);
            if (maxVertexIndex > 0) {
                maxs = [verts[0] * scale, verts[1] * scale, verts[2] * scale];
                mins = [maxs[0], maxs[1], maxs[2]];
                for (var index = 0, i = 0 ; i < maxVertexIndex ; ++i) {
                    for (var j = 0 ; j < 3 ; ++j, ++index) {
                        var val = verts[index] * scale;
                        if (val < mins[j]) { mins[j] = val; } else if (val > maxs[j]) { maxs[j] = val; }
                        verts[index] = val;
                    }
                }
            }
            pos = new tf.webgl.PosBuffer({ context: context, data: new Float32Array(mesh.vertices) })
        }
        else {
            maxVertexIndex = nVertices = 0;
        }
        var nor = mesh.normals != undefined ? new tf.webgl.NorBuffer({ context: context, data: new Float32Array(mesh.normals) }) : undefined;
        var tex2d, tex2dData;
        if (mesh.texturecoords == undefined) {
            //tex2dData = new Float32Array(maxVertexIndex * 2);
        }
        else {
            tex2dData = new Float32Array(mesh.texturecoords[0]);
        }
        var tex2d = tex2dData !== undefined ? new tf.webgl.Tex2DBuffer({ context: context, data: tex2dData }) : undefined;
        //tex2d = undefined;
        var indices;
        if (mesh.faces != undefined) {
            var faces = mesh.faces;
            var nFaces = faces.length;
            var nIndices = nFaces * 3;
            var is8 = maxVertexIndex < 256, is16 = maxVertexIndex < 256 * 256, is32 = !is16;
            var indexData = is8 ? new Uint8Array(nIndices) : (is16 ? new Uint16Array(nIndices) : new Uint32Array(nIndices));
            for (var j = 0, k = 0 ; j < nFaces ; ++j) { for (var l = 0 ; l < 3 ; ++l) { indexData[k++] = faces[j][l]; } }
            indices = new tf.webgl.IndexBuffer({ context: context, data: indexData, is8: is8, is16: is16, is32: is32 });
        }
        vertexBuffer = new tf.webgl.VertexBuffer({
            cullFrontFace: false,
            context: context, pos: pos, nor: nor, tex2d: tex2d, indices: indices
        });
    }
    return { vertexBuffer: vertexBuffer, maxs: maxs, mins: mins };
}
tf.webgl.Load3DSModel2 = function (context, object, scale, mergeBuffers) {
    var comboList, combos, namedMeshes, mins, maxs;
    function createVertexBuffers(node) {
        if (tf.js.GetIsValidObject(node)) {
            if (tf.js.GetIsNonEmptyArray(node.meshes)) {
                var nMeshes = node.meshes.length;
                for (var i = 0 ; i < nMeshes ; ++i) {
                    var meshIndex = node.meshes[i];
                    if (meshIndex == "$$$DUMMY") {
                        console.log('here');
                    }
                    var mesh = namedMeshes[meshIndex];
                    if (tf.js.GetIsValidObject(mesh)) {
                        var meshMaterialIndex = mesh.materialindex;
                        if (meshMaterialIndex >= 0 && meshMaterialIndex < combos.length) {
                            var results = tf.webgl.CreateVertexBufferFrom3DSMesh(context, mesh, scale);
                            if (!!results && !!results.vertexBuffer) {
                                if (mins == undefined) { mins = results.mins.slice(0); maxs = results.maxs.slice(0); }
                                else {
                                    for (var minMaxIndex = 0; minMaxIndex < 3 ; ++minMaxIndex) {
                                        if (mins[minMaxIndex] > results.mins[minMaxIndex]) { mins[minMaxIndex] = results.mins[minMaxIndex]; }
                                        if (maxs[minMaxIndex] < results.maxs[minMaxIndex]) { maxs[minMaxIndex] = results.maxs[minMaxIndex]; }
                                    }
                                }
                                combos[meshMaterialIndex].AddVertexBuffer(results.vertexBuffer);
                            }
                        }
                    }
                }
            }
            for (var i in node.children) { createVertexBuffers(node.children[i]); }
        }
    }
    if (tf.js.GetIsInstanceOf(context, tf.webgl.Context) && !!context.GetContext() &&
        tf.js.GetIsValidObject(object) && tf.js.GetIsValidObject(object.rootnode) &&
        tf.js.GetIsNonEmptyArray(object.materials) &&
        tf.js.GetIsNonEmptyArray(object.meshes)) {
        combos = [];
        namedMeshes = {};
        scale = tf.js.GetFloatNumber(scale, 1.0);
        for (var i in object.materials) {
            var mat3ds = object.materials[i];
            var mat = tf.webgl.CreateMaterialFrom3DSMeshMaterial(mat3ds);
            var matSettings = mat.GetSettings();
            var texFile = matSettings.texFile;
            var texture2 = tf.js.GetIsNonEmptyString(texFile) ? new tf.webgl.Texture2({ context: context, url: texFile }) : undefined;
            var normalsFile = matSettings.normalsFile;
            var normalsTexture2 = tf.js.GetIsNonEmptyString(normalsFile) ? new tf.webgl.Texture2({ context: context, url: normalsFile, unit: 1 }) : undefined;
            var combo = new tf.webgl.MatTex2VertCombo({ material: mat, texture2: texture2, normalsTexture2: normalsTexture2, vertices: undefined });
            combos.push(combo);
        }
        for (var i in object.meshes) { var mesh = object.meshes[i]; namedMeshes[mesh.name] = mesh; }
        createVertexBuffers(object.rootnode);
        comboList = new tf.webgl.MatTex2VertComboList({ combos: combos, mergeBuffers: mergeBuffers });
        //sceneObject = new tf.webgl.SceneObject({ context: context, program: context.GetMaterialProgram(), comboList: comboList, attributes: undefined, texture: undefined, matrix: undefined });
    }
    return { comboList: comboList, mins: mins, maxs: maxs };
};
tf.webgl.Load3DSModel = function (context, object, scale, mergeBuffers) {
    var comboList, combos, mins, maxs;
    if (tf.js.GetIsInstanceOf(context, tf.webgl.Context) && !!context.GetContext() &&
        tf.js.GetIsValidObject(object) && tf.js.GetIsValidObject(object.rootnode) &&
        tf.js.GetIsNonEmptyArray(object.materials) &&
        tf.js.GetIsNonEmptyArray(object.meshes)) {
        combos = [];
        scale = tf.js.GetFloatNumber(scale, 1.0);
        for (var i in object.materials) {
            var mat3ds = object.materials[i];
            var mat = tf.webgl.CreateMaterialFrom3DSMeshMaterial(mat3ds);
            var matSettings = mat.GetSettings();
            var texFile = matSettings.texFile;
            var texture2 = tf.js.GetIsNonEmptyString(texFile) ? new tf.webgl.Texture2({ context: context, url: texFile }) : undefined;
            var normalsFile = matSettings.normalsFile;
            var normalsTexture2 = tf.js.GetIsNonEmptyString(normalsFile) ? new tf.webgl.Texture2({ context: context, url: normalsFile, unit: 1 }) : undefined;
            var combo = new tf.webgl.MatTex2VertCombo({ material: mat, texture2: texture2, normalsTexture2: normalsTexture2, vertices: undefined });
            combos.push(combo);
        }
        for (var i in object.meshes) {
            var mesh = object.meshes[i];
            if (tf.js.GetIsValidObject(mesh)) {
                var meshMaterialIndex = mesh.materialindex;
                if (meshMaterialIndex >= 0 && meshMaterialIndex < combos.length) {
                    var results = tf.webgl.CreateVertexBufferFrom3DSMesh(context, mesh, scale);
                    if (!!results && !!results.vertexBuffer) {
                        if (mins == undefined) { mins = results.mins.slice(0); maxs = results.maxs.slice(0); }
                        else {
                            for (var minMaxIndex = 0; minMaxIndex < 3 ; ++minMaxIndex) {
                                if (mins[minMaxIndex] > results.mins[minMaxIndex]) { mins[minMaxIndex] = results.mins[minMaxIndex]; }
                                if (maxs[minMaxIndex] < results.maxs[minMaxIndex]) { maxs[minMaxIndex] = results.maxs[minMaxIndex]; }
                            }
                        }
                        combos[meshMaterialIndex].AddVertexBuffer(results.vertexBuffer);
                    }
                }
            }
        }
        comboList = new tf.webgl.MatTex2VertComboList({ combos: combos, mergeBuffers: mergeBuffers });
        //sceneObject = new tf.webgl.SceneObject({ context: context, program: context.GetMaterialProgram(), comboList: comboList, attributes: undefined, texture: undefined, matrix: undefined });
    }
    return { comboList: comboList, mins: mins, maxs: maxs };
};
/*
tf.webgl.Load3DSModel2 = function (context, object, scale) {
    function buildSceneObjectNode(root, node) {
        var sceneObject;
        if (tf.js.GetIsValidObject(node)) {
            //var transformMatrix = new tf.math.Matrix4({ matrix: node.transformation })
            sceneObject = new tf.webgl.SceneObject({ context: context, attributes: undefined, texture: undefined, program: undefined });
            if (tf.js.GetIsNonEmptyArray(node.meshes)) {
                var nMeshes = node.meshes.length;
                //var program = context.GetTextureColorProgram();
                var program = context.GetMaterialProgram();
                var texture = context.GetFourColorTexture();
                for (var i = 0 ; i < nMeshes ; ++i) {
                    var meshIndex = node.meshes[i];
                    var mesh = root.namedMeshes[meshIndex];
                    if (!!mesh) {
                        var attributes = tf.webgl.CreateVertexBufferFrom3DSMesh(context, mesh, scale).vertexBuffer;
                        var material;
                        var meshMaterial = root.materials[mesh.materialindex];
                        if (!!meshMaterial) { material = tf.webgl.CreateMaterialFrom3DSMeshMaterial(meshMaterial); }
                        var meshObject = new tf.webgl.SceneObject({
                            material: material,
                            context: context, attributes: attributes, texture: texture, program: program
                        });
                        sceneObject.AddSubObject(meshObject);
                    }
                }
            }
            if (tf.js.GetIsNonEmptyArray(node.children)) {
                for (var i in node.children) {
                    var subObj = buildSceneObjectNode(root, node.children[i]);
                    if (!!subObj) { sceneObject.AddSubObject(subObj); }
                }
            }
        }
        return sceneObject;
    }
    var sceneObject;
    if (tf.js.GetIsInstanceOf(context, tf.webgl.Context) && !!context.GetContext() &&
        tf.js.GetIsValidObject(object) && tf.js.GetIsValidObject(object.rootnode)) {
        scale = tf.js.GetFloatNumber(scale, 1.0);
        object.namedMeshes = {};
        for (var i in object.meshes) {
            var mesh = object.meshes[i];
            var meshName = mesh.name;
            object.namedMeshes[meshName] = mesh;
        }
        sceneObject = buildSceneObjectNode(object, object.rootnode)
    }
    return sceneObject;
};
tf.webgl.Check3DSModel = function (object) {
    function dumpNode(level, node) {
        if (tf.js.GetIsValidObject(node)) {
            var logStr = 'level: ' + level + ' node: ' + node.name + ' ';
            if (tf.js.GetIsValidObject(node.meshes)) {
                if (!tf.js.GetIsArrayWithLength(node.meshes, 1)) {
                    console.log(logStr + node.meshes.length + ' meshes');
                }
            }
            else {
                console.log(logStr + 'no meshes');
            }
            if (tf.js.GetIsNonEmptyArray(node.children)) {
                for (var i in node.children) {
                    dumpNode(level + 1, node.children[i]);
                }
            }
        }
    }
    function checkMeshes(object) {
        var nWithTexture = 0, nWithNormals = 0;
        console.log('nMeshes: ' + object.meshes.length);
        var allMaxs, allMins;
        for (var i in object.meshes) {
            var mesh = object.meshes[i];
            var meshName = mesh.name;
            var primitiveTypes = mesh.primitivetypes;
            if (i != meshName) {
                if (object.namedMeshes[meshName] == undefined) {
                    console.log('mesh: ' + meshName + ' name differs from index and is not found');
                }
            }
            if (primitiveTypes != 4) {
                console.log('mesh: ' + meshName + ' primitiveTypes is not 4: ' + primitiveTypes);
            }
            if (!!mesh.texturecoords) { ++nWithTexture; }
            if (!!mesh.normals) { ++nWithNormals; }
            var vertices = mesh.vertices;
            if (tf.js.GetIsArrayWithMinLength(vertices, 1)) {
                var nVertices = vertices.length;
                var maxs = [vertices[0], vertices[1], vertices[2]];
                var mins = [vertices[0], vertices[1], vertices[2]];
                for (var j = 3 ; j < nVertices ; j += 3) {
                    for (var k = 0 ; k < 3 ; ++k) {
                        var thisCoord = vertices[j + k];
                        if (thisCoord > maxs[k]) { maxs[k] = thisCoord; }
                        if (thisCoord < mins[k]) { mins[k] = thisCoord; }
                    }
                }
                //console.log('mesh: ' + meshName + ' maxs: ' + maxs + ' mins: ' + mins);
                if (allMaxs == undefined) {
                    allMaxs = maxs.slice(0);
                    allMins = mins.slice(0);
                }
                else {
                    for (var j = 0 ; j < 3 ; ++j) {
                        var thisMax = maxs[j], thisMin = mins[j];
                        if (thisMax > allMaxs[j]) { allMaxs[j] = thisMax; }
                        if (thisMin < allMins[j]) { allMins[j] = thisMin; }
                    }
                }
                var faces = mesh.faces;
                if (tf.js.GetIsArrayWithMinLength(faces, 1)) {
                    for (var j in faces) {
                        var face = faces[j];
                        for (var k in face) {
                            var vertexIndex = face[k];
                            if (vertexIndex < 0 || vertexIndex >= nVertices) {
                                console.log('mesh: ' + meshName + ' face: ' + j + ' index: ' + k + ' is invalid: ' + vertexIndex + ' out of ' + nVertices);
                            }
                        }
                    }
                }
                else {
                    console.log('mesh: ' + meshName + ' has no faces');
                }
            }
            else {
                console.log('mesh: ' + meshName + ' has no vertices');
            }
        }
        console.log('meshes with texture: ' + nWithTexture + ' meshes with normals: ' + nWithNormals);
        if (!!allMaxs) { console.log('meshes allMaxs: ' + allMaxs + ' allMins: ' + allMins); }
    }
    function checkMaterials(object) {
        var materialFields = {};
        for (var i in object.materials) {
            var material = object.materials[i];
            for (var j in material.properties) {
                var prop = material.properties[j];
                var index = prop.index;
                var semantic = prop.semantic;
                var key = prop.key;
                if (index != 0) {
                    console.log('index mat/obj: ' + i + ' / ' + j + ' index: ' + index);
                }
                if (semantic != 0 && semantic != 1 && semantic != 5 && semantic != 7) {
                    console.log('semantic mat/obj: ' + i + ' / ' + j + ' semantic: ' + semantic);
                }
                if (materialFields[key] == undefined) {
                    materialFields[key] = {};
                }
                if (materialFields[key][typeof prop.value] == undefined) {
                    materialFields[key][typeof prop.value] = [];
                }
                materialFields[key][typeof prop.value].push(prop.value);
                switch (key) {
                    case "?mat.name":
                    case "$mat.opacity":
                    case "$mat.shininess":
                    case "$mat.shadingm":
                    case "$mat.shinpercent":
                    case "$mat.bumpscaling":
                    case "$clr.ambient":
                    case "$clr.diffuse":
                    case "$clr.emissive":
                    case "$clr.specular": break;
                    case "$tex.mapmodeu":
                    case "$tex.mapmodev":
                    case "$tex.uvtrafo":
                    case "$tex.file":
                    case "$tex.blend":
                        console.log(key + ' ' + prop.value);
                        break;
                    default:
                        console.log('new material key: ' + key);
                        break;
                }
            }
        }
        //console.log(materialFields);
    }
    if (tf.js.GetIsValidObject(object) && tf.js.GetIsValidObject(object.rootnode)) {
        object.namedMeshes = {};
        for (var i in object.meshes) {
            var mesh = object.meshes[i];
            var meshName = mesh.name;
            object.namedMeshes[meshName] = mesh;
        }
        dumpNode(0, object.rootnode);
        checkMeshes(object);
        checkMaterials(object);
    }
};
*/
tf.webgl.MapMarker = function (settings) {
    var theThis, map, mapObject, sceneObject, attributes, mapCoords, context, texture, canvas, perspectiveMap, scale;
    this.GetSettings = function () { return settings; }
    this.IsDeleted = function () { return isDeleted(); }
    //this.OnDelete = function () { return onDelete(); }
    this.Update = function () { return update(); }
    this.GetSceneObject = function () { return sceneObject; }
    this.GetMapObject = function () { return mapObject; }
    function isDeleted() { return map == undefined; }
    function createCanvas(markerSettings) {
        if (!!markerSettings.marker) {
            var options = {
                dontTranslate: true,
                font_height: 14, font_color: "#000", border_line_color: "#00b", border_line_width: 2, line_opacity: 0.6,
                line_width: 3, line_color: "#fff", arrow_length: 14, label: "v", fill_color: "#ffe57f", horpos: "center", verpos: "top", fill_opacity: 0.8, border_line_opacity: 0.6
            };
            options = tf.js.GetIsValidObject(markerSettings) ? markerSettings : options;
            canvas = tf.canvas.CreateMemoryImage({ drawFunction: tf.canvas.DrawTextMarkerImage, drawSettings: options }).image;
            updateScale();
        }
        else {
            canvas = document.createElement('canvas');
            canvas.width = canvas.height = 1;
            var img = new tf.dom.Img({
                crossOrigin: true,
                src: markerSettings.icon_url,
                onLoad: function (img) {
                    if (img.GetIsValid()) {
                        var imgElem = img.GetImg();
                        var w = imgElem.width, h = imgElem.height, l = 0, t = 0;
                        var ctx = canvas.getContext('2d');
                        if (markerSettings.useFrame) {
                            var margin = 3, margin2 = margin + margin;
                            w += margin2;
                            h += margin2;
                            canvas.width = w;
                            canvas.height = h;
                            l += margin;
                            t += margin;
                            tf.canvas.DrawRoundRect(ctx, {
                                dontTranslate: true,
                                width: w, height: h, radius: margin, fill: true, fill_color: "rgba(255, 255, 255, 1)", line: true, line_color: 'rgba(192, 192, 192, 0.8)', line_width: 2
                            });
                        }
                        else {
                            canvas.width = w;
                            canvas.height = h;
                        }
                        ctx.drawImage(imgElem, l, t);
                        texture.UpdateFromImage(canvas, true);
                        updateScale();
                    }
                }
            });
        }
        return canvas;
    }
    function createTexture(markerSettings) {
        texture = new tf.webgl.Texture2({ context: context, img: createCanvas(markerSettings), flipVerticalBool: true });
    }
    function updateScale() {
        if (!isDeleted()) {
            var pos = attributes.GetPos();
            if (!!pos) {
                var cw = canvas.width, ch = canvas.height;
                var canvasAspect = cw > 0 ? ch / cw : 1;
                var scaleScale = 1;
                var x = 1 / (canvasAspect * 2), z = 0, y = 0.5;
                var vertices = new Float32Array([x, y, z, -x, y, z, -x, -y, z, x, -y, z]);
                scale = ch * scaleScale;;
                pos.Update(vertices);
            }
        }
    }
    function update() {
        if (!isDeleted()) {
            var scaleUse = scale / perspectiveMap.GetMapSize()[1];
            sceneObject.GetObjectToSceneMatrix().UpdateWorld({
                //rotate: { angle: 45 * Math.PI / 180, axisx: 0, axisy: 1, axisz: 0 },
                translate: { tx: 0, ty: 0.5 * scaleUse, tz: 0 },
                scale: { sx: scaleUse, sy: scaleUse, sz: scaleUse }
            });
        }
    }
    function initialize() {
        if ((tf.js.GetIsValidObject(settings)) &&
            tf.js.GetIsInstanceOf(settings.perspectiveMap, tf.webgl.PerspectiveMap)) {
            perspectiveMap = settings.perspectiveMap;
            map = perspectiveMap.GetMap();
            context = perspectiveMap.GetContext();
            mapCoords = tf.js.GetMapCoordsFrom(settings.mapCoords);
            scale = 1;
            if (tf.js.GetIsValidObject(settings.sceneObject)) { sceneObject = settings.sceneObject; }
            else {
                var program = context.GetTextureColorProgram();
                attributes = new tf.webgl.QuadXY({ context: context });
                createTexture(settings.style);
                sceneObject = new tf.webgl.SceneObject({
                    onPreRender: update, context: context, attributes: attributes, texture: texture, program: program
                });
            }
            var skipRotate = settings.skipRotate !== undefined ? !!settings.skipRotate : true;
            var skipScale = settings.skipScale !== undefined ? !!settings.skipScale : true;
            mapObject = perspectiveMap.CreateMapObject({
                mapMarker: theThis,
                mapCoords: mapCoords, sceneObject: sceneObject, skipRotate: skipRotate, skipScale: skipScale, usePick: settings.usePick
            });
        }
        else { map = undefined; }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.webgl.MapObject = function (settings) {
    var theThis, map, sceneObjectHolder, sceneObject, mapCoords, context, skipRotate, skipScale, perspectiveMap, pickColor, pickID, scale, scaleMatrix;
    this.SetScale = function (scale) { return setScale(scale); }
    this.GetScale = function () { return scale; }
    this.GetSettings = function () { return settings; }
    this.GetPickColor = function () { return pickColor; }
    this.GetPickID = function () { return pickID; }
    this.OnDelete = function () { return onDelete(); }
    this.IsDeleted = function () { return isDeleted(); }
    this.Update = function () { return update(); }
    this.GetSceneObject = function () { return sceneObject; }
    this.GetSceneObjectHolder = function () { return sceneObjectHolder; }
    function isDeleted() { return map == undefined; }
    function onDelete() {
        if (!isDeleted()) {
            if (!!pickID) { context.UnRegisterForPick(pickID); }
            map.SetPixelTranslateCallBack(undefined);
            pickID = map = sceneObject = sceneObjectHolder = context = perspectiveMap = undefined;
        }
    }
    function setScale(scaleSet) {
        scale = tf.js.GetFloatNumber(scaleSet, 1);
        if (scale != 1) {
            scaleMatrix.SetScale({ sx: scale, sy: scale, sz: scale });
        }
    }
    function update() {
        if (!isDeleted()) {
            sceneObjectHolder.GetObjectToSceneMatrix().UpdateWorld(perspectiveMap.GetMapToWorldSpecs(mapCoords, skipRotate, skipScale));
            if (scale != 1) {
                sceneObjectHolder.GetObjectToSceneMatrix().MultByMatrix(scaleMatrix);
            }
            sceneObject.SetPickColor(pickColor);
        }
    }
    function initialize() {
        if ((tf.js.GetIsValidObject(settings)) &&
            (!!(map = tf.js.GetMapFrom(settings.map))) &&
            tf.js.GetIsInstanceOf(settings.context, tf.webgl.Context) && !!settings.context.GetContext() &&
            tf.js.GetIsInstanceOf(settings.sceneObject, tf.webgl.SceneObject)) {
            perspectiveMap = settings.perspectiveMap;
            context = settings.context;
            mapCoords = tf.js.GetMapCoordsFrom(settings.mapCoords);
            sceneObject = settings.sceneObject;
            pickID = tf.js.GetBoolFromValue(settings.usePick) ? context.RegisterForPick(theThis) : 0;
            if (!!pickID) { pickColor = tf.webgl.EncodeIntIntoColor(pickID); }
            sceneObjectHolder = new tf.webgl.SceneObject({ context: context, attributes: undefined, texture: undefined, program: undefined });
            sceneObjectHolder.AddSubObject(sceneObject);
            sceneObjectHolder.SetOnPreRender(update);
            scaleMatrix = new tf.math.ScaleMatrix4();
            setScale(settings.scale);
            skipRotate = !!settings.skipRotate;
            skipScale = !!settings.skipScale;
        }
        else { map = undefined; }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.webgl.MapObjectGroup = function (settings) {
    var theThis, perspectiveMap, groupObject, scene;
    this.GetGroupObject = function () { return groupObject; }
    this.AddObject = function (object) { return addObject(object); }
    this.DelObject = function (object) { return delObject(object); }
    this.DelAllSubObjects = function () { return delAllSubObjects(); }
    this.OnDelete = function () { return onDelete(); }
    this.IsDeleted = function () { return isDeleted(); }
    function delObject(object) {
        if (!isDeleted && tf.js.GetIsInstanceOf(object, tf.webgl.MapObject)) {
            groupObject.DelSubObject(object.GetSceneObjectHolder());
        }
    }
    function addObject(object) {
        if (!isDeleted() && tf.js.GetIsInstanceOf(object, tf.webgl.MapObject)) {
            if (!object.IsDeleted()) { groupObject.AddSubObject(object.GetSceneObjectHolder()); }
        }
        return object;
    }
    function isDeleted() { return perspectiveMap == undefined; }
    function delAllSubObjects() { if (!isDeleted()) { groupObject.DelAllSubObjects(); } }
    function onDelete() {
        if (!isDeleted()) {
            scene.DelObject(groupObject);
            groupObject.DelAllSubObjects();
            scene = groupObject = perspectiveMap = undefined;
        }
    }
    function initialize() {
        if ((tf.js.GetIsValidObject(settings)) && tf.js.GetIsInstanceOf(settings.perspectiveMap, tf.webgl.PerspectiveMap)) {
            (scene = (perspectiveMap = settings.perspectiveMap).GetScene()).AddObject(groupObject = new tf.webgl.SceneObject({ context: perspectiveMap.GetContext() }));
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * @public
 * @description {@link tf.webgl.PerspectiveMap} lost device event
*/
tf.consts.perspectiveMapLostDeviceEvent = "lostdevice";
/**
 * @public
 * @description {@link tf.webgl.PerspectiveMap} restored device event
*/
tf.consts.perspectiveMapRestoredDeviceEvent = "restoreddevice";
/**
 * @public
 * @description {@link tf.webgl.PerspectiveMap} visibility change event
*/
tf.consts.perspectiveMapVisibilityChangeEvent = "visibilityChange";
/**
 * @public
 * @description {@link tf.webgl.PerspectiveMap} mapObject hover in and out event
*/
tf.consts.perspectiveMapObjectHoverInOutEvent = "objecthoverinout";
/**
 * @public
 * @description {@link tf.webgl.PerspectiveMap} mapObject click event
*/
tf.consts.perspectiveMapObjectClickEvent = "objectclick";
/**
 * @public
 * @description {@link tf.webgl.PerspectiveMap} map mouse move event
*/
tf.consts.perspectiveMapMouseMoveEvent = "mapmousemove";
/**
 * @public
 * @description {@link tf.webgl.PerspectiveMap} map click event
*/
tf.consts.perspectiveMapClickEvent = "mapclick";
/**
 * @public
 * @description {@link tf.webgl.PerspectiveMap} post compose event
*/
tf.consts.perspectiveMapPostComposeEvent = "postcompose";
tf.consts.allPerspectiveMapEventNames = [
    tf.consts.perspectiveMapVisibilityChangeEvent,
    tf.consts.perspectiveMapObjectHoverInOutEvent,
    tf.consts.perspectiveMapObjectClickEvent,
    tf.consts.perspectiveMapPostComposeEvent,
    tf.consts.perspectiveMapLostDeviceEvent,
    tf.consts.perspectiveMapRestoredDeviceEvent,
    tf.consts.perspectiveMapMouseMoveEvent = "mapmousemove",
    tf.consts.perspectiveMapClickEvent = "mapclick"
];
tf.webgl.PerspectiveMap = function (settings) {
    var theThis, map, webGL, context, ctx, canvas, mapTexture, htmlControl;
    var scene, mapSceneObject, objectCreationSettings;
    var viewRadius, viewAngle, viewZOff, mapSize, mapAspect, mapCenter, mapRotationRad, mapCosRotationRad, mapSinRotationRad, mapResolution, mapScale;
    var allEventDispatchers;
    var hasMapCenter, hasMeasure, hasDownload, mapMouseMoveListener, mapMouseClickListener;
    var renderCount, pickFrameBufferRenderCount, pickFrameBufferDim, pickFrameBuffer, pickedColor, lastHoveredMapObject;
    var inversePerspective, ptOrigin, vYAxisUnit, cameraPos, cameraDir;
    var renderMap, renderMapXScale, renderMapYScale, forceUpdatePerspective;
    var pickFrameBufferSceneObject;
    this.GetMapSize = function () { return mapSize; }
    this.GetLastHoveredMapObject = function () { return lastHoveredMapObject; }
    this.AddListener = function (eventName, callBack) { return allEventDispatchers.AddListener(eventName, callBack); }
    this.GetIsVisible = function () { return getIsVisible(); }
    this.SetIsVisible = function (bool) { return setIsVisible(bool); }
    this.IsDeleted = function () { return isDeleted(); }
    this.OnDelete = function () { return onDelete(); }
    this.GetContext = function () { return context; }
    this.GetMap = function () { return map; }
    this.GetScene = function () { return scene; }
    this.GetMapToWorldSpecs = function (mapCoords, skipRotate, skipScale) { return getMapToWorldSpecs(mapCoords, skipRotate, skipScale); }
    this.GetMapToWorldTransform = function (mapCoords, skipRotate, skipScale) { return new tf.math.WorldMatrix4(getMapToWorldSpecs(mapCoords, skipRotate, skipScale)); }
    this.CreateMapMarker = function (settings) { return new tf.webgl.MapMarker(mergeCreationSettings(settings)); }
    this.CreateMapObject = function (settings) { return new tf.webgl.MapObject(mergeCreationSettings(settings)); }
    function mergeCreationSettings(settings) { return tf.js.ShallowMerge(settings, objectCreationSettings); }
    function onDelete() {
        if (!isDeleted()) {
            if (!!mapMouseMoveListener) { mapMouseMoveListener.OnDelete(); }
            if (!!mapMouseClickListener) { mapMouseClickListener.OnDelete(); }
            mapMouseClickListener = mapMouseMoveListener = webGL = undefined;
        }
    }
    function isDeleted() { return webGL == undefined; }
    function getIsVisible() { return !isDeleted() && (!!htmlControl ? htmlControl.GetIsVisible() : false); }
    function setIsVisible(bool) {
        if (!isDeleted()) {
            if (getIsVisible() != (bool = !!bool)) {
                if (!!htmlControl) { htmlControl.SetVisible(bool); }
                notifyListeners(tf.consts.perspectiveMapVisibilityChangeEvent);
                updateMapVisibleControls();
                if (bool) { if (context.IsContextLost()) { context.RestoreContext(); } else { onFrame(); } }
            }
        }
    }
    function updateMapVisibleControls() {
        var isVisible = getIsVisible();
        map.ShowPanel(tf.consts.panelNameMeasure, !isVisible && hasMeasure);
        map.ShowPanel(tf.consts.panelNameDownload, !isVisible && hasDownload);
    }
    function intersectRayPlane(rayOrigin, rayDirection, planeOrigin, planeNormal) {
        var ptIntersect, planeNormalDotRayDirection = planeNormal.Dot(rayDirection);
        if (Math.abs(planeNormalDotRayDirection) > 0.0000001) {
            var diffV = new tf.math.Vector3({ vector: planeOrigin }); diffV.Sub(rayOrigin);
            var planeNormalDotDiffV = planeNormal.Dot(diffV);
            var distance = planeNormalDotDiffV / planeNormalDotRayDirection;
            var rayDir = new tf.math.Vector3({ vector: rayDirection });
            rayDir.MultByScalar(distance);
            ptIntersect = new tf.math.Vector3({ vector: rayOrigin });
            ptIntersect.Add(rayDir);
        }
        return ptIntersect;
    }
    function mapPixelCoordsToPerspectiveMapQuadCoords(pixelCoords) {
        var x = (2 * pixelCoords[0]) / mapSize[0] - 1;
        var y = 1 - (2 * pixelCoords[1]) / mapSize[1];
        var view = scene.GetView();
        cameraPos.Update(view.GetView().vFrom);
        cameraDir.Update({ x: x, y: y, z: 1 });
        cameraDir.MultByMatrix(inversePerspective);
        cameraDir.MultByMatrix(view.GetInverse());
        cameraDir.Sub(cameraPos);
        cameraDir.Normalize();
        return intersectRayPlane(cameraPos, cameraDir, ptOrigin, vYAxisUnit);
    }
    function updateInversePerspective() {
        if (!isDeleted()) {
            inversePerspective.CopyFrom(scene.GetPerspective()); inversePerspective.ToInverse();
            if (!!mapSceneObject) {
                var x = 1 / (mapAspect * 2), y = 0, z = 0.5;
                x *= renderMapXScale;
                z *= renderMapYScale;
                var vertices = new Float32Array([x, y, -z, -x, y, -z, -x, y, z, x, y, z]);
                mapSceneObject.GetAttributes().GetPos().Update(vertices);
            }
        }
    }
    function updateMapSettings() {
        mapSize = map.GetPixelSize();
        if (mapSize[0] <= 0) { mapSize[0] = 1; }
        if (mapSize[1] <= 0) { mapSize[1] = 1; }
        mapAspect = mapSize[1] / mapSize[0];
        var isAnimating = map.GetIsAnimating();
        //mapCenter = map.GetCenter();
        //mapCenter = map.GetInstantCenter();
        mapCenter = isAnimating ? map.GetCenter() : map.GetInstantCenter();
        mapRotationRad = map.GetRotationRad();
        mapCosRotationRad = Math.cos(mapRotationRad);
        mapSinRotationRad = Math.sin(mapRotationRad);
        //mapResolution = map.GetResolution();
        //mapResolution = map.GetInstantResolution();
        mapResolution = isAnimating ? map.GetResolution() : map.GetInstantResolution();
        mapScale = 1 / (mapResolution * mapSize[1]);
        //renderMap.Render();
        if (canvas.clientWidth != canvas.width || canvas.clientHeight != canvas.height || forceUpdatePerspective) {
            forceUpdatePerspective = false;
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            scene.GetPerspective().UpdateAspect(1 / mapAspect);
            updateInversePerspective();
        }
    }
    function getMapToWorldSpecs(mapCoords, skipRotate, skipScale) {
        mapCoords = tf.js.GetMapCoordsFrom(mapCoords);
        var distXCoord = [mapCoords[0], mapCenter[1]];
        var distZCoord = [mapCenter[0], mapCoords[1]];
        var distX = tf.units.GetDistanceInMetersBetweenMapCoords(mapCenter, distXCoord) / mapResolution;
        var distZ = -tf.units.GetDistanceInMetersBetweenMapCoords(mapCenter, distZCoord) / mapResolution;
        if (mapCenter[0] < mapCoords[0]) { distX = -distX; }
        if (mapCenter[1] < mapCoords[1]) { distZ = -distZ; }
        var newDistX = distX * mapCosRotationRad - distZ * mapSinRotationRad;
        var newDistZ = distX * mapSinRotationRad + distZ * mapCosRotationRad;
        distX = newDistX / (mapSize[0]) / mapAspect;
        distZ = newDistZ / (mapSize[1]);
        var rotate = !!skipRotate ? undefined : { angle: -mapRotationRad, axisx: 0, axisy: 1, axisz: 0 };
        var scale = !!skipScale ? undefined : { sx: mapScale, sy: mapScale, sz: mapScale };
        return { scale: scale, rotate: rotate, translate: { tx: -distX, ty: 0, tz: -distZ } };
    }
    function mapPixelCoordsToPerspectivePixelCoords(pixelCoords) {
        var coords;
        var mapQuadCoords = mapPixelCoordsToPerspectiveMapQuadCoords(pixelCoords);
        if (!!mapQuadCoords) {
            coords = [
                (mapQuadCoords[0] * mapAspect + 0.5) * mapSize[0],
                (mapQuadCoords[2] + 0.5) * mapSize[1]
            ];
        }
        return coords;
    }
    function mapPixelCoordsToPerspectiveMapCoords(pixelCoords) {
        var coords;
        var perspectivePixelCoords = mapPixelCoordsToPerspectivePixelCoords(pixelCoords);
        if (!!perspectivePixelCoords) { coords = map.PixelToMapCoords(perspectivePixelCoords); }
        return coords;
    }
    function initContext(onContext) {
        //var sceneNear = 0.1, sceneFar = 10, viewY, viewZ, vFrom, vTo;
        var sceneNear = 0.01, sceneFar = 100, viewY, viewZ, vFrom, vTo;
        viewY = Math.sin(viewAngle) * viewRadius;
        viewZ = Math.cos(viewAngle) * viewRadius;
        vFrom = [0, viewY, viewZ + viewZOff], vTo = [0, 0, viewZOff];
        var view = { vFrom: vFrom, vTo: vTo, vUp: [0, 1, 0] };
        var ambientComponent = 1;
        var lightComponent = 0.75;
        scene = new tf.webgl.Scene({
            context: onContext, clearColor: [1, 1, 1, 1], clearDepth: 1,
            ambientColor: [ambientComponent, ambientComponent, ambientComponent],
            lightDir: [0, 0, 1],
            lightColor: [lightComponent, lightComponent, lightComponent],
            view: view,
            perspective: { fovy: 30 * Math.PI / 180, near: sceneNear, far: sceneFar }
        });
        updateInversePerspective();
        var program = onContext.GetTextureColorProgram();
        var quad = new tf.webgl.QuadXY({ context: onContext });
        mapSceneObject = new tf.webgl.SceneObject({
            //usePick: true,
            context: onContext, attributes: quad, texture: mapTexture, program: program
        });
        var normals = new Float32Array([0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0]);
        mapSceneObject.GetAttributes().GetNor().Update(normals);
        scene.AddObject(mapSceneObject);
        /*pickFrameBufferSceneObject = new tf.webgl.SceneObject({
            context: onContext, attributes: new tf.webgl.QuadXY({ context: onContext }),
            texture: pickFrameBuffer.GetTexture(),
            //texture: context.GetFourColorTexture(),
            program: program,
            scale: {sx: 0.1, sy: 0.1, sz: 0.1}
        });
        scene.AddObject(pickFrameBufferSceneObject);*/
        //var lightDir = new tf.math.Vector3({ x: 0, y: 1, z: 0 });
        //lightDir.Normalize();
        //scene.SetLightDir([lightDir[0], lightDir[1], lightDir[2]]);
    }
    function getMapCanvas() {
        //return map.GetCanvas();
        return renderMap.GetCanvas();
    }
    function onScenePostCompose(notification) { notifyListeners(tf.consts.perspectiveMapPostComposeEvent, { sender: theThis, sceneNotification: notification }); }
    function drawFrame(onContext) {
        var mapCanvas = getMapCanvas();
        if (!!mapCanvas) {
            updateMapSettings();
            mapTexture.UpdateFromImage(mapCanvas, true);
            scene.OnPreRender();
            var renderOptions = {
                onPostCompose: onScenePostCompose,
                viewportWidth: canvas.width, viewportHeight: canvas.height,
                isForPick: false,
                frameBuffer: undefined, clearColor: undefined, useProgram: undefined
            };
            scene.RenderOn(renderOptions);
            if (((++renderCount) % pickFrameBufferRenderCount) == 0) {
                renderOptions.viewportWidth = renderOptions.viewportHeight = pickFrameBufferDim;
                renderOptions.isForPick = true;
                renderOptions.frameBuffer = pickFrameBuffer.GetFrameBuffer();
                renderOptions.clearColor = [0, 0, 0, 0];
                renderOptions.useProgram = context.GetTextureColorPickProgram();
                scene.RenderOn(renderOptions);
            }
        }
    }
    function restoreContext() {
        if (!!context) { context.RestoreContext(); }
    }
    function onFrame(notification) { if (getIsVisible()) { drawFrame(context); context.RequestAnimFrame(); } }
    function onLost(notification) {
        notifyListeners(tf.consts.perspectiveMapLostDeviceEvent);
        //setTimeout(restoreContext, 1000);
        //setTimeout(restoreContext, 1);
        if (getIsVisible()) { setIsVisible(false); }
    }
    function onRestored(notification) {
        if (!!webGL) {
            forceUpdatePerspective = true;
            notifyListeners(tf.consts.perspectiveMapRestoredDeviceEvent);
            setTimeout(function () { return onFrame(notification); }, 100);
        }
    }
    function notifyListeners(eventName, moreArgs) { allEventDispatchers.Notify(eventName, tf.js.ShallowMerge(moreArgs, { sender: theThis, eventName: eventName })); }
    function getMapObjectFromPixel(px, py) {
        var mapObj;
        if (!isDeleted()) {
            ctx.bindFramebuffer(ctx.FRAMEBUFFER, pickFrameBuffer.GetFrameBuffer());
            ctx.readPixels(px, py, 1, 1, ctx.RGBA, ctx.UNSIGNED_BYTE, pickedColor);
            ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
            mapObj = context.GetPickObject(tf.webgl.DecodeColorIntoInt(pickedColor));
        }
        return mapObj;
    }
    function getMapObjectFromMapNotification(notification) {
        var mapObj;
        if (!isDeleted()) {
            var tx = Math.floor(notification.actualPixelCoords[0] / mapSize[0] * pickFrameBufferDim);
            var tz = pickFrameBufferDim - Math.floor(notification.actualPixelCoords[1] / mapSize[1] * pickFrameBufferDim);
            mapObj = getMapObjectFromPixel(tx, tz);
        }
        return mapObj;
    }
    function onMapMouseClick(notification) {
        if (!isDeleted()) {
            var mapObj = getMapObjectFromMapNotification(notification);
            if (!!mapObj) { notifyListeners(tf.consts.perspectiveMapObjectClickEvent, { mapObject: mapObj }); }
            else {
                notifyListeners(tf.consts.perspectiveMapClickEvent);
            }
            //context.LoseContext();
        }
    }
    function onMapMouseMove(notification) {
        if (!isDeleted()) {
            var mapObj = getMapObjectFromMapNotification(notification), prevLastHoveredMapObject = lastHoveredMapObject, notifyOut, notifyIn;
            if (!!(lastHoveredMapObject = mapObj)) { if (! (notifyIn = !prevLastHoveredMapObject)) { notifyIn = notifyOut = mapObj != prevLastHoveredMapObject; } }
            else { notifyOut = !!prevLastHoveredMapObject; }
            if (notifyIn || notifyOut) {
                if (notifyOut) { notifyListeners(tf.consts.perspectiveMapObjectHoverInOutEvent, { nextMapObject: lastHoveredMapObject, mapObject: prevLastHoveredMapObject, isHoverIn: false }); }
                if (notifyIn) { notifyListeners(tf.consts.perspectiveMapObjectHoverInOutEvent, { prevMapObject: prevLastHoveredMapObject, mapObject: lastHoveredMapObject, isHoverIn: true }) }
            }
            else { notifyListeners(tf.consts.perspectiveMapMouseMoveEvent, notification); }
        }
    }
    function translatePixelForMapEvents(pixelCoords) { if (getIsVisible()) { return mapPixelCoordsToPerspectivePixelCoords(pixelCoords); } }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        /*viewRadius = 0.72;
        viewAngle = 30 * Math.PI / 180;
        viewZOff = 0.23;*/
        viewRadius = 1.5;
        viewAngle = 30 * Math.PI / 180;
        viewZOff = 0;
        mapSize = [100, 100];
        mapAspect = 1;
        inversePerspective = new tf.math.Matrix4({ noInit: true });
        ptOrigin = new tf.math.Vector3({ x: 0, y: 0, z: 0 });
        vYAxisUnit = new tf.math.Vector3({ x: 0, y: 1, z: 0 });
        cameraPos = new tf.math.Vector3();
        cameraDir = new tf.math.Vector3();
        allEventDispatchers = new tf.events.MultiEventNotifier({ eventNames: tf.consts.allPerspectiveMapEventNames });
        if (map = tf.js.GetMapFrom(settings.map)) {
            webGL = tf.webgl.GetWebGL();
            if (webGL.GetHasWebGL()) {
                context = new tf.webgl.Context({ optionalAttributes: { antialias: true }, onFrame: onFrame, onLost: onLost, onRestored: onRestored });
                objectCreationSettings = { map: map, context: context, perspectiveMap: theThis };
                mapTexture = new tf.webgl.Texture2({ context: context, img: map.GetCanvas() });
                ctx = context.GetContext();
                canvas = context.GetCanvas();
                pickedColor = new Uint8Array(4);
                renderCount = 0;
                pickFrameBufferRenderCount = 10;
                pickFrameBufferDim = 512;
                pickFrameBuffer = new tf.webgl.FrameBuffer({ context: context, width: pickFrameBufferDim, height: pickFrameBufferDim });
                var styles = tf.GetStyles(), subStyles = styles.GetSubStyles();
                var canvasStyles = { backgroundColor: "rgba(0,0,0,1)", width: "100%", height: "100%", position: 'relative', display: 'block' };
                var containerStyles = {
                    inherits: [subStyles.cursorDefaultStyle, subStyles.noSelectStyle],
                    backgroundColor: "rgba(0,0,0,0)",
                    color: "#fc0", padding: "0px", border: 'none', width: "100%", height: "100%",
                    position: "absolute", left: "0px", top: "0px",
                    overflow: 'hidden', pointerEvents: 'none', display: "block", zIndex: 0
                };
                var isVisible = !tf.js.GetIsFalseNotUndefined(settings.isVisible);
                hasMapCenter = map.IsShowingMapCenter();
                hasMeasure = map.IsPanelShowing(tf.consts.panelNameMeasure);
                hasDownload = map.IsPanelShowing(tf.consts.panelNameDownload);
                styles.ApplyStyleProperties(canvas, canvasStyles);
                htmlControl = new tf.map.HTMLControl({ map: map, content: canvas, cssStyle: containerStyles, isVisible: isVisible });
                updateMapVisibleControls();
                mapMouseMoveListener = map.AddListener(tf.consts.mapMouseMoveEvent, onMapMouseMove);
                mapMouseClickListener = map.AddListener(tf.consts.mapClickEvent, onMapMouseClick);
                map.SetPixelTranslateCallBack(translatePixelForMapEvents);
                renderMapXScale = 1.5;
                renderMapYScale = 3;
                renderMap = new tf.map.RenderMap({ map: map, scale: [renderMapXScale, renderMapYScale] });
                initContext(context);
                forceUpdatePerspective = true;
                onFrame();
            }
            else { webGL = map = undefined; }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.webgl.MapQuad = function (settings) {
    var theThis, map, mapObject, sceneObject, attributes, mapCoords, context, texture, perspectiveMap, coordinates;
    this.OnDelete = function () { return onDelete(); }
    this.IsDeleted = function () { return isDeleted(); }
    this.Update = function () { return update(); }
    this.GetSceneObject = function () { return sceneObject; }
    this.GetMapObject = function () { return mapObject; }
    function isDeleted() { return map == undefined; }
    function onDelete() {
        if (!isDeleted()) {
            mapObject = map = perspectiveMap = texture = coordinates = attributes = sceneObject = mapObject = undefined;
        }
    }
    function update() {
        if (!isDeleted()) {
        }
    }
    function createQuad() {
        if (!isDeleted()) {
            var program = context.GetTextureColorProgram();
            attributes = new tf.webgl.QuadXY({ context: context });
            var yCoord = 0.01;
            var vertices = [0, yCoord, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            var normals = new Float32Array([0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0]);
            for (var i = 1, iPrev = i - 1, iv = 3, ivPrev = iv - 3 ; i < 4 ; ++i, ++iPrev, iv += 3, ivPrev += 3) {
                var xPrev = vertices[ivPrev], zPrev = vertices[ivPrev + 2]
                var coordPrev = coordinates[iPrev], coord = coordinates[i];
                var distance = tf.units.GetDistanceInMetersBetweenMapCoords(coordPrev, coord);
                var angle = -tf.units.GetMapHeading(coordPrev, coord);
                var cangle = Math.cos(angle), sangle = Math.sin(angle);
                var x = xPrev + distance * cangle;
                var z = zPrev + distance * sangle;
                vertices[iv] = x; vertices[iv + 1] = yCoord; vertices[iv + 2] = z;
            }
            attributes.GetPos().Update(new Float32Array(vertices));
            attributes.GetNor().Update(normals);
            sceneObject = new tf.webgl.SceneObject({
                cullFrontFace: true,
                onPreRender: update, context: context, attributes: attributes, texture: texture, program: program//, useLines: true
            });
            mapObject = perspectiveMap.CreateMapObject({ mapCoords: coordinates[0], sceneObject: sceneObject, skipRotate: false, skipScale: false });
        }
    }
    function initialize() {
        if ((tf.js.GetIsValidObject(settings)) &&
            tf.js.GetIsInstanceOf(settings.perspectiveMap, tf.webgl.PerspectiveMap) &&
            tf.js.GetIsArrayWithMinLength(settings.coordinates, 4) &&
            tf.js.GetIsInstanceOf(settings.texture, tf.webgl.Texture2)) {
            perspectiveMap = settings.perspectiveMap;
            map = perspectiveMap.GetMap();
            context = perspectiveMap.GetContext();
            texture = settings.texture;
            coordinates = settings.coordinates;
            createQuad();
        }
        else { map = undefined; }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.webgl.PerspectiveDLayer = function (settings) {
    var theThis, dLayer, featureLayer, map, mapDLayers, context, perspectiveMap, mapMarkerGroup, mapMarkers, featureLayerVisibilityListener, perspectiveMapVisibilityListener;
    var imgObjCache;
    this.PreProcessServiceData = function (data, dLayer) { return preProcessServiceData(data, dLayer); }
    this.OnDelete = function () { return onDelete(); }
    this.IsDeleted = function () { return isDeleted(); }
    function isDeleted() { return mapDLayers == undefined; }
    function onDelete() {
        if (!isDeleted()) {
            if (!!perspectiveMapVisibilityListener) { perspectiveMapVisibilityListener.OnDelete(); }
            if (!!featureLayerVisibilityListener) { featureLayerVisibilityListener.OnDelete(); }
            deleteCurrentMarkers();
            mapMarkers = context = imgObjCache = perspectiveMapVisibilityListener = featureLayer = featureLayerVisibilityListener = mapMarkerGroup = mapDLayers = perspectiveMap = undefined;
        }
    }
    function convertTextStyle(style) {
        style.dontTranslate = true;
        style.arrow_length = style.marker_arrowlength;
        style.border_line_color = style.border_color;
        style.border_line_opacity = style.border_opacity / 100;
        style.border_line_width = style.border_width;
        style.fill_color = style.marker_color;
        style.fill_opacity = style.marker_opacity / 100;
        style.line_opacity = style.line_opacity / 100;
        style.horpos = style.marker_horpos;
        style.verpos = style.marker_verpos;
    }
    function convertImgStyle(style) {
    }
    function updateVisibility(notification) {
        if (!isDeleted()) {
            if (!!mapMarkerGroup && !mapMarkerGroup.IsDeleted()) {
                var isVisible = featureLayer.GetIsVisible();
                var groupObject = mapMarkerGroup.GetGroupObject();
                if (isVisible != groupObject.GetIsVisible()) {
                    groupObject.SetIsVisible(isVisible);
                }
            }
        }
    }
    function updatePerspectiveMapVisibility(notification) {
        if (!isDeleted()) {
            var perspectiveIsVisible = perspectiveMap.GetIsVisible();
            featureLayer.SetIsForcedInvisible(perspectiveIsVisible);
            dLayer.SetShowsInfoWindow(!perspectiveIsVisible);
        }
    }
    function createQuad(v1, v2, v3, v4, src) {
        var img = new tf.dom.Img({
            crossOrigin: true,
            src: src,
            onLoad: function (img) {
                if (img.GetIsValid()) {
                    var imgElem = img.GetImg();
                    var w = imgElem.width, h = imgElem.height, l = 0, t = 0;
                    var canvas = document.createElement('canvas');
                    var ctx = canvas.getContext('2d');
                    canvas.width = w;
                    canvas.height = h;
                    ctx.drawImage(imgElem, l, t);
                    var texture = new tf.webgl.Texture2({ context: context, img: canvas, flipVerticalBool: true });
                    var quad = new tf.webgl.MapQuad({ perspectiveMap: perspectiveMap, coordinates: [v1, v2, v3, v4], texture: texture });
                    if (!quad.IsDeleted()) { mapMarkerGroup.AddObject(quad.GetMapObject()); }
                }
            }
        });
    }
    function deleteCurrentMarkers() {
        var markers = mapMarkerGroup.GetGroupObject().GetSubObjects();
        for (var i in markers) { markers[i].OnDelete(true, true, true); }
        mapMarkerGroup.DelAllSubObjects();
        for (var i in mapMarkers) { mapMarkers[i].GetMapObject().OnDelete(); }
        mapMarkers = [];
    }
    function preProcessServiceData(data, dLayerSet) {
        //return;
        if (!isDeleted()) {
            if (dLayerSet != dLayer) { tf.GetDebug().LogIfTest('tf.webgl.PerspectiveDLayer: dLayer in preProcess is different'); }
            deleteCurrentMarkers();
            if (featureLayerVisibilityListener == undefined) {
                featureLayer = dLayer.GetFeatureLayer();
                featureLayerVisibilityListener = featureLayer.AddListener(tf.consts.mapFeatureLayerVisibilityChangeEvent, updateVisibility);
                perspectiveMapVisibilityListener = perspectiveMap.AddListener(tf.consts.perspectiveMapVisibilityChangeEvent, updatePerspectiveMapVisibility);
                updatePerspectiveMapVisibility();
                updateVisibility();
            }
            if (tf.js.GetIsValidObject(data) && tf.js.GetIsArrayWithMinLength(data.features, 1)) {
                var features = data.features;
                var context = perspectiveMap.GetContext();
                //var program = context.GetOneLightPerVertexProgram();
                var program = context.GetTextureColorProgram();
                var markerStyles = dLayer.GetMarkerStyleSpecs();
                var textMarkerStyle = markerStyles.textMarkerBaseStyle;
                var imgMarkerStyle = markerStyles.imgMarkerBaseStyle;
                var display_fields = dLayer.GetDisplayFieldName();
                convertTextStyle(textMarkerStyle);
                convertImgStyle(imgMarkerStyle);
                var altaCreated = true;
                for (var i in features) {
                    var thisFeature = features[i];
                    var props = thisFeature.properties;
                    var pointCoords = tf.js.GetMapCoordsFrom(thisFeature.geometry.coordinates);
                    if (pointCoords[0]) {
                        var label = props[display_fields];
                        var prefix = "http://", len_of_prefix = prefix.length;
                        var isImageMarker = label.trim().toLowerCase().substring(0, len_of_prefix) == prefix;
                        var cachedObject;
                        var markerObject, style = isImageMarker ?
                            tf.js.ShallowMerge(imgMarkerStyle, { icon_url: label }) :
                            tf.js.ShallowMerge(textMarkerStyle, { label: label });
                        var skipThis = false;
                        var skipRotate;
                        if (isImageMarker) {
                            //cachedObject = imgObjCache[label];
                            var catID = data["category id"];
                            if (tf.js.GetIsNonEmptyString(catID)) {
                                catID = catID.toLowerCase();
                                if (catID == "geoimages") {
                                    style.useFrame = true;
                                }
                                else if (catID == "alta") {
                                    //style.rotate_with_map = false;
                                    //skipRotate = false;
                                    if (!altaCreated) {
                                        altaCreated = true;
                                        var UC_X1 = tf.js.GetLongitudeFrom(props.UC_X1);
                                        var UC_X2 = tf.js.GetLongitudeFrom(props.UC_X2);
                                        var UC_X3 = tf.js.GetLongitudeFrom(props.UC_X3);
                                        var UC_X4 = tf.js.GetLongitudeFrom(props.UC_X4);
                                        var UC_Y1 = tf.js.GetLatitudeFrom(props.UC_Y1);
                                        var UC_Y2 = tf.js.GetLatitudeFrom(props.UC_Y2);
                                        var UC_Y3 = tf.js.GetLatitudeFrom(props.UC_Y3);
                                        var UC_Y4 = tf.js.GetLatitudeFrom(props.UC_Y4);
                                        var v1 = [UC_X1, UC_Y1], v2 = [UC_X2, UC_Y2], v3 = [UC_X3, UC_Y3], v4 = [UC_X4, UC_Y4];
                                        var src = props["Display_Thumbnail"];
                                        createQuad(v1, v2, v3, v4, src);
                                        props.additionalFeatureSpecs = [
                                            {
                                                type: "linestring", coordinates: [v1, v2, v3, v4, v1],
                                                style: [{ line: true, line_color: "#fff", line_width: 4 }, { line: true, line_color: "#000", line_width: 2 }]
                                            }
                                        ];
                                        props.hoverFeatureSpecs = [
                                            {
                                                type: "polygon", coordinates: [[v1, v2, v3, v4]],
                                                style: { line: true, line_color: "#00a", line_width: 4, fill: true, fill_color: "#fff", fill_opacity: 40, zindex: 2 }
                                            },
                                            { type: "point", coordinates: v1, style: { marker: true, label: "v1" } },
                                            { type: "point", coordinates: v2, style: { marker: true, label: "v2" } },
                                            { type: "point", coordinates: v3, style: { marker: true, label: "v3" } },
                                            { type: "point", coordinates: v4, style: { marker: true, label: "v4" } }
                                        ];
                                    }
                                    else {
                                        //skipThis = true;
                                    }
                                }
                            }
                        }
                        if (!skipThis) {
                            markerObject = perspectiveMap.CreateMapMarker({
                                dLayer: { dLayer: dLayer, props: props},
                                usePick: true, mapCoords: pointCoords, style: style, sceneObject: cachedObject, skipRotate: skipRotate
                            });
                            markerObject.GetPointCoords = function (pointCoords) { return function () { return pointCoords; } }(pointCoords);
                            tf.js.SetObjProperty(markerObject, tf.consts.DLayerProperty, { properties: props, label: dLayer.GetName(), map: map, dLayer: dLayer });
                            mapMarkers.push(markerObject);
                            if (!!markerObject && !markerObject.IsDeleted()) {
                                //if (cachedObject == undefined) { imgObjCache[label] = markerObject.GetSceneObject(); }
                                mapMarkerGroup.AddObject(markerObject.GetMapObject());
                            }
                        }
                    }
                }
            }
        }
    }
    function initialize() {
        if ((tf.js.GetIsValidObject(settings)) && tf.js.GetIsInstanceOf(settings.mapDLayers, tf.webgl.PerspectiveDLayers)) {
            mapDLayers = settings.mapDLayers;
            dLayer = settings.dLayer;
            context = mapDLayers.GetMapOnQuad().GetContext();
            map = mapDLayers.GetMapOnQuad().GetMap();
            //mapMarkers = [];
            imgObjCache = {};
            mapMarkerGroup = new tf.webgl.MapObjectGroup({ perspectiveMap: perspectiveMap = mapDLayers.GetMapOnQuad() });
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.webgl.PerspectiveDLayers = function (settings) {
    var theThis, perspectiveMap, mapDLayers, mapObjectHoverInOutListener, mapObjectClickListener, mapPostComposeListener, hoveringMapObject;
    this.PreProcessServiceData = function (data, dLayer) { return preProcessServiceData(data, dLayer); }
    this.GetMapOnQuad = function () { return perspectiveMap; }
    this.OnDelete = function () { return onDelete(); }
    this.IsDeleted = function () { return isDeleted(); }
    function isDeleted() { return perspectiveMap == undefined; }
    function onDelete() {
        if (!isDeleted()) {
            for (var i in mapDLayers) { mapDLayers[i].OnDelete(); }
            if (!!mapObjectHoverInOutListener) { mapObjectHoverInOutListener.OnDelete(); }
            if (!!mapObjectClickListener) { mapObjectClickListener.OnDelete(); }
            if (!!mapPostComposeListener) { mapPostComposeListener.OnDelete(); }
            mapPostComposeListener = mapObjectClickListener = mapObjectHoverInOutListener = mapDLayers = perspectiveMap = undefined;
        }
    }
    function getOrCreateMapDLayer(dLayer) {
        var index = dLayer.GetIndex();
        var mapDLayer = mapDLayers[index];
        if (!mapDLayer) {
            mapDLayer = mapDLayers[index] = new tf.webgl.PerspectiveDLayer({ mapDLayers: theThis, dLayer: dLayer });
        }
        return mapDLayer;
    }
    function preProcessServiceData(data, dLayer) {
        //return;
        if (!isDeleted()) { getOrCreateMapDLayer(dLayer).PreProcessServiceData(data, dLayer); }
    }
    function getDLayerPropsFromMapObject(mapObject) {
        var dLayer;
        if (!!mapObject) { var marker = mapObject.GetSettings().mapMarker; if (!!marker) { dLayer = marker.GetSettings().dLayer; } }
        return dLayer;
    }
    function onMapObjectHoverInOut(notification) {
        var dLayer = getDLayerPropsFromMapObject(notification.mapObject);
        if (!!dLayer) {
            if (notification.isHoverIn) { tf.urlapi.ShowdLayerInfoWindow(notification.mapObject.GetSettings().mapMarker); }
            hoveringMapObject = notification.isHoverIn ? notification.mapObject : undefined;
            //notification.mapObject.GetSceneObjectHolder().SetIsVisible(!notification.isHoverIn);
        }
    }
    function onMapObjectClick(notification) {
        var dLayer = getDLayerPropsFromMapObject(notification.mapObject);
        if (!!dLayer) { tf.urlapi.ShowdLayerInfoWindow(notification.mapObject.GetSettings().mapMarker); }
    }
    function onMapPostCompose(notification) {
        if (!!hoveringMapObject) {
            var sceneObject = hoveringMapObject.GetSceneObject();
            if (!!sceneObject) {
                var renderMatrix = sceneObject.GetRenderMatrix();
                if (renderMatrix != undefined) {
                    var newRenderMatrix = new tf.math.Matrix4({ matrix: renderMatrix });
                    var scaleMatrix = new tf.math.ScaleMatrix4({ sx: 1.2, sy: 1.2, sz: 1.2 });
                    newRenderMatrix.MultByMatrix(scaleMatrix);
                    sceneObject.SetUseDepth(false);
                    sceneObject.SetRenderMatrix(newRenderMatrix);
                    notification.sceneNotification.renderImmediate(sceneObject);
                    sceneObject.SetRenderMatrix(renderMatrix);
                    sceneObject.SetUseDepth(true);
                }
            }
        }
    }
    function initialize() {
        if ((tf.js.GetIsValidObject(settings)) && tf.js.GetIsInstanceOf(settings.perspectiveMap, tf.webgl.PerspectiveMap)) {
            perspectiveMap = settings.perspectiveMap;
            mapObjectHoverInOutListener = perspectiveMap.AddListener(tf.consts.perspectiveMapObjectHoverInOutEvent, onMapObjectHoverInOut);
            mapObjectClickListener = perspectiveMap.AddListener(tf.consts.perspectiveMapObjectClickEvent, onMapObjectClick);
            mapPostComposeListener = perspectiveMap.AddListener(tf.consts.perspectiveMapPostComposeEvent, onMapPostCompose);
            mapDLayers = {};
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
