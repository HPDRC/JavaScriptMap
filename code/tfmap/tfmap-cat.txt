"use strict";


// SOURCE FILE: namespace.js
/**
 * TerraFly namespace
 * @public
 * @class
 * @namespace
 * @description <b>tf</b> is the TerraFly API root namespace
*/
var tf = {
    /**
     * class types
     * @public
     * @class
     * @namespace
     * @description Components in this namespace define the types used in the TerraFly API.
    */
    types: {},
   /**
     * class consts
     * @public
     * @class
     * @namespace
     * @description Components in this namespace define the constants used in the TerraFly API. Applications should always
     * use these constants instead of referring directly to their corresponding literal values.
    */
    consts: {},
    /**
     * class platform
     * @public
     * @class
     * @namespace
     * @description Components in this namespace are related with the platform (Test, Stage, or Production) in which the application is running.
    */
    platform: {},
    /**
     * class browser
     * @public
     * @class
     * @namespace
     * @description Components in this namespace are related to the Browser that is currently running the application.
    */
    browser: {},
    /**
     * class helpers
     * @public
     * @class
     * @namespace
     * @description This namespace contains miscellaneous auxiliary components.
    */
    helpers: {},
    /**
     * class units
     * @public
     * @class
     * @namespace
     * @description Componenents in this namespace are related to measurements and unit conversions.
    */
    units: {},
    /**
     * class js
     * @public
     * @class
     * @namespace
     * @description Components in this namespace are related to JavaScript programming.
    */
    js: {},
    /**
     * class layout
     * @public
     * @class
     * @namespace
     * @description Components in this namespace support building HTML application layouts.
    */
    layout: {},
    /**
     * class dom
     * @public
     * @class
     * @namespace
     * @description Components in this namespace encapsulate access to HTML elements.
    */
    dom: {},
    /**
     * class events
     * @public
     * @class
     * @namespace
     * @description Components in this namespace support event listener registration and event dispatching.
    */
    events: {},
    /**
     * class ui
     * @public
     * @class
     * @namespace
     * @description Components in this namespace encapsulate access to high level user interface items.
    */
    ui: {},
    /**
     * class apps
     * @private
     * @class
     * @namespace
     * @description Components in this namespace are related to specific TerraFly applications.
    */
    apps: {},
    /**
     * class ajax
     * @public
     * @class
     * @namespace
     * @description Components in this namespace support access to remote services.
    */
    ajax: {},
    /**
     * class styles
     * @public
     * @class
     * @namespace
     * @description Components in this namespace support JavaScript programmatic access to CSS/HTML application styling.
    */
    styles: {},
    /**
     * class canvas
     * @public
     * @class
     * @namespace
     * @description Components in this namespace are related with HTML5 canvas drawing.
    */
    canvas: {},
    /**
     * class map
     * @public
     * @class
     * @namespace
     * @description Components in this namespace implement the TerraFly Map API.
    */
    map: {
        /**
         * class ui
         * @private
         * @class
         * @namespace
         * @description Components in this namespace implement user interface items used by the TerraFly MAP API.
        */
        ui: {},
        /**
         * class aux
         * @private
         * @class
         * @namespace
         * @description Components in this namespace implement auxiliary functionality required by the TerraFly MAP API.
        */
        aux: {}
    },
   /**
   * class urlapi
   * @public
   * @class
   * @namespace
   * @description Components in this namespace implement the TerraFly URL-API and encapsulate the creation of TerraFly maps and applications according to [URL Parameters]{@link tf.types.URLParameters}
  */
    urlapi: { },
    /**
    * class services
    * @public
    * @class
    * @namespace
    * @description Components in this namespace encapsulate access to TerraFly services.
   */
    services: { },
    /**
    * class services
    * @public
    * @class
    * @namespace
    * @description Components in this namespace encapsulate access to mathematical objects and functions.
   */
    math: { }
};
tf.g_Styles = null;
tf.g_SvgGlyphBtnMaker = null;
tf.g_Counter = null;
tf.g_Debug = null;
tf.g_DocMouseListener = null;
tf.g_UtmGdcConverter = null;
tf.g_LevelResolutionConverter = null;
tf.g_scriptCallDispatcher = null;
tf.g_SvgGlyphLib = null;

// SOURCE FILE: consts.js
/*if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function (obj, fromIndex) {
        fromIndex = tf.js.GetNonNegativeIntFrom(fromIndex);
        for (var i = fromIndex, j = this.length; i < j; ++i) {
            if (this[i] === obj) return i;
        }
        return -1;
    };
}*/
tf.consts.URLAPIDocumentTitle = "TerraMap";
tf.consts.MVideoDocumentTitle = "Data Mapper";
tf.consts.TimeSeriesDocumentTitle = "TerraFly - TimeSeries";
tf.consts.MLSDocumentTitle = "TerraFly MLS Search";
tf.consts.MLSDocumentTitle2 = "Search Tool for S Florida Real Estate Powered by TerraFly";
tf.consts.urlPartsSeparatorStr = "$$";
/**
 * @public
 * @description default map center latitude
*/
tf.consts.defaultLatitude = 25.75869;
tf.consts.minLatitude = -90.0;
tf.consts.maxLatitude = 90.0;
tf.consts.latitudeRange = tf.consts.maxLatitude - tf.consts.minLatitude;
/**
 * Latitude values, between -90 and 90 degrees, in the World Geodetic System, "EPSG:4326"
 * @public
 * @typedef {number} tf.types.latitude
 */
/**
 * @public
 * @description default map center longitude
*/
tf.consts.defaultLongitude = -80.37388;
tf.consts.minLongitude = -180.0;
tf.consts.maxLongitude = 180.0;
tf.consts.longitudeRange = tf.consts.maxlongitude - tf.consts.minlongitude;
/**
 * Longitude values, between -180 and 180 degrees, in the World Geodetic System, "EPSG:4326"
 * @public
 * @typedef {number} tf.types.longitude
 */
/**
 * @public
 * @description default map center coordinates
*/
tf.consts.defaultMapCenter = [tf.consts.defaultLongitude, tf.consts.defaultLatitude];
/**
 * @public
 * @description default map resolution (2.4)
*/
tf.consts.defaultRes = 2.4;
/**
 * Map resolution is closely related with {@link tf.types.mapLevel}. 
 * The [default map resolution]{@link tf.consts.defaultRes} corresponds to the [default level]{@link tf.consts.defaultLevel}
 * The unit of Map resolution values is <b>meters per pixel</b>
 * @public
 * @typedef {number} tf.types.mapResolution
 */
/**
 * @public
 * @description default map level (16)
*/
tf.consts.defaultLevel = 16;
/**
 * @public
 * @description maximum map level (24)
*/
tf.consts.maxLevel = 24;
/**
 * @public
 * @description minimum map level (1)
*/
tf.consts.minLevel = 1;
/**
 * Map levels are sometimes called zoom levels; incrementing / decrementing the map level doubles / halves the map's resolution.
 * Valid values are in the range of [minLevel]{@link tf.consts.minLevel} to [maxLevel]{@link tf.consts.maxLevel}. Map level
 * defaults to [defaultLevel]{@link tf.consts.defaultLevel}
 * See {@link tf.types.mapResolution}
 * @public
 * @typedef {number} tf.types.mapLevel
 */
/*
~osm-lines:Roads_from_Open_Street_Maps@osm_roads-0-7000;
~osm-names:Road_names_from_Open_Street_Maps@osm_road_names-0-240;
~osm-buildings:Building_data_from_Open_Street_Maps@osm_buildings-0-7;
~osm-place-names:Place_names_from_Open_Street_Maps@osm_place_names-0-30000;
~osm-water:Water_data_from_Open_Street_Maps@osm_water-0-4000;
~osm-land:Land_from_Open_Street_Maps@osm_land-0-30000;
~osm-land-use:Land_use_from_Open_Street_Maps@osm_landuse-0-30000;
~osm-land-use:Land_use_from_Open_Street_Maps@osm_landuse-0-30000;~osm-land:Land_from_Open_Street_Maps@osm_land-0-30000;~osm-water:Water_data_from_Open_Street_Maps@osm_water-0-4000;~osm-place-names:Place_names_from_Open_Street_Maps@osm_place_names-0-30000;~osm-buildings:Building_data_from_Open_Street_Maps@osm_buildings-0-7;~osm-names:Road_names_from_Open_Street_Maps@osm_road_names-0-240;~osm-lines:Roads_from_Open_Street_Maps@osm_roads-0-7000;
*/
tf.consts.defaultTFLogoOn = true;
/**
 * @public
 * @description default Mapnik 1.0 Map [Legend String]{@link tf.types.legendString}
*/
tf.consts.defaultLegend = "$$http://vn4.cs.fiu.edu/defaultmap$$";
//tf.consts.defaultLegendH = "{Cities::~Capitals:Capitals_WorldMap@wm_Capitals-120-6000;Capitals:Capitals_WorldMap@wm_Capitals-6000-15000;~Metro:Big_Cities_over_million_WorldMap@wm_Cities_Greater_900K-120-5000;Metro:Big_Cities_over_million_WorldMap@wm_Cities_Greater_900K-5000-15000;~Cities:Cities_WorldMap@wm_Cities_75K_to_900K-120-2400+wm_Cities_Greater_900K-120-2400+wm_Cities_Unknownpop-120-2400;Cities:Cities_WorldMap@wm_Cities_75K_to_900K-2400-15000+wm_Cities_Greater_900K-2400-15000+wm_Cities_Unknownpop-2400-15000;};{Hubs::~Ports:Marine_Ports_WorldMap@wm_Marine_Ports-120-360;Ports:Marine_Ports_WorldMap@wm_Marine_Ports-360-2000;~Railway:Railway_Stations_WorldMap@wm_Railway_Stations-120-240;~Airports:Airports_WorldMap@wm_Airports-120-240;};{Water::Bays:Seas_and_Bays_WorldMap@wm_Seas_Bays-120-2000;Glaciers:Glaciers_WorldMap@wm_Glacier-120-4000;~Rivers_B:Lake_and_River_contours_WorldMap@wm_Water_Poly-120-500;~Great_Lakes_L:Great_Lakes_labels_WorldMap@WM_GREAT_LAKES_NAME-120-4000;~Great_Lakes_B:Great_Lakes_contours_WorldMap@wm_Great_Lakes-120-4000;osm-water:Water_data_from_Open_Street_Maps@osm_water-0-4000;};{Regions::~Admin_L:States_and_Provinces_names_labeled_WorldMap@wm_World_Admin_name-120-2000;~Admin_B:States_and_Provinces_boundaries_WorldMap@wm_World_Admin-120-2000;~Countries_L:Nation_names_labeled_WorldMap@nation_name-2000-5000;Countries_L:Nation_names_labeled_WorldMap@nation_name-5000-30000;~Countries_B:Nations_boundaries_WorldMap@wm_World_Nations-120-15000;osm-admin:Administrative_boundary_data_from_Open_Street_Maps@osm_admin-0-60000;};{Parcels::~owner:Property_owner@flpropertiesowner-0-0.5;year_built:Year_property_built_or_renovated@flpropertiesyear-0-0.5;size:Sizes_of_property_interior_and_lot@flpropertiessize-0-0.5;appraisal:Property_value@flpropertiesvalue-0-0.5;~lines:Property_lines,_from_First_American@fa_parcel-0-1;lines:Property_lines,_from_First_American@fa_parcel-1-2;MLS_Real_estate:MLS_listings_for_sale_and_rent_in_Miami_area@re1n-0-5+re2n-0-5+rntn-0-5+rinn-0-5+rldn-0-5;osm-buildings:Building_data_from_Open_Street_Maps@osm_buildings-0-7;};{People::population:People_per_block_per_Census_2000@blk_pop-0-5;income:Aggregate_Neighborhood_Income_and_number_of_homes,_per_Census-2000@bg_mhinc-0.7-10;};{Services::~business:Yellow_Pages@nypages-0-1.2;business:Yellow_Pages@nypages-1.2-5;food:Restaurants_from_NavTeq@nv_restrnts-0-10;doctors:Physicians_specialties@physicianspecialty-0-5;};Landmarks:Cultural_Landmarks_WorldMap@wm_Cultural_Landmarks-120-1800;Utilities:Utilities_WorldMap@wm_Utilities-120-720;Environment:Hydrology@prism-0-120;~Places:Places@gnis2-0-6+hotels-0-6;Places:Places@gnis2-6-24+hotels-6-24;OSM-place-names:Place_names_from_Open_Street_Maps@osm_place_names-0-30000;{Road::~navteq-lines:Roads,_and_streets@street-5-2000;navteq-lines:Roads,_and_streets@street-0-5;~navteq-names:Roads,_and_streets@street_names-0-240;osm-lines:Open_Street_Maps@osm_roads-0-7000;osm-names:Open_Street_Maps@osm_road_names-0-240;~routes:Routes_WorldMap@wm_Major_Routes-120-1000+wm_Minor_Routes-120-1000;routes:Routes_WorldMap@wm_Major_Routes-1000-5000+wm_Minor_Routes-1000-5000;~railways:Railroad_WorldMap@wm_Railroad_Track-120-2000;};{Town::~borders:Borders@incorp-0-120;~towns:Cities,_towns@wtown-0-60;};";
//tf.consts.defaultLegendH = "$$http://n00.cs.fiu.edu/defaultmapFL$$";
//tf.consts.defaultLegendM = "~osm-land-use:Land_use_from_Open_Street_Maps@osm_landuse-0-30000;~osm-land:Land_from_Open_Street_Maps@osm_land-0-30000;~osm-water:Water_data_from_Open_Street_Maps@osm_water-0-4000;~osm-place-names:Place_names_from_Open_Street_Maps@osm_place_names-0-30000;~osm-buildings:Building_data_from_Open_Street_Maps@osm_buildings-0-7;~osm-names:Road_names_from_Open_Street_Maps@osm_road_names-0-240;~osm-lines:Roads_from_Open_Street_Maps@osm_roads-0-7000;";
/**
 * @public
 * @description default Mapnik 2.0 Map [Legend String]{@link tf.types.legendString}
*/
tf.consts.defaultLegendM = "$$http://n00.cs.fiu.edu/Defaults/layers.maponly.mapnik2$$";
/**
 * @public
 * @description default Mapnik 2.0 Hybrid [Legend String]{@link tf.types.legendString}
*/
tf.consts.defaultLegendH = "$$http://n00.cs.fiu.edu/Defaults/layers.hybrid.mapnik2$$";
/**
 * @public
 * @description Mapnik 1.0 engine
*/
tf.consts.mapnikEngine = "m";
/**
 * @public
 * @description Mapnik 2.0 engine
*/
tf.consts.mapnik2Engine = "m2";
tf.consts.defaultFMap = tf.consts.mapnik2Engine;
/**
 * The Vector Tile engine used by the map, either {@link tf.consts.mapnik2Engine} or {@link tf.consts.mapnikEngine}
 * @public
 * @typedef {tf.types.mapEngine} tf.types.mapEngine
 */
tf.consts.defaultTFPassThrough = "";
tf.consts.defaultVid = "";
tf.consts.defaultHelp =
    "<span>" +
    "<b>Double Click</b>: Local Data Reports and Queries<br />" +
    "<b>Drag</b>: Browse the map<br />" +
    "Buttons: <b>Full Screen</b>, <b>Reset Rotation</b>, <b>Search Location</b>, <b>Zoom</b>, <b>Map Layers</b><br /><br />" +
    "Address bar examples:<br />" +
    "1 Flagler St, Miami, FL<br />Miami<br />Miami, FL<br />33139<br />25.77 -80.19 (coordinates)" +
    "</span>";
tf.consts.defaultAddress = "";
tf.consts.tfLogoOnStr = "1";
tf.consts.tfLogoOffStr = "0";
/**
 * @public
 * @description Hybrid map display (Aerial + Map combined)
*/
tf.consts.typeNameHybrid = "hybrid";
/**
 * @public
 * @description Map display (Vector tiles only)
*/
tf.consts.typeNameMap = "map";
/**
 * @public
 * @description Aerial display (Aerial tiles only)
*/
tf.consts.typeNameAerial = "satellite";
tf.consts.typeNameUndefined = "undefined";
tf.consts.defaultTypeName = tf.consts.typeNameHybrid;
/**
 * The type of map images displayed by the map, either {@link tf.consts.typeNameHybrid}, {@link tf.consts.typeNameMap} or {@link tf.consts.typeNameAerial}
 * @public
 * @typedef {tf.types.mapType} tf.types.mapType
 */
/** 
 * @public 
 * @description Best Available source for map Aerial tiles 
*/
tf.consts.sourceName_best_available = "best_available";
/**
 * @public
 * @description source for map Aerial tiles 
*/
tf.consts.sourceName_naip_1m = "naip_1m";
/**
 * @public
 * @description source for map Aerial tiles 
*/
tf.consts.sourceName_usgs_toop_r = "usgs_toop_r";
/**
 * @public
 * @description source for map Aerial tiles 
*/
tf.consts.sourceName_county_1ft = "county_1ft";
/**
 * @public
 * @description source for map Aerial tiles 
*/
tf.consts.sourceName_landsat7_321 = "landsat7_321";
/**
 * @public
 * @description source for map Aerial tiles 
*/
tf.consts.sourceName_usgs_1m = "usgs_1m";
/**
 * @public
 * @description source for map Aerial tiles 
*/
tf.consts.sourceName_country_3inch = "country_3inch";
/**
 * @public
 * @description source for map Aerial tiles 
*/
tf.consts.sourceName_usgs_ap_cir = "usgs_ap_cir";
/**
 * @public
 * @description source for map Aerial tiles 
*/
tf.consts.sourceName_usgs_ap_r = "usgs_ap_r";
/**
 * @public
 * @description source for map Aerial tiles 
*/
tf.consts.sourceName_dor_1ft = "dor_1ft";
/**
 * @public
 * @description source for map Aerial tiles 
*/
tf.consts.sourceName_usgs_ap_cir = "usgs_ap_cir";
tf.consts.defaultSourceName = tf.consts.sourceName_best_available;
tf.consts.appParamName = "app";
tf.consts.appStartParamName = "appstart";
tf.consts.appStartExpandedValue = "expanded";
tf.consts.appStartCollapsedValue = "collapsed";
/**
 * @public
 * @description target of HTML 'a' elements: '_blank', '_top', etc. defaults to '_top'
*/
tf.consts.paramLinkTargetStr = 'linktarget';
/**
 * The source of aerial tiles displayed by the map, one of:<br>
 * {@link tf.consts.sourceName_best_available},<br>
 * {@link tf.consts.sourceName_naip_1m},<br>
 * {@link tf.consts.sourceName_usgs_toop_r},<br>
 * {@link tf.consts.sourceName_county_1ft},<br>
 * {@link tf.consts.sourceName_landsat7_321},<br>
 * {@link tf.consts.sourceName_usgs_1m},<br>
 * {@link tf.consts.sourceName_country_3inch},<br>
 * {@link tf.consts.sourceName_usgs_ap_cir},<br>
 * {@link tf.consts.sourceName_usgs_ap_r},<br>
 * {@link tf.consts.sourceName_dor_1ft},<br>
 * or {@link tf.consts.sourceName_usgs_ap_cir}
 * @public
 * @typedef {tf.types.mapAerialSource} tf.types.mapAerialSource
 */
/**
 * @public
 * @description map zoom control name: "zoom"
*/
tf.consts.panelNameZoom = "zoom";
/**
 * @public
 * @description map overview control name: "overview"
*/
tf.consts.panelNameOverview = "overview";
/**
 * @public
 * @description map layers control name: "legend"
*/
tf.consts.panelNameLayers = "legend";
/**
 * @public
 * @description map markers control name: "markerspanecollapsed"
*/
tf.consts.markersPanelCollapsed = "markerspanecollapsed";
/**
 * @public
 * @description map download control name: "download"
*/
tf.consts.panelNameDownload = "download";
/**
 * @public
 * @description map measure control name: "measure"
*/
tf.consts.panelNameMeasure = "measure";
/**
 * @public
 * @description map type control name: "type"
*/
tf.consts.panelNameType = "type";
/**
 * @public
 * @description map fullscreen control name: "fullscreen"
*/
tf.consts.panelNameFullscreen = "fullscreen";
/**
 * @public
 * @description map source control name: "source"
*/
tf.consts.panelNameSource = "source";
/**
 * @public
 * @description map address control name: "address"
*/
tf.consts.panelNameAddress = "address";
/**
 * @public
 * @description map location control name: "maplocation"
*/
tf.consts.panelNameMapLocation = "maplocation";
/**
 * @public
 * @description map scale control name: "mapscale"
*/
tf.consts.panelNameMapScale = "mapscale";
/**
 * @public
 * @description map rotate control name: "maprotate"
*/
tf.consts.panelNameMapRotate = "maprotate";
/**
 * @public
 * @description map user location control name: "userlocation"
*/
tf.consts.panelNameUserLocation = "userlocation";
/**
 * @public
 * @description map logo control name: "tflogo"
*/
tf.consts.panelNameTFLogo = "tflogo";
/**
 * @public
 * @description prevents the map's address bar control from being displayed: "noaddress"
*/
tf.consts.panelNameNoAddress = "noaddress";
/**
 * @public
 * @description prevents the map's location control from being displayed: "nomaplocation"
*/
tf.consts.panelNameNoMapLocation = "nomaplocation";
/**
 * @public
 * @description prevents the map's rotate control from being displayed: "nomaprotate"
*/
tf.consts.panelNameNoMapRotate = "nomaprotate";
/**
 * @public
 * @description prevents the map's scale control from being displayed: "nomapscale"
*/
tf.consts.panelNameNoMapScale = "nomapscale";
/**
 * @public
 * @description prevents the map's user location control from being displayed: "nouserlocation"
*/
tf.consts.panelNameNoUserLocation = "nouserlocation";
tf.consts.panelNameNoMapCenter = "nomapcenter";
/**
 * @public
 * @description character used to separate string component names, like names of map panels ({@link tf.types.mapPanelName}) in a panel name string ({@link tf.types.mapPanelNamesString})
*/
tf.consts.charSplitStrings = '+';
tf.consts.allPanelNames = [
    tf.consts.panelNameAddress,
    tf.consts.panelNameZoom,
    tf.consts.panelNameLayers,
    tf.consts.markersPanelCollapsed,
    tf.consts.panelNameType,
    tf.consts.panelNameMeasure,
    tf.consts.panelNameDownload,
    tf.consts.panelNameSource,
    tf.consts.panelNameFullscreen,
    tf.consts.panelNameMapLocation,
    tf.consts.panelNameOverview,
    tf.consts.panelNameMapScale,
    tf.consts.panelNameMapRotate,
    tf.consts.panelNameUserLocation,
    tf.consts.panelNameTFLogo
];
tf.consts.defaultPanels =
    tf.consts.panelNameTFLogo + tf.consts.charSplitStrings +
    tf.consts.panelNameAddress + tf.consts.charSplitStrings +
    tf.consts.panelNameZoom + tf.consts.charSplitStrings +
    tf.consts.panelNameLayers + tf.consts.charSplitStrings +
    tf.consts.panelNameType + tf.consts.charSplitStrings +
    tf.consts.panelNameMeasure + tf.consts.charSplitStrings +
    tf.consts.panelNameMapLocation + tf.consts.charSplitStrings +
    tf.consts.panelNameUserLocation + tf.consts.charSplitStrings +
    tf.consts.panelNameMapRotate + tf.consts.charSplitStrings +
    tf.consts.panelNameMapScale + tf.consts.charSplitStrings +
    tf.consts.panelNameOverview;
tf.consts.charSplitApps = '+';
/**
 * The name of a map panel displayed by default by the URL-API, one of:<br>
 * {@link tf.consts.panelNameAddress},<br>
 * {@link tf.consts.panelNameLayers},<br>
 * {@link tf.consts.markersPanelCollapsed},<br>
 * {@link tf.consts.panelNameMapLocation},<br>
 * {@link tf.consts.panelNameMapRotate},<br>
 * {@link tf.consts.panelNameMapScale},<br>
 * {@link tf.consts.panelNameMeasure},<br>
 * {@link tf.consts.panelNameOverview},<br>
 * {@link tf.consts.panelNameTFLogo},<br>
 * {@link tf.consts.panelNameType},<br>
 * {@link tf.consts.panelNameUserLocation},<br>
 * or {@link tf.consts.panelNameZoom}
 * @public
 * @typedef {tf.types.mapDefaultPanelName} tf.types.mapDefaultPanelName
 */
/**
 * The name of a map panel, one of:<br>
 * {@link tf.consts.panelNameAddress},<br>
 * {@link tf.consts.panelNameDownload},<br>
 * {@link tf.consts.panelNameFullscreen},<br>
 * {@link tf.consts.panelNameLayers},<br>
 * {@link tf.consts.markersPanelCollapsed},<br>
 * {@link tf.consts.panelNameMapLocation},<br>
 * {@link tf.consts.panelNameMapRotate},<br>
 * {@link tf.consts.panelNameMapScale},<br>
 * {@link tf.consts.panelNameMeasure},<br>
 * {@link tf.consts.panelNameOverview},<br>
 * {@link tf.consts.panelNameSource},<br>
 * {@link tf.consts.panelNameTFLogo},<br>
 * {@link tf.consts.panelNameType},<br>
 * {@link tf.consts.panelNameUserLocation},<br>
 * {@link tf.consts.panelNameZoom},<br>
 * {@link tf.consts.panelNameNoAddress},<br>
 * {@link tf.consts.panelNameNoMapLocation},<br>
 * {@link tf.consts.panelNameNoMapRotate},<br>
 * {@link tf.consts.panelNameNoMapScale},<br>
 * {@link tf.consts.panelNameNoMapCenter},<br>
 * or {@link tf.consts.panelNameNoUserLocation}
 * @public
 * @typedef {tf.types.mapPanelName} tf.types.mapPanelName
 */
/**
 * A string listing names of map panels (see {@link tf.types.mapPanelName}) separated by the character {@link tf.consts.charSplitStrings}<br>
 * This type of string is used by the namespace {@link tf.urlapi}, and in the creation of [Map]{@link tf.map.Map} instances 
 * @public
 * @typedef {string} tf.types.mapPanelNamesString
 */
/**
*/
 //* Name of the [URL Parameter]{@link tf.types.URLParameters} that activates the "Realtor" native application
 //* @public
 //*/
//tf.consts.appNameRAMB = "ramb";
//tf.consts.appNameALTA = "alta";
/*tf.consts.allAppsNames = [
    //tf.consts.appNameALTA,
    tf.consts.appNameRAMB
];
tf.consts.defaultApps = "";*/
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the Map Engine to use: "fmap"
 * @public
 */
tf.consts.paramNameFMap = "fmap";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the initial map center latitude coordinate: "lat"
 * @public
 */
tf.consts.paramNameLat = "lat";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the initial map center latitude coordinate: "lon"
 * @public
 */
tf.consts.paramNameLon = "lon";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the initial map resolution: "res"
 * @public
 */
tf.consts.paramNameRes = "res";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the initial map level, ignored if <b>resolution</b> is defined: "level"
 * @public
 */
tf.consts.paramNameLevel = "level";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the initial visibility of [map panels]{@link tf.types.mapPanelNamesString}: "panels"
 * @public
 */
tf.consts.paramNamePanels = "panels";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the initial contents of the map's address bar: "address"
 * @public
 */
tf.consts.paramNameAddress = "address";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the contents of the help message displayed by the map: "help"
 * @public
 */
tf.consts.paramNameHelp = "help";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling a string used by the map when interacting with some TerraFly services: "vid"
 * @public
 */
tf.consts.paramNameVid = "vid";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling a string used by the map when interacting with some TerraFly services: "tf_passtrough"
 * @public
 */
tf.consts.paramNamePassThrough = "tf_passtrough";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling whether the TerraFly logo is displayed by the map: "tflogo"
 * @public
 */
tf.consts.paramNameTFLogo = "tflogo";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the initial map type: "type"
 * @public
 */
tf.consts.paramNameType = "type";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the initial map source: "source"
 * @public
 */
tf.consts.paramNameSource = "source";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the number of seconds before the map's Message Popup closes itself: "rgpopup"
 * @public
 */
tf.consts.paramNameMessageTimeout = "rgpopup";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the [Legend String]{@link tf.types.legendString} for Mapnik 1.0 used by the map's Base Layers: "legend"
 * @public
 */
tf.consts.paramNameLegend = "legend";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the hybrid [Legend String]{@link tf.types.legendString} for Mapnik 2.0 used by the map's Base Layers: "legendh"
 * @public
 */
tf.consts.paramNameLegendH = "legendh";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the Map [Legend String]{@link tf.types.legendString} for Mapnik 2.0 used by the map's Base Layers: "legendm"
 * @public
 */
tf.consts.paramNameLegendM = "legendm";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the optional name of a the native TerraFly API application to be executed. Currently {@link tf.consts.appNameRAMB} is supported: "apps"
 * @public
 */
tf.consts.paramNameApps = "apps";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling an optional file name containing additional specifications: "appspecs"
 * @public
 */
tf.consts.paramNameAppSpecs = "appspecs";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the name of a [DLayer]{@link tf.urlapi.DLayer}, ending with the number identifying a dlayer: "dlayerlegend1", "dlayerlegend2", etc.
 * @public
 */
tf.consts.paramNameDLLegend = "dlayerlegend";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the remote service associated with a [DLayer]{@link tf.urlapi.DLayer}, ending with the number identifying a dlayer: "dlayerdata1", "dlayerdata2", etc.
 * @public
 */
tf.consts.paramNameDLData = "dlayerdata";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the [DLayer]{@link tf.urlapi.DLayer} field to display as a [Map Feature]{@link tf.map.Feature}, ending with the number identifying a dlayer: "dlayerfield1", "dlayerfield2", etc.
 * @public
 */
tf.consts.paramNameDLField = "dlayerfield";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the initial map visibility of a [DLayer]{@link tf.urlapi.DLayer}, ending with the number identifying a dlayer: "dlayerselect1", "dlayerselect2", etc.
 * @public
 */
tf.consts.paramNameDLSelect = "dlayerselect";
/**
 * Name of the [URL Parameter]{@link tf.types.URLParameters} controlling the color with which to display text markers belonging to a [DLayer]{@link tf.urlapi.DLayer}, ending with the number identifying a dlayer: "dlayercolor1", "dlayercolor2", etc.
 * @public
 */
tf.consts.paramNameDLColor = "dlayercolor";
/**
 * Name of the optional [URL Parameter]{@link tf.types.URLParameters} containing a number that, when present, determines the minimum number of records of the first DLayer that must initially be displayed either by zooming out or by re-centering the map, or a combination of both
 * @public
 */
tf.consts.paramNameDLExtent = "dlayerextent";
tf.consts.paramNameDLPreClick = "dlayerpreclick";
/**
 * Name of the optional [URL Parameter]{@link tf.types.URLParameters} governing the optional creation of a perspective map, if set to {@link void} no perspective map is created,
 * if set to {@link boolean} a perspective map is created, and displayed or hidden according to the given boolean value (true = displayed, false = hidden)
 * @public
 */
tf.consts.paramNamePerspectiveMap = "perspectivemap";
tf.consts.paramNameDirectionsMode = "directionsmode";
tf.consts.paramNameDirectionsDest = "directionsdest";
tf.consts.paramNameDirectionsUseBus = "directionsbus";
tf.consts.MVideoParamNameVideo = "m";
tf.consts.minMessageTimeout = 0;
tf.consts.maxMessageTimeout = 60;
/**
 * @public
 * @description default timeout in secods for the map Message Popup
*/
tf.consts.defaultMessageTimeout = 5;
tf.consts.addressBarName = "Search Location";
tf.consts.mapTypesName = "Display Type";
tf.consts.mapTypesHybridLabel = "Hybrid";
tf.consts.mapTypesAerialLabel = "Aerial";
tf.consts.mapTypesMapLabel = "Map";
tf.consts.mapTypesHybridTip = "Hybrid: Aerial + Map";
tf.consts.mapTypesAerialTip = "Aerial images only";
tf.consts.mapTypesMapTip = "Map images only";
tf.consts.centerToUserLocationTip = "Center Map to User Location";
tf.consts.mapLayersName = "Map Layers";
tf.consts.baseMapLayersName = "Base Layers";
tf.consts.baseMapLayersToolTip = "View Base Layers";
tf.consts.mapSourcesName = "Aerial Source";
tf.consts.mapSourcesItemTip = "Use images from: ";
tf.consts.mapLayerSourceName = "maplayersource";
tf.consts.mapDownloadName = "Download";
tf.consts.mapMeasureName = "Measure";
tf.consts.mapLocationShowTip = "Enable Location Information on Map Move";
tf.consts.mapLocationHideTip = "Disable Location Information on Map Move";
tf.consts.mapLocationPopupHideTip = "Hide Location Information";
tf.consts.fullScreenToolTipNormal = "View Full Screen";
tf.consts.fullScreenToolTipFull = "Exit Full Screen";
tf.consts.minAppWidthNumber = 400;
tf.consts.minAppHeightNumber = 360;
tf.consts.defaultGeocoderError = "ERROR IN ADDRESS, PLEASE REENTER";
/**
 * @public
 * @description {@link TMap} instance panel visible state
 * @deprecated TerraFly applications use should replace the use of {@link TMap} instances with {@link tf.map.Map} instances
*/
tf.consts.strShowPanel = "SHOW";
/**
 * @public
 * @description {@link TMap} instance panel hidden state
 * @deprecated TerraFly applications use should replace the use of {@link TMap} instances with {@link tf.map.Map} instances
*/
tf.consts.strHidePanel = "HIDE";
/**
 * The visibility state of a [TMap]{@link TMap} panel, either {@link tf.consts.strShowPanel} or {@link tf.consts.strHidePanel}
 * @public
 * @typedef {tf.types.mapPanelVisibilityState} tf.types.mapPanelVisibilityState
 */
/**
 * URL to the TerraFly routing service
 * @public
 */
tf.consts.RoutingServiceURL = "http://131.94.133.147:5000/";
/**
 * Mode used by the TerraFly routing service
 * @public
 */
tf.consts.routingServiceModeFoot = "foot";
/**
 * Mode used by the TerraFly routing service
 * @public
 */
tf.consts.routingServiceModeCar = "car";
/**
 * Mode used by the TerraFly routing service
 * @public
 */
tf.consts.routingServiceModeBicycle = "bicycle";
tf.consts.routingServiceModeBus = "bus";
/**
 * A mode string with the TerraFly routing service, one of:<br>
 * {@link tf.consts.routingServiceModeFoot},<br>
 * {@link tf.consts.routingServiceModeBicycle},<br>
 * or {@link tf.consts.routingServiceModeCar}
 * @public
 * @typedef {string} tf.types.routingServiceMode
 */
tf.consts.worldGeodeticSystemStr = "EPSG:4326";
tf.consts.sphericalMercatorSystemStr = "EPSG:3857";
tf.consts.UTMSystemStr = "EPSG:3006";
tf.consts.olSystem = tf.consts.sphericalMercatorSystemStr;
tf.consts.tmSystem = tf.consts.worldGeodeticSystemStr;
tf.consts.downloadSystem = tf.consts.UTMSystemStr;
/**
 * Reserved prefix used by the API for [SVG Glyph Specifications]{@link tf.types.SVGGlyphSpecs} provided by the API's {@link singleton} [SVG Glyph Library]{@link tf.styles.SvgGlyphLib} 
 * @public
 */
tf.consts.SVGGlyphPrefix = "-tf-svgglyph-";
/**
 * Reserved prefix used by the API for known object properties of value <b>"-tf-prop-"</b>. Applications using the API should not name public object properties using with this prefix
 * @public
 */
tf.consts.KnownPropertyPrefix = "-tf-prop-";
/**
 * The reserved and default property name for [DLayer]{@link tf.urlapi.DLayer} instances
 * @public
 */
tf.consts.DLayerProperty = tf.consts.KnownPropertyPrefix + "dlayer";
/**
 * The reserved and default property name for [Table Row]{@link tf.ui.TableRow} instances
 * @public
 */
tf.consts.TableRowProperty = tf.consts.KnownPropertyPrefix + "tablerow";
/**
 * The reserved and default property name for [Keyed Feature]{@link tf.map.KeyedFeature} instances
 * @public
 */
tf.consts.KeyedFeatureProperty = tf.consts.KnownPropertyPrefix + "keyedfeature";
/**
 * The name of a known TerraFly API property, one of:<br>
 * {@link tf.consts.DLayerProperty},<br>
 * {@link tf.consts.TableRowProperty},<br>
 * or {@link tf.consts.KeyedFeatureProperty}
 * @public
 * @typedef {tf.types.KnownAPIPropertyName} tf.types.KnownAPIPropertyName
 * @see [Known Property Prefix]{@link tf.consts.KnownPropertyPrefix}
 */
tf.consts.DOMEventNames = {};
/**
 * @public
 * @description DOM "focus" event
*/
tf.consts.DOMEventNamesFocus = "focus";
/**
 * @public
 * @description DOM "blur" event
*/
tf.consts.DOMEventNamesBlur = "blur";
/**
 * @public
 * @description DOM "ended" event
*/
tf.consts.DOMEventNamesEnded = "ended";
/**
 * @public
 * @description DOM "timeupdate" event
*/
tf.consts.DOMEventNamesTimeUpdate = "timeupdate";
/**
 * @public
 * @description DOM "loadmetadata" event
*/
tf.consts.DOMEventNamesLoadMetaData = "loadmetadata";
/**
 * @public
 * @description DOM "click" event
*/
tf.consts.DOMEventNamesClick = "click";
/**
 * @public
 * @description DOM "DOMMouseScroll" event
*/
tf.consts.DOMEventNamesDOMMouseScroll = "DOMMouseScroll";
/**
 * @public
 * @description DOM "mousewheel" event
*/
tf.consts.DOMEventNamesMouseWheel = "mousewheel";
/**
 * @public
 * @description DOM "losefocus" event
*/
tf.consts.DOMEventNamesLoseFocus = "losefocus";
/**
 * @public
 * @description DOM "resize" event
*/
tf.consts.DOMEventNamesResize = "resize";
/**
 * @public
 * @description DOM "keypress" event
*/
tf.consts.DOMEventNamesKeyPress = "keypress";
/**
 * @public
 * @description DOM "keyup" event
*/
tf.consts.DOMEventNamesKeyUp = "keyup";
/**
 * @public
 * @description DOM "mousemove" event
*/
tf.consts.DOMEventNamesMouseMove = "mousemove";
/**
 * @public
 * @description DOM "mouseup" event
*/
tf.consts.DOMEventNamesMouseUp = "mouseup";
/**
 * @public
 * @description DOM "mousedown" event
*/
tf.consts.DOMEventNamesMouseDown = "mousedown";
/**
 * @public
 * @description DOM "mouseover" event
*/
tf.consts.DOMEventNamesMouseOver = "mouseover";
/**
 * @public
 * @description DOM "mouseout" event
*/
tf.consts.DOMEventNamesMouseOut = "mouseout";
/**
 * @public
 * @description DOM "mouseenter" event
*/
tf.consts.DOMEventNamesMouseEnter = "mouseenter";
/**
 * @public
 * @description DOM "mouseleave" event
*/
tf.consts.DOMEventNamesMouseLeave = "mouseleave";
/**
 * @public
 * @description DOM "touchstart" event
*/
tf.consts.DOMEventNamesTouchStart = "touchstart";
/**
 * @public
 * @description DOM "touchmove" event
*/
tf.consts.DOMEventNamesTouchMove = "touchmove";
/**
 * @public
 * @description DOM "touchend" event
*/
tf.consts.DOMEventNamesTouchEnd = "touchend";
/**
 * @public
 * @description DOM "touchenter" event
*/
tf.consts.DOMEventNamesTouchEnter = "touchenter";
/**
 * @public
 * @description DOM "touchleave" event
*/
tf.consts.DOMEventNamesTouchLeave = "touchleave";
/**
 * @public
 * @description DOM "touchcancel" event
*/
tf.consts.DOMEventNamesTouchCancel = "touchcancel";
/**
 * The name of a DOM event, one of:<br>
 * {@link tf.consts.DOMEventNamesBlur},<br>
 * {@link tf.consts.DOMEventNamesFocus},<br>
 * {@link tf.consts.DOMEventNamesEnded},<br>
 * {@link tf.consts.DOMEventNamesTimeUpdate},<br>
 * {@link tf.consts.DOMEventNamesLoadMetaData},<br>
 * {@link tf.consts.DOMEventNamesClick},<br>
 * {@link tf.consts.DOMEventNamesLoseFocus},<br>
 * {@link tf.consts.DOMEventNamesResize},<br>
 * {@link tf.consts.DOMEventNamesKeyPress},<br>
 * {@link tf.consts.DOMEventNamesKeyUp},<br>
 * {@link tf.consts.DOMEventNamesMouseMove},<br>
 * {@link tf.consts.DOMEventNamesMouseUp},<br>
 * {@link tf.consts.DOMEventNamesMouseDown},<br>
 * {@link tf.consts.DOMEventNamesMouseOver},<br>
 * {@link tf.consts.DOMEventNamesMouseOut},<br>
 * {@link tf.consts.DOMEventNamesMouseEnter},<br>
 * {@link tf.consts.DOMEventNamesMouseLeave},<br>
 * {@link tf.consts.DOMEventNamesTouchStart},<br>
 * {@link tf.consts.DOMEventNamesTouchMove},<br>
 * {@link tf.consts.DOMEventNamesTouchEnd},<br>
 * {@link tf.consts.DOMEventNamesTouchEnter},<br>
 * {@link tf.consts.DOMEventNamesTouchLeave},<br>
 * {@link tf.consts.DOMEventNamesTouchCancel},<br>
 * or another {@link string} known to be a DOM event name.
 * @public
 * @typedef {tf.types.DOMEventName} tf.types.DOMEventName
 */
/**
 * The name of a mouse related DOM event, one of:<br>
 * {@link tf.consts.DOMEventNamesMouseMove},<br>
 * {@link tf.consts.DOMEventNamesMouseUp},<br>
 * {@link tf.consts.DOMEventNamesMouseDown},<br>
 * {@link tf.consts.DOMEventNamesMouseOver},<br>
 * {@link tf.consts.DOMEventNamesMouseOut},<br>
 * {@link tf.consts.DOMEventNamesMouseEnter},<br>
 * {@link tf.consts.DOMEventNamesMouseLeave},<br>
 * {@link tf.consts.DOMEventNamesTouchStart},<br>
 * {@link tf.consts.DOMEventNamesTouchMove},<br>
 * {@link tf.consts.DOMEventNamesTouchEnd},<br>
 * {@link tf.consts.DOMEventNamesTouchEnter},<br>
 * {@link tf.consts.DOMEventNamesTouchLeave},<br>
 * or {@link tf.consts.DOMEventNamesTouchCancel}
 * @public
 * @typedef {tf.types.DOMMouseEventName} tf.types.DOMMouseEventName
 */
tf.consts.allMouseEventNames = [
 tf.consts.DOMEventNamesMouseMove,
 tf.consts.DOMEventNamesMouseUp,
 tf.consts.DOMEventNamesMouseDown,
 tf.consts.DOMEventNamesMouseOver,
 tf.consts.DOMEventNamesMouseOut,
 tf.consts.DOMEventNamesMouseEnter,
 tf.consts.DOMEventNamesMouseLeave,
 tf.consts.DOMEventNamesTouchStart,
 tf.consts.DOMEventNamesTouchMove,
 tf.consts.DOMEventNamesTouchEnd,
 tf.consts.DOMEventNamesTouchEnter,
 tf.consts.DOMEventNamesTouchLeave,
 tf.consts.DOMEventNamesTouchCancel
];
tf.consts.DOMEventNameswebkitfullscreenchange = "webkitfullscreenchange";
tf.consts.DOMEventNamesmozfullscreenchange = "mozfullscreenchange";
tf.consts.DOMEventNamesfullscreenchange = "fullscreenchange";
tf.consts.DOMEventNamesMSFullscreenChange = "MSFullscreenChange";
tf.consts.allFullScreenEventNames = [
    tf.consts.DOMEventNameswebkitfullscreenchange,
    tf.consts.DOMEventNamesmozfullscreenchange,
    tf.consts.DOMEventNamesfullscreenchange,
    tf.consts.DOMEventNamesMSFullscreenChange
];
/**
 * @public
 * @description {@link tf.js.KeyedList} list deleted event
*/
tf.consts.keyedListDeleteEvent = "listDelete";
/**
 * @public
 * @description {@link tf.js.KeyedList} items added event
*/
tf.consts.keyedListAddedItemsEvent = "listAddedItems";
/**
 * @public
 * @description {@link tf.js.KeyedList} items updated event
*/
tf.consts.keyedListUpdatedItemsEvent = "listUpdatedItems";
/**
 * @public
 * @description {@link tf.js.KeyedList} items deleted event
*/
tf.consts.keyedListDeletedItemsEvent = "listDeletedItems";
tf.consts.allKeyedListEventNames = [
    tf.consts.keyedListDeleteEvent,
    tf.consts.keyedListAddedItemsEvent,
    tf.consts.keyedListUpdatedItemsEvent,
    tf.consts.keyedListDeletedItemsEvent
];
/**
 * The name of a [Keyed List]{@link tf.js.KeyedList} event, one of:<br>
 * {@link tf.consts.keyedListDeleteEvent},<br>
 * {@link tf.consts.keyedListAddedItemsEvent},<br>
 * {@link tf.consts.keyedListUpdatedItemsEvent},<br>
 * or {@link tf.consts.keyedListDeletedItemsEvent}
 * @public
 * @typedef {tf.types.keyedListEventName} tf.types.keyedListEventName
 */
/**
 * @public
 * @description {@link tf.map.FeatureList} features added event
*/
tf.consts.keyedFeaturesAddedEvent = "featuresAdded";
/**
 * @public
 * @description {@link tf.map.FeatureList} features updated event
*/
tf.consts.keyedFeaturesUpdatedEvent = "featuresUpdated";
/**
 * @public
 * @description {@link tf.map.FeatureList} features deleted event
*/
tf.consts.keyedFeaturesDeletedEvent = "featuresDeleted";
tf.consts.allKeyedFeaturesEventNames = [
    tf.consts.keyedFeaturesAddedEvent,
    tf.consts.keyedFeaturesUpdatedEvent,
    tf.consts.keyedFeaturesDeletedEvent
];
/**
 * The name of a [Keyed Feature List]{@link tf.map.KeyedFeatureList} event, one of:<br>
 * {@link tf.consts.keyedFeaturesAddedEvent},<br>
 * {@link tf.consts.keyedFeaturesUpdatedEvent},<br>
 * or {@link tf.consts.keyedFeaturesDeletedEvent}
 * @public
 * @typedef {tf.types.keyedFeatureListEventName} tf.types.keyedFeatureListEventName
 */
/**
 * @public
 * @description {@link tf.ui.KeyedTable} rows added event
*/
tf.consts.keyedTableRowsAddedEvent = "keyedTableRowsAdded";
/**
 * @public
 * @description {@link tf.ui.KeyedTable} rows updated event
*/
tf.consts.keyedTableRowsUpdatedEvent = "keyedTableRowsUpdated";
/**
 * @public
 * @description {@link tf.ui.KeyedTable} rows deleted event
*/
tf.consts.keyedTableRowsDeletedEvent = "keyedTableRowsDeleted";
tf.consts.keyedTableRowsEventNames = [
    tf.consts.keyedTableRowsAddedEvent,
    tf.consts.keyedTableRowsUpdatedEvent,
    tf.consts.keyedTableRowsDeletedEvent
];
/**
 * The name of a [Keyed Table]{@link tf.ui.KeyedTable} event, one of:<br>
 * {@link tf.consts.keyedRowTableRowsAddedEvent},<br>
 * {@link tf.consts.keyedRowTableRowsUpdatedEvent},<br>
 * or {@link tf.consts.keyedRowTableRowsDeletedEvent}
 * @public
 * @typedef {tf.types.keyedFeatureListEventName} tf.types.keyedFeatureListEventName
 */
/**
 * @public
 * @description {@link tf.map.FeatureLayer} visibility change event
*/
tf.consts.mapFeatureLayerVisibilityChangeEvent = "visibilityChange";
tf.consts.allMapFeatureLayerEventNames = [
    tf.consts.mapFeatureLayerVisibilityChangeEvent
];
/**
 * The name of a {@link tf.map.FeatureLayer} event, one of:<br>
 * {@link tf.consts.mapFeatureLayerVisibilityChangeEvent}
 * @public
 * @typedef {tf.types.mapFeatureLayerEventName} tf.types.mapFeatureLayerEventName
 */
/**
 * @public
 * @description {@link tf.map.Map} toggle scale unit event
*/
tf.consts.mapToggleScaleUnitEvent = "toggleScaleUnit";
/**
 * @public
 * @description {@link tf.map.Map} move end event
*/
tf.consts.mapMoveEndEvent = "moveEnd";
tf.consts.mapMoveStartEvent = "moveStart";
/**
 * @public
 * @description {@link tf.map.Map} map container resized event
*/
tf.consts.mapResizedEvent = "resized";
/**
 * @public
 * @description {@link tf.map.Map} mouse move event
*/
tf.consts.mapMouseMoveEvent = "mouseMove";
/**
 * @public
 * @description {@link tf.map.Map} mouse click event
*/
tf.consts.mapClickEvent = "click";
/**
 * @public
 * @description {@link tf.map.Map} mouse drag event
*/
tf.consts.mapMouseDragEvent = "mouseDrag";
/**
 * @public
 * @description {@link tf.map.Map} mouse drag event
*/
tf.consts.mapEndDragEvent = "endDrag";
/**
 * @public
 * @description {@link tf.map.Map} mouse instant click event
*/
tf.consts.mapInstantClickEvent = "iclick";
/**
 * @public
 * @description {@link tf.map.Map} mouse double click event
*/
tf.consts.mapDblClickEvent = "dblClick";
/**
 * @public
 * @description {@link tf.map.Map} mouse click on map feature event
*/
tf.consts.mapFeatureClickEvent = "featureClick";
/**
 * @public
 * @description {@link tf.map.Map} mouse click on map feature event
*/
tf.consts.mapFeatureInstantClickEvent = "ifeatureClick";
/**
 * @public
 * @description {@link tf.map.Map} mouse double click on map feature event
*/
tf.consts.mapFeatureDblClickEvent = "featureDblClick";
/**
 * @public
 * @description {@link tf.map.Map} mouse move on map feature event
*/
tf.consts.mapFeatureMouseMoveEvent = "featureMouseMove";
/**
 * @public
 * @description {@link tf.map.Map} mouse drag on map feature event
*/
tf.consts.mapFeatureMouseDragEvent = "featureMouseDrag";
/**
 * @public
 * @description {@link tf.map.Map} mouse hover in our out of map feature event
*/
tf.consts.mapFeatureHoverInOutEvent = "featureHoverInOut";
/**
 * @public
 * @description {@link tf.map.Map} map mode change event
*/
tf.consts.mapTypeChangeEvent = "modeChange";
/**
 * @public
 * @description {@link tf.map.Map} map level change event
*/
tf.consts.mapLevelChangeEvent = "levelChange";
/**
 * @public
 * @description {@link tf.map.Map} map resolution change event
*/
tf.consts.mapResolutionChangeEvent = "resolutionChange";
/**
 * @public
 * @description {@link tf.map.Map} map rotation change event
*/
tf.consts.mapRotationChangeEvent = "rotationChange";
/**
 * @public
 * @description {@link tf.map.Map} map switch to/from fullscreen event
*/
tf.consts.mapFullScreenEvent = "fullScreen";
/**
 * @public
 * @description {@link tf.map.Map} map postcompose event
*/
tf.consts.mapPostComposeEvent = "postCompose";
tf.consts.mapPostPostComposeEvent = "postPostCompose";
/**
 * @public
 * @description {@link tf.map.Map} map precompose event
*/
tf.consts.mapPreComposeEvent = "preCompose";
/**
 * @public
 * @description {@link tf.map.Map} map postrender event
*/
tf.consts.mapPostRenderEvent = "postRender";
/**
 * @public
 * @description {@link tf.map.Map} map view settings changed event
*/
tf.consts.mapViewSettingsChangedEvent = "viewsettingschanged";
tf.consts.allMapEventNames = [
    tf.consts.mapToggleScaleUnitEvent,
    tf.consts.mapMoveEndEvent,
    tf.consts.mapMoveStartEvent,
    tf.consts.mapResizedEvent,
    tf.consts.mapMouseMoveEvent,
    tf.consts.mapMouseDragEvent,
    tf.consts.mapEndDragEvent,
    tf.consts.mapClickEvent,
    tf.consts.mapInstantClickEvent,
    tf.consts.mapDblClickEvent,
    tf.consts.mapFeatureInstantClickEvent,
    tf.consts.mapFeatureClickEvent,
    tf.consts.mapFeatureDblClickEvent,
    tf.consts.mapFeatureMouseMoveEvent,
    tf.consts.mapFeatureMouseDragEvent,
    tf.consts.mapFeatureHoverInOutEvent,
    tf.consts.mapTypeChangeEvent,
    tf.consts.mapLevelChangeEvent,
    tf.consts.mapResolutionChangeEvent,
    tf.consts.mapRotationChangeEvent,
    tf.consts.mapFullScreenEvent,
    tf.consts.mapPostComposeEvent,
    tf.consts.mapPostPostComposeEvent,
    tf.consts.mapPreComposeEvent,
    tf.consts.mapPostRenderEvent,
    tf.consts.mapViewSettingsChangedEvent
];
/**
 * The name of a [Map]{@link tf.map.Map} event, one of:<br>
 * {@link tf.consts.mapToggleScaleUnitEvent},<br>
 * {@link tf.consts.mapMoveEndEvent},<br>
 * {@link tf.consts.mapMoveStartEvent},<br>
 * {@link tf.consts.mapResizedEvent},<br>
 * {@link tf.consts.mapMouseMoveEvent},<br>
 * {@link tf.consts.mapMouseDragEvent},<br>
 * {@link tf.consts.mapEndDragEvent},<br>
 * {@link tf.consts.mapClickEvent},<br>
 * {@link tf.consts.mapInstantClickEvent},<br>
 * {@link tf.consts.mapDblClickEvent},<br>
 * {@link tf.consts.mapFeatureClickEvent},<br>
 * {@link tf.consts.mapInstantFeatureClickEvent},<br>
 * {@link tf.consts.mapFeatureDblClickEvent},<br>
 * {@link tf.consts.mapFeatureMouseMoveEvent},<br>
 * {@link tf.consts.mapFeatureMouseDragEvent},<br>
 * {@link tf.consts.mapFeatureHoverInOutEvent},<br>
 * {@link tf.consts.mapTypeChangeEvent},<br>
 * {@link tf.consts.mapLevelChangeEvent},<br>
 * {@link tf.consts.mapResolutionChangeEvent},<br>
 * {@link tf.consts.mapRotationChangeEvent},<br>
 * {@link tf.consts.mapFullScreenEvent},<br>
 * {@link tf.consts.mapPreComposeEvent},<br>
 * {@link tf.consts.mapPostComposeEvent},<br>
 * {@link tf.consts.mapPostPostComposeEvent},<br>
 * {@link tf.consts.mapPostRenderEvent},<br>
 * or {@link tf.consts.mapViewSettingsChangedEvent}
 * @public
 * @typedef {tf.types.mapEventName} tf.types.mapEventName
 */
/**
 * @public
 * @description positioning specification
*/
tf.consts.positioningCenter = 'center';
/**
 * @public
 * @description positioning specification
*/
tf.consts.positioningLeft = 'left';
/**
 * @public
 * @description positioning specification
*/
tf.consts.positioningRight = 'right';
/**
 * @public
 * @description positioning specification
*/
tf.consts.positioningTop = 'top';
/**
 * @public
 * @description positioning specification
*/
tf.consts.positioningBottom = 'bottom';
/**
 * The name of a horizontal positioning, one of:<br>
 * {@link tf.consts.positioningCenter},<br>
 * {@link tf.consts.positioningLeft},<br>
 * or {@link tf.consts.positioningRight}
 * @public
 * @typedef {tf.types.horizontalPositioning} tf.types.horizontalPositioning
 */
/**
 * The name of a vertical positioning, one of:<br>
 * {@link tf.consts.positioningCenter},<br>
 * {@link tf.consts.positioningTop},<br>
 * or {@link tf.consts.positioningBottom}
 * @public
 * @typedef {tf.types.verticalPositioning} tf.types.verticalPositioning
 */
/**
 * @public
 * @description the default style name used by instances of [Map Feature With Named Styles]{@link tf.map.FeatureWithNamedStyles}
*/
tf.consts.defaultMapFeatureStyleName = "defaultMapFeatureStyleName";
/**
 * @public
 * @description the default duration, in milliseconds, used in [AnimatedSetLevel]{@link tf.map.Map#AnimatedSetLevel}
*/
tf.consts.defaultMapAnimatedDurationPerLevelMillis = 400;
/**
 * @public
 * @description the default duration, in milliseconds, used in [AnimatedSetCenter]{@link tf.map.Map#AnimatedSetLevel}
*/
tf.consts.defaultMapAnimatedCenterDurationMillis = 300;

// SOURCE FILE: platform.js
// tf.platform
tf.platform.TestURL = "http://experiment2.cs.fiu.edu/hterramap/test/";
tf.platform.StageURL = "http://experiment2.cs.fiu.edu/hterramap/stage/";
tf.platform.ProdURL = "http://tfcore.cs.fiu.edu/hterramap/";
tf.platform.LocalURL = "http://localhost/terramap/";
tf.platform.isKnown = false;
/**
 * @public
 * @function
 * @summary - Retrieves the URL of this platform of the <b>TerraFly API</b>
* @returns {string} - | {@link string} the URL string
*/
tf.platform.GetURL = function () {
    function getURLOfScript (scriptFileName) {
        var scriptURL;
        if (typeof scriptFileName === "string") {
            var scriptElements = document.getElementsByTagName('script');
            var i, element;
            for (i = 0; element = scriptElements[i]; ++i) {
                var myfile = element.src, index = myfile.indexOf(scriptFileName);
                if (index >= 0) { scriptURL = myfile.substring(0, index); break; }
            }
        }
        return scriptURL;
    }
    function findURL() {
        var url = getURLOfScript("mapapi.js");
        if (url !== undefined) {
            if (tf.platform.isKnown = (url.indexOf('test') >= 0)) { url = tf.platform.TestURL; }
            else if (tf.platform.isKnown = (url.indexOf('stage') >= 0)) { url = tf.platform.StageURL; }
            else if (tf.platform.isKnown = (url.indexOf('tfcore') >= 0)) { url = tf.platform.ProdURL; }
        }
        if (!tf.platform.isKnown) { url = '';/*url = tf.platform.TestURL;*/ tf.platform.isKnown = false; }
        return url;
    }
    if (tf.platform.PlatformURL == undefined) {
        tf.platform.PlatformURL = findURL();
    }
    return tf.platform.PlatformURL;
}
/**
 * @public
 * @function
 * @summary - Checks if this is a known platform of the <b>TerraFly API</b>
* @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.platform.GetIsKnown = function () { tf.platform.GetURL(); return tf.platform.isKnown; }
/**
 * @public
 * @function
 * @summary - Checks if this is the Test platform of the <b>TerraFly API</b>
* @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.platform.GetIsTest = function () { return tf.platform.GetURL() == tf.platform.TestURL || !tf.platform.isKnown; }
/**
 * @public
 * @function
 * @summary - Checks if this is the Stage platform of the <b>TerraFly API</b>
* @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.platform.GetIsStage = function () { return tf.platform.GetURL() == tf.platform.StageURL; }
/**
 * @public
 * @function
 * @summary - Checks if this is the Production platform of the <b>TerraFly API</b>
* @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.platform.GetIsProduction = function () { return tf.platform.GetURL() == tf.platform.ProdURL; }

// SOURCE FILE: methods.js
tf.map.MapSphere = new ol.Sphere(6378137);
tf.js.GetLegendCompositesStrs = function (decodedLegend, atGivenResolution) {
    var m1H = "", m1M = "", m2 = "";
    function getCompositesPartials(visible, composites) {
        var count = 0, m1Mpartial = "", m1Hpartial = "", m2partial = "";
        if (visible && tf.js.GetIsNonEmptyArray(composites)) {
            var tolerance = 0.00001;
            var nComposites = composites.length;
            var separatorM1 = "";
            var separatorM2 = "";
            for (var i = 0; i < nComposites; ++i) {
                var composite = composites[i];
                var willAdd = atGivenResolution == undefined ? true : (composite.min - tolerance <= atGivenResolution && composite.max + tolerance >= atGivenResolution);
                if (willAdd) {
                    m1Mpartial += separatorM1 + composite.prefix + composite.suffixM;
                    m1Hpartial += separatorM1 + composite.prefix + composite.suffixH;
                    m2partial += separatorM2 + composite.value;
                    separatorM1 = "+";
                    separatorM2 = ",";
                    ++count;
                }
            }
        }
        return { count: count, m1Mpartial: m1Mpartial, m1Hpartial: m1Hpartial, m2partial: m2partial };
    }
    function addCompositePartials(alreadyAdded, compositePartials) {
        var willAdd = compositePartials.count > 0;
        if (willAdd) {
            var m1MSeparator = alreadyAdded ? '+' : '';
            var m2Separator = alreadyAdded ? ',' : '';
            m1M += m1MSeparator + compositePartials.m1Mpartial;
            m1H += m1MSeparator + compositePartials.m1Hpartial;
            m2 += m2Separator + compositePartials.m2partial;
        }
        return willAdd;
    }
    if (tf.js.GetIsNonEmptyArray(decodedLegend)) {
        var nItems = decodedLegend.length, added = false;
        for (var i = 0; i < nItems; ++i) {
            var item = decodedLegend[i];
            if (tf.js.GetIsNonEmptyArray(item.groups)) {
                var nGroups = item.groups.length;
                for (var j = 0; j < nGroups ; ++j) {
                    if (addCompositePartials(added, getCompositesPartials(item.groups[j].visible, item.groups[j].composites))) { added = true; }
                }
            }
            else { if (addCompositePartials(added, getCompositesPartials(item.visible, item.composites))) { added = true }; }
        }
    }
    return { m1H: m1H, m1M: m1M, m2: m2 };
};
tf.js.DecodeLegend = function(legendStr) {
    var result = [];
    function readVisibleNameDesc(nameAndDesc, forceVisible) {
        var visible = !!forceVisible, name = "", desc = "";
        if (tf.js.GetIsNonEmptyString(nameAndDesc)) {
            var split = nameAndDesc.split(':'), name = split[0].replace(/\_/g, ' ');
            if (name.length > 0) { if (name[0] == '~') { visible = true; name = name.substr(1); } }
            if (split.length > 1) { desc = split[1].replace(/\_/g, ' '); } else { desc = name; }
        }
        return { visible: visible, name: name, desc: desc };
    };
    function readComposite(compositeStr) {
        var result;
        if (tf.js.GetIsNonEmptyString(compositeStr)) {
            var parts = compositeStr.split("-"), nParts = parts.length;
            var composite = { prefix: "", value: "", suffixM: "", suffixH: "", min: 10e10, max: -1 };
            // e.g. street.l_ else downward compatible else e.g. flpropertiesyear-0-0.15
            if (nParts == 1) { composite.value = composite.prefix = compositeStr; composite.min = -1; composite.max = 150; }
            else if (nParts == 2) {
                composite.value = composite.prefix = compositeStr;
                var digitMin = parts[1].substr(0, 1), digitMax = parts[1].substr(1, 1);
                if (digitMin == "_") { composite.min = 0; }
                else { composite.min = Math.pow(2, (parseInt(digitMin, 10))); if (composite.min > 150) composite.min = 150; }
                if (digitMax == "_") { composite.max = 0.999; }
                else { composite.max = Math.pow(2, (parseInt(digitMax, 10) + 1)) - 0.001; if (composite.max > 150) composite.max = 150; }
            }
            else if ((nParts == 3) || (nParts == 4)) {
                composite.prefix = parts[0] + "-" + parts[1] + "-" + parts[2] + "-";
                composite.value = parts[0];
                composite.min = parseFloat(parts[1]);
                composite.max = parseFloat(parts[2]);
                if (composite.min > composite.max) { swap = composite.min; composite.min = composite.max; composite.max = swap; }
                if (nParts == 4) {
                    var suffixes = parts[3].split("||");
                    composite.suffixH = suffixes[0];
                    composite.suffixM = (suffixes.length == 2) ? suffixes[1] : suffixes[0];
                }
            }
            else { composite = undefined; }
            result = composite;
        }
        return result;
    };
    function readComposites(compositesStr) {
        var composites = [];
        var max = undefined, min = undefined;
        if (tf.js.GetIsNonEmptyString(compositesStr)) {
            var compositesArray = compositesStr.split('+'), nComposites = compositesArray.length;
            for (var i = 0; i < nComposites; ++i) {
                var ce = readComposite(compositesArray[i]);
                if (ce != undefined) {
                    if (min == undefined || min > ce.min) { min = ce.min; }
                    if (max == undefined || max > ce.max) { max = ce.max; }
                    composites.push(ce);
                }
            }
        }
        return { composites: composites, min: min, max: max };
    };
    function readGroups(groupStr, forceVisible) {
        var result = [];
        if (tf.js.GetIsNonEmptyString(groupStr)) {
            var groups = groupStr.split(';'), nGroups = groups.length;
            if (nGroups > 0) {
                for (var i = 0; i < nGroups; ++i) {
                    var group = groups[i], element = undefined;
                    var nameAndComposites = group.split('@');
                    if (nameAndComposites.length == 2) {
                        var compositesResult = readComposites(nameAndComposites[1]);
                        if (compositesResult.composites.length > 0) {
                            element = tf.js.ShallowMerge(compositesResult, readVisibleNameDesc(nameAndComposites[0], forceVisible));
                        }
                    }
                    if (element != undefined) { result.push(element); }
                }
            }
        }
        return result;
    };
    if (tf.js.GetIsNonEmptyString(legendStr)) {
        var groupSets = legendStr.split("};"), nGroupSets = groupSets.length;
        for (var i = 0; i < nGroupSets; ++i) {
            var groupSet = groupSets[i], groupSetLen = groupSet.length, element = undefined;
            if (groupSetLen > 0) {
                var beforeGroupSetAndGroupSet = groupSet.split('{');
                if (beforeGroupSetAndGroupSet.length == 2) {
                    var groups = readGroups(beforeGroupSetAndGroupSet[0]);
                    if (groups.length > 0) { result.push.apply(result, groups); }
                    groupSet = beforeGroupSetAndGroupSet[1];
                    groupSetLen = groupSet.length;
                }
                if (groupSetLen) {
                    var nameAndGroups = groupSet.split('::');
                    if (nameAndGroups.length == 2) {
                        var visibleNameDesc = readVisibleNameDesc(nameAndGroups[0]);
                        var groups = readGroups(nameAndGroups[1], visibleNameDesc.visible);
                        if (groups.length > 0) { element = { groups: groups, name: visibleNameDesc.name, desc: visibleNameDesc.desc }; }
                    }
                }
            }
            if (element != undefined) { result.push(element); }
        }
    }
    return result;
};
// DOMParser support for browsers that may lack it, slightly adapted from https://developer.mozilla.org/en-US/docs/Web/API/DOMParser
(function (DOMParser) {
    var proto = DOMParser.prototype, nativeParse = proto.parseFromString;
    // Firefox/Opera/IE throw errors on unsupported types
    try {
        // WebKit returns null on unsupported types
        if ((new DOMParser()).parseFromString("", "text/html")) {
            // text/html parsing is natively supported
            return;
        }
    } catch (ex) { }
    proto.parseFromString = function (markup, type) {
        if (/^\s*text\/html\s*(?:;|$)/i.test(type)) {
            var doc = document.implementation.createHTMLDocument("");
            if (markup.toLowerCase().indexOf('<!doctype') > -1) { doc.documentElement.innerHTML = markup; }
            else { doc.body.innerHTML = markup; }
            return doc;
        } else { return nativeParse.apply(this, arguments); }
    };
}(DOMParser));
/*if (!String.prototype.trim) {
    Object.defineProperty(String.prototype, 'trim', {
        value: function () { return this.replace(/^\s+|\s+$/g, ''); },
        writable: false, enumerable: false, configurable: false
    });
}*/
/**
 * @public
 * @function
 * @summary - Retrieves the {@link tf.events.DocMouseListener} singleton
 * @returns {tf.events.DocMouseListener} - | {@link tf.events.DocMouseListener} the singleton
*/
tf.GetDocMouseListener = function () { if (!tf.g_DocMouseListener) { tf.g_DocMouseListener = new tf.events.DocMouseListener(); } return tf.g_DocMouseListener; }
/**
 * @public
 * @function
 * @summary - Retrieves the {@link tf.styles.Styles} singleton
 * @param {tf.types.APIStyleSpecs} alternativeSpecs - overrides the default API style specifications, if defined the first time an application calls this function
 * @returns {tf.styles.Styles} - | {@link tf.styles.Styles} the singleton
*/
tf.GetStyles = function (alternativeSpecs) { if (!tf.g_Styles) { tf.g_Styles = new tf.styles.Styles(alternativeSpecs); } return tf.g_Styles; }
/**
 * @public
 * @function
 * @summary - Retrieves the {@link tf.js.Counter} singleton
 * @returns {tf.js.Counter} - | {@link tf.js.Counter} the singleton
*/
tf.GetGlobalCounter = function () { if (!tf.g_Counter) { tf.g_Counter = new tf.js.Counter(); } return tf.g_Counter; }
tf.GetNextDynCSSClassName = function () { return "tf-dyn-css-" + tf.GetGlobalCounter().GetNext(); }
/**
 * @public
 * @function
 * @summary - Retrieves the {@link tf.Debug} singleton
 * @returns {tf.Debug} - | {@link tf.Debug} the singleton
*/
tf.GetDebug = function () { if (!tf.g_Debug) { tf.g_Debug = new tf.Debug(); } return tf.g_Debug; }
/**
 * @public
 * @function
 * @summary - Retrieves a JavaScript {@link object} from an XML node, such as one in httpRequest.responseXML.documentElement
 * @param {object} XMLNode - the given XML node
 * @returns {object} - | {@link object} the object
*/
tf.helpers.XML2Object = function (XMLNode) {
    var dataObj = {};
    function Add(name, value) {
        if (dataObj[name]) { if (!tf.js.GetIsArray(dataObj[name])) { dataObj[name] = [dataObj[name]]; } dataObj[name][dataObj[name].length] = value; }
        else { dataObj[name] = value; }
    };
    if (tf.js.GetIsValidObject(XMLNode) && tf.js.GetIsValidObject(XMLNode.attributes) && tf.js.GetIsValidObject(XMLNode.childNodes)) {
        var c, cn;
        for (c = 0; cn = XMLNode.attributes[c]; ++c) { Add(cn.name, cn.value); }
        for (c = 0; cn = XMLNode.childNodes[c]; ++c) {
            if (cn.nodeType == 1) {
                if (cn.childNodes.length == 1 && cn.firstChild.nodeType == 3) { Add(cn.nodeName, cn.firstChild.nodeValue); }
                else { Add(cn.nodeName, tf.helpers.XML2Object(cn)); }
            }
        }
    }
    return dataObj;
};
/**
 * @public
 * @function
 * @summary - Retrieves a JavaScript {@link object} from an XML string
 * @param {string} XMLString - the given XML string
 * @returns {object} - | {@link object} the object
*/
tf.helpers.XMLString2Object = function (XMLString) {
    var dataObj = {};
    if (tf.js.GetIsNonEmptyString(XMLString)) {
        var doc = new DOMParser().parseFromString(XMLString, "application/xml");
        if (tf.js.GetIsValidObject(doc) && tf.js.GetIsValidObject(doc.documentElement)) {
            dataObj = tf.helpers.XML2Object(doc.documentElement);
        }
    }
    return dataObj;
};
tf.js.ParseSplitStringWithSeparators = function (str, separator) {
    var result = {};
    if (tf.js.GetIsNonEmptyString(str) && tf.js.GetIsNonEmptyString(separator)) {
        str = str.split(separator);
        var nStr = str.length;
        for (var i = 0; i < nStr; ++i) {
            var thisStr = str[i];
            result[thisStr.toLowerCase()] = thisStr;
        }
    }
    return result;
};
tf.js.AddStringWithSeparators = function (strBeingAddedTo, strToBeAdded, separator) {
    if (tf.js.GetIsNonEmptyString(strToBeAdded) && tf.js.GetIsNonEmptyString(separator)) {
        if (tf.js.GetIsNonEmptyString(strBeingAddedTo)) { strBeingAddedTo += separator + strToBeAdded; }
        else { strBeingAddedTo = strToBeAdded; }
    }
    return strBeingAddedTo;
};
tf.js.AddStringsWithSeparatorsIfAbsent = function (strBeingAddedTo, strsToBeAdded, separator) {
    if (tf.js.GetIsNonEmptyString(separator)) {
        var parsed = tf.js.ParseSplitStringWithSeparators(strBeingAddedTo, separator);
        if (tf.js.GetIsValidObject(parsed)) {
            if (!tf.js.GetIsNonEmptyArray(strsToBeAdded)) { strsToBeAdded = [strsToBeAdded]; }
            var nStrsToBeAdded = strsToBeAdded.length;
            for (var i = 0; i < nStrsToBeAdded; ++i) {
                var strToBeAdded = strsToBeAdded[i];
                if (tf.js.GetIsNonEmptyString(strToBeAdded)) {
                    if (!parsed[strToBeAdded]) {
                        strBeingAddedTo = tf.js.AddStringWithSeparators(strBeingAddedTo, strToBeAdded, separator);
                    }
                }
            }
        }
    }
    return strBeingAddedTo;
};
/**
 * Object returned by {@link tf.helpers.HitTestMapCoordinatesArray}
 * @public
 * @typedef {object} tf.types.HitTestCoordinatesArrayResult
 * @property {number} minDistance - the minimum distance
 * @property {number} minDistanceIndex - the index of the array containing the initial coordinates of the segment where the minimum distance was found
 */
tf.helpers.HitTestSegment = function (segStart, segEnd, coordinates) {
    var distance, closestPoint;
    var isStart = false, isEnd = false, isSeg = false;
    var proj;
    if (tf.js.GetIsArrayWithMinLength(segStart, 2) && tf.js.GetIsArrayWithMinLength(segEnd, 2) && tf.js.GetIsArrayWithMinLength(coordinates, 2)) {
        var startLon = segStart[0], startLat = segStart[1];
        var endLon = segEnd[0], endLat = segEnd[1];
        if (startLon == endLon && startLat == endLat) { closestPoint = [startLon, startLat]; isEnd = true; proj = 1; }
        else {
            var coordsLon = coordinates[0], coordsLat = coordinates[1];
            var lonCoordsToStart = coordsLon - startLon, latCoordsToStart = coordsLat - startLat;
            var lonEndToStart = endLon - startLon, latEndToStart = endLat - startLat;
            var distEndStart = lonEndToStart * lonEndToStart + latEndToStart * latEndToStart;
            var proj = (lonCoordsToStart * lonEndToStart + latCoordsToStart * latEndToStart) / distEndStart;
            if (proj < 0) { closestPoint = [startLon, startLat]; isStart = true; proj = 0; }
            else if (proj > 1) { closestPoint = [endLon, endLat]; isEnd = true; proj = 1; }
            else {
                closestPoint = [startLon + lonEndToStart * proj, startLat + latEndToStart * proj];
                isSeg = true;
            }
        }
        distance = tf.units.GetDistanceInMetersBetweenMapCoords(coordinates, closestPoint);
    }
    return { distance: distance, closestPoint: closestPoint, isStart: isStart, isEnd: isEnd, isSeg: isSeg, proj: proj };
}
/**
 * @public
 * @function
 * @summary - Calculates the minimum distance between given map coordinates and a given segment defined by an array of map coordinates
 * @param {array<tf.types.mapCoordinates>} mapCoordinatesArray - the array of map coordinates defining a segment
 * @param {tf.types.mapCoordinates} coordinates - the given coordinates
 * @returns {tf.types.HitTestCoordinatesArrayResult} - | {@link tf.types.HitTestCoordinatesArrayResult} the result
*/
tf.helpers.HitTestMapCoordinatesArray = function(mapCoordinatesArray, coordinates, startSegIndex, startMinProj, endSegIndex) {
    var minDistance = -1;
    var minDistanceIndex = -1;
    var closestPoint = undefined, proj = undefined;
    if (tf.js.GetIsArrayWithMinLength(mapCoordinatesArray, 1) && tf.js.GetIsArrayWithMinLength(mapCoordinatesArray[0], 2) && tf.js.GetIsArrayWithMinLength(coordinates, 2)) {
        var nSegs = mapCoordinatesArray.length - 1;
        var mapCoordinatesArrayUse;
        if (nSegs == 0) { mapCoordinatesArrayUse = [mapCoordinatesArray[0], mapCoordinatesArray[0]]; nSegs = 1; }
        else { mapCoordinatesArrayUse = mapCoordinatesArray; }
        if (startSegIndex == undefined) { startSegIndex = 0; }
        if (startMinProj == undefined) { startMinProj = 0; }
        for (var i = startSegIndex ; i < nSegs; ++i) {
            var startSeg = mapCoordinatesArrayUse[i];
            var endSeg = mapCoordinatesArrayUse[1 + i];
            var hitSeg = tf.helpers.HitTestSegment(startSeg, endSeg, coordinates);
            if (hitSeg.distance != undefined && hitSeg.proj >= startMinProj && (minDistance == -1 || hitSeg.distance < minDistance)) {
                minDistance = hitSeg.distance;
                closestPoint = !!hitSeg.closestPoint ? hitSeg.closestPoint.slice(0) : undefined;
                minDistanceIndex = i;
                proj = hitSeg.proj;
                if (endSegIndex != undefined && i >= endSegIndex) { break; }
            }
            startMinProj = 0;
        }
    }
    //else { console.log('invalid array'); }
    return { minDistance: minDistance, minDistanceIndex: minDistanceIndex, closestPoint: closestPoint, proj: proj };
}
/**
 * @public
 * @function
 * @summary - Calculates the average coordinates of a given array of map coordinates
 * @param {array<tf.types.mapCoordinates>} mapCoordinatesArray - the array of map coordinates
 * @param {boolean} skipLastCoordBool - if <b>true</b> the last coordinate in the array is not included in the average
 * @returns {tf.types.mapCoordinates} - | {@link tf.types.mapCoordinates} the average coordinates
*/
tf.helpers.CalcAverageCoordinates = function (coordsArray, skipLastCoordBool) {
    var avg = [0, 0];
    if (tf.js.GetIsNonEmptyArray(coordsArray) && tf.js.GetIsArrayWithLength(coordsArray[0], 2)) {
        var nCoords = 0;
        var length = coordsArray.length;
        skipLastCoordBool = !!skipLastCoordBool;
        for (var i in coordsArray) {
            var coords = coordsArray[i];
            if (!!coords) {
                if (coords.length == 2) {
                    avg[0] += coords[0];
                    avg[1] += coords[1];
                    nCoords++;
                }
                else { break; }
            }
            else { break; }
            if (skipLastCoordBool && i == length - 2) { break; }
        }
        if (nCoords) { avg[0] /= nCoords; avg[1] /= nCoords; }
    }
    return avg;
}
// tf.dom
tf.dom.OnRangeChange = function (rangeInputElmt, listener) {
    var inputEvtHasNeverFired = true;
    var rangeValue = { current: undefined, mostRecent: undefined };
    function onInput(evt) {
        inputEvtHasNeverFired = false;
        rangeValue.current = evt.target.value;
        if (rangeValue.current !== rangeValue.mostRecent) { listener(evt, rangeValue); }
        rangeValue.mostRecent = rangeValue.current;
    }
    function onChange(evt) { if (inputEvtHasNeverFired) { listener(evt, rangeValue); } }
    rangeInputElmt.addEventListener("input", onInput);
    rangeInputElmt.addEventListener("change", onChange);
};
tf.dom.ScrollVerticallyToEnsureVisible = function(scrollerElem, subElem, marginInt) {
    var scrolled = false;
    var marginIntUse = marginInt != undefined ? marginInt : 10;
    if (!!(scrollerElem = tf.dom.GetHTMLElementFrom(scrollerElem)) && !!(subElem = tf.dom.GetHTMLElementFrom(subElem))) {
        var topOffset = subElem.offsetTop - scrollerElem.offsetTop;
        var curTop = scrollerElem.scrollTop, curBot = curTop + scrollerElem.offsetHeight;
        if (topOffset > curBot - marginIntUse) {
            scrolled = true;
            scrollerElem.scrollTop = topOffset - marginIntUse;
        }
        else if (topOffset < curTop + marginIntUse) {
            scrolled = true;
            scrollerElem.scrollTop = topOffset - marginIntUse;
        }
        //if (scrolled = (topOffset > curBot - 10 || topOffset < curTop)) { scrollerElem.scrollTop = topOffset; }
    }
    return scrolled;
}
tf.dom.ScrollHorizontallyToEnsureVisible = function (scrollerElem, subElem) {
    var scrolled = false;
    if (!!(scrollerElem = tf.dom.GetHTMLElementFrom(scrollerElem)) && !!(subElem = tf.dom.GetHTMLElementFrom(subElem))) {
        var leftOffset = subElem.offsetLeft - scrollerElem.offsetLeft;
        var curLeft = scrollerElem.scrollLeft, curRight = curLeft + scrollerElem.offsetWidth;
        if (scrolled = (leftOffset > curRight - 10 || leftOffset < curLeft)) { scrollerElem.scrollLeft = leftOffset; }
    }
    return scrolled;
}
tf.dom.SetDisplayStyle = function (elem, verb) {
    if (elem = tf.dom.GetHTMLElementFrom(elem)) { elem.style.display = verb; }
}
tf.dom.ToggleDisplayStyle = function(elem, verb1, verb2) {
    if (elem = tf.dom.GetHTMLElementFrom(elem)) { elem.style.display = elem.style.display == verb1 ? verb2 : verb1; }
}
tf.dom.ToggleDisplayBlockNone = function (elem) { return tf.dom.ToggleDisplayStyle(elem, 'block', 'none'); }
tf.dom.SetDisplayBlockNone = function (elem, bool) { return tf.dom.SetDisplayStyle(elem, !!bool? 'block' : 'none'); }
/**
 * @public
 * @function
 * @summary - Inserts an HTML <b>'script'</b> into the Documents head
 * @param {string} scriptSrc - the source url of the script
 * @param {function} callBack - if defined, called when the script finishes loading
 * @returns {void} - | {@link void} no return value
*/
tf.dom.AddScript = function (scriptSrc, callBack, customDoc) {
    if (tf.js.GetIsNonEmptyString(scriptSrc)) {
        var docUse = customDoc != undefined ? customDoc : document;
        var script = docUse.createElement('script'); script.type = "text/javascript"; script.src = scriptSrc;
        if (tf.js.GetFunctionOrNull(callBack)) { script.onload = callBack; }
        docUse.head.appendChild(script);
    }
}
tf.dom.AddScripts = function (scripts, callBack, customDoc) {
    var nScriptsLoaded = 0, nScriptsToLoad = 0, notified = false;
    function onScriptLoaded() {
        if (!notified) {
            if (++nScriptsLoaded >= nScriptsToLoad) {
                notified = true;
                callBack();
            }
        }
    }
    if (tf.js.GetIsNonEmptyArray(scripts)) {
        var nScripts = scripts.length;
        for (var i = 0; i < nScripts; ++i) {
            tf.dom.AddScript(scripts[i], onScriptLoaded, customDoc);
        }
    }
};
/**
 * @public
 * @function
 * @summary - Inserts an HTML <b>'link'</b> into the Documents head
 * @param {string} hRef - the href url of the link
 * @param {string} rel - the rel attribute of the link
 * @param {string} type - the type attribute of the link
 * @param {function} callBack - if defined, called when the link finishes loading
 * @returns {void} - | {@link void} no return value
*/
tf.dom.AddLink = function (hRef, rel, type, callBack) {
    if (tf.js.GetIsNonEmptyString(hRef)) {
        var link = document.createElement('link');
        if (tf.js.GetFunctionOrNull(callBack)) { link.onload = callBack; }
        link.href = hRef;
        if (tf.js.GetIsNonEmptyString(rel)) { link.rel = rel; }
        if (tf.js.GetIsNonEmptyString(type)) { link.type = type; }
        document.head.appendChild(link);
    }
}
/**
 * @public
 * @function
 * @summary - Inserts an HTML <b>'link'</b> into the Documents head to a google font from font.googleapis.com
 * @param {string} fontSpecs - specification of the fonts to retrieve, example: "Cantarell|Tangerine:bold,bolditalic|Inconsolata:italic|Droid+Sans"
 * @param {function} callBack - if defined, called when the font is ready for use
 * @returns {void} - | {@link void} no return value
*/
tf.dom.AddGoogleFont = function (fontSpecs, callBack) {
    if (tf.js.GetIsNonEmptyString(fontSpecs)) { tf.dom.AddLink("http://fonts.googleapis.com/css?family=" + fontSpecs, "stylesheet", "text/css", callBack); }
}
/**
 * @public
 * @function
 * @summary - Calculates the current pixel dimensions of the Browser's window
 * @returns {tf.types.pixelCoordinates} - | {@link tf.types.pixelCoordinates} the dimensions
*/
tf.dom.GetWindowDims = function () {
    var w = window, d = document, e = d.documentElement, g = d.getElementsByTagName('body')[0];
    var winW = w.innerWidth || e.clientWidth || g.clientWidth, winH = w.innerHeight || e.clientHeight || g.clientHeight;
    return [winW - 1, winH - 1];
}
/**
 * @public
 * @function
 * @summary - Calculates the current pixel dimensions of the Browser's window and resizes the given container to the calculated dimensions
 * @param {HTMLElementLike} container - the container to be resized
 * @returns {tf.types.pixelCoordinates} - | {@link tf.types.pixelCoordinates} the dimensions
*/
tf.dom.FitContainerToWindowDims = function (container) {
    var winDims = tf.dom.GetWindowDims();
    var containerUse = tf.dom.GetHTMLElementFrom(container);
    if (!!containerUse) {
        var containerStyle = containerUse.style;
        containerStyle.width = containerStyle.maxWidth = winDims[0] + "px";
        containerStyle.height = containerStyle.maxHeight = winDims[1] + "px";
    }
    return winDims;
}
/**
 * @public
 * @function
 * @summary - Determines if the given parameter is an {@link HTMLNode}
 * @param {object} node - the node candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if node is an {@link HTMLNode}, <b>false</b> otherwise
*/
tf.dom.GetIsHTMLNode = function (node) {
    return (
      typeof Node === "object" ? node instanceof Node :
      node && typeof node === "object" && typeof node.nodeType === "number" && typeof node.nodeName === "string"
    );
}
/**
 * @public
 * @function
 * @summary - Determines if the given parameter is an {@link HTMLElement}
 * @param {object} node - the element candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if node is an {@link HTMLElement}, <b>false</b> otherwise
*/
tf.dom.GetIsHTMLElement = function (element) {
    return tf.js.GetIsValidObject(element) && element.nodeType === 1 && typeof element.nodeName === "string";
    /*return (
      typeof HTMLElement === "object" ? element instanceof HTMLElement : //DOM2
      element && typeof element === "object" && element !== null && element.nodeType === 1 && typeof element.nodeName === "string"
  );*/
}
/**
 * @public
 * @function
 * @summary - Retrieves the {@link HTMLElement associated with the given object, if any
 * @param {object} element - the object from which to retrive an HTMLElement
 * @returns {HTMLElement} - | {@link HTMLElement} the retrieved {@link HTMLElement}, or {@link void}
*/
tf.dom.GetHTMLElementFrom = function (element) {
    if (!!element) {
        if (!tf.dom.GetIsHTMLElement(element)) {
            if (tf.js.GetIsNonEmptyString(element)) { element = document.getElementById(element); }
            else if (tf.js.GetIsValidObject(element) && tf.js.GetFunctionOrNull(element.GetHTMLElement)) { element = element.GetHTMLElement(); }
            else { element = null; }
        }
    }
    return element;
}
/**
 * @private
 * @function
 * @summary - Retrieves the a DOM event listener target from the given element
 * @param {object} element - the object from which to retrive a DOM event listener target
 * @returns {object} - | {@link object} the retrieved DOM event listener target
*/
tf.dom.GetDOMEventListenerFrom = function (element) {
    if (!!element) {
        if (!tf.dom.GetIsHTMLElement(element)) {
            if (tf.js.GetIsNonEmptyString(element)) { element = document.getElementById(element); }
            else if (tf.js.GetIsValidObject(element) && tf.js.GetFunctionOrNull(element.GetHTMLElement)) { element = element.GetHTMLElement(); }
        }
        if (!tf.js.GetIsValidObject(element)) { element = null; }
    }
    return element;
}
tf.dom.GetElemClassName = function(elem) {
    return elem instanceof SVGElement ? (((elem.className ? elem.className.baseVal : elem.getAttribute('class'))) || '') : elem.className;
}
tf.dom.SetElemClassName = function (elem, elemClassName) {
    if (elem instanceof SVGElement) {
        if (elem.className) {
            elem.className.baseVal = elemClassName;
        }
        else {
            elem.setAttribute('class', elemClassName);
        }
    }
    else {
        return elem.className = elemClassName;
    }
}
/**
 * @public
 * @function
 * @summary - Checks if the given element contains the given CSS style/class name among its class names
 * @param {HTMLElementLike} elem - the element to check
 * @param {tf.types.CSSStyleName} cssStyleName - the CSS style/class name
 * @returns {boolean} - | {@link boolean} <b>true</b> if the given class name is one of the classes of <b>elem</b>, <b>false</b> otherwise
 * @see [AddCSSClass]{@link tf.dom.AddCSSClass}, [RemoveCSSClass]{@link tf.dom.RemoveCSSClass}, and [ReplaceCSSClass]{@link tf.dom.ReplaceCSSClass}
*/
tf.dom.GetContainsCSSClass = function (elem, cssStyleName) {
    if (elem = tf.dom.GetHTMLElementFrom(elem)) {
        return tf.js.GetNonEmptyString(cssStyleName) && new RegExp('(\\s+|^)' + cssStyleName + '(\\s+|$)').test(tf.dom.GetElemClassName(elem));
    }
    return false;
}
/**
 * @public
 * @function
 * @summary - Adds the given CSS style/class name to the class names associated with the given element
 * @param {HTMLElementLike} elem - the element
 * @param {tf.types.CSSStyleName} cssStyleName - the CSS style/class name
 * @returns {void} - | {@link void} no return value
 * @see [RemoveCSSClass]{@link tf.dom.RemoveCSSClass}, [ReplaceCSSClass]{@link tf.dom.ReplaceCSSClass}, and [GetContainsCSSClass]{@link tf.dom.GetContainsCSSClass}
*/
tf.dom.AddCSSClass = function (elem, cssStyleName) {
    if ((elem = tf.dom.GetHTMLElementFrom(elem)) && (!!cssStyleName)) {
        if (!tf.js.GetIsArray(cssStyleName)) { cssStyleName = cssStyleName.split(' '); }
        var elemClassName = tf.dom.GetElemClassName(elem);
        for (var i = 0, len = cssStyleName.length; i < len; ++i) {
            if (cssStyleName[i] && !new RegExp('(\\s+|^)' + cssStyleName[i] + '(\\s+|$)').test(elemClassName)) {
                elemClassName = elemClassName.trim() + ' ' + cssStyleName[i];
            }
        }
        tf.dom.SetElemClassName(elem, elemClassName);
    }
}
/**
 * @public
 * @function
 * @summary - Removes the given CSS style/class name from the class names associated with the given element
 * @param {HTMLElementLike} elem - the element
 * @param {tf.types.CSSStyleName} cssClassStr - the CSS style/class name
 * @returns {void} - | {@link void} no return value
 * @see [AddCSSClass]{@link tf.dom.AddCSSClass}, [ReplaceCSSClass]{@link tf.dom.ReplaceCSSClass}, and [GetContainsCSSClass]{@link tf.dom.GetContainsCSSClass}
*/
tf.dom.RemoveCSSClass = function (elem, cssStyleName) {
    if ((elem = tf.dom.GetHTMLElementFrom(elem)) && (!!cssStyleName)) {
        if (!tf.js.GetIsArray(cssStyleName)) { cssStyleName = cssStyleName.split(' '); }
        var elemClassName = tf.dom.GetElemClassName(elem);
        for (var i = 0, len = cssStyleName.length; i < len; ++i) {
            elemClassName = elemClassName.replace(new RegExp('(\\s+|^)' + cssStyleName[i] + '(\\s+|$)'), ' ').trim();
        }
        tf.dom.SetElemClassName(elem, elemClassName);
    }
}
/**
 * @public
 * @function
 * @summary - Replaces a given CSS style/class name with another style/class name among the style/class names associated with the given element
 * @param {HTMLElementLike} elem - the element
 * @param {tf.types.CSSStyleName} cssStyleNameOld - the existing CSS style/class name to be replaced
 * @param {tf.types.CSSStyleName} cssStyleNameNew - the new CSS class style/name to replace <b>cssStyleNameOld</b>
 * @returns {void} - | {@link void} no return value
 * @see [AddCSSClass]{@link tf.dom.AddCSSClass}, [RemoveCSSClass]{@link tf.dom.RemoveCSSClass}, and [GetContainsCSSClass]{@link tf.dom.GetContainsCSSClass}
*/
tf.dom.ReplaceCSSClass = function (elem, cssStyleNameOld, cssStyleNameNew) { tf.dom.RemoveCSSClass(elem, cssStyleNameOld); tf.dom.AddCSSClass(elem, cssStyleNameNew); }
tf.dom.ReplaceCSSClassCondition = function (elem, condition, classTrue, classFalse) {
    if (!!condition) { tf.dom.ReplaceCSSClass(elem, classFalse, classTrue); }
    else { tf.dom.ReplaceCSSClass(elem, classTrue, classFalse); }
}
/**
 * @private
 * @function
 * @summary - Adds the given child element to the list of children of the given parent element, uses JavaScript <b>appendChild</b>
 * @param {HTMLElementLike} childElem - the child element
 * @param {HTMLElementLike} parentElem - the parent element
 * @returns {void} - | {@link void} no return value
*/
tf.dom.AppendTo = function (childElem, parentElem) {
    if ((parentElem = tf.dom.GetHTMLElementFrom(parentElem)) && (childElem = tf.dom.GetHTMLElementFrom(childElem))) {
        if (tf.js.GetFunctionOrNull(parentElem.appendChild)) {
            parentElem.appendChild(childElem);
        }
    }
}
/**
 * @private
 * @function
 * @summary - Adds the given child element to the list of children of the given parent element, uses child's <b>AppendTo</b> function, if defined
 * @param {HTMLElementLike} child - the child element
 * @param {HTMLElementLike} parent - the parent element
 * @returns {void} - | {@link void} no return value
*/
tf.dom.AddContent = function (child, parent) {
    if (tf.js.GetIsValidObject(child) && tf.js.GetIsValidObject(parent)) {
        if (tf.js.GetFunctionOrNull(child.AppendTo)) { child.AppendTo(parent); }
        else {
            var childElem = tf.dom.GetHTMLElementFrom(child), parentElem = tf.dom.GetHTMLElementFrom(parent);
            if (!!childElem && !!parentElem) { parentElem.appendChild(childElem); }
        }
    }
}
/**
 * @public
 * @function
 * @summary - Removes all children from the given element
 * @param {HTMLElementLike} elem - the element
 * @returns {void} - | {@link void} no return value
*/
tf.dom.RemoveAllChildren = function (elem) { if (elem = tf.dom.GetHTMLElementFrom(elem)) { var lastChild; while (lastChild = elem.lastChild) { elem.removeChild(lastChild); } } }
/**
 * @public
 * @function
 * @summary - Creates an unique id for {@link HTMLElement} using {@link tf.GetGlobalCounter}
 * @param {string} withPrefix - an application defined prefix for the id
 * @returns {string} - | {@link string} the id
*/
tf.dom.CreateDomElementID = function (withPrefix) { return withPrefix + tf.GetGlobalCounter().GetNext() + ''; }
// tf.js
/**
 * @public
 * @function
 * @summary - Creates an {@link object} containing the combined properties of the given objects
 * @param {...object} object - any number of comma separated objects
 * @returns {object} - | {@link object} the merged object
*/
tf.js.ShallowMerge = function () {
    var merged = {}, nContent = arguments.length;
    for (var i = 0 ; i < nContent ; ++i) {
        var thisContent = arguments[i];
        if (!!thisContent && typeof thisContent === "object") {
            for (var property in thisContent) { if (thisContent.hasOwnProperty(property)) { merged[property] = thisContent[property]; } }
        }
    }
    return merged;
}
/**
 * @public
 * @function
 * @summary - Checks if the given candidate is of type {@link boolean}
 * @param {*} candidate - the candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsBoolean = function (candidate) { return typeof candidate === "boolean"; }
/**
 * @public
 * @function
 * @summary - Checks if the given candidate is a {@link string}
 * @param {*} candidate - the candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsString = function (candidate) { return !!candidate && typeof candidate === "string"; }
/**
 * @public
 * @function
 * @summary - Checks if the given candidate is a {@link string} with at least <b>length</b> characters
 * @param {*} candidate - the candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsStringWithMinLength = function (candidate, length) { return tf.js.GetIsString(candidate) && candidate.length >= length; }
tf.js.GetIsStringWithLength = function (candidate, length) { return tf.js.GetIsString(candidate) && candidate.length == length; }
/**
 * @public
 * @function
 * @summary - Checks if the given candidate is a {@link string} with at least one character
 * @param {*} candidate - the candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsNonEmptyString = function (candidate) { return tf.js.GetIsString(candidate) && !!candidate.length; }
/**
 * @public
 * @function
 * @summary - Returns the given object if it is a {@link string} with at least one character, otherwise returns the given default
 * @param {object} fromString - the non empty string candidate
 * @param {string} optionalDefaultString - the default string, can be {@link void}
 * @returns {string} - | {@link string} <b>fromString</b> or <b>optionalDefaultString</b>
*/
tf.js.GetNonEmptyString = function (fromString, optionalDefaultString) { return tf.js.GetIsNonEmptyString(fromString) ? fromString : optionalDefaultString; }
/**
 * @public
 * @function
 * @summary - Checks if the given candidate is an {@link array}
 * @param {*} candidate - the candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsArray = function (candidate) {
    if (!!candidate) {
        if (candidate.constructor === Array) { return true; }
        if (tf.js.GetFunctionOrNull(candidate)) { return false; }
        if (!tf.js.GetIsString(candidate) && candidate.length !== undefined) { return typeof candidate.length == 'number'; }
    }
    return false;
    
}
/**
 * @public
 * @function
 * @summary - Checks if the given candidate is an {@link array} with at least one element
 * @param {*} candidate - the candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsNonEmptyArray = function (candidate) { return tf.js.GetIsArray(candidate) && !!candidate.length; }
/**
 * @public
 * @function
 * @summary - Checks if the given candidate is an {@link array} with a number of elements equal to the given length
 * @param {*} candidate - the candidate
 * @param {number} length - the length
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsArrayWithLength = function (candidate, length) { return tf.js.GetIsArray(candidate) && candidate.length == length; }
/**
 * @public
 * @function
 * @summary - Checks if the given candidate is an {@link array} with a number of elements equal to the given length
 * @param {*} candidate - the candidate
 * @param {number} length - the length
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsArrayWithLength = function (candidate, length) { return tf.js.GetIsArray(candidate) && candidate.length == length; }
/**
 * @public
 * @function
 * @summary - Checks if the given candidate is an {@link array} with a number of elements greater or equal to the given length
 * @param {*} candidate - the candidate
 * @param {number} length - the length
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsArrayWithMinLength = function (candidate, length) { return tf.js.GetIsArray(candidate) && candidate.length >= length; }
/**
 * @public
 * @function
 * @summary - Checks if the given object is a valid {@link object}
 * @param {*} candidate - the candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsValidObject = function (candidate) { return !!candidate && (typeof candidate === "object"); }
/**
 * @public
 * @function
 * @summary - Returns the given object if it is a valid {@link object}, otherwise returns an empty object {}
 * @param {*} candidate - the candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetValidObjectFrom = function (candidate) { return tf.js.GetIsValidObject(candidate) ? candidate : {} ; }
/**
 * @public
 * @function
 * @summary - Returns the given candidate if it is a valid {@link function}, or {@link void} otherwise
 * @param {*} fromFunction - the candidate
 * @returns {function} - | {@link function} <b>fromFunction</b> or {@link void}
*/
tf.js.GetFunctionOrNull = function (fromFunction) { return typeof fromFunction === "function" ? fromFunction : null; }
/**
 * @private
 * @function
 * @summary - Parses the given string in JSON format using JavaScript's <b>eval</b> function. Fallback in case Browser does not support JSON. Used internally by the API
 * @param {string} str - a string in JSON format
 * @returns {object} - | {@link object} the object
*/
tf.js.JSONParseWithEval = function (str) { return tf.js.GetNonEmptyString(str) ? eval('(' + str + ')') : null; }
/**
 * @public
 * @function
 * @summary - Parses the given string in JSON format
 * @param {string} str - a string in JSON format
 * @returns {object} - | {@link object} the object
*/
tf.js.JSONParse = function (str) {
    var parsed = null;
    var jsonParse = (!!JSON && !!JSON.parse) ? JSON.parse : tf.js.JSONParseWithEval;
    try { parsed = jsonParse(str); }
    catch (e) {
        if (jsonParse != tf.js.JSONParseWithEval) { try { parsed = tf.js.JSONParseWithEval(str); } catch (e) { parsed = null; } } else { parsed = null; }
        if (!parsed) { tf.GetDebug().LogIfTest("exception on JSON decode"); }
    }
    return parsed;
}
/**
 * @public
 * @function
 * @summary - Retrieves the URL where a the script of the given file name was loaded from
 * @param {string} scriptFileName - the script file name
 * @returns {string} - | {@link string} the the URL
*/
tf.js.GetURLOfScript = function (scriptFileName) {
    var scriptURL;
    if (typeof scriptFileName === "string") {
        var scriptElements = document.getElementsByTagName('script');
        var i, element;
        for (i = 0; element = scriptElements[i]; ++i) {
            var myfile = element.src, index = myfile.indexOf(scriptFileName);
            if (index >= 0) { scriptURL = myfile.substring(0, index); break; }
        }
    }
    return scriptURL;
}
/**
 * @public
 * @function
 * @summary - Returns a valid {@link hexColor} parsed from the given color, or the given default color if parsing fails
 * @param {hexColor|deprecatedColor} fromColorStr - the given color
 * @param {hexColor} defaultColorStr - the default color
 * @returns {hexColor} - | {@link hexColor} a valid color
*/
tf.js.GetHexColorStr = function (fromColorStr, defaultColorStr) {
    var returnColorStr = defaultColorStr;
    if (typeof fromColorStr == "string") {
        if (fromColorStr.length > 0) {
            if (fromColorStr[0] != '#') {
                if (fromColorStr.indexOf("0x") == 0) {
                    returnColorStr = '#' + fromColorStr.substr(2);
                }
                else {
                    fromColorStr = parseInt(fromColorStr, 10);
                    returnColorStr = "#" + fromColorStr.toString(16);
                }
            }
            else {
                returnColorStr = fromColorStr;
            }
        }
    }
    else if (typeof fromColorStr == "number") {
        returnColorStr = "#" + fromColorStr.toString(16);
    }
    return returnColorStr;
}
/**
 * @public
 * @function
 * @summary - Returns a valid {@link rgbaColor} or {@link rgbColor} parsed from the given color and using the given opacity
 * @param {hexColor|deprecatedColor} fromColorStr - the given color
 * @param {hexColor} defaultColorStr - the default color, used if parsing of <b>fromColorStr</b> fails
 * @param {tf.types.opacity01} opacity - the given opacity
 * @returns {rgbaColor|rgbColor} - | {@link rgbaColor}|{@link rgbColor} a valid color, returns {@link rgbColor} if <b>opacity</b> is <b>1</b>
*/
tf.js.GetRGBAColor = function (fromColorStr, defaultColorStr, opacity) {
    var rgbaColor = "rgb(0,0,0)";
    fromColorStr = tf.js.GetHexColorStr(fromColorStr, defaultColorStr);
    if (fromColorStr) {
        var len = fromColorStr.length;
        var nPerColor = len == 7 ? 2 : (len == 4 ? 1 : 0);
        if (nPerColor && fromColorStr.charAt(0) == '#') {
            var r = parseInt(fromColorStr.substr(1, nPerColor), 16);
            var g = parseInt(fromColorStr.substr(1 + nPerColor, nPerColor), 16);
            var b = parseInt(fromColorStr.substr(1 + 2 * nPerColor, nPerColor), 16);
            if (nPerColor == 1) {
                r = r * 16 + r;
                g = g * 16 + g;
                b = b * 16 + b;
            }
            var needOpacity = false;
            if (typeof opacity == "number") {
                opacity = opacity < 0.0 ? 0.0 : (opacity > 1.0 ? 1.0 : opacity);
                needOpacity = opacity != 1.0;
            }
            rgbaColor = needOpacity ? "rgba(" + r + "," + g + "," + b + "," + opacity + ")" : "rgb(" + r + "," + g + "," + b + ")";
        }
    }
    return rgbaColor;
}
/**
 * @public
 * @function
 * @summary - Returns a random {@link hexColor}
 * @returns {hexColor} - | {@link hexColor} a random color
*/
tf.js.GetRandomHexColorStr = function () { return '#' + Math.floor(Math.random() * 16777215).toString(16); }
/**
 * @public
 * @function
 * @summary - Calculates the gray [color component]{@link tf.types.rgbColorComponent} approximately equivalent to the combined <b>"brightness"</b> of the given rgb components
 * @param {tf.types.rgbColorComponents} rgb - the given components
 * @returns {tf.types.rgbColorComponent} - | {@link tf.types.rgbColorComponent} the gray value
*/
tf.js.GetGrayFromRGB = function (rgb) { return rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114; }
/**
 * @public
 * @function
 * @summary - Retrieves the rgb components of a given color
 * @param {hexColor|deprecatedColor} fromColorStr - the given color
 * @param {hexColor} defaultColorStr - the default color, used if parsing of <b>fromColorStr</b> fails
 * @returns {tf.types.rgbColorComponents} - | {@link tf.types.rgbColorComponents} the rgb components
*/
tf.js.GetRGBFromColor = function (fromColorStr, defaultColorStr) {
    var r = 255, g = 255, b = 255;
    fromColorStr = tf.js.GetHexColorStr(fromColorStr, defaultColorStr);
    if (fromColorStr) {
        var len = fromColorStr.length;
        var nPerColor = len == 7 ? 2 : (len == 4 ? 1 : 0);
        if (nPerColor && fromColorStr.charAt(0) == '#') {
            var r = parseInt(fromColorStr.substr(1, nPerColor), 16);
            var g = parseInt(fromColorStr.substr(1 + nPerColor, nPerColor), 16);
            var b = parseInt(fromColorStr.substr(1 + 2 * nPerColor, nPerColor), 16);
            if (nPerColor == 1) {
                r += r << 4;
                g += g << 4;
                b += b << 4;
            }
        }
    }
    return { r: r, g: g, b: b };
}
/**
 * @public
 * @function
 * @summary - Checks if the parameter is a valid JavaScript {@link number}
 * @param {object} aNumber - the given candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsValidNumber = function (aNumber) { return (Number(aNumber) === aNumber) && isFinite(aNumber); }
/**
 * @public
 * @function
 * @summary - Checks if the parameter is a valid JavaScript non negative {@link number}
 * @param {object} aNumber - the given candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsNonNegativeNumber = function (aNumber) { return tf.js.GetIsValidNumber(aNumber) && aNumber >= 0; }
/**
 * @public
 * @function
 * @summary - Checks if the parameter is a valid JavaScript positive {@link number}
 * @param {object} aNumber - the given candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsPositiveNumber = function (aNumber) { return tf.js.GetIsValidNumber(aNumber) && aNumber > 0; }
/**
 * @public
 * @function
 * @summary - Checks if the parameter is a valid JavaScript integer {@link number}
 * @param {object} aNumber - the given candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsInt = function (aNumber) { return tf.js.GetIsValidNumber(aNumber) && (aNumber % 1 === 0); }
/**
 * @public
 * @function
 * @summary - Checks if the parameter is a valid JavaScript non negative integer {@link number}
 * @param {object} aNumber - the given candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsNonNegativeInt = function (aNumber) { return tf.js.GetIsInt(aNumber) && tf.js.GetIsNonNegativeNumber(aNumber); }
/**
 * @public
 * @function
 * @summary - Checks if the parameter is a valid JavaScript positive integer {@link number}
 * @param {object} aNumber - the given candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsPositiveInt = function (aNumber) { return tf.js.GetIsInt(aNumber) && tf.js.GetIsPositiveNumber(aNumber); }
/**
 * @public
 * @function
 * @summary - Retrieves a valid non negative integer from the given parameter, or returns the given default value
 * @param {string|number} aNumber - the given candidate, strings are parsed in base 10
 * @param {number} defaultValue - the given default
 * @returns {number} - | {@link number} <b>aNumber</b> or <b>defaultValue</b>
*/
tf.js.GetNonNegativeIntFrom = function (aNumber, defaultValue) {
    tf.js.GetIsNonEmptyString(aNumber) && (aNumber = parseInt(aNumber, 10));
    return tf.js.GetIsNonNegativeInt(aNumber) ? aNumber : (defaultValue !== undefined ? defaultValue : 0);
}
/**
 * @public
 * @function
 * @summary - Retrieves a valid positive integer from the given parameter, or returns the given default value
 * @param {string|number} aNumber - the given candidate, [strings]{@link string} are parsed in base 10
 * @param {number} defaultValue - the given default
 * @returns {number} - | {@link number} <b>aNumber</b> or <b>defaultValue</b>
*/
tf.js.GetPositiveIntFrom = function (aNumber, defaultValue) {
    tf.js.GetIsNonEmptyString(aNumber) && (aNumber = parseInt(aNumber, 10));
    return tf.js.GetIsPositiveInt(aNumber) ? aNumber : (defaultValue !== undefined ? defaultValue : 1);
}
/**
 * @public
 * @function
 * @summary - Constrains the given value into the given range
 * @param {number} original - the given value
 * @param {number} minValue - the given minimum acceptable value
 * @param {number} maxValue - the given maximum acceptable value
 * @returns {number} - | {@link number} a number in the given range
*/
tf.js.NumberClip = function (original, minValue, maxValue) { return original < minValue ? minValue : (original > maxValue ? maxValue : original); }
/**
 * @public
 * @function
 * @summary - Retrieves a valid {@link number} from the given number or the given default number
 * @param {number|string|void} fromValue - the given number
 * @param {number} defaultValue - default used when a {@link number} cannot be extracted from <b>fromValue</b>
 * @returns {number} - | {@link number} a valid number
*/
tf.js.GetFloatNumber = function (fromValue, defaultValue) {
    if (fromValue !== undefined) {
        if (typeof fromValue === "string") { fromValue = parseFloat(fromValue); }
        if (typeof fromValue !== "number" || !isFinite(fromValue)) { fromValue = defaultValue; }
    }
    else { fromValue = defaultValue; }
    return fromValue;
}
/**
 * @public
 * @function
 * @summary - Retrieves a valid {@link number} from the given number or the given default number, constrained to the given range
 * @param {number|string|void} fromValue - the given number
 * @param {number} minValue - the given minimum acceptable value
 * @param {number} maxValue - the given maximum acceptable value
 * @param {number} defaultValue - default used when a {@link number} cannot be extracted from <b>fromValue</b>
 * @returns {number} - | {@link number} a valid number
*/
tf.js.GetFloatNumberInRange = function (fromValue, minValue, maxValue, defaultValue) {
    fromValue = tf.js.GetFloatNumber(fromValue, defaultValue);
    return tf.js.NumberClip(fromValue, minValue, maxValue);
}
/**
 * @public
 * @function
 * @summary - Retrieves a valid integer {@link number} from the given number or the given default number, constrained to the given range
 * @param {number|string|void} fromValue - the given number
 * @param {number} minValue - the given minimum acceptable value
 * @param {number} maxValue - the given maximum acceptable value
 * @param {number} defaultValue - default used when a {@link number} cannot be extracted from <b>fromValue</b>
 * @returns {number} - | {@link number} a valid number
*/
tf.js.GetIntNumberInRange = function (fromValue, minValue, maxValue, defaultValue) {
    return Math.floor(tf.js.GetFloatNumberInRange(fromValue, minValue, maxValue, defaultValue));
}
/**
 * @public
 * @function
 * @summary - Checks if the given parameter is a {boolean} <b>false</b>
 * @param {boolean|string|void} value - the given candidate, "false", "FALSE", "False", etc. are acceptable <b>false</b> values
 * @returns {boolean} - | {@link boolean} <b>true</b> if <b>value</b> is <b>false</b>, <b>false</b> otherwise
*/
tf.js.GetIsFalseNotUndefined = function (value) { return value === undefined ? false : ! tf.js.GetBoolFromValue(value, false); }
/**
 * @public
 * @function
 * @summary - Retrieves a valid {@link boolean} value from the given parameter
 * @param {boolean|string|void} fromValue - the given candidate, "false", "FALSE", "False", etc. are acceptable <b>false</b> values
 * @param {boolean|void} defaultOrFalseIfUndefined - default used when a {@link boolean} cannot be extracted from <b>fromValue</b>, defaults to <b>false</b> if undefined
 * @returns {boolean} - | {@link boolean} <b>true</b> if <b>value</b> is <b>true</b>, <b>false</b> otherwise
*/
tf.js.GetBoolFromValue = function (fromValue, defaultOrFalseIfUndefined) {
    if (typeof fromValue === "boolean") { return fromValue; }
    if (typeof fromValue === "string") { return fromValue.length > 0 && fromValue.toLowerCase() !== 'false'; }
    return defaultOrFalseIfUndefined === undefined ? false : !!defaultOrFalseIfUndefined;
}
/**
 * @public
 * @function
 * @summary - Retrieves a valid {@link tf.types.latitude} from the given latitude, defaults to {@link tf.consts.defaultLatitude}
 * @param {number|string|void} latitude - the given latitude
 * @returns {tf.types.latitude} - | {@link tf.types.latitude} a valid latitude
*/
tf.js.GetLatitudeFrom = function (latitude) { return tf.js.GetFloatNumberInRange(latitude, tf.consts.minLatitude, tf.consts.maxLatitude, tf.consts.defaultLatitude); }
/**
 * @public
 * @function
 * @summary - Retrieves a valid {@link tf.types.longitude} from the given longitude, defaults to {@link tf.consts.defaultLongitude}
 * @param {number|string|void} longitude - the given longitude
 * @returns {tf.types.longitude} - | {@link tf.types.longitude} a valid longitude
*/
tf.js.GetLongitudeFrom = function (longitude) { return tf.js.GetFloatNumberInRange(longitude, tf.consts.minLongitude, tf.consts.maxLongitude, tf.consts.defaultLongitude); }
/**
 * @public
 * @function
 * @summary - Creates a random valid {@link tf.types.latitude}
 * @returns {tf.types.latitude} - | {@link tf.types.latitude} a random valid latitude
*/
tf.js.GetRandomLatitude = function () { return Math.random() * tf.consts.latitudeRange - tf.consts.maxLatitude; }
/**
 * @public
 * @function
 * @summary - Creates a random valid {@link tf.types.longitude}
 * @returns {tf.types.longitude} - | {@link tf.types.longitude} a random valid longitude
*/
tf.js.GetRandomLongitude = function () { return Math.random() * tf.consts.longitudeRange - tf.consts.maxLongitude; }
/**
 * @public
 * @function
 * @summary - Retrieves a valid {@link tf.types.mapLevel} from the given level, defaults to {@link tf.consts.defaultLevel}
 * @param {number|string|void} level - the given level
 * @returns {tf.types.mapLevel} - | {@link tf.types.mapLevel} a valid level
*/
tf.js.GetLevelFrom = function (level) { return tf.js.GetIntNumberInRange(level, tf.consts.minLevel, tf.consts.maxLevel, tf.consts.defaultLevel); }
/**
 * @public
 * @function
 * @summary - Validates and retrieves [MinMaxLevels]{@link tf.types.MinMaxLevels} from the given minimum and maximum levels
 * @param {tf.types.mapLevel} minLevel - the minimum level
 * @param {tf.types.mapLevel} maxLevel - the maximum level
 * @returns {tf.types.MinMaxLevels} - | {@link tf.types.MinMaxLevels} the validated minimum and maximum levels
*/
tf.js.GetMinMaxLevelsFrom = function (minLevel, maxLevel) {
    if (minLevel === undefined) { minLevel = tf.consts.minLevel; }
    if (maxLevel === undefined) { maxLevel = tf.consts.maxLevel; }
    minLevel = tf.js.GetLevelFrom(minLevel);
    maxLevel = tf.js.GetLevelFrom(maxLevel);
    if (minLevel < maxLevel) { var t = minLevel; minLevel = maxLevel; maxLevel = t; }
    return { minLevel: minLevel, maxLevel: maxLevel };
}
tf.js.GetMidExtentCoord = function (extent) {
    var midCoord;
    if (tf.js.GetIsArrayWithMinLength(extent, 4)) {
        extent[0] = tf.js.GetLongitudeFrom(extent[0]);
        extent[1] = tf.js.GetLatitudeFrom(extent[1]);
        extent[2] = tf.js.GetLongitudeFrom(extent[2]);
        extent[3] = tf.js.GetLatitudeFrom(extent[3]);
        midCoord = [extent[0] + (extent[2] - extent[0]) / 2, extent[1] + (extent[3] - extent[1]) / 2];
    }
    return midCoord;
};
/**
 * @public
 * @function
 * @summary - Retrieves a valid {@link tf.types.mapExtent} from the given extent
 * @param {tf.types.mapExtent} extent - the given extent
 * @returns {tf.types.mapExtent} - | {@link tf.types.mapExtent} a valid extent
*/
tf.js.GetMapExtentFrom = function (extent) {
    if (tf.js.GetIsArrayWithMinLength(extent, 4)) {
        extent[0] = tf.js.GetLongitudeFrom(extent[0]);
        extent[1] = tf.js.GetLatitudeFrom(extent[1]);
        extent[2] = tf.js.GetLongitudeFrom(extent[2]);
        extent[3] = tf.js.GetLatitudeFrom(extent[3]);
        if (extent[0] > extent[2]) { var t = extent[0]; extent[0] = extent[2]; extent[2] = t; }
        if (extent[1] > extent[3]) { var t = extent[1]; extent[1] = extent[3]; extent[3] = t; }
    }
    else {
        extent = [tf.consts.defaultLongitude, tf.consts.defaultLatitude, tf.consts.defaultLongitude, tf.consts.defaultLatitude];
    }
    return extent;
}
/**
 * @public
 * @function
 * @summary - Checks if the given [map extent]{@link tf.types.mapExtent} contains the given [map coordinate]{@link tf.types.mapCoordinates}
 * @param {tf.types.mapExtent} extent - the given extent
 * @param {tf.types.mapCoordinates} coord - the given coordinate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetExtentContainsCoord = function (extent, coord) {
    extent = tf.js.GetMapExtentFrom(extent);
    coord = tf.js.GetMapCoordsFrom(coord);
    return coord[0] >= extent[0] && coord[0] <= extent[2] && coord[1] >= extent[1] && coord[1] <= extent[3];
}
/**
 * @public
 * @function
 * @summary - Updates the given [map extent]{@link tf.types.mapExtent} to include the given [map coordinate]{@link tf.types.mapCoordinates}
 * @param {tf.types.mapExtent} extent - the given extent
 * @param {tf.types.mapCoordinates} coord - the given coordinate
 * @returns {tf.types.mapExtent} - | {@link tf.types.mapExtent} the updated extent
*/
tf.js.UpdateMapExtent = function (extent, coord) {
    coord = tf.js.GetMapCoordsFrom(coord);
    if (extent == undefined) { extent = [coord[0], coord[1], coord[0], coord[1]]; }
    else {
        extent = tf.js.GetMapExtentFrom(extent);
        if (extent[0] > coord[0]) { extent[0] = coord[0]; } else if (extent[2] < coord[0]) { extent[2] = coord[0]; }
        if (extent[1] > coord[1]) { extent[1] = coord[1]; } else if (extent[3] < coord[1]) { extent[3] = coord[1]; }
    }
    return extent;
}
tf.js.GetExtentCenter = function (extent) { return tf.js.GetIsArrayWithMinLength(extent, 4) ? [extent[0] + (extent[2] - extent[0]) / 2, extent[1] + (extent[3] - extent[1]) / 2] : undefined; }
/**
 * @public
 * @function
 * @summary - Merges the given [map extents]{@link tf.types.mapExtent}
 * @param {tf.types.mapExtent} extent1 - a given extent
 * @param {tf.types.mapExtent} extent2 - a given extent
 * @returns {tf.types.mapExtent} - | {@link tf.types.mapExtent} the merged extent
*/
tf.js.MergeMapExtents = function (extent1, extent2) {
    extent1 = tf.js.GetMapExtentFrom(extent1);
    extent2 = tf.js.GetMapExtentFrom(extent2);
    var extent = extent1.slice(0);
    extent = tf.js.UpdateMapExtent(extent, [extent2[0], extent2[1]]);
    extent = tf.js.UpdateMapExtent(extent, [extent2[2], extent2[3]]);
    return extent;
}
/**
 * @public
 * @function
 * @summary - Scales the given {@link tf.types.mapExtent} to the given scale multiplier
 * @param {tf.types.mapExtent} extent - the given extent
 * @param {number} scale - the given multiplier
 * @returns {tf.types.mapExtent} - | {@link tf.types.mapExtent} the scaled extent
*/
tf.js.ScaleMapExtent = function (extent, scale) {
    extent = tf.js.GetMapExtentFrom(extent); scale = tf.js.GetFloatNumber(scale, 1);
    var extentHW = (extent[2] - extent[0]) / 2, extentHH = (extent[3] - extent[1]) / 2;
    var extentCX = extent[0] + extentHW, extentCY = extent[1] + extentHH;
    extentHW *= scale; extentHH *= scale;
    return [extentCX - extentHW, extentCY - extentHH, extentCX + extentHW, extentCY + extentHH];
}
tf.js.GetPolyGeomFromExtent = function (extent) {
    extent = tf.js.GetMapExtentFrom(extent);
    var topLeft = [extent[0], extent[1]], topRight = [extent[2], extent[1]], bottomRight = [extent[2], extent[3]], bottomLeft = [extent[0], extent[3]];
    return {
        type: 'polygon',
        coordinates: [[topLeft, topRight, bottomRight, bottomLeft, topLeft]]
    };
};
/**
 * @public
 * @function
 * @summary - Returns an array containing all properties in the given {@link object}
 * @param {object} theObject - the given object
 * @returns {array} - | {@link array} the array containing <b>theObject</b>'s properties
*/
tf.js.ObjectToArray = function (object) {
    var array = []; for (var i in object) { array.push(object[i]); }
    return array;
}
/**
 * @public
 * @function
 * @summary - Extracts an {@link HTMLElementSize} from the given dimension
 * @param {HTMLElementSizeOrPxNumber} dim - the given dimension, [numbers]{@link number} are treated as pixel dimensions
 * @param {HTMLElementSize} defaultDim - the default dimension
 * @returns {HTMLElementSize} - | {@link HTMLElementSize} the size
*/
tf.js.GetDimFromStrOrPxNumber = function (dim, defaultDim) {
    if (typeof dim === "number") { return dim + 'px' };
    if (typeof dim !== "string" || !dim.length) { return defaultDim; }
    return dim;
}
/**
 * @public
 * @function
 * @summary - Converts the give number of seconds into "HH:MM:SS" format
 * @param {number} numberOfSeconds - the given number of seconds
 * @returns {string} - | {@link string} the number of seconds in "HH:MM:SS" format
*/
tf.js.ConvertToHHMMSS = function (numberOfSeconds) {
    var sec_num = Math.abs(tf.js.GetFloatNumber(numberOfSeconds, 0)), hours = Math.floor(sec_num / 3600);
    var minutes = Math.floor((sec_num - (hours * 3600)) / 60), seconds = Math.floor(sec_num - (hours * 3600) - (minutes * 60));
    if (hours < 10) { hours = "0" + hours; } if (minutes < 10) { minutes = "0" + minutes; } if (seconds < 10) { seconds = "0" + seconds; }
    var timeStr = hours + ':' + minutes + ':' + seconds;
    return timeStr;
}
/**
 * @public
 * @function
 * @summary - Converts the give number of seconds into "HH:MM:SS" format, adds "HH" only if necessary, uses "M" instead of "MM" when possible
 * @param {number} numberOfSeconds - the given number of seconds
 * @returns {string} - | {@link string} the number of seconds in "HH:MM:SS" format
*/
tf.js.ConvertToHHMMSSBrief = function (numberOfSeconds) {
    var sec_num = tf.js.GetFloatNumber(numberOfSeconds, 0);
    var hours = Math.floor(sec_num / 3600);
    var minutes = Math.floor((sec_num - (hours * 3600)) / 60);
    var seconds = Math.floor(sec_num - (hours * 3600) - (minutes * 60));
    if (hours < 10) { if (hours > 0) { hours = "0" + hours + ':' } else { hours = ''; } }
    if (minutes < 10) { if (minutes > 0) { if (hours > 0) { minutes = "0" + minutes + ':'; } else { minutes = minutes + ':'; } } else { minutes = '0:'; } }
    if (seconds < 10) { seconds = "0" + seconds; }
    var time = hours + minutes + seconds;
    return time;
}
/**
 * @public
 * @function
 * @summary - Converts the give number of seconds into "HH:MM:SS" format, adds "HH" only if necessary, uses "M" instead of "MM" when possible
 * @param {number} numberOfSeconds - the given number of seconds
 * @returns {string} - | {@link string} the number of seconds in "HH:MM:SS" format
*/
tf.js.ConvertToHourMinute = function (numberOfSeconds) {
    var sec_num = tf.js.GetFloatNumber(numberOfSeconds, 0);
    var hours = Math.floor(sec_num / 3600);
    var minutes = Math.floor((sec_num - (hours * 3600)) / 60);
    var time;
    if (!!hours) {
        if (minutes < 10) { minutes = '0' + minutes; }
        time = hours + 'h:' + minutes + 'm';
    }
    else {
        time = minutes + 'm';
    }
    return time;
}
tf.js.ConvertToHourMinute2 = function (numberOfSeconds) {
    var sec_num = tf.js.GetFloatNumber(numberOfSeconds, 0);
    var hours = Math.floor(sec_num / 3600);
    var minutes = Math.floor((sec_num - (hours * 3600)) / 60);
    var time;
    if (!!hours) {
        if (minutes == 0) { time = hours + ' ' + (hours != 1 ? 'hours' : 'hour'); }
        else { time = hours + ' h ' + minutes + ' min'; }
    }
    else { time = minutes + ' min'; }
    return time;
}
/**
 * @public
 * @function
 * @summary - Removes the last character from the given string if it matches the given character
 * @param {string} fromStr - the given string
 * @param {string} theChar - the given character
 * @returns {string} - | {@link string} the string with the character removed
*/
tf.js.ClipEndingChar = function (fromStr, theChar) {
    var fromStrUse = tf.js.GetNonEmptyString(fromStr, "");
    var charUse = tf.js.GetNonEmptyString(theChar, "");
    if (!!fromStrUse && !!charUse) {
        var fromStrUseLen = fromStrUse.length;
        if (fromStrUse.charAt(fromStrUseLen - 1) == charUse.charAt(0)) {
            fromStrUse = fromStrUse.substring(0, --fromStrUseLen);
        }
    }
    return fromStrUse;
}
/**
 * @public
 * @function
 * @summary - Removes parenthesis, '(' and ')', from the start and end of the given string, if present
 * @param {string} fromStr - the given string
 * @returns {string} - | {@link string} the string without parenthesis
*/
tf.js.RemoveParenthesisFrom = function (fromStr) {
    var strUse = tf.js.GetNonEmptyString(fromStr);
    if (strUse) {
        if (strUse.charAt(0) == '(') { strUse = strUse.slice(1); }
        if (!!strUse.length) { if (strUse.charAt(strUse.length - 1) == ')') { strUse = strUse.slice(0, -1); } }
    }
    return strUse;
}
/**
 * @public
 * @function
 * @summary - Removes brackets, '[' and ']', from the start and end of the given string, if present
 * @param {string} fromStr - the given string
 * @returns {string} - | {@link string} the string without brackets
*/
tf.js.RemoveBracketsFrom = function (fromStr) {
    var strUse = tf.js.GetNonEmptyString(fromStr);
    if (strUse) {
        if (strUse.charAt(0) == '[') { strUse = strUse.slice(1); }
        if (!!strUse.length) { if (strUse.charAt(strUse.length - 1) == ']') { strUse = strUse.slice(0, -1); } }
    }
    return strUse;
}
/**
 * @public
 * @function
 * @summary - Capitalizes the first letter of the given string
 * @param {string} string - the given string
 * @returns {string} - | {@link string} the string with the first letter capitalized
*/
tf.js.CapitaliseFirstLetter = function (string) {
    if (tf.js.GetIsNonEmptyString(string)) { string = string.charAt(0).toUpperCase() + string.slice(1); }
    return string;
}
/**
 * @public
 * @function
 * @summary - Capitalizes the first letter of the given string, after converting it to lower case
 * @param {string} string - the given string
 * @returns {string} - | {@link string} the string with only the first letter capitalized
*/
tf.js.CapitaliseFirstLetterOnly = function (string) {
    if (tf.js.GetIsNonEmptyString(string)) { string = tf.js.CapitaliseFirstLetter(string.toLowerCase()) }
    return string;
}
/**
 * @public
 * @function
 * @summary - Retrieves a random element from the given array, or {@link void} if the given array is invalid or empty
 * @param {array<*>} theArray - the given array
 * @returns {*} - | {@link *} a random element from the array, or {@link void} if none is available
*/
tf.js.GetRandomArrayElement = function (theArray) { return tf.js.GetIsNonEmptyArray(theArray) ? theArray[Math.floor(Math.random() * theArray.length)] : null; }
/**
 * @public
 * @function
 * @summary - Determines if the given candidate is an instance of a given type
 * @param {*} obj - the given candidate
 * @param {object} type - the given type
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsInstanceOf = function (obj, type) { return !!obj && !!type && (obj instanceof type); }
/**
 * @public
 * @function
 * @summary - Determines if the given candidate is an instance of the [TerraFly Map]{@link tf.map.Map}
 * @param {*} obj - the given candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsMap = function (obj) { return tf.js.GetIsInstanceOf(obj, tf.map.Map); }
/**
 * @public
 * @function
 * @summary - Determines if the given candidate is an instance of [Feature Layer]{@link tf.map.FeatureLayer}
 * @param {*} obj - the given candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsMapFeatureLayer = function (obj) { return tf.js.GetIsInstanceOf(obj, tf.map.FeatureLayer); }
/**
 * @public
 * @function
 * @summary - Determines if the given candidate is an instance of [Map Feature]{@link tf.map.Feature}
 * @param {*} obj - the given candidate
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.js.GetIsMapFeature = function (obj) { return tf.js.GetIsInstanceOf(obj, tf.map.Feature); }
/**
 * @public
 * @function
 * @summary - Retrieves the given candidate instance of the [TerraFly Map]{@link tf.map.Map} or {@link void} if the candidate is not a valid map
 * @param {*} mapCandidate - the given candidate
 * @returns {tf.map.Map} - | {@link tf.map.Map} <b>mapCandidate</b> or {@link void}
*/
tf.js.GetMapFrom = function (mapCandidate) {
    return tf.js.GetIsMap(mapCandidate) ? mapCandidate : null;
    /*var map = !!tMapCandidate && typeof tMapCandidate === "object" ? tMapCandidate : null;
    if (!!map) {
        if (!tf.js.GetIsMap(map)) {
            while (!!map && tf.js.GetFunctionOrNull(map.GetMap)) { map = map.GetMap(); }
            if (!tf.js.GetIsMap(map)) { map = null; }
        }
    }
    return map;*/
}
/**
 * @private
 * @function
 * @summary - Makes a standard [API Key]{@link tf.types.Key} from a given application defined key. Used internally by the API
 * @param {*} key - the given key
 * @returns {tf.types.Key} - | {@link tf.types.Key} the key
*/
tf.js.MakeObjectKey = function (key) { return !!key ? '#' + key : null; }
/**
 * @public
 * @function
 * @summary - Determines if the given {@link object} has the necessary properties of a [GeoJSON Geometry]{@link tf.types.GeoJSONGeometry}
 * @param {object} obj - the given object
 * @returns {boolean} - | {@link boolean} <b>true</b> if <b>obj</b> has GeoJSON geometry attributes, <b>false</b> otherwise
*/
tf.js.GetHasGeoJSONGeometryProperties = function (obj) {
    if (tf.js.GetIsValidObject(obj) && tf.js.GetIsNonEmptyString(obj.type)) {
        var minLen = obj.type.toLowerCase() == "point" ? 2 : 1;
        return tf.js.GetIsArrayWithMinLength(obj.coordinates, minLen);
    }
    return false;
}
/**
 * @public
 * @function
 * @summary - Returns the given {@link object} if it has the <b>geometry</b> property with the necessary sub-properties of a [GeoJSON Geometry]{@link tf.types.GeoJSONGeometry}
 * @param {object} obj - the given object
 * @returns {tf.types.GeoJSONGeometry} - | {@link tf.types.GeoJSONGeometry} <b>obj</b> or {@link void} if <b>obj</b> lacks the necessary properties
*/
tf.js.GetGeoJSONGeometryFrom = function (obj) {
    var geometry = null;
    if (tf.js.GetIsValidObject(obj)) {
        var geom = obj.geometry;
        if (tf.js.GetIsValidObject(geom) && tf.js.GetIsNonEmptyString(geom.type) && tf.js.GetIsNonEmptyArray(geom.coordinates)) { geometry = geom; }
    }
    return geometry;
}
/**
 * @public
 * @function
 * @summary - Returns a valid [GeoJSON extracting callback]{@link tf.types.GetGeoJSONGeometryCallBack} from the given candidate
 * @param {*} getGeometryFromDataFunction - the given candidate
 * @returns {tf.types.GetGeoJSONGeometryCallBack} - | {@link tf.types.GetGeoJSONGeometryCallBack} a valid GeoJSON extracting callback, defaults to {@link tf.js.GetGeoJSONGeometryFrom}
 * @see [Keyed Feature Lists]{@link tf.map.KeyedFeatureList} and [Keyed Feature List Settings]{@link tf.types.KeyedFeatureListSettings}
*/
tf.js.GetGeoJSONGeometryFunctionFrom = function (getGeometryFromDataFunction) {
    if (!(getGeometryFromDataFunction = tf.js.GetFunctionOrNull(getGeometryFromDataFunction))) {
        getGeometryFromDataFunction = tf.js.GetGeoJSONGeometryFrom;
    }
    return getGeometryFromDataFunction;
}
/**
 * @public
 * @function
 * @summary - Determines if the given <b>coords</b> look like [GeoJSON linestring coordinates]{@link tf.types.GeoJSONGeometryType},
 * i.e. coords is an array with 2 or more elements and its first element is also an array with 2 or more elements
 * @param {object} coords - the given coordinates
 * @returns {boolean} - | {@link boolean} <b>true</b> if the given coordinates seem to be linestring coordinates
*/
tf.js.GetLooksLikeLineStringCoords = function (coords) {
    return tf.js.GetIsArrayWithMinLength(coords, 2) && tf.js.GetIsArrayWithMinLength(coords[0], 2);
}
tf.js.GetLooksLineMultiLineStringCoords = function (coords) {
    return tf.js.GetIsArrayWithLength(coords, 0) || (tf.js.GetIsArrayWithMinLength(coords, 1) && tf.js.GetLooksLikeLineStringCoords(coords[0]));
}
tf.js.GetLooksLikeMultiLineStringGeom = function (geom) {
    return tf.js.GetIsValidObject(geom) && tf.js.GetIsNonEmptyString(geom.type) && geom.type.toLowerCase() == "multilinestring" && tf.js.GetLooksLineMultiLineStringCoords(geom.coordinates);
    /*if (!tf.js.GetIsValidObject(geom)) { return false; }
    if (!tf.js.GetIsNonEmptyString(geom.type)) { return false;}
    if (geom.type.toLowerCase() != "multilinestring") { return false; }
    if (!tf.js.GetLooksLineMultiLineStringCoords(geom.coordinates)) { return false; }
    return true;*/
}
tf.js.InterpolateCoords = function(startCoord, endCoord, proj01) {
    return [
        startCoord[0] + (endCoord[0] - startCoord[0]) * proj01,
        startCoord[1] + (endCoord[1] - startCoord[1]) * proj01
    ];
}
tf.js.GetLSPointAt = function(fromLS, index, proj) {
    var point;
    if (index >= 0 && proj >= 0 && proj <= 1) {
        if (tf.js.GetLooksLikeLineStringCoords(fromLS)) {
            var lsLen = fromLS.length;
            if (index < lsLen - 1) {
                var thisCoord = fromLS[index], nextCoord = fromLS[index + 1];
                point = tf.js.InterpolateCoords(thisCoord, nextCoord, proj);
            }
            else if (index == lsLen - 1) {
                if (proj != 1) {
                    console.log('proj should be 1 at end ' + proj);
                }
                point = fromLS[index]
            }
            else { console.log('invalid index ' + index + ' for len ' + lsLen); }
        } else { console.log('does not look like a line string'); }
    }
    else { console.log('negative index or invalid proj: ' + index + ' ' + proj); }
    return point;
}
tf.js.CreatePartialLS = function(fromLS, sindex, sproj, eindex, eproj) {
    var lsLen = tf.js.GetLooksLikeLineStringCoords(fromLS) ? fromLS.length : 0;
    var partialLS = [];
    if (lsLen > 1) {
        if (sindex >= 0 && eindex < lsLen && sindex <= eindex) {
            var nMidCoords = eindex - sindex;
            if (nMidCoords > 0) {
                partialLS = fromLS.slice(sindex + 1, sindex + nMidCoords);
            }
            var startCoord = fromLS[sindex], afterStart = fromLS[sindex + 1];
            /*var newStartCoord = [
                startCoord[0] + (afterStart[0] - startCoord[0]) * sproj,
                startCoord[1] + (afterStart[1] - startCoord[1]) * sproj
            ];*/
            var newStartCoord = tf.js.InterpolateCoords(startCoord, afterStart, sproj);
            var endCoord = fromLS[eindex];
            var newEndCoord;
            if (eindex < lsLen - 1) {
                var afterEnd = fromLS[eindex + 1];
                /*newEndCoord = [
                    endCoord[0] + (afterEnd[0] - endCoord[0]) * eproj,
                    endCoord[1] + (afterEnd[1] - endCoord[1]) * eproj
                ];*/
                newEndCoord = tf.js.InterpolateCoords(endCoord, afterEnd, eproj);
            }
            else {
                newEndCoord = endCoord;
            }
            partialLS.unshift(newStartCoord);
            partialLS.push(newEndCoord);
        }
    }
    return partialLS;
}
tf.js.CopyLineStringCoords = function(lineStringCoords) {
    var result = [];
    if (tf.js.GetIsArrayWithMinLength(lineStringCoords, 1) && tf.js.GetIsArrayWithMinLength(lineStringCoords[0], 2)) {
        for (var i in lineStringCoords) {
            var lsc = lineStringCoords[i];
            if (tf.js.GetIsArrayWithMinLength(lsc, 2)) {
                result.push([tf.js.GetLongitudeFrom(lsc[0]), tf.js.GetLatitudeFrom(lsc[1])]);
            }
        }
    }
    return result;
}
tf.js.CopyMultiLineStringCoords = function (mlsCoords) {
    var result = [];
    if (tf.js.GetIsNonEmptyArray(mlsCoords)) {
        for (var i in mlsCoords) {
            var ls = mlsCoords[i];
            var lsCopy = tf.js.CopyLineStringCoords(ls);
            if (!!lsCopy) { result.push(lsCopy); }
        }
    }
    return result;
}
tf.js.CopyMultiLineStringGeom = function (geom) {
    var result = { type: 'multilinestring', coordinates: [] };
    if (tf.js.GetIsValidObject(geom) && tf.js.GetIsNonEmptyArray(geom.coordinates)) {
        result.coordinates = tf.js.CopyMultiLineStringCoords(geom.coordinates);
    }
    return result;
}
tf.js.CountMLSPoints = function(mls) {
    var totalPoints = 0;
    if (tf.js.GetIsValidObject(mls) && tf.js.GetIsNonEmptyArray(mls.coordinates)) {
        for (var i in mls.coordinates) {
            var ls = mls.coordinates[i];
            if (tf.js.GetIsNonEmptyArray(ls)) {
                if (tf.js.GetIsArrayWithMinLength(ls[0], 2)) {
                    totalPoints += ls.length;
                }
            }
        }
    }
    return totalPoints;
}
/**
 * @public
 * @function
 * @summary - Extracts standard [Map Coordinates]{@link tf.types.mapCoordinates} from the given coordinates
 * @param {tf.types.mapCoordinates|deprecatedMapCoords1|deprecatedMapCoords2|deprecatedMapCoords3|deprecatedMapCoords4} coords - the given coordinates
 * @returns {tf.types.mapCoordinates} - | {@link tf.types.mapCoordinates} map coordinates
*/
tf.js.GetMapCoordsFrom = function (coords) {
    var latitude, longitude;
    if (tf.js.GetIsArrayWithMinLength(coords, 2)) { latitude = coords[1]; longitude = coords[0]; }
    else if (typeof coords === "object") {
        if (coords.lat !== undefined) { latitude = coords.lat; longitude = coords.lon; }
        else if (coords.Lat != undefined) { latitude = coords.Lat; longitude = coords.Lon; }
        else if (coords.latitude != undefined) { latitude = coords.latitude; longitude = coords.longitude; }
        else if (coords.Latitude != undefined) { latitude = coords.Latitude; longitude = coords.Longitude; }
    }
    if (latitude === undefined) { latitude = 0; longitude = 0; }
    else { latitude = tf.js.GetLatitudeFrom(latitude); longitude = tf.js.GetLongitudeFrom(longitude); }
    return [longitude, latitude];
}
/**
 * @private
 * @function
 * @summary - Implements a basic inheritance pattern. Used internally by the API
 * @param {object} subClass - the subclass
 * @param {object} superClass - the superclass
 * @returns {void} - | {@link void} no return value
*/
tf.js.InheritFrom = function (subClass, superClass) { return ol.inherits(subClass, superClass); }
/**
 * @public
 * @function
 * @summary - Creates and sets to the given value, or deletes, the given property of the given object
 * @param {object} toObj - the object to which the property will be set
 * @param {string} propertyName - the name of the property to be set
 * @param {object|void} propertyObj - the value of the property to be set, if {@link void} the property <b>propertyName<b> is deleted from <b>toObj</b>
 * @returns {void} - | {@link void} no return value
 * @see {@link tf.js.GetObjProperty} and {@link tf.types.KnownAPIPropertyName}
*/
tf.js.SetObjProperty = function (toObj, propertyName, propertyObj) {
    if (tf.js.GetIsValidObject(toObj) && tf.js.GetIsNonEmptyString(propertyName) && ((! propertyObj) || tf.js.GetIsValidObject(propertyObj))) {
        if (!!propertyObj) { toObj[propertyName] = propertyObj; } else if (!!toObj[propertyName]) { delete toObj[propertyName]; }
    }
}
/**
 * @public
 * @function
 * @summary - Retrieves given property from the given object
 * @param {object} fromObj - the object from which the property will be retrieved
 * @param {string} propertyName - the name of the property to retrieve
 * @returns {object} - | {@link object} the retrieved property, or {@link void} if <b>fromObj</b> does not contain a property named <b>propertyName</b>
 * @see {@link tf.js.SetObjProperty} and {@link tf.types.KnownAPIPropertyName}
*/
tf.js.GetObjProperty = function (fromObj, propertyName) {
    var propertyObj = undefined;
    if (tf.js.GetIsValidObject(fromObj) && tf.js.GetIsNonEmptyString(propertyName)) { propertyObj = fromObj[propertyName]; }
    return propertyObj;
}
/**
 * @public
 * @function
 * @summary - Retrieves a regular expression used by the API to retrieve attribute name references from
 * inside strings, example: to reference an attribute named "tempCelsius" in a string use "The temperature in Celsius is $[tempCelsius], it's a sunny day";
 * the regular expression captures the string enclosed inside brackets that immediately follow a $ sign
 * @returns {RegExp} - | {@link RegExp} the regular expression
*/
tf.js.GetFindReferenceInStringRegExp = function () { return /\$\[(\w+)\]/; }
/**
 * @public
 * @function
 * @summary - Replaces references made in the given string with values from attributes of the given object,
 * or a default given value
 * @param {string} strToReplace - the given string including references
 * @param {object} objectWithValues - the object from which attribute values will be retrieved
 * @param {string} defaultStr - the given default string, used if <b>objectWithValues</b> does not contain a referenced attribute
 * @param {RegExp} attributeNameMatch - if defined, used to locate attribute name references in <b>strToReplace</b>, defaults to
 * the regular expression obtained with the function {@link tf.js.GetFindReferenceInStringRegExp}
 * @returns {string} - | {@link string} the string with replacements
*/
tf.js.ReplaceWithValues = function (strToReplace, objectWithValues, defaultStr, attributeNameMatch) {
    var strReplaced = defaultStr;
    if (tf.js.GetIsString(strToReplace)) {
        strReplaced = strToReplace;
        if (tf.js.GetIsValidObject(objectWithValues)) {
            if (attributeNameMatch === undefined) { attributeNameMatch = tf.js.GetFindReferenceInStringRegExp(); }
            if (tf.js.GetIsInstanceOf(attributeNameMatch, RegExp)) {
                var match;
                while (match = attributeNameMatch.exec(strReplaced)) {
                    var propsVal = objectWithValues[match[1]];
                    if (!tf.js.GetIsString(propsVal)) {
                        if (propsVal !== undefined && tf.js.GetFunctionOrNull(propsVal.toString)) {
                            propsVal = propsVal.toString();
                        }
                        else {
                            propsVal = '';
                        }
                    }
                    strReplaced = strReplaced.replace(match[0], propsVal);
                }
            }
        }
    }
    return strReplaced;
}
/**
 * @public
 * @function
 * @summary - Replaces references in string attributes of the given object with the same named attribute values of another given object
 * @param {object} objectToReplace - the object whose string attribute values will be replaced
 * @param {object} objectWithValues - the object from which attribute values will be retrieved
 * @param {RegExp} attributeNameMatch - if defined, used to locate attribute name references in the string attributes of <b>objectToReplace</b>, defaults to
 * the regular expression obtained with the function {@link tf.js.GetFindReferenceInStringRegExp}
 * @returns {object} - | {@link object} the object with attribute replacements
*/
tf.js.ReplaceObjectWithValues = function (objectToReplace, objectWithValues, attributeNameMatch) {
    if (attributeNameMatch === undefined) { attributeNameMatch = tf.js.GetFindReferenceInStringRegExp(); }
    if (tf.js.GetIsValidObject(objectToReplace) && tf.js.GetIsValidObject(objectWithValues) && tf.js.GetIsInstanceOf(attributeNameMatch, RegExp)) {
        for (var property in objectToReplace) {
            if (objectToReplace.hasOwnProperty(property)) {
                var propertyVal = objectToReplace[property];
                if (tf.js.GetIsNonEmptyString(propertyVal)) { objectToReplace[property] = tf.js.ReplaceWithValues(propertyVal, objectWithValues, propertyVal, attributeNameMatch); }
            }
        }
    }
    return objectToReplace;
}
tf.js.Spline1D = function (startCoord, startControlCoord, endControlCoord, endCoord) {
    var theThis, C1, C2, C3, C4;
    this.GetStartCoord = function () { return C4; }
    this.GetEndCoord = function () { return C1; }
    this.GetControlCoord = function (startControlBool) { return !!startControlBool ? C3 : C2; }
    this.GetCoord = function (t) {
        var t2 = t * t, t3 = t2 * t, invT = 1 - t, invT2 = invT * invT, invT3 = invT2 * invT;
        return C1 * t3 + 3 * (C2 * t2 * invT + C3 * t * invT2) + C4 * invT3;
    }
    this.GetVelocity = function (t) {
        var invT = 1 - t;
        return 3 * ((invT * invT * (C3 - C4)) + (t * t * (C1 - C2))) + 6 * invT * t * (C2 - C3);
    }
    this.GetAcceleration = function (t) { return 6 * ((1 - t) * (C2 - 2 * C3 + C4) + t * (C1 - 2 * C2 + C3)); }
    function initialize() {
        C1 = tf.js.GetFloatNumber(endCoord, 0);
        C2 = tf.js.GetFloatNumber(endControlCoord, 0);
        C3 = tf.js.GetFloatNumber(startControlCoord, 0);
        C4 = tf.js.GetFloatNumber(startCoord, 0);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.Spline2D = function (startCoords, startControlCoords, endControlCoords, endCoords) {
    var theThis, splines;
    this.GetStartCoords = function () { return [splines[0].GetStartCoord(), splines[1].GetStartCoord()]; }
    this.GetEndCoords = function () { return [splines[0].GetEndCoord(), splines[1].GetEndCoord()]; }
    this.GetControlCoords = function (startControlBool) { return [splines[0].GetControlCoord(startControlBool), splines[1].GetControlCoord(startControlBool)]; }
    this.GetCoords = function (t) { return [splines[0].GetCoord(t), splines[1].GetCoord(t)]; }
    this.GetVelocity = function (t) { return [splines[0].GetVelocity(t), splines[1].GetVelocity(t)]; }
    this.GetAcceleration = function (t) { return [splines[0].GetAcceleration(t), splines[1].GetAcceleration(t)]; }
    function initialize() {
        var zz = [0, 0];
        startCoords = tf.js.GetIsArrayWithMinLength(startCoords, 2) ? startCoords.slice(0) : zz,
        startControlCoords = tf.js.GetIsArrayWithMinLength(startControlCoords, 2) ? startControlCoords.slice(0) : zz,
        endControlCoords = tf.js.GetIsArrayWithMinLength(endControlCoords, 2) ? endControlCoords.slice(0) : zz,
        endCoords = tf.js.GetIsArrayWithMinLength(endCoords, 2) ? endCoords.slice(0) : zz,
        splines = [
            new tf.js.Spline1D(startCoords[0], startControlCoords[0], endControlCoords[0], endCoords[0]),
            new tf.js.Spline1D(startCoords[1], startControlCoords[1], endControlCoords[1], endCoords[1])
        ];
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * @public
 * @function
 * @summary - Retrieves the URL to the "Powered by TerraFly" logo in this platform of the <b>TerraFly API</b>
* @returns {string} - | {@link string} the logo URL
*/
tf.platform.GetPoweredByTerraFlyLogoImgStr = function () {
    return "http://tf-core.cs.fiu.edu/hterramap/image/svg/poweredByTF.svg";
    //return tf.platform.MakePlatformPath("image/svg/poweredByTF.svg");
}
/**
 * @public
 * @function
 * @summary - Retrieves the ["Powered by TerraFly" logo]{@link tf.dom.Img} from this platform of the <b>TerraFly API</b>
* @returns {tf.dom.Img} - | {@link tf.dom.Img} the logo
*/
tf.platform.GetPoweredByTerraFlyLogo = function () { return tf.GetStyles().CreateImageFullWidthHeight(tf.platform.GetPoweredByTerraFlyLogoImgStr()); }
/**
* @public
* @function
* @summary - Retrieves the full url to a resource in this platform of the <b>TerraFly API</b> given a relative path
* @param {string} srcRelPathNoLeadingSlash - the relative path, without a leading '\' or '/' character
* @returns {string} - | {@link string} the full url
*/
tf.platform.MakePlatformPath = function (srcRelPathNoLeadingSlash) { return tf.platform.GetURL() + srcRelPathNoLeadingSlash; }
// tf.units
/**
 * @public
 * @function
 * @summary - An [Easing Function]{@link tf.types.EasingFunction} that starts slow and speeds up
 * @param {tf.types.value01} t - the input value
 * @return {tf.types.value01} - | {@link tf.types.value01} the output value
 */
tf.units.EaseIn = function (t) { return Math.pow(t, 3); }; 
/**
 * @public
 * @function
 * @summary - An [Easing Function]{@link tf.types.EasingFunction} that starts fast and slows down
 * @param {tf.types.value01} t - the input value
 * @return {tf.types.value01} - | {@link tf.types.value01} the output value
 */
tf.units.EaseOut = function (t) { return 1 - ol.easing.easeIn(1 - t); };
/**
 * @public
 * @function
 * @summary - An [Easing Function]{@link tf.types.EasingFunction} that starts slow, speeds up, and then slows down again
 * @param {tf.types.value01} t - the input value
 * @return {tf.types.value01} - | {@link tf.types.value01} the output value
 */
tf.units.EaseInAndOut = function (t) { return 3 * t * t - 2 * t * t * t; }
/**
 * @public
 * @function
 * @summary - An [Easing Function]{@link tf.types.EasingFunction} that maintains the same rate of variation as its argument,
 * and can be used to achieve constant speed over time
 * @param {tf.types.value01} t - the input value
 * @return {tf.types.value01} - | {@link tf.types.value01} the output value
 */
tf.units.EaseLinear = function (t) { return t; }
/**
 * @public
 * @function
 * @summary - Retrieves the number of milliseconds in one day
 * @returns {number} - | {@link number} the number of milliseconds in one day
*/
tf.units.GetOneDayMillis = function () { return 24 * 60 * 60 * 1000; }
/**
 * @public
 * @function
 * @summary - Retrieves the number of days between two given dates
 * @param {Date} date1 - a date
 * @param {Date} date2 - a date
 * @returns {number} - | {@link number} the number of days between the two given dates
*/
tf.units.GetDaysBetweenDates = function (date1, date2) { return Math.round(Math.abs((date1.getTime() - date2.getTime()) / (tf.units.GetOneDayMillis()))); }
/**
 * @public
 * @function
 * @summary - Retrieves the {@link tf.units.UtmGdcConverter} singleton
 * @returns {tf.units.UtmGdcConverter} - | {@link tf.units.UtmGdcConverter} the singleton
*/
tf.units.GetUtmGdcConverter = function () { if (!tf.g_UtmGdcConverter) { tf.g_UtmGdcConverter = new tf.units.UtmGdcConverter(); } return tf.g_UtmGdcConverter; }
/**
 * @public
 * @function
 * @summary - Retrieves the {@link tf.units.LevelResolutionConverter} singleton
 * @returns {tf.units.LevelResolutionConverter} - | {@link tf.units.LevelResolutionConverter} the singleton
*/
tf.units.GetLevelResolutionConverter = function () { if (!tf.g_LevelResolutionConverter) { tf.g_LevelResolutionConverter = new tf.units.LevelResolutionConverter(); } return tf.g_LevelResolutionConverter; }
/**
 * @public
 * @function
 * @summary - Converts an angle in degrees to radians
 * @param {number} angle - in degrees
 * @returns {number} - | {@link number} angle in radians
*/
tf.units.DegreesToRadians = function (angle) { angle = tf.js.GetFloatNumber(angle, 0); return Math.PI * angle / 180; }
/**
 * @public
 * @function
 * @summary - Converts an angle in radians to degrees
 * @param {number} angle - in radians
 * @returns {number} - | {@link number} angle in degrees
*/
tf.units.RadiansToDegrees = function (angle) { angle = tf.js.GetFloatNumber(angle, 0); return 180 * angle / Math.PI; }
/**
 * @public
 * @function
 * @summary - Calculates the total distance in meters between the given <b>coords</b>, that should be formatted like [GeoJSON linestring coordinates]{@link tf.types.GeoJSONGeometryType},
 * i.e. coords is an array with 2 or more elements and its first element is also an array with 2 or more elements
 * @param {object} coords - the given coordinates
 * @param {boolean} wrapBool - if <b>true</b> adds the distance between the first and last points, defaults to {@link void}
 * @returns {number} - | {@link number} the total distance in meters
*/
tf.units.GetTotalDistanceInMeters = function (pointCoords, wrapBool) {
    var totalDist = 0;
    if (tf.js.GetLooksLikeLineStringCoords(pointCoords)) {
        var len = pointCoords.length, lastCoord = len - 1;
        for (var i = 0 ; i < lastCoord ; ++i) {
            totalDist += tf.units.GetDistanceInMetersBetweenMapCoords(pointCoords[i], pointCoords[i + 1]);
        }
        if (!!wrapBool) { totalDist += tf.units.GetDistanceInMetersBetweenMapCoords(pointCoords[0], pointCoords[lastCoord]); }
    }
    return totalDist;
}
tf.units.GetTotalHaversineDistanceInMeters = function (pointCoords, wrapBool) {
    var totalDist = 0;
    if (tf.js.GetLooksLikeLineStringCoords(pointCoords)) {
        var len = pointCoords.length, lastCoord = len - 1;
        for (var i = 0 ; i < lastCoord ; ++i) {
            totalDist += tf.units.GetHaversineDistance(pointCoords[i], pointCoords[i + 1]);
        }
        if (!!wrapBool) { totalDist += tf.units.GetHaversineDistance(pointCoords[0], pointCoords[lastCoord]); }
    }
    return totalDist;
}
tf.units.SplitSegment = function (startPoint, endPoint, nSplits) {
    var splitPoints = [];
    if ((startPoint = tf.js.GetMapCoordsFrom(startPoint)) !== undefined &&
        (endPoint = tf.js.GetMapCoordsFrom(endPoint)) !== undefined) {
        var X = startPoint[0], Y = startPoint[1], offX = endPoint[0] - X, offY = endPoint[1] - Y;
        for (var j = 0 ; j < nSplits ; ++j) {
            var mult = (j + 1) / (nSplits + 1);
            var dX = offX * mult, dY = offY * mult;
            splitPoints.push([X + dX, Y + dY]);
        }
    }
    return splitPoints;
}
tf.units.SplitLineStringSegments = function (pointCoords, maxSegDist, wrapBool, indicesArray) {
    if (tf.js.GetLooksLikeLineStringCoords(pointCoords) && maxSegDist !== undefined && tf.js.GetIsNonNegativeNumber(maxSegDist)) {
        var len = pointCoords.length, lastCoord = len - 1;
        var indexInIndices = 0, nIndices;
        if (tf.js.GetIsNonEmptyArray(indicesArray)) { nIndices = indicesArray.length; indexInIndices = 0; } else { indicesArray = null; }
        for (var i = 0 ; i < lastCoord ; ++i) {
            var pt1 = pointCoords[i], pt2 = pointCoords[i + 1];
            var thisDist = tf.units.GetDistanceInMetersBetweenMapCoords(pt1, pt2);
            if (!!indicesArray) { while (indexInIndices < nIndices && indicesArray[indexInIndices] <= i) { ++ indexInIndices; } }
            if (thisDist > maxSegDist) {
                var nSplits = Math.floor(thisDist / maxSegDist) + 1;
                var splitPoints = tf.units.SplitSegment(pt1, pt2, nSplits);
                for (var j = 0 ; j < splitPoints.length ; ++j) { pointCoords.splice(i + j + 1, 0, splitPoints[j]); }
                if (!!indicesArray) { for (var ind = indexInIndices ; ind < nIndices ; ind++) { indicesArray[ind] += (nSplits); } }
                i += nSplits;
                lastCoord += nSplits;
            }
        }
        if (!!wrapBool) {
            var pt1 = pointCoords[lastCoord], pt2 = pointCoords[0];
            var thisDist = tf.units.GetDistanceInMetersBetweenMapCoords(pt1, pt2);
            if (thisDist > maxSegDist) {
                var nSplits = Math.floor(thisDist / maxSegDist) + 1;
                var splitPoints = tf.units.SplitSegment(pt1, pt2, nSplits);
                pointCoords = pointCoords.concat(splitPoints);
            }
        }
    }
    return pointCoords;
}
tf.units.DisplaceMapCoords = function(mapCoords, angleRad, distanceInMeters) {
    var mc = tf.js.GetMapCoordsFrom(mapCoords);
    var lat = mapCoords[1], lon = mapCoords[0];
    distanceInMeters = distanceInMeters / 6378137;
    var latRad = tf.units.DegreesToRadians(lat);
    var lonRad = tf.units.DegreesToRadians(lon);
    var newLatRad = Math.asin(Math.sin(latRad) * Math.cos(distanceInMeters) +
        Math.cos(latRad) * Math.sin(distanceInMeters) * Math.cos(angleRad));
    var newLonRad = lonRad + Math.atan2(Math.sin(angleRad) * Math.sin(distanceInMeters) * Math.cos(latRad),
        Math.cos(distanceInMeters) - Math.sin(latRad) * Math.sin(newLatRad));
    return (isNaN(newLatRad) || isNaN(newLonRad)) ? [0, 0] : [tf.units.RadiansToDegrees(newLonRad), tf.units.RadiansToDegrees(newLatRad)];
}
/**
 * @public
 * @function
 * @summary - Calculates the distance in meters between two given map coordinates
 * @param {tf.types.mapCoordinates} pointCoords1 - map coordinates 1
 * @param {tf.types.mapCoordinates} pointCoords2 - map coordinates 2
 * @returns {number} - | {@link number} the distance in meters
*/
tf.units.GetDistanceInMetersBetweenMapCoords = function (pointCoords1, pointCoords2) {
    var meters1 = tf.units.Degrees2Meters(pointCoords1);
    var meters2 = tf.units.Degrees2Meters(pointCoords2);
    var dx = meters2[0] - meters1[0], dy = meters2[1] - meters1[1];
    return Math.sqrt(dx * dx + dy * dy);
}
tf.js.CalcPolyAreaInSquareMeters = function (lineString, isClosed) {
    var area = 0;
    if (tf.js.GetLooksLikeLineStringCoords(lineString)) {
        var lineStringUse = !!isClosed ? lineString : lineString.slice(0);
        if (!isClosed) { lineStringUse.push(lineString[0]); }
        area = Math.abs(tf.map.MapSphere.geodesicArea(lineStringUse));
    }
    return area;
};
tf.units.GetHaversineDistance = function (c1, c2) {
    var REarth = 6378137;
    var toRad = Math.PI / 180;
    var lat1 = toRad * c1[1];
    var lat2 = toRad * c2[1];
    var deltaLatBy2 = (lat2 - lat1) / 2;
    var deltaLonBy2 = (toRad * (c2[0] - c1[0])) / 2;
    var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +
        Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) *
        Math.cos(lat1) * Math.cos(lat2);
    return 2 * REarth * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
/**
 * @public
 * @function
 * @summary - Calculates the heading from the given start to end coordinates
 * @param {tf.types.mapCoordinates} start - start coordinates
 * @param {tf.types.mapCoordinates} end - end coordinates
 * @returns {number} - | {@link number} the angle in radians
*/
tf.units.GetMapHeading = function (start, end) {
    var heading = 0;
    if (tf.js.GetIsArrayWithMinLength(start, 2) && tf.js.GetIsArrayWithMinLength(end, 2)) {
        var fromLon = start[0], toLon = end[0], fromLat = start[1], toLat = end[1];
        var deltaX = (toLon - fromLon);
        var deltaY = (toLat - fromLat);
        heading = Math.atan2(deltaY, deltaX);
    }
    return heading;
}
/**
 * @public
 * @function
 * @summary - Normalizes the given angle to the [0..2*PI] range
 * @param {number} angle - the given angle, in radians
 * @returns {number} - | {@link number} the normalized angle, in radians
*/
tf.units.NormalizeAngle0To2PI = function (a) {
    var TwoPI = Math.PI * 2;
    var nAngle = ((a % TwoPI) + TwoPI) % TwoPI;
    var tolerance = 0.00001;
    if (Math.abs(nAngle) < tolerance || Math.abs(TwoPI = nAngle) < tolerance) { nAngle = 0; }
    return nAngle;
}
/**
 * @public
 * @function
 * @summary - Calculates the smallest arc between two given angles
 * @param {number} fromAngle - the given initial angle, in radians
 * @param {number} toAngle - the given final angle, in radians
 * @returns {number} - | {@link number} the smallest arc, in radians
*/
tf.units.GetShortestArcBetweenAngles = function (fromAngle, toAngle) {
    var PI = Math.PI, twoPI = PI + PI, threePI = twoPI + PI;
    return ((((toAngle - fromAngle) % twoPI) + threePI) % twoPI) - PI;
}
/**
 * @public
 * @class
 * @summary The {@link singleton} instance of this class, obtainable by calling {@link tf.units.GetUtmGdcConverter},
 * converts {@link tf.types.mapCoordinates} to and from {@link tf.types.mapUTMCoordinates}
*/
tf.units.UtmGdcConverter = function () {
    var RADIANS_PER_DEGREE = 0.0174532925199432957692;
    var DEGREES_PER_RADIAN = 57.2957795130823208768;
    var CScale = 0.9996;
    var A = 6378137, F = 1 / 298.257223563, C = (A) * (1 - F);
    var Eps2 = (F) * (2.0 - F), Eps25 = 0.25 * (Eps2), Epps2 = (Eps2) / (1.0 - Eps2), EF = F / (2.0 - F), Epsp2 = 0;
    var Con = (1.0 - Eps2), Con2 = 2 / (1.0 - Eps2), Con6 = 0.166666666666667, Con24 = 4 * .0416666666666667 / (1 - Eps2), Con120 = 0.00833333333333333, Con720 = 4 * 0.00138888888888888 / (1 - Eps2);
    var polx2b_i = 3.0 / 8.0 * (1.0 * Eps2 + 1.0 / 4.0 * Math.pow(Eps2, 2) + 15.0 / 128.0 * Math.pow(Eps2, 3) - 455.0 / 4096.0 * Math.pow(Eps2, 4));
    var polx3b_i = 15.0 / 256.0 * (1.0 * Math.pow(Eps2, 2) + 3.0 / 4.0 * Math.pow(Eps2, 3) - 77.0 / 128.0 * Math.pow(Eps2, 4));
    var polx4b_i = 35.0 / 3072.0 * (Math.pow(Eps2, 3) - 41.0 / 32.0 * Math.pow(Eps2, 4));
    var polx5b_i = -315.0 / 131072.0 * Math.pow(Eps2, 4);
    var poly1b = 1.0 - (1.0 / 4.0 * Eps2) - (3.0 / 64.0 * Math.pow(Eps2, 2)) - (5.0 / 256.0 * Math.pow(Eps2, 3)) - (175.0 / 16384.0 * Math.pow(Eps2, 4));
    var poly2b = polx2b_i * -2.0 + polx3b_i * 4.0 - polx4b_i * 6.0 + polx5b_i * 8.0;
    var poly3b = polx3b_i * -8.0 + polx4b_i * 32.0 - polx5b_i * 80.0;
    var poly4b = polx4b_i * -32.0 + polx5b_i * 192.0;
    var poly5b = polx5b_i * -128.0;
    var polx1a_i = 1.0 - Eps2 / 4.0 - 3.0 / 64.0 * Math.pow(Eps2, 2) - 5.0 / 256.0 * Math.pow(Eps2, 3) - 175.0 / 16384.0 * Math.pow(Eps2, 4);
    var polx2a_i = 3.0 / 2.0 * EF - 27.0 / 32.0 * Math.pow(EF, 3);
    var polx4a_i = 21.0 / 16.0 * Math.pow(EF, 2) - 55.0 / 32.0 * Math.pow(EF, 4);
    var polx6a_i = 151.0 / 96.0 * Math.pow(EF, 3);
    var polx8a_i = 1097.0 / 512.0 * Math.pow(EF, 4);
    var conap = A * polx1a_i;
    var polx2b = polx2a_i * 2.0 + polx4a_i * 4.0 + polx6a_i * 6.0 + polx8a_i * 8.0;
    var polx3b = polx4a_i * -8.0 - polx6a_i * 32.0 - 80.0 * polx8a_i;
    var polx4b = polx6a_i * 32.0 + 192.0 * polx8a_i;
    var polx5b = -128.0 * polx8a_i;
    /**
     * @public
     * @function
     * @summary - Converts UTM coordinates into Map coordinates
     * @param {tf.types.mapUTMCoordinates} xyzoneCoords - UTM coordinates
     * @returns {tf.types.mapCoordinates} - | {@link tf.types.mapCoordinates} map coordinates
    */
    this.UtmToGdc = function (xyzoneCoords) {
        var latitude = 0, longitude = 0;
        if (tf.js.GetIsArrayWithLength(xyzoneCoords, 3)) {
            var x = xyzoneCoords[0];
            var y = xyzoneCoords[1];
            var zone = xyzoneCoords[2];
            var hemisphere_north = zone >= 0; if (!hemisphere_north) { zone = -zone; }
            var source_x = (x - 500000.0) / 0.9996;
            var source_y = hemisphere_north ? y / 0.9996 : (y - 1.0E7) / 0.9996;
            var u = source_y / conap, su = Math.sin(u), cu = Math.cos(u), su2 = su * su; // TEST U TO SEE IF AT POLES
            var xlon0 = (6.0 * (zone) - 183.0) / DEGREES_PER_RADIAN;
            /* THE SNYDER FORMULA FOR PHI1 IS OF THE FORM: PHI1=U+POLY2A*Sin(2U)+POLY3A*Sin(4U)+POLY4ASin(6U)+...
            BY USINGG MULTIPLE ANGLE TRIGONOMETRIC IDENTITIES AND APPROPRIATE FACTORING JUST THE SINE AND COSINE ARE REQUIRED NOW READY TO GET PHI1 */
            var temp = polx2b + su2 * (polx3b + su2 * (polx4b + su2 * polx5b));
            var phi1 = u + su * cu * temp;
            // COMPUTE VARIABLE COEFFICIENTS FOR FINAL RESULT COMPUTE THE VARIABLE COEFFICIENTS OF THE LAT AND LON EXPANSIONS
            var sp = Math.sin(phi1), sp2 = sp * sp, cp = Math.cos(phi1), cp2 = cp * cp, tp = sp / cp, tp2 = tp * tp;
            var eta2 = Epsp2 * cp2; // note 2015-10-14 Epsp2 is always 0 => eta2 is always 0
            var top = 0.25 - (sp2 * (Eps2 / 4));
            // inline sq root
            var rn = A / ((0.25 - Eps25 * sp2 + 0.9999944354799 / 4) + (0.25 - Eps25 * sp2) / (0.25 - Eps25 * sp2 + 0.9999944354799 / 4));
            var b3 = 1.0 + tp2 + tp2 + eta2, b4 = 5 + tp2 * (3 - 9 * eta2) + eta2 * (1 - 4 * eta2);
            var b5 = 5 + tp2 * (tp2 * 24.0 + 28.0) + eta2 * (tp2 * 8.0 + 6.0);
            var b6 = 46.0 - 3.0 * eta2 + tp2 * (-252.0 - tp2 * 90.0);
            b6 = eta2 * (b6 + eta2 * tp2 * (tp2 * 225.0 - 66.0));
            b6 += 61.0 + tp2 * (tp2 * 45.0 + 90.0);
            var d1 = source_x / rn, d2 = d1 * d1;
            latitude = (phi1 - tp * top * (d2 * (Con2 + d2 * ((-Con24) * b4 + d2 * Con720 * b6)))) * DEGREES_PER_RADIAN;
            longitude = (xlon0 + d1 * (1.0 + d2 * (-Con6 * b3 + d2 * Con120 * b5)) / cp) * DEGREES_PER_RADIAN;
        }
        return [longitude, latitude];
    }
    /**
     * @public
     * @function
     * @summary - Converts Map coordinates into UTM coordinates
     * @param {tf.types.mapCoordinates} lonLatCoords - Map coordinates
     * @returns {tf.types.mapUTMCoordinates} - | {@link tf.types.mapUTMCoordinates} UTM coordinates
    */
    this.GdcToUtm = function (lonLatCoords) {
        var x = 0, y = 0, zone = 0;
        if (tf.js.GetIsArrayWithLength(lonLatCoords, 2)) {
            var longitude = lonLatCoords[0];
            var latitude = lonLatCoords[1];
            var hemisphere_north = latitude >= 0;
            var source_lat = latitude * RADIANS_PER_DEGREE, source_lon = longitude * RADIANS_PER_DEGREE;
            var s1 = Math.sin(source_lat), c1 = Math.cos(source_lat), tx = s1 / c1, s12 = s1 * s1;
            // USE IN-LINE SQUARE ROOT
            var rn = A / ((0.25 - Eps25 * s12 + .9999944354799 / 4) + (0.25 - Eps25 * s12) / (0.25 - Eps25 * s12 + 0.9999944354799 / 4));
            // Compute Zone
            zone = (source_lon * 30.0 / 3.1415926 + 31); zone = zone <= 0 ? 1 : zone >= 61 ? 60 : zone;
            // this statement is very important. zone should be an integer. there would be a large deviation without it.
            if ((zone % 1) != 0) { zone = zone - (zone % 1); }
            // COMPUTE UTM COORDINATES
            var axlon0 = (zone * 6 - 183) * RADIANS_PER_DEGREE;
            var al = (source_lon - axlon0) * c1;
            var sm = s1 * c1 * (poly2b + s12 * (poly3b + s12 * (poly4b + s12 * poly5b))); sm = A * (poly1b * source_lat + sm);
            var tn2 = tx * tx, cee = Epps2 * c1 * c1, al2 = al * al;
            var poly1 = 1.0 - tn2 + cee;
            var poly2 = 5.0 + tn2 * (tn2 - 18.0) + cee * (14.0 - tn2 * 58.0);
            // COMPUTE EASTING
            x = (CScale * rn * al * (1.0 + al2 * (0.166666666666667 * poly1 + 0.00833333333333333 * al2 * poly2))) + 5.0E5;
            //COMPUTE NORTHING
            poly1 = 5.0 - tn2 + cee * (cee * 4.0 + 9.0);
            poly2 = 61.0 + tn2 * (tn2 - 58.0) + cee * (270.0 - tn2 * 330.0);
            y = CScale * (sm + rn * tx * al2 * (0.5 + al2 * (0.0416666666666667 * poly1 + 0.00138888888888888 * al2 * poly2)));
            if (source_lat < 0.0) { y += 1.0E7; }
            // compute isnorth
            if (!hemisphere_north) { zone = -zone; }
        }
        return [x, y, zone];
    }
};
/**
 * @public
 * @function
 * @summary - Converts Map coordinates into UTM coordinates
 * @param {tf.types.mapCoordinates} lonLatCoords - Map coordinates
 * @returns {tf.types.mapUTMCoordinates} - | {@link tf.types.mapUTMCoordinates} UTM coordinates
*/
tf.units.GdcToUtm = function (lonlatCoords) { return tf.units.GetUtmGdcConverter().GdcToUtm(lonlatCoords); }
/**
 * @public
 * @function
 * @summary - Converts UTM coordinates into Map coordinates
 * @param {tf.types.mapUTMCoordinates} xyzoneCoords - UTM coordinates
 * @returns {tf.types.mapCoordinates} - | {@link tf.types.mapCoordinates} map coordinates
*/
tf.units.UtmToGdc = function (xyzoneCoords) { return tf.units.GetUtmGdcConverter().UtmToGdc(xyzoneCoords); }
/**
 * @public
 * @class
 * @summary The {@link singleton} instance of this class, obtainable by calling {@link tf.units.GetLevelResolutionConverter},
 * converts {@link tf.types.mapLevel} values to and from {@link tf.types.mapResolution} values
*/
tf.units.LevelResolutionConverter = function () {
    var theThis, zoomLevels, maxLevels, minResolutions;
    /**
     * @public
     * @function
     * @summary - Obtains the map level corresponding to the given map resolution
     * @param {tf.types.mapResolution} resolution - the given map resolution
     * @returns {tf.types.mapLevel} - | {@link tf.types.mapLevel} the corresponding map level
    */
    this.GetLevelByResolution = function (resolution) {
        resolution = tf.js.GetFloatNumber(resolution, tf.consts.defaultRes);
        var level = 0; while (level < maxLevels - 1 && resolution < minResolutions[level]) { ++level; }
        return level + 1;
    }
    /**
     * @public
     * @function
     * @summary - Obtains the map resolution corresponding to the given map level
     * @param {tf.types.mapLevel} level - the given map level
     * @returns {tf.types.mapResolution} - | {@link tf.types.mapResolution} the corresponding map resolution
    */
    this.GetResolutionByLevel = function (level) { return zoomLevels[tf.js.GetIntNumberInRange(level, tf.consts.minLevel, maxLevels/*tf.consts.maxLevel*/, tf.consts.defaultLevel) - 1]; }
    function initialize() {
        var sqrt2 = Math.SQRT2;
        minResolutions = [];
        zoomLevels = [];
        //LatlongData
        zoomLevels[0] = 78271.5170; zoomLevels[1] = 39135.7585; zoomLevels[2] = 19567.8792; zoomLevels[3] = 9783.9396;
        zoomLevels[4] = 4891.9698; zoomLevels[5] = 2445.9849; zoomLevels[6] = 1222.9925; zoomLevels[7] = 611.4962;
        zoomLevels[8] = 305.7481; zoomLevels[9] = 152.8741;
        // UTMData
        zoomLevels[10] = 76.8; zoomLevels[11] = 38.4; zoomLevels[12] = 19.2; zoomLevels[13] = 9.6;
        zoomLevels[14] = 4.8; zoomLevels[15] = 2.4; zoomLevels[16] = 1.2; zoomLevels[17] = 0.6;
        zoomLevels[18] = 0.3; zoomLevels[19] = 0.15; zoomLevels[20] = 0.075;
        zoomLevels[21] = 0.0375; zoomLevels[22] = 0.01875; zoomLevels[23] = 0.009375; zoomLevels[24] = 0.0046875;
        maxLevels = zoomLevels.length;
        for (var i = 0 ; i < maxLevels ; ++i) { minResolutions[i] = zoomLevels[i] / sqrt2; }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * @public
 * @function
 * @summary - Obtains the map level corresponding to the given map resolution
 * @param {tf.types.mapResolution} resolution - the given map resolution
 * @returns {tf.types.mapLevel} - | {@link tf.types.mapLevel} the corresponding map level
*/
tf.units.GetLevelByResolution = function (resolution) { return tf.units.GetLevelResolutionConverter().GetLevelByResolution(resolution); }
/**
 * @public
 * @function
 * @summary - Obtains the map resolution corresponding to the given map level
 * @param {tf.types.mapLevel} level - the given map level
 * @returns {tf.types.mapResolution} - | {@link tf.types.mapResolution} the corresponding map resolution
*/
tf.units.GetResolutionByLevel = function (level) { return tf.units.GetLevelResolutionConverter().GetResolutionByLevel(level); }
/**
 * @public
 * @function
 * @summary - Obtains the minimum map level required to display the given map extent
 * @param {tf.types.mapCoordinates} pointNW - the left top corner of the extent
 * @param {tf.types.mapCoordinates} pointSE - the right bottom corner of the extent
 * @returns {tf.types.mapLevel} - | {@link tf.types.mapLevel} the minimum map level required to display the given map extent
*/
tf.units.GetBoundsZoomLevel = function (pointNW, pointSE, width, height) {
    var res1 = tf.units.GetDistanceInMetersBetweenMapCoords(pointNW, [pointNW[0], pointSE[1]]) / height;
    var res2 = tf.units.GetDistanceInMetersBetweenMapCoords(pointNW, [pointSE[0], pointNW[1]]) / width;
    var res = (res1 > res2) ? res1 : res2;
    return tf.units.GetLevelByResolution(res) - 1;
}
/**
 * @public
 * @function
 * @summary - Converts length in meters to feet
 * @param {number} length - in meters
 * @returns {number} - | {@link number} length in feet
*/
tf.units.GetMetersToFeet = function (length) { return length * 3.28084; }
/**
 * @public
 * @function
 * @summary - Converts speed in km/h to mph
 * @param {number} speed - in km/h
 * @returns {number} - | {@link number} speed in mph
*/
tf.units.GetKMHToMPH = function (speed) { return speed * 0.621371; }
/**
 * @public
 * @function
 * @summary - Converts area in square meters to square feet
 * @param {number} area - in square meters
 * @returns {number} - | {@link number} area in square feet
*/
tf.units.GetSquareMetersToSquareFeet = function (area) { return tf.units.GetMetersToFeet(tf.units.GetMetersToFeet(area)); }
/**
 * @public
 * @function
 * @summary - Converts area in square meters to acres
 * @param {number} area - in square meters
 * @returns {number} - | {@link number} area in acres
*/
tf.units.GetAcresFromSquareMeters = function (area) { return tf.js.GetFloatNumber(area, 0) / 4046.873; }
/**
 * @private
 * @function
 * @summary - Converts map units from the TerraFly API format into the underlying map engine's format
 * @param {tf.types.mapCoordinates} pointCoords - map coordinates
 * @returns {tf.types.mapCoordinates} - | {@link tf.types.mapCoordinates} converted map coordinates
*/
tf.units.TM2OL = function (pointCoords) { return ol.proj.transform(pointCoords, tf.consts.tmSystem, tf.consts.olSystem); }
/**
 * @private
 * @function
 * @summary - Converts map units from the underlying map engine's format into the TerraFly API format
 * @param {tf.types.mapCoordinates} pointCoords - map coordinates
 * @returns {tf.types.mapCoordinates} - | {@link tf.types.mapCoordinates} converted map coordinates
*/
tf.units.OL2TM = function (pointCoords) { return ol.proj.transform(pointCoords, tf.consts.olSystem, tf.consts.tmSystem); }
// tf.browser
/**
 * @public
 * @function
 * @summary - Returns the number of actual pixels corresponding to one logical pixel
 * @returns {number} - | {@link number} the ratio
*/
tf.browser.GetDevicePixelRatio = function () {
    var ratio = 1;
    // To account for zoom, change to use deviceXDPI instead of systemXDPI, only allow for values > 1
    if (window.screen.systemXDPI !== undefined && window.screen.logicalXDPI !== undefined && window.screen.systemXDPI > window.screen.logicalXDPI) {
        ratio = window.screen.systemXDPI / window.screen.logicalXDPI;
    }
    else if (window.devicePixelRatio !== undefined) { ratio = window.devicePixelRatio; }
    return ratio;
}
tf.browser.GetLooksLikeFullScreen = function () {
    return screen.width === window.innerWidth;
}
/**
 * @public
 * @function
 * @summary - Checks if the Browser is in fullscreen mode
 * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
*/
tf.browser.GetIsFullScreen = function (docUse) {
    var doc = docUse != undefined ? docUse : document; return !!(doc.webkitIsFullScreen || doc.mozFullScreen || doc.msFullscreenElement || doc.fullscreenElement);
};
/**
 * @public
 * @function
 * @summary - Requests the Browser to display the given container in fullscreen mode
 * @param {HTMLElementLike} container - the container
 * @returns {void} - | {@link void} no return value
*/
tf.browser.RequestFullScreen = function (container) {
    var requestCall = (container.webkitRequestFullscreen || container.mozRequestFullScreen || container.msRequestFullscreen || container.requestFullscreen);
    if (!!requestCall) { requestCall.call(container); }
}
/**
 * @public
 * @function
 * @summary - Requests the Browser to exit fullscreen mode
 * @returns {void} - | {@link void} no return value
*/
tf.browser.ExitFullScreen = function (docUse) {
    var doc = docUse != undefined ? docUse : document;
    var requestCall = (doc.webkitCancelFullScreen || doc.mozCancelFullScreen || doc.msExitFullscreen || doc.exitFullscreen || doc.cancelFullScreen);
    if (!!requestCall) { requestCall.call(doc); }
};
/**
 * @private
 * @function
 * @summary Calculates {@link tf.browser.Type} use the pre-calculated object instead
 * @returns {boolean} - | {@link boolean } <b>true</b> if the Browser is compatible, <b>false</b> otherwise
*/
tf.browser.GetBrowserType = function () {
    var userAgent = navigator.userAgent.toLowerCase();
    var type = "unknown";
    var version = -1;
    var isAndroidMobile = !!userAgent.match(/Android/i);
    var isBlackBerryMobile = !!userAgent.match(/BlackBerry/i);
    var isiOSMobile = !!userAgent.match(/iPhone|iPad|iPod/i);
    var isOperaMobile = !!userAgent.match(/Opera Mini/i);
    var isWindowsMobile = !!userAgent.match(/IEMobile/i) || !!userAgent.match(/WPDesktop/i);
    var isAnyMobile = isAndroidMobile || isBlackBerryMobile || isiOSMobile || isOperaMobile || isWindowsMobile;
    var isIE = false, isFireFox = false, isChrome = false;
    if (/webkit/.test(userAgent)) {
        if (/chrome/.test(userAgent)) {
            type = "chrome";
            version = (userAgent.match(/.+(?:chrome)[\/]([\d.]+)/) || [])[1];
            isChrome = true;
        }
        else {
            type = "safari";
            version = (userAgent.match(/.+(?:version)[\/]([\d.]+)/) || [])[1];
        }
    }
    else if (/opera/.test(userAgent)) {
        type = "opera";
        version = (userAgent.match(/.+(?:ra)[\/]([\d.]+)/) || [])[1];
    }
    else if ((/msie/.test(userAgent) || /trident.*rv\:11\./.test(userAgent)) && !/opera/.test(userAgent)) {
        isIE = true;
        type = "msie";
        version = (userAgent.match(/(?:ie)[ ]([\d.]+)/) || [])[1];
    }
    else if (/firefox/.test(userAgent) && !/(compatible|webkit)/.test(userAgent)) {
        isFireFox = true;
        type = "firefox";
        version = (userAgent.match(/.+(?:firefox)[\/]([\d.]+)/) || [])[1];
    }
    else if (/mozilla/.test(userAgent) && !/(compatible|webkit)/.test(userAgent) && !/(compatible|firefox)/.test(userAgent)) {
        type = "mozilla";
        version = (userAgent.match(/.+(?:la)[\/]([\d.]+)/) || [])[1];
    }
    return {
        type: type,
        version: version,
        userAgent: userAgent,
        isIE: isIE,
        isFireFox: isFireFox,
        isChrome: isChrome,
        isAndroidMobile: isAndroidMobile,
        isBlackBerryMobile: isBlackBerryMobile,
        isiOSMobile: isiOSMobile,
        isOperaMobile: isOperaMobile,
        isWindowsMobile: isWindowsMobile,
        isAnyMobile: isAnyMobile
    };
};
/**
 * @public
 * @object
 * @summary Provides information about the Browser being used
 * @property {string} type - one of 'chrome', 'safari', 'opera', 'msie', 'firefox', 'mozilla', or 'unknown'
 * @property {string} version - obtained from navigator.userAgent
 * @property {boolean} isIE - true if IE, false otherwise
 * @property {boolean} isFireFox - true if Firefox, false otherwise
 * @property {boolean} isChrome - true if Chrome, false otherwise
 * @property {boolean} isAndroidMobile - true if Android in mobile platform, false otherwise
 * @property {boolean} isBlackBerryMobile - true if Blackberry in mobile platform, false otherwise
 * @property {boolean} isiOSMobile - true if iOS in mobile platform, false otherwise
 * @property {boolean} isOperaMobile - true if Opera in mobile platform, false otherwise
 * @property {boolean} isWindowsMobile - true if Windows in mobile platform, false otherwise
 * @property {boolean} isAnyMobile - true if in mobile platform, false otherwise
*/
tf.browser.Type = tf.browser.GetBrowserType();
/**
 * @public
 * @function
 * @summary Determines if the Browser is compatible with the TerraFly API
 * @returns {boolean} - | {@link boolean } <b>true</b> if the Browser is compatible, <b>false</b> otherwise
*/
tf.browser.IsCompatible = function () { return tf.browser.HasCanvas(); }
/**
 * @public
 * @function
 * @summary Determines if the Browser supports touch events
 * @returns {boolean} - | {@link boolean } <b>true</b> if the Browser supports touch events, <b>false</b> otherwise
*/
tf.browser.HasTouch = function () { return ol !== undefined ? (ol.has !== undefined ? ol.has.TOUCH : false) : false; }
/**
 * @public
 * @function
 * @summary Determines if the Browser supports the 'canvas' HTML5 element
 * @returns {boolean} - | {@link boolean } <b>true</b> if the Browser supports canvas , <b>false</b> otherwise
*/
tf.browser.HasCanvas = function () {
    var elem = document.createElement('canvas');
    return !!(elem.getContext && elem.getContext('2d'));
}
// tf.map
/**
 * @public
 * @function
 * @summary Retrieves a valid map engine from the given name, defaults to {@link tf.consts.mapnik2Engine}
 * @param {string} mapEngineStr - map engine candidate
 * @returns {tf.types.mapEngine} - | {@link tf.types.mapEngine} a valid map engine
*/
tf.map.GetMapEngineFrom = function (mapEngineStr) {
    var mapEngine = (tf.js.GetNonEmptyString(mapEngineStr, tf.consts.mapnik2Engine)).toLowerCase();
    if (mapEngine !== tf.consts.mapnikEngine) { mapEngine = tf.consts.mapnik2Engine; }
    return mapEngine;
}
/**
 * @public
 * @function
 * @summary Creates an array of convex hull coordinates of the given coordinates, which should be formatted like [GeoJSON linestring coordinates]{@link tf.types.GeoJSONGeometryType},
 * i.e. coords is an array with 2 or more elements and its elemets each an array with 2 or more elements
 * @param {array<tf.types.mapCoordinates>} coords - the given coordinates
 * @returns {array<tf.types.mapCoordinates>} - | {@link array<tf.types.mapCoordinates>} the coordinates of the convex hull
*/
tf.map.GetConvexHull = function (coords) {
    var allBaseLines;
    function getDistant(cpt, bl) { var Vy = bl[1][0] - bl[0][0], Vx = bl[0][1] - bl[1][1]; return (Vx * (cpt[0] - bl[0][0]) + Vy * (cpt[1] - bl[0][1])) }
    function findMostDistantPointFromBaseLine(baseLine, points) {
        var maxD = 0, maxPt = [], newPoints = [];
        for (var idx in points) {
            var pt = points[idx], d = getDistant(pt, baseLine);
            if (d > 0) { newPoints.push(pt); } else { continue; }
            if (d > maxD) { maxD = d; maxPt = pt; }
        }
        return { 'maxPoint': maxPt, 'newPoints': newPoints };
    }
    function buildConvexHull(baseLine, points) {
        var convexHullBaseLines = [];
        var t = findMostDistantPointFromBaseLine(baseLine, points);
        allBaseLines.push(baseLine);
        if (t.maxPoint.length) {
            convexHullBaseLines = convexHullBaseLines.concat(buildConvexHull([baseLine[0], t.maxPoint], t.newPoints));
            convexHullBaseLines = convexHullBaseLines.concat(buildConvexHull([t.maxPoint, baseLine[1]], t.newPoints));
            return convexHullBaseLines;
        } else { return [baseLine]; }
    }
    function getConvexHull(points) {
        var ch = [];
        if (tf.js.GetLooksLikeLineStringCoords(points)) {
            var maxX, minX, maxPt, minPt;
            allBaseLines = [];
            for (var idx in points) {
                var pt = points[idx];
                if (pt[0] > maxX || !maxX) { maxPt = pt; maxX = pt[0]; }
                if (pt[0] < minX || !minX) { minPt = pt; minX = pt[0]; }
            }
            var chSegments = [].concat(buildConvexHull([minPt, maxPt], points), buildConvexHull([maxPt, minPt], points));
            ch.push(chSegments[0][0]); for (var i in chSegments) { ch.push(chSegments[i][1]); }
        }
        return ch;
    }
    return getConvexHull(coords);
};
tf.helpers.Timer = function () {
    var theThis, elapsedTime, lastTimeChecked, isPaused, speed, limit, wrap;
    this.SetLimit = function (limitSet) { limit = tf.js.GetFloatNumber(limitSet, 0); if (limit <= 0) { limit = undefined; } }
    this.GetLimit = function () { return limit; }
    this.SetWrap = function (wrapSet) { wrap = !!wrapSet; }
    this.GetWrap = function () { return wrap; }
    this.GetElapsedTime = function () { return getElapsedTime(); }
    this.SetElapsedTime = function (elapsedTimeSet) { elapsedTime = tf.js.GetFloatNumber(elapsedTimeSet, 0); lastTimeChecked = Date.now(); }
    this.GetIsPaused = function () { return isPaused; }
    this.Pause = function (bool) { getElapsedTime(); isPaused = !!bool; }
    this.SetSpeed = function (speedSet) { speed = tf.js.GetFloatNumber(speedSet, 1); }
    this.GetSpeed = function () { return speed; }
    function getElapsedTime() {
        var now = Date.now();
        if (!isPaused) {
            elapsedTime += (now - lastTimeChecked) * speed;
            if (limit != undefined) { if (elapsedTime >= limit) { elapsedTime = wrap ? elapsedTime % limit : limit; } }
        }
        lastTimeChecked = now;
        return elapsedTime;
    }
    function initialize() { lastTimeChecked = Date.now(); elapsedTime = 0; isPaused = false; speed = 1; limit = undefined; wrap = true; }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.Collection = function (settings) {
    var theThis, collection, availableIDs, nextID, count, type;
    this.GetType = function () { return type; }
    this.Add = function (object) {
        var id;
        if (object !== undefined && (type == undefined || tf.js.GetIsInstanceOf(object, type))) {
            id = availableIDs.length > 0 ? availableIDs.shift() : nextID++;
            collection[id] = object;
            ++count;
        }
        return id;
    }
    this.Get = function (id) { return collection[id]; }
    this.Del = function (id) {
        var deleted;
        if (deleted = (collection[id] !== undefined)) {
            availableIDs.push(id); delete collection[id];
            --count;
        }
        return deleted;
    }
    this.GetCount = function () { return count; }
    this.ForEach = function (callback) {
        if (!!(callback = tf.js.GetFunctionOrNull(callback))) { for (var i in collection) { callback(collection[i]); } }
    }
    this.Empty = function () { collection = {}; count = 0; }
    function initialize() {
        collection = {};
        count = 0;
        nextID = 1;
        availableIDs = [];
        if (tf.js.GetIsValidObject(settings)) {
            if (settings.type !== undefined) {
                type = settings.type;
            }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.GetMonthDayYearStr = function(fromDate) {
    var mdyStr = '';
    if (!!fromDate) {
        var day = fromDate.getDate(); if (day < 10) { day = '0' + day; }
        var mon = fromDate.getMonth() + 1; if (mon < 10) { mon = '0' + mon; }
        var year = fromDate.getFullYear();
        mdyStr = '' + year + '-' + mon + '-' + day;
    }
    return mdyStr;
}
tf.js.GetDateFromTimeStamp = function (timeStampStr) {
    //"012345678901234567890"
    //"2016-06-14 22:50:10.0"
    var dateTime;
    if (tf.js.GetIsStringWithMinLength(timeStampStr, 21)) {
        var year = parseInt(timeStampStr.substring(0, 4), 10);
        var month = parseInt(timeStampStr.substring(5, 7), 10) - 1;
        var day = parseInt(timeStampStr.substring(8, 10), 10);
        var hours = parseInt(timeStampStr.substring(11, 13), 10);
        var minutes = parseInt(timeStampStr.substring(14, 16), 10);
        var seconds = parseInt(timeStampStr.substring(17, 19), 10);
        dateTime = new Date(year, month, day, hours, minutes, seconds);
    }
    return dateTime;
}
tf.js.GetTimeStampFromDate = function (date) {
    var timeStampStr;
    if (!!date) {
        var year = date.getFullYear();
        var month = date.getMonth() + 1;
        var day = date.getDate();
        var hours = date.getHours();
        var minutes = date.getMinutes();
        var seconds = date.getSeconds();
        if (month < 10) { month = '0' + month; }
        if (day < 10) { day = '0' + day; }
        if (hours < 10) { hours = '0' + hours; }
        if (minutes < 10) { minutes = '0' + minutes; }
        if (seconds < 10) { seconds = '0' + seconds; }
        timeStampStr = '' + year + '-' + month + '-' + day + ' ' + hours + ':' + minutes + ':' + seconds + '.0';
    }
    return timeStampStr;
}
tf.js.GetAMPMHourWithSeconds = function (fromDate) {
    var str = "";
    if (!!fromDate) {
        var hours = fromDate.getHours();
        var minutes = fromDate.getMinutes(); if (minutes < 10) { if (minutes == 0) { minutes = '00'; } else { minutes = '0' + minutes; } }
        var seconds = fromDate.getSeconds(); if (seconds < 10) { if (seconds == 0) { seconds = '00'; } else { seconds = '0' + seconds; } }
        var ispm = hours >= 12;
        var ampm = ispm ? ' pm' : ' am';
        var hoursUse = ispm && hours != 12 ? hours - 12 : hours;
        return hoursUse + ':' + minutes + ':' + seconds + ampm;
    }
    return str;
}
tf.js.GetAMPMHourWithMinutes = function (fromDate) {
    var str = "";
    if (!!fromDate) {
        var hours = fromDate.getHours();
        var minutes = fromDate.getMinutes(); if (minutes < 10) { if (minutes == 0) { minutes = '00'; } else { minutes = '0' + minutes; } }
        var ispm = hours >= 12;
        var ampm = ispm ? ' pm' : ' am';
        var hoursUse = ispm && hours != 12 ? hours - 12 : hours;
        return hoursUse + ':' + minutes + ampm;
    }
    return str;
}
tf.js.TranslateHourMinSec = function (hourMinSec) {
    var amPm = 'am';
    var secsInAMin = 60, secsInAnHour = secsInAMin * 60;
    var militaryHour = Math.floor(hourMinSec / secsInAnHour), hour = militaryHour;
    var minSec = hourMinSec - hour * secsInAnHour;
    var min = Math.floor(minSec / secsInAMin);
    var sec = minSec - min * secsInAMin;
    if (hour < 10) { hour = '0' + hour; }
    else if (hour >= 12) { if (hour == 12) { amPm = 'pm'; } else if (hour == 24) { hour -= 12; } else if (hour > 24) { hour -= 24; } else { hour -= 12; amPm = 'pm'; } }
    if (min < 10) { min = '0' + min; }
    if (sec < 10) { sec = '0' + sec; }
    var HM = hour + ':' + min, HMS = HM + ':' + sec;
    var MHM = militaryHour + ':' + min, MHMS = MHM + ':' + sec;
    return { HM: HM + amPm, HMS: HMS + amPm, MHM: MHM, MHMS: MHMS };
};
tf.js.GetShortHMSStr = function (hourMinSec, getAbsoluteValueBool) {
    var hmsStr;
    if (hourMinSec != undefined) {
        var signStr = '';
        hmsStr = '';
        if (hourMinSec < 0) { hourMinSec = -hourMinSec; signStr = '-' } else { signStr = '+'; }
        if (hourMinSec == 0) {
            hmsStr = "0s";
        }
        else {
            var secsInAMin = 60, secsInAnHour = secsInAMin * 60;
            var hour = Math.floor(hourMinSec / secsInAnHour);
            var minSec = hourMinSec - hour * secsInAnHour;
            var min = Math.floor(minSec / secsInAMin);
            var sec = (minSec - min * secsInAMin).toFixed(0);
            if (hour > 0) { hmsStr += hour + 'h'; }
            if (min > 0) { hmsStr += min + 'm'; }
            if (sec > 0) { hmsStr += sec + 's'; }
        }
        if (!getAbsoluteValueBool) { hmsStr = signStr + hmsStr; }
    }
    return hmsStr;
};
tf.js.GetHMSFromDate = function (fromDate) { return !!fromDate ? ((fromDate.getHours() * 60) + fromDate.getMinutes()) * 60 + fromDate.getSeconds() : undefined; }
tf.js.BinarySearch = function (theArray, theKey, compareFunction) {
    if (tf.js.GetIsNonEmptyArray(theArray) && tf.js.GetFunctionOrNull(compareFunction)) {
        var m = 0, n = theArray.length - 1;
        while (m <= n) {
            var k = (n + m) >>> 1, cmp = compareFunction(theKey, theArray[k]);
            if (cmp > 0) { m = k + 1; } else if (cmp < 0) { n = k - 1; } else { return k; }
        }
        return -m - 1;
    }
    return undefined;
};
tf.js.BinarySearchGetExactOrNextIndex = function(theArray, theKey, compareFunction) {
    var result = tf.js.BinarySearch(theArray, theKey, compareFunction);
    if (result != undefined) {
        if (result < 0) {
            result = -(result + 1);
            if (result < 0) { result = 0; }
            else if (result >= theArray.length) { result = theArray.length - 1; }
        }
    }
    return result;
};
tf.js.BinarySearchGetExactOrPrevIndex = function (theArray, theKey, compareFunction) {
    var result = tf.js.BinarySearch(theArray, theKey, compareFunction);
    if (result != undefined) {
        if (result < 0) {
            result = -(result + 1) - 1;
            if (result < 0) { result = 0; }
            else if (result >= theArray.length) { result = theArray.length - 1; }
        }
    }
    return result;
};
tf.js.SortObject = function (map, sortFnc) {
    var sortMap;
    if (tf.js.GetIsValidObject(map) && tf.js.GetFunctionOrNull(sortFnc)) {
        var sortArray = [];
        sortMap = {};
        for (var i in map) { sortArray.push({ key: i, value: map[i] }); }
        sortArray.sort(function (a, b) { return sortFnc(a.value, b.value); });
        for (var i in sortArray) { var sortElem = sortArray[i]; sortMap[sortElem.key] = sortElem.value; }
    }
    return sortMap;
};
tf.units.Degrees2Meters = function (coords) {
    var lon = coords[0], lat = coords[1]
    var x = lon * 20037508.34 / 180;
    var y = Math.log(Math.tan((90 + lat) * Math.PI / 360)) / (Math.PI / 180);
    y = y * 20037508.34 / 180;
    return [x, y]
}
tf.js.SquaredDistance = function (x1, y1, x2, y2) { var dx = x2 - x1, dy = y2 - y1; return dx * dx + dy * dy; };
tf.js.SquaredSegmentDistance = function (x, y, x1, y1, x2, y2) {
    var dx = x2 - x1, dy = y2 - y1;
    if (dx !== 0 || dy !== 0) {
        var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
        if (t > 1) { x1 = x2; y1 = y2; } else if (t > 0) { x1 += dx * t; y1 += dy * t; }
    }
    return tf.js.SquaredDistance(x, y, x1, y1);
};
tf.map.SimplifyLS = function (lsCoords, simplifyTolerance) {
    var simplifiedlsCoords = [];
    var start = 0, end = lsCoords.length, n = end - start;
    var squaredTolerance = simplifyTolerance * simplifyTolerance;
    if (n < 3) { for (; start < end; ++start) { simplifiedlsCoords.push(lsCoords[start]); } }
    else {
        var markers = new Array(n);
        var stack = [start, end - 1], index = 0, i;
        var meterLSCoords = [];
        for (var i = 0 ; i < n ; ++i) { meterLSCoords.push(tf.units.Degrees2Meters(lsCoords[i])); }
        markers[0] = markers[n - 1] = 1;
        while (stack.length > 0) {
            var last = stack.pop(), first = stack.pop();
            var inMeters = meterLSCoords[first];
            var x1 = inMeters[0], y1 = inMeters[1];
            inMeters = meterLSCoords[last];
            var x2 = inMeters[0], y2 = inMeters[1];
            var maxSquaredDistance = 0;
            for (i = first + 1; i < last; i += 1) {
                var inMeters = meterLSCoords[i];
                var x = inMeters[0], y = inMeters[1];
                var squaredDistance = tf.js.SquaredSegmentDistance(x, y, x1, y1, x2, y2);
                if (squaredDistance > maxSquaredDistance) { index = i; maxSquaredDistance = squaredDistance; }
            }
            if (maxSquaredDistance > squaredTolerance) {
                markers[index - start] = 1;
                if (first + 1 < index) { stack.push(first, index); }
                if (index + 1 < last) { stack.push(index, last); }
            }
        }
        for (i = 0; i < n; ++i) { if (markers[i]) { simplifiedlsCoords.push(lsCoords[start + i]); } }
    }
    return simplifiedlsCoords;
};
tf.map.GetIsLSClockwise = function (lsCoords) {
    var isClockwise = false;
    if (tf.js.GetLooksLikeLineStringCoords(lsCoords)) {
        var last = lsCoords.length - 1;
        if (last > 1) {
            //var meterLSCoords = [];
            //for (var i = 0 ; i <= last ; ++i) { meterLSCoords.push(tf.units.Degrees2Meters(lsCoords[i])); }
            var meterLSCoords = lsCoords;
            var sum = 0, lastCoord = meterLSCoords[0];
            for (var i = 1; i < last; ++i) {
                var thisCoord = meterLSCoords[i];
                sum += (thisCoord[0] - lastCoord[0]) * (thisCoord[1] + lastCoord[1])
                lastCoord = thisCoord;
            }
            thisCoord = meterLSCoords[0];
            lastCoord = meterLSCoords[last];
            sum += (thisCoord[0] - lastCoord[0]) * (thisCoord[1] + lastCoord[1])
            isClockwise = sum >= 0;
            //isClockwise = sum <= 0; // 
        }
    }
    return isClockwise;
}
tf.js.DecodeHeaderObjectArray = function (theArray) {
    var newArray;
    if (tf.js.GetIsArrayWithMinLength(theArray, 1)) {
        var header = theArray[0];
        if (tf.js.GetIsArrayWithMinLength(header, 1)) {
            var nPs = header.length;
            if (nPs > 0) {
                var arrayLen = theArray.length, contentLen = arrayLen - 1;
                newArray = [];
                for (var i = 1 ; i < arrayLen ; ++i) {
                    var record = theArray[i];
                    if (record.length == nPs) {
                        var element = {};
                        for (var j = 0 ; j < nPs ; ++j) {
                            var val = record[j];
                            if (val == null) { val = undefined; }
                            element[header[j]] = val;
                        }
                        newArray.push(element);
                    }
                }
            }
        }
    }
    return newArray;
}
tf.js.GetCoordsAreDifferent = function (coord1, coord2) {
    if (!tf.js.GetIsArrayWithMinLength(coord1, 2)) { coord1 = undefined; }
    if (!tf.js.GetIsArrayWithMinLength(coord2, 2)) { coord2 = undefined; }
    return (coord1 == undefined && coord2 != undefined) || (coord1 != undefined && coord2 == undefined) || (coord1 != undefined && coord2 != undefined && (coord1[0] != coord2[0] || coord1[1] != coord2[1]));
}
tf.js.BinaryHeap = function (settings) {
    var theThis, heap, currentCount, itemIndexByItemKeyMap, compareFunction, getItemKeyFunction, nInserts, nPops, nGets, nUpdates, nDeletes, nResets, maxCount;
    this.GetStats = function () { return { nInserts: nInserts, nPops: nPops, nGets: nGets, nUpdates: nUpdates, nDeletes: nDeletes, nResets: nResets, maxCount: maxCount }; }
    this.GetCount = function () { return currentCount; }
    this.IsEmpty = function () { return currentCount == 0; }
    this.Insert = function (item) { return insert(item); }
    this.PeekRoot = function () { return getRoot(); }
    this.PopRoot = function () { return popRoot(); }
    this.GetItem = function (key) { return getItem(key); }
    this.Update = function (item, optionalNewItem) { return update(item, optionalNewItem); }
    this.Delete = function (item) { return deleteItem(item); }
    this.FromItems = function (items) { return fromItems(items); }
    this.Reset = function () { return reset(); }
    this.GetHeap = function () { return heap; }
    function getItem(key) {
        var itemIndex = itemIndexByItemKeyMap != undefined ? itemIndexByItemKeyMap[key] : undefined;
        return itemIndex != undefined ? heap[itemIndex] : undefined;
    }
    function setItemAtHeapIndex(index, item) { heap[index] = item; if (itemIndexByItemKeyMap != undefined) { itemIndexByItemKeyMap[getItemKeyFunction(item)] = index; } }
    function getIndexOfItem(item) { return itemIndexByItemKeyMap != undefined ? itemIndexByItemKeyMap[getItemKeyFunction(item)] : undefined; }
    function delIndexOfItem(item) { if (itemIndexByItemKeyMap != undefined) { delete itemIndexByItemKeyMap[getItemKeyFunction(item)]; } }
    function percolateUp(bubbleIndex) {
        var item = heap[bubbleIndex], parentIndex = (bubbleIndex - 1) >> 1, startBubbleIndex = bubbleIndex;
        while (parentIndex >= 0 && compareFunction(item, heap[parentIndex]) < 0) { setItemAtHeapIndex(bubbleIndex, heap[parentIndex]); parentIndex = ((bubbleIndex = parentIndex) - 1) >> 1; }
        if (bubbleIndex != startBubbleIndex) { setItemAtHeapIndex(bubbleIndex, item); }
        return bubbleIndex;
    }
    function percolateDown(bubbleIndex) {
        var item = heap[bubbleIndex], startBubbleIndex = bubbleIndex;
        for (var child = bubbleIndex * 2 + 1; child < currentCount ; child = child * 2 + 1) {
            if (child < currentCount - 1 && compareFunction(heap[child + 1], heap[child]) < 0) { ++child; }
            if (compareFunction(heap[child], item) < 0) { setItemAtHeapIndex(bubbleIndex, heap[child]); }
            else { break; }
            bubbleIndex = child;
        }
        if (bubbleIndex != startBubbleIndex) { setItemAtHeapIndex(bubbleIndex, item); }
        return bubbleIndex;
    }
    function percolateUpAndDown(bubbleIndex) { if (bubbleIndex != undefined) { if (bubbleIndex == percolateUp(bubbleIndex)) { percolateDown(bubbleIndex); } } }
    function insert(item) { if (!!compareFunction) { ++nInserts; setItemAtHeapIndex(currentCount, item); percolateUp(currentCount++); if (currentCount > maxCount) { maxCount = currentCount; } } }
    function getRoot() { return currentCount > 0 ? heap[0] : undefined; }
    function popRoot() { var rootItem = getRoot(); if (rootItem != undefined) { ++nPops; delIndexOfItem(rootItem); setItemAtHeapIndex(0, heap[--currentCount]); percolateDown(0); } return rootItem; }
    function update(item, optionalNewItem) {
        var itemIndex = getIndexOfItem(item);
        if (itemIndex != undefined && (optionalNewItem == undefined || itemIndex == getIndexOfItem(optionalNewItem))) {
            ++nUpdates;
            if (optionalNewItem != undefined) { setItemAtHeapIndex(itemIndex, optionalNewItem); }
            percolateUpAndDown(itemIndex);
        }
    }
    function deleteItem(item) {
        var itemIndex = getIndexOfItem(item);
        if (itemIndex != undefined) {
            ++nDeletes;
            if (currentCount < 2) { reset(); --nResets; }
            else {
                var lastItem = heap[--currentCount];
                delIndexOfItem(item);
                if (lastItem != item) { delIndexOfItem(lastItem); setItemAtHeapIndex(itemIndex, lastItem); percolateUpAndDown(itemIndex); }
            }
        }
    }
    function buildHeap() { for (var i = currentCount >> 1 ; i >= 0 ; --i) { percolateDown(i); } }
    function fromItems(items) {
        var len = tf.js.GetIsNonEmptyArray(items) ? items.length : 0;
        reset();
        if (len > 0) { heap = new Array(len); for (var i = 0 ; i < len ; ++i) { setItemAtHeapIndex(i, items[i]); } currentCount = len; buildHeap(); }
    }
    function reset() { ++nResets; currentCount = 0; heap = [undefined]; itemIndexByItemKeyMap = !!getItemKeyFunction ? {} : undefined; }
    function initialize() {
        nInserts = nPops = nGets = nUpdates = nDeletes = nResets = maxCount = 0;
        compareFunction = tf.js.GetFunctionOrNull(settings.compareFunction);
        getItemKeyFunction = tf.js.GetFunctionOrNull(settings.getItemKeyFunction);
        reset();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.GraphSearch = function (settings) {
    var theThis, stats;
    this.GetStats = function () { return stats; }
    function initialize() {
        if (tf.js.GetIsNonEmptyArray(settings.startNodes)) {
            var getNodeKeyCB = tf.js.GetFunctionOrNull(settings.getNodeKey);
            var getNodeNeighborsCB = tf.js.GetFunctionOrNull(settings.getNodeNeighbors);
            var getIsEndNodeCB = tf.js.GetFunctionOrNull(settings.getIsEndNode);
            var compareNodesCB = tf.js.GetFunctionOrNull(settings.compareNodes);
            var foundEndNodeCB = tf.js.GetFunctionOrNull(settings.foundEndNode);
            if (!!getNodeKeyCB && !!getNodeNeighborsCB && !!getIsEndNodeCB && !!compareNodesCB && !!foundEndNodeCB) {
                var interrupted = false;
                var nUpdated = 0, nInserted = 0, nSettled = 0, nStart = 0, nFound = 0;
                var bh = new tf.js.BinaryHeap({ compareFunction: compareNodesCB, getItemKeyFunction: getNodeKeyCB });
                var settledNodes = {};
                for (var i in settings.startNodes) { bh.Insert(settings.startNodes[i]); ++nStart; }
                while (!(interrupted || bh.IsEmpty())) {
                    var settledNode = bh.PopRoot();
                    ++nSettled;
                    if (getIsEndNodeCB(settledNode)) { ++nFound; if (!foundEndNodeCB({ sender: theThis, endNode: settledNode })) { interrupted = true; } }
                    else {
                        var settledNodeNeighbors = getNodeNeighborsCB(settledNode);
                        settledNodes[getNodeKeyCB(settledNode)] = settledNode;
                        for (var i in settledNodeNeighbors) {
                            var snn = settledNodeNeighbors[i], snnKey = getNodeKeyCB(snn);
                            if (settledNodes[snnKey] == undefined) {
                                var existingItem = bh.GetItem(snnKey);
                                if (existingItem == undefined) { ++nInserted; bh.Insert(snn); }
                                else if (compareNodesCB(snn, existingItem) < 0) { ++nUpdated; bh.Update(existingItem, snn); }
                            }
                        }
                    }
                }
                stats = { binaryHeapStats: bh.GetStats(), nStart: nStart, nFound: nFound, nInserted: nInserted, nSettled: nSettled, nUpdated: nUpdated, interrupted: interrupted };
            }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.GetKeyCodeFromEvent = function (event) { return (typeof event === "object") ? (window.event && event.keyCode) ? event.keyCode : (event.which ? event.which : 0) : 0; }
tf.js.Context = function (settings) {
    var theThis, eventDispatcher, ctxChangeEventName, lastCtx;
    this.AddListener = function (callBack) { return eventDispatcher.AddListener(ctxChangeEventName, callBack); }
    this.GetCtx = function () { return getCtx(); }
    this.SetCtx = function (ctx) { return setCtx(ctx); }
    this.SetCtxAttribute = function (attributeName, newValueSet) { return setCtxAttribute(attributeName, newValueSet); }
    this.GetCtxAttribute = function (attributeName) { return getCtxAttribute(attributeName); }
    function notifyCtxChange() { eventDispatcher.Notify(ctxChangeEventName, { sender: theThis, ctx: getCtx() }); }
    function getCtx() { return tf.js.ShallowMerge(lastCtx); }
    function setCtx(ctx) { var changed = false; for (var i in ctx) { if (doSetCtxAttribute(i, ctx[i])) { changed = true; } } if (changed) { notifyCtxChange(); } return changed; } function getCtxAttribute(attributeName) { return lastCtx[attributeName]; }
    function doSetCtxAttribute(attributeName, newValueSet) { var changed = lastCtx[attributeName] != newValueSet; if (changed) { lastCtx[attributeName] = newValueSet; } return changed; }
    function setCtxAttribute(attributeName, newValueSet) { var changed = doSetCtxAttribute(attributeName, newValueSet); if (changed) { notifyCtxChange(); } return changed; }
    function initialize() { ctxChangeEventName = "ctxChange"; eventDispatcher = new tf.events.MultiEventNotifier({ eventNames: [ctxChangeEventName] }); lastCtx = tf.js.ShallowMerge(settings.ctx); }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.UnCamelize = function (name) {
    var newName = '', nChars = typeof name === "string" ? name.length : 0;
    for (var i = 0; i < nChars; ++i) {
        var thisChar = name[i], thisCharLower = thisChar.toLowerCase();
        newName += thisChar == thisCharLower ? thisChar : "-" + thisCharLower;
    }
    return newName;
};
tf.js.CompassDirectionToAngle = function (compassDirectionStr) {
    var compassDirectionsToAngles = { 'N': 0, 'NE': 45, 'E': 90, 'SE': 135, 'S': 180, 'SW': 225, 'W': 270, 'NW': 315 };
    var compassDirectionAngle = compassDirectionsToAngles[compassDirectionStr];
    return compassDirectionAngle != undefined ? Math.PI * compassDirectionAngle / 180 : 0;
};
tf.js.ClipLineSegment = function (extent, startCoord, endCoord) {
    function bitCode(x, y) {
        var code = 0;
        if (x < extent[0]) { code |= leftF; } else if (x > extent[2]) { code |= rightF; }
        if (y < extent[1]) { code |= bottomF; } else if (y > extent[3]) { code |= topF; }
        return code;
    };
    var insideF = 0, leftF = 1, rightF = 2, bottomF = 4, topF = 8;
    var xmin = extent[0], ymin = extent[1], xmax = extent[2], ymax = extent[3];
    var x0 = startCoord[0], y0 = startCoord[1], x1 = endCoord[0], y1 = endCoord[1];
    var intersects = false;
    var bc0 = bitCode(x0, y0), bc1 = bitCode(x1, y1);
    var clippedStart = !!bc0, clippedEnd = !!bc1;
    while (true) {
        if (!(bc0 | bc1)) { intersects = true; break; } else if (bc0 & bc1) { break; }
        else {
            var x, y, bcu = bc0 ? bc0 : bc1;
            if (bcu & topF) { x = x0 + (x1 - x0) * (ymax - y0) / (y1 - y0); y = ymax; }
            else if (bcu & bottomF) { x = x0 + (x1 - x0) * (ymin - y0) / (y1 - y0); y = ymin; }
            else if (bcu & rightF) { y = y0 + (y1 - y0) * (xmax - x0) / (x1 - x0); x = xmax; }
            else if (bcu & leftF) { y = y0 + (y1 - y0) * (xmin - x0) / (x1 - x0); x = xmin; }
            if (bcu == bc0) { x0 = x; y0 = y; bc0 = bitCode(x0, y0); }
            else { x1 = x; y1 = y; bc1 = bitCode(x1, y1); }
        }
    }
    return { intersects: intersects, startCoord: [x0, y0], endCoord: [x1, y1], clippedStart: clippedStart, clippedEnd: clippedEnd };
};
tf.js.ClipMapLineSegment = function (extent, startCoord, endCoord) {
    var extentMinOL = tf.units.TM2OL([extent[0], extent[1]]), extentMaxOL = tf.units.TM2OL([extent[2], extent[3]]);
    var clipResult = tf.js.ClipLineSegment([extentMinOL[0], extentMinOL[1], extentMaxOL[0], extentMaxOL[1]], tf.units.TM2OL(startCoord), tf.units.TM2OL(endCoord));
    if (clipResult.intersects) {
        clipResult.startCoord = clipResult.clippedStart ? tf.units.OL2TM(clipResult.startCoord) : startCoord;
        clipResult.endCoord = clipResult.clippedEnd ? tf.units.OL2TM(clipResult.endCoord) : endCoord;
    }
    return clipResult;
};
tf.js.propagateValues = function (valuesArray, nValues, valueStep, valueMult) { for (var i = 1; i < nValues; ++i) { for (var j = 0; j < valueStep; ++j) { valuesArray[i * valueStep + j] = valuesArray[(i - 1) * valueStep + j] * valueMult; } } return valuesArray; }
tf.js.CalcDistancesInMeters = function () { var distancesInMeters = [0.1, 0.2, 0.5]; return tf.js.propagateValues(distancesInMeters, 20, 3, 10); }
tf.js.CalcDistancesInMiles = function () { var mult = 1609.34, distancesInUSMiles = [0.01 * mult, 0.02 * mult, 0.05 * mult]; return tf.js.propagateValues(distancesInUSMiles, 24, 3, 10); }
tf.js.CalcDistancesInFeet = function () { var mult = 0.3048, distancesInUSFeet = [0.1 * mult, 0.2 * mult, 0.5 * mult]; return tf.js.propagateValues(distancesInUSFeet, 20, 3, 10); }
tf.js.CalcDistances3Units = function () { return { distancesInMeters: tf.js.CalcDistancesInMeters(), distancesInMiles: tf.js.CalcDistancesInMiles(), distancesInFeet: tf.js.CalcDistancesInFeet() }; };
tf.js.ObjectToURLParams = function (settings) {
    var urlParams;
    if (tf.js.GetIsValidObject(settings)) {
        var addedParam = false;
        urlParams = "";
        for (var i in settings) {
            var value = settings[i];
            if (value != undefined) {
                if (addedParam) { urlParams += "&"; }
                urlParams += i + "=" + encodeURIComponent(value);
                addedParam = true;
            }
        }
    }
    return urlParams;
};

// SOURCE FILE: mapmeasures.js
tf.consts.measureColorTicDefaultHybrid = "#fff";
tf.consts.measureColorTicDefaultMap = "#1E90FF";
tf.js.CalcVertexInfos = function (lineString, area, distanceFunction) {
    var vertexInfos = [];
    if (tf.js.GetIsNonEmptyArray(lineString)) {
        var distanceFunctionUse = tf.js.GetFunctionOrNull(distanceFunction) ? distanceFunction : tf.units.GetHaversineDistance;
        var nPoints = lineString.length;
        if (nPoints > 0) {
            var thisPoint = lineString[0], totalDistance = 0;
            var twoPI = 2 * Math.PI;
            var minRotateTextAngle = Math.PI / 2;
            var maxRotateTextAngle = 3 * minRotateTextAngle;
            for (var i = 1; i < nPoints + 1; ++i) {
                var nextPoint = i < nPoints ? lineString[i] : lineString[0];
                var midCoords = [thisPoint[0] + (nextPoint[0] - thisPoint[0]) / 2, thisPoint[1] + (nextPoint[1] - thisPoint[1]) / 2]
                var distanceToNext = distanceFunctionUse(thisPoint, nextPoint);
                var headingToNext = tf.units.NormalizeAngle0To2PI(tf.units.GetMapHeading(thisPoint, nextPoint));
                var normal = Math.PI - headingToNext;
                var textDirection = twoPI - headingToNext;
                var endTextAlign;
                if (distanceToNext <= 0) { distanceToNext = 0.000001; }
                var uprightTextDirection = textDirection;
                if (textDirection > minRotateTextAngle && textDirection < maxRotateTextAngle) { textDirection += Math.PI; endTextAlign = "right"; }
                else { endTextAlign = "left"; }
                var textFlowDirection = tf.units.NormalizeAngle0To2PI(textDirection + Math.PI / 2);
                var vertexInfo = {
                    coords: thisPoint.slice(0), nextCoords: nextPoint.slice(0), midCoords: midCoords,
                    headingToNext: headingToNext, normal: normal, uprightTextDirection: uprightTextDirection, textDirection: textDirection, textFlowDirection: textFlowDirection, endTextAlign: endTextAlign,
                    distanceToNext: distanceToNext, totalDistance: totalDistance,
                    index: i
                };
                if (i == nPoints) { vertexInfo.area = area; }
                vertexInfos.push(vertexInfo);
                thisPoint = nextPoint;
                totalDistance += distanceToNext;
            }
        }
    }
    return vertexInfos;
};
tf.js.CalcClippedVertexInfo = function (map, vi, nPoints, optionalExtent, optionalMapRotation, distanceFunction, clipFunction) {
    var pvi;
    var extent = optionalExtent != undefined ? optionalExtent : map.GetVisibleExtent();
    var distanceFunctionUse = tf.js.GetFunctionOrNull(distanceFunction) ? distanceFunction : tf.units.GetHaversineDistance;
    var clipFunctionUse = tf.js.GetFunctionOrNull(clipFunction) ? clipFunction : tf.js.ClipLineSegment;
    var lineClip = clipFunctionUse(extent, vi.coords, vi.nextCoords);
    if (lineClip.intersects) {
        var mapRotation = optionalMapRotation != undefined ? optionalMapRotation : map.GetRotationRad();
        var coordsPx = map.ActualMapToPixelCoords(vi.coords);
        var nextCoordsPx = map.ActualMapToPixelCoords(vi.nextCoords);
        var midCoordsPx = map.ActualMapToPixelCoords(vi.midCoords);
        var coordsClip = lineClip.startCoord;
        var nextCoordsClip = lineClip.endCoord;
        var coordsClipPx = map.ActualMapToPixelCoords(coordsClip);
        var nextCoordsClipPx = map.ActualMapToPixelCoords(nextCoordsClip);
        var lengthXPx = nextCoordsPx[0] - coordsPx[0];
        var lengthYPx = nextCoordsPx[1] - coordsPx[1];
        var lengthSegPxSq = lengthXPx * lengthXPx + lengthYPx * lengthYPx;
        var lengthSegPx = Math.sqrt(lengthSegPxSq);
        var textDirectionWithRotation = vi.textDirection + mapRotation;
        var coordsIsVisible = !lineClip.clippedStart;
        var nextCoordsIsVisible = !lineClip.clippedEnd;
        var invisibleStartDistance = distanceFunctionUse(vi.coords, coordsClip);
        var invisibleEndDistance = distanceFunctionUse(vi.nextCoords, nextCoordsClip);
        pvi = {
            vi: vi,
            coordsPx: coordsPx, nextCoordsPx: nextCoordsPx, midCoordsPx: midCoordsPx,
            coordsClip: coordsClip, nextCoordsClip: nextCoordsClip, coordsClipPx: coordsClipPx, nextCoordsClipPx: nextCoordsClipPx,
            coordsIsVisible: coordsIsVisible, nextCoordsIsVisible: nextCoordsIsVisible,
            invisibleStartDistance: invisibleStartDistance, invisibleEndDistance: invisibleEndDistance,
            lengthXPx: lengthXPx, lengthYPx: lengthYPx, lengthSegPxSq: lengthSegPxSq, lengthSegPx: lengthSegPx,
            textDirectionWithRotation: textDirectionWithRotation,
            isLast: vi.index == nPoints
        };
    }
    return pvi;
};
tf.js.CalcDisplayDistances = function (totalDistance, useUSScale, mapResolution, distances3Units) {
    var distanceTicScaleInMeters0 = 100;
    var distanceTicScaleInMetersTry = distanceTicScaleInMeters0 * mapResolution;
    var useMiles = totalDistance > 1609;
    var distanceChoicesUse = useUSScale ? (useMiles ? distances3Units.distancesInMiles : distances3Units.distancesInFeet) : distances3Units.distancesInMeters;
    var distanceUnitText;
    if (useUSScale) { if (useMiles) { distanceUnitText = 'mi'; } else { distanceUnitText = 'ft'; } }
    else { if (totalDistance > 999.5) { distanceUnitText = "km"; } else { distanceUnitText = "m"; } }
    var indexDistance = tf.js.BinarySearchGetExactOrNextIndex(distanceChoicesUse, distanceTicScaleInMetersTry, function (a, b) { return a < b ? -1 : (a > b ? 1 : 0); })
    var distanceMarkScaleInMeters = distanceChoicesUse[indexDistance];
    var distanceTicScaleInMeters = distanceMarkScaleInMeters / 10;
    var offsetMetersEndSegText = (distanceTicScaleInMeters0 / 8) * mapResolution;
    var nTics = Math.floor(totalDistance / distanceTicScaleInMeters);
    return {
        distanceUnitText: distanceUnitText,
        distanceMarkScaleInMeters: distanceMarkScaleInMeters, distanceTicScaleInMeters: distanceTicScaleInMeters,
        offsetMetersEndSegText: offsetMetersEndSegText, nTics: nTics
    }
};
tf.js.FormatDistanceText = function (distanceInMeters, distanceUnitText, isArea) {
    var distanceText;
    if (distanceInMeters > 0) {
        var divisor;
        //if (isArea && distanceUnitText == 'ft' && distanceInMeters > 5280 * 10) { distanceUnitText = 'mi'; }
        switch (distanceUnitText) {
            default: case 'm': divisor = 1; break;
            case 'km': divisor = 1000; break;
            case 'mi': divisor = 1609.34; break;
            case 'ft': divisor = 0.3048; break;
        }
        if (isArea) { divisor *= divisor; }
        distanceInMeters /= divisor;
        distanceText = '' + distanceInMeters.toFixed(3);
        var countZeros = 0, len = distanceText.length;
        while (len > 1 && distanceText[len - 1] == '0') { --len; ++countZeros; }
        if (countZeros > 0) {
            distanceText = distanceText.slice(0, -countZeros);
            if (distanceText[distanceText.length - 1] == '.') { distanceText = distanceText.slice(0, -1); }
        }
        distanceText += ' ' + distanceUnitText;
        if (isArea) { distanceText += "\u00B2"; }
    }
    else { distanceText = "0"; }
    return distanceText;
};
/*
map, ctx, pvi, distances, mapRotation, showIntermediateLenghts, colorTicNormalHybrid, colorTicNormalMap,
    optionalMapResolution, optionalShowingHybrid, optionalHybridTextStyle, optionalMapTextStyle
*/
tf.js.DrawMeasuredVertex = function (drawSettings) {
    var pixelRatio = tf.browser.GetDevicePixelRatio();
    function showText(textShowSettings, ctx, theText, textX, textY, textDirection, textAlign) {
        var fontSize = parseInt(textShowSettings.fontSize, 10) * pixelRatio + 'px';
        ctx.font = textShowSettings.fontWeight + " " + fontSize + " " + textShowSettings.fontFamily;
        ctx.textAlign = textAlign != undefined ? textAlign : "center";
        ctx.textBaseline = 'middle';
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        if (!tf.browser.Type.isFireFox) {
            ctx.shadowColor = "rgba(255,255,255,1)";
            ctx.shadowBlur = 6;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }
        ctx.translate(textX * pixelRatio, textY * pixelRatio);
        ctx.rotate(textDirection);
        ctx.fillStyle = textShowSettings.textFill;
        ctx.strokeStyle = textShowSettings.textLine;
        ctx.lineWidth = textShowSettings.lineWidth * pixelRatio;
        ctx.strokeText(theText, 0, 0);
        ctx.fillText(theText, 0, 0);
        ctx.restore();
    };
    function showDistanceText(textShowSettings, ctx, distanceInMeters, textX, textY, textDirection, textAlign, showingHybrid, distanceUnitText) {
        showText(textShowSettings, ctx, tf.js.FormatDistanceText(distanceInMeters, distanceUnitText, false), textX, textY, textDirection, textAlign);
    };
    function showAreaText(textShowSettings, ctx, areaInSqMeters, textX, textY, textDirection, textAlign, showingHybrid, distanceUnitText) {
        showText(textShowSettings, ctx, tf.js.FormatDistanceText(areaInSqMeters, distanceUnitText, true), textX, textY, textDirection, textAlign);
    };
    function offsetMetersInSegToPixelCoords(pvi, offsetMetersInSeg) {
        var vi = pvi.vi, segLen = vi.distanceToNext > 0 ? vi.distanceToNext : 0.000001;
        var dSeg = offsetMetersInSeg / segLen;
        var xPx = pvi.coordsPx[0] + dSeg * pvi.lengthXPx;
        var yPx = pvi.coordsPx[1] + dSeg * pvi.lengthYPx;
        return [xPx, yPx];
    };
    var largerFontSize = drawSettings.largerFontSize != undefined ? drawSettings.largerFontSize : "16px";
    var map = drawSettings.map;
    var showingHybrid = drawSettings.showingHybrid != undefined ? !!drawSettings.showingHybrid : map.GetMapType() != tf.consts.typeNameMap;
    var textShowSettings = drawSettings.textStyle != undefined ? drawSettings.textStyle :
        (showingHybrid ?
            { fontFamily: "Roboto", lineWidth: 4, textFill: "#fff", textLine: "rgba(0, 0, 0, 0.7)", fontSize: "12px", fontWeight: "400" } :
            { fontFamily: "Roboto", lineWidth: 1, textFill: "#000", textLine: "rgba(30, 144, 255, 0.7)", fontSize: "11px", fontWeight: "300" });
    var endTextShowSettings = drawSettings.endTextStyle != undefined ?
        tf.js.ShallowMerge(textShowSettings, drawSettings.endTextStyle) : tf.js.ShallowMerge(textShowSettings, { fontSize: largerFontSize });
    var distances = drawSettings.distances;
    var distanceUnitText = distances.distanceUnitText;
    var distanceMarkScaleInMeters = distances.distanceMarkScaleInMeters;
    var distanceTicScaleInMeters = distances.distanceTicScaleInMeters;
    var offsetMetersEndSegText = distances.offsetMetersEndSegText;
    var nTics = distances.nTics;
    var pvi = drawSettings.pvi;
    var vi = pvi.vi;
    var res = drawSettings.resolution != undefined ? drawSettings.resolution : map.GetResolution();
    var distanceDisplace0 = 2 * res, distanceDisplace = 6 * res, startDisplaceHeight = 0.3;
    var heightText = 2.5, textEndSegOffsetPxInt = 36, textEndSegOffsetVal = textEndSegOffsetPxInt * textEndSegOffsetPxInt;
    var displacedMid = tf.units.DisplaceMapCoords(vi.midCoords, vi.normal, distanceDisplace);
    var displacedMidPx = map.ActualMapToPixelCoords(displacedMid);
    var displaceXPx = displacedMidPx[0] - pvi.midCoordsPx[0], displaceYPx = displacedMidPx[1] - pvi.midCoordsPx[1];
    var colorTic = drawSettings.colorTic != undefined ? drawSettings.colorTic : (showingHybrid ? tf.consts.measureColorTicDefaultHybrid : tf.consts.measureColorTicDefaultMap);
    var distanceAtSegStart = vi.totalDistance, distanceAtSegEnd = distanceAtSegStart + vi.distanceToNext;
    var startVisibleDistance = distanceAtSegStart + pvi.invisibleStartDistance;
    var endVisibleDistance = distanceAtSegEnd - pvi.invisibleEndDistance;
    var firstTicIndex = startVisibleDistance / distanceTicScaleInMeters;
    var firstTicIndexInt = Math.floor(firstTicIndex);
    if (firstTicIndex != firstTicIndexInt) { ++firstTicIndexInt; }
    var lastTicIndex = endVisibleDistance / distanceTicScaleInMeters;
    var lastTicIndexInt = Math.floor(lastTicIndex);
    //lastTicIndexInt = firstTicIndexInt - 1;
    var ctx = drawSettings.ctx;
    for (var iTicIndex = firstTicIndexInt; iTicIndex <= lastTicIndexInt; ++iTicIndex) {
        var distanceTic = iTicIndex * distanceTicScaleInMeters;
        var distanceInSegMeters = distanceTic - distanceAtSegStart;
        var ticCoordsPx = offsetMetersInSegToPixelCoords(pvi, distanceInSegMeters);
        var xPx = ticCoordsPx[0] + displaceXPx * startDisplaceHeight;
        var yPx = ticCoordsPx[1] + displaceYPx * startDisplaceHeight;
        var heightTic, colorTic, widthTic, needText = false;
        if (iTicIndex % 5 == 0) {
            if (iTicIndex % 2 == 0) {
                heightTic = 1.25; widthTic = 2; colorTic = colorTic;
                //needText = vi.distanceToNext > distanceInSegMeters + 1 * distanceTicScaleInMeters;
                needText = !drawSettings.skipScaleText;
            }
            else { heightTic = 1; widthTic = 2; colorTic = colorTic; }
        }
        else { heightTic = 0.75; widthTic = 1; colorTic = colorTic; }
        if (!drawSettings.skipTics) {
            var xPx2 = xPx + displaceXPx * heightTic;
            var yPx2 = yPx + displaceYPx * heightTic;
            ctx.beginPath();
            ctx.strokeStyle = colorTic;
            ctx.lineWidth = widthTic * pixelRatio;
            ctx.moveTo(xPx * pixelRatio, yPx * pixelRatio);
            ctx.lineTo(xPx2 * pixelRatio, yPx2 * pixelRatio);
            ctx.closePath(); ctx.fill(); ctx.stroke();
        }
        if (needText) {
            var xPxT = ticCoordsPx[0] + displaceXPx * heightText;
            var yPxT = ticCoordsPx[1] + displaceYPx * heightText;
            showDistanceText(textShowSettings, ctx, distanceTic, xPxT, yPxT, pvi.textDirectionWithRotation, "center", showingHybrid, distanceUnitText);
        }
    }
    var needEndSegDistance = (drawSettings.showIntermediateLenghts && lastTicIndex > firstTicIndex + 1 )|| pvi.isLast;
    if (needEndSegDistance) {
        var distanceToShowAt = vi.distanceToNext + offsetMetersEndSegText + (12 * res);
        var textSegCoordsPx = offsetMetersInSegToPixelCoords(pvi, distanceToShowAt);
        var xPxT = textSegCoordsPx[0];
        var yPxT = textSegCoordsPx[1];
        var showSettingsUse = pvi.isLast ? endTextShowSettings : textShowSettings;
        showDistanceText(showSettingsUse, ctx, distanceAtSegEnd, xPxT, yPxT, pvi.textDirectionWithRotation, vi.endTextAlign, showingHybrid, distanceUnitText);
        if (vi.area != undefined) {
            var rotation = drawSettings.rotation != undefined ? drawSettings.rotation : map.GetRotationRad();
            var textDisplaceDistance = 18 * res;
            var displacedTextMid = tf.units.DisplaceMapCoords(vi.midCoords, vi.uprightTextDirection + rotation, textDisplaceDistance);
            var displacedTextMidPx = map.ActualMapToPixelCoords(displacedTextMid);
            var xPxT2 = displacedTextMidPx[0];
            var yPxT2 = displacedTextMidPx[1];
            showAreaText(showSettingsUse, ctx, vi.area, xPxT2, yPxT2, pvi.textDirectionWithRotation, "center", showingHybrid, distanceUnitText);
        }
    }
    return lastTicIndexInt - firstTicIndexInt + 1;
};
/*
vertexInfos, showArea, distances3Units, *extent, *rotation, *useUSScale, *resolution, *showIntermediateLenghts, *showingHybrid, *colorTic, *colorSeg, *textStyle, *distanceFunction, *clipFunction
*/
tf.js.DrawMeasuredVertices = function (drawSettings) {
    var distances, vertexExtent;
    var nTicsDrawn = 0, nTics = 0;
    var totalDistance = 0, area = 0;
    var vertexInfos = drawSettings.vertexInfos;
    if (tf.js.GetIsNonEmptyArray(vertexInfos)) {
        var nPoints = vertexInfos.length;
        if (nPoints >= 2) {
            var map = drawSettings.map;
            var extent = drawSettings.extent != undefined ? drawSettings.extent : map.GetVisibleExtent();
            var rotation = drawSettings.rotation != undefined ? drawSettings.rotation : map.GetRotationRad();
            var showArea = !!drawSettings.showArea;
            if (nPoints == 2) { nPoints = 1; showArea = false } else { if (!showArea) { --nPoints; } }
            var isUSScale = drawSettings.useUSScale != undefined ? !!drawSettings.useUSScale : map.GetIsUSScaleUnits();
            var res = drawSettings.resolution != undefined ? drawSettings.resolution : map.GetResolution();
            var distanceFunctionUse = tf.js.GetFunctionOrNull(drawSettings.distanceFunction) ? drawSettings.distanceFunction : tf.units.GetHaversineDistance;
            var clipFunctionUse = tf.js.GetFunctionOrNull(drawSettings.clipFunction) ? drawSettings.clipFunction : tf.js.ClipLineSegment;
            totalDistance = vertexInfos[nPoints - 1].totalDistance + vertexInfos[nPoints - 1].distanceToNext;
            distances = tf.js.CalcDisplayDistances(totalDistance, isUSScale, res, drawSettings.distances3Units);
            var pvis = [];
            for (var i = 0; i < nPoints; ++i) {
                var vi = vertexInfos[i], pvi = tf.js.CalcClippedVertexInfo(map, vi, nPoints, extent, rotation, distanceFunctionUse, clipFunctionUse);
                if (vi.area != undefined) { area = vi.area; }
                vertexExtent = tf.js.UpdateMapExtent(vertexExtent, vi.coords);
                vertexExtent = tf.js.UpdateMapExtent(vertexExtent, vi.nextCoords);
                if (pvi != undefined) { pvis.push(pvi); }
            }
            var npvis = pvis.length;
            if (npvis > 0) {
                var pixelRatio = tf.browser.GetDevicePixelRatio();
                var showingHybrid = drawSettings.showingHybrid != undefined ? drawSettings.showingHybrid : map.GetMapType() != tf.consts.typeNameMap;
                var colorTic = drawSettings.colorTic != undefined ? drawSettings.colorTic : (showingHybrid ? tf.consts.measureColorTicDefaultHybrid : tf.consts.measureColorTicDefaultMap);
                var showIntermediateLenghts = drawSettings.showIntermediateLenghts != undefined ? !!drawSettings.showIntermediateLenghts : true;
                var ctx = drawSettings.ctx;
                nTics = distances.nTics;
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.lineCap = "round";
                ctx.lineJoin = "round";
                ctx.setLineDash([]);
                if (!drawSettings.skipEdges) {
                    var segWidth = drawSettings.lineWidth != undefined ? drawSettings.lineWidth : 1;
                    var colorSeg = drawSettings.colorSeg != undefined ? drawSettings.colorSeg : (showingHybrid ? tf.consts.measureColorTicDefaultMap : tf.consts.measureColorTicDefaultHybrid);
                    for (var i = 0; i < npvis; ++i) {
                        var pvi = pvis[i];
                        ctx.beginPath();
                        ctx.strokeStyle = colorSeg;
                        ctx.lineWidth = segWidth * pixelRatio;
                        ctx.moveTo(pvi.coordsClipPx[0] * pixelRatio, pvi.coordsClipPx[1] * pixelRatio);
                        ctx.lineTo(pvi.nextCoordsClipPx[0] * pixelRatio, pvi.nextCoordsClipPx[1] * pixelRatio);
                        ctx.closePath(); ctx.fill(); ctx.stroke();
                    }
                }
                if (!drawSettings.skipMeasures) {
                    var drawVertexSettings = {
                        map: map,
                        ctx: ctx,
                        skipScaleText: drawSettings.skipScaleText,
                        skipTics: drawSettings.skipTics,
                        distances: distances,
                        rotation: rotation,
                        showIntermediateLenghts: showIntermediateLenghts,
                        colorTic: colorTic,
                        resolution: res,
                        showingHybrid: showingHybrid,
                        textStyle: drawSettings.textStyle,
                        largerFontSize: drawSettings.largerFontSize
                    };
                    for (var i = 0; i < npvis; ++i) { drawVertexSettings.pvi = pvis[i]; nTicsDrawn += tf.js.DrawMeasuredVertex(drawVertexSettings); }
                }
                ctx.restore();
            }
        }
    }
    return { nTicsDrawn: nTicsDrawn, nTics: nTics, distances: distances, vertexExtent: vertexExtent, totalDistance: totalDistance, area: area };
};
/*
tf.js.GetTextHeight = function (font) {
    var result = {};
    var text = document.createElement('span');
    var block = document.createElement('div');
    var div = document.createElement('div');
    var body = document.body;
    text.innerHTML = "Hg";
    text.style.fontFamily = font;
    block.style.display = "inline-block";
    block.style.width = "1px";
    block.style.height = "0px";
    div.appendChild(text, block);
    body.appendChild(div);
    try {
        block.style.verticalAlign = "baseline";
        result.ascent = block.offsetTop - text.offsetTop;
        block.style.verticalAlign = "bottom";
        result.height = block.offsetTop - text.offsetTop;
        result.descent = result.height - result.ascent;
    } finally { body.removeChild(div); }
    return result;
};
*/

// SOURCE FILE: domui.js
/**
 * Settings used in the creation of [Insertable]{@link tf.dom.Insertable} instances
 * @public
 * @typedef {object} tf.types.InsertableSettings
 * @property {object} domObj - a mandatory property
 * @property {HTMLElementLike} domElement - a mandatory property
*/
/**
 * @public
 * @class
 * @summary Insertable is a base class for other API classes whose instances can be inserted into the HTML Document Object Model.
 * @param {tf.types.InsertableSettings} settings - creation settings
 */
tf.dom.Insertable = function (settings) {
    var theThis, domObj, domElement;
    /**
     * @public
     * @function
     * @summary - Retrieves the {@link object} associated with this Insertable instance
     * @returns {object} - | {@link object} the element
    */
    this.GetDomObj = function () { return domObj; }
    /**
     * @public
     * @function
     * @summary - Retrieves the {@link HTMLElementLike} associated with this Insertable instance
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the element
    */
    this.GetHTMLElement = function () { return domElement; }
    /**
     * @public
     * @function
     * @summary - Retrieves the {@link HTMLElement} parent node of the {@link HTMLElementLike} instance associated with this Insertable instance
     * @returns {HTMLElement} - | {@link HTMLElement} the parent node object
    */
    this.GetParentNode = function () { return !!domElement ? domElement.parentNode : null; }
    this.RemoveFromParent = function () {
        var parent = theThis.GetParentNode();
        if (!!parent) {
            parent.removeChild(theThis.GetHTMLElement());
        }
    }
    this.GetHasParent = function () { return !!theThis.GetParentNode(); }
    /**
     * @public
     * @function
     * @summary - Adds this Insertable instance to the given {@link HTMLElementLike} instance
     * @param {HTMLElementLike} elem - the given instance
     * @returns {void} - | {@link void} no return value
    */
    this.AppendTo = function (elem) { if (!!domElement) { tf.dom.AppendTo(theThis, elem); } }
    function initialize() {
        if (!!(domObj = tf.js.GetIsValidObject(settings.domObj) ? settings.domObj : null)) {
            if (!(domElement = tf.dom.GetHTMLElementFrom(settings.domElement))) {
                domObj = null;
                tf.GetDebug().LogIfTest("Insertable: failed to get HTML element");
            }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Settings used in the creation of [Element]{@link tf.dom.Element} instances
 * @public
 * @typedef {object} tf.types.ElementSettings
 * @property {object} domObj - a mandatory property
 * @property {HTMLElementLike} domElement - a mandatory property
 * @property {string} id - optional id. If defined, sets the HTML <b>id</b> property, defaults to {@link void}
 * @property {tf.types.CSSStyleName} cssClass - optional css class. If defined, sets the HTML <b>class</b> property, defaults to {@link void}
 * @property {string} tooltip - optional tooltip string. If defined, sets the HTML <b>title</b> property, defaults to {@link void}
 * @property {string} value - optional value string. If defined, sets the HTML <b>value</b> property, defaults to {@link void}
 * @property {boolean} addTextContentAsSpan - If <b>true</b> this instance creates HTML spans when adding text content, if <b>false</b> text content is used as an HTML id. Defaults to <b>true</b>
 * @property {tf.types.CSSStyleName} spanCSSClass - optional css class used when adding HTML spans to this instance, defaults to {@link void}
*/
/**
 * @public
 * @class
 * @summary Element is an [Insertable]{@link tf.dom.Insertable} used as base class for other API classes whose instances are directly 
 * related with standard elements in the HTML Document Object Model, such as <b>'div'</b>.
 * @param {tf.types.ElementSettings} settings - creation settings
 * @extends {tf.dom.Insertable}
 */
tf.dom.Element = function (settings) {
    var theThis, domObj, domElement, spanCSSClass, addTextContentAsSpan, onClick, onClickCB, onHover, onHoverCB;
    /**
     * @public
     * @function
     * @summary - Call this function before disposing of this Element instance to perform clean-up
     * @param {string} newValue - the value
     * @returns {void} - | {@link void} no return value
    */
    this.OnDelete = function () { return onDelete(); }
    /**
     * @public
     * @function
     * @summary - Sets this instance's HTML <b>value</b> property
     * @param {string} newValue - the value
     * @returns {void} - | {@link void} no return value
    */
    this.SetValue = function (newValue) { if (!!domElement) { domElement.value = tf.js.GetNonEmptyString(newValue, ''); } }
    /**
     * @public
     * @function
     * @summary - Retrieves this instance's HTML <b>value</b> property
     * @returns {string} - | {@link string} the value
    */
    this.GetValue = function () { return !!domElement ? domElement.value.trim() : ''; }
    /**
     * @public
     * @function
     * @summary - Sets a [Click Listener]{@link tf.events.DOMClickListener} for this Element instance
     * @param {tf.types.MultiDOMEventListenerCallBack} callBack - to receive event notifications
     * @param {object} optionalScope - optional scope used with <b>callBack</b>
     * @param {object} callBackSettings - application defined properties, to be passed to <b>callBack</b> during notifications
     * @returns {void} - | {@link void} no return value
    */
    this.SetOnClick = function (callBack, optionalScope, callBackSettings) { return setOnClick(callBack, optionalScope, callBackSettings); }
    this.SetOnHover = function (callBack, optionalScope, callBackSettings) { return setOnHover(callBack, optionalScope, callBackSettings); }
    /**
     * @public
     * @function
     * @summary - Removes any content that was previously added to this Element instance
     * @returns {void} - | {@link void} no return value
    */
    this.ClearContent = function () { tf.dom.RemoveAllChildren(theThis); domElement.innerHTML = ''; }
    /**
     * @public
     * @function
     * @summary - Replaces any content that was previously added to this Element instance with the given new contents
     * @param {...HTMLElementLike} newContents - zero or more comma separated contents to added
     * @returns {void} - | {@link void} no return value
    */
    this.ReplaceContent = function () { theThis.ClearContent(); theThis.AddContent.apply(theThis, arguments); }
    /**
     * @public
     * @function
     * @summary - Adds the given new content to contents that were previously added to this Element instance
     * @param {...HTMLElementLike} newContents - zero or more comma separated contents to added
     * @returns {void} - | {@link void} no return value
    */
    this.AddContent = function () {
        for (var i in arguments) {
            var elem = arguments[i];
            if (!!elem) {
                if (tf.js.GetIsString(elem)) {
                    if (addTextContentAsSpan) {
                        var htmlSpanDiv = (new tf.dom.Span({ cssClass: spanCSSClass })).GetHTMLElement();
    
                        htmlSpanDiv.innerHTML = elem;
                        domElement.appendChild(htmlSpanDiv);
                    }
                    else { domElement.appendChild(document.createTextNode(elem)); }
                }
                else if (tf.js.GetFunctionOrNull(elem.AppendTo)) { elem.AppendTo(theThis); }
                else if (elem = tf.dom.GetHTMLElementFrom(elem)) { domElement.appendChild(elem); }
            }
        }
    }
    /**
     * @public
     * @function
     * @summary - Removes the the given existing content from this container
     * @param {HTMLElementLike} existingContent - the content  to remove
     * @returns {void} - | {@link void} no return value
    */
    this.RemoveContent = function (existingContent) {
        if (!!(existingContent = tf.dom.GetHTMLElementFrom(existingContent))) {
            if (existingContent.parentNode == domElement) { domElement.removeChild(existingContent); }
        }
    }
    /**
     * @public
     * @function
     * @summary - Inserts the the given new content as the new first child of this container
     * @param {HTMLElementLike} newContent - the content  to insert
     * @returns {void} - | {@link void} no return value
    */
    this.InsertHead = function (newContent) {
        if (!!(newContent = tf.dom.GetHTMLElementFrom(newContent))) {
            //if (newContent.parentNode == domElement) { theThis.RemoveContent(newContent); }
            if (domElement.childNodes.length == 0) { return theThis.AddContent(newContent); }
            else { return theThis.InsertContentBefore(newContent, domElement.firstElementChild); }
        }
    }
    /**
     * @public
     * @function
     * @summary - Inserts the the given new content before an existing content
     * @param {HTMLElementLike} newContent - the content  to insert
     * @param {HTMLElementLike} existingContent - the existing content, before which <b>newContent</b> will be inserted
     * @returns {void} - | {@link void} no return value
    */
    this.InsertContentBefore = function (newContent, existingContent) {
        if (!!(newContent = tf.dom.GetHTMLElementFrom(newContent)) && !!(existingContent = tf.dom.GetHTMLElementFrom(existingContent))) {
            if (existingContent.parentNode == domElement) { domElement.insertBefore(newContent, existingContent); }
        }
    }
    /**
     * @public
     * @function
     * @summary - Inserts the the given new content after an existing content
     * @param {HTMLElementLike} newContent - the content  to insert
     * @param {HTMLElementLike} existingContent - the existing content, after which <b>newContent</b> will be inserted
     * @returns {void} - | {@link void} no return value
    */
    this.InsertContentAfter = function (newContent, existingContent) {
        if (!!(newContent = tf.dom.GetHTMLElementFrom(newContent)) && !!(existingContent = tf.dom.GetHTMLElementFrom(existingContent))) {
            if (existingContent.parentNode == domElement) { if (existingContent = existingContent.nextSibling) { theThis.InsertContentBefore(newContent, existingContent); } }
        }
    }
    /**
     * @public
     * @function
     * @summary - Vertically scrolls the contents of this Element instance to the top of the given existing content
     * @param {HTMLElementLike} existingContent - content belonging to this Element instance, to the top of which this Element's contents will be vertically scrolled
     * @returns {void} - | {@link void} no return value
    */
    this.ScrollContent = function (existingContent) {
        if (existingContent = tf.dom.GetHTMLElementFrom(existingContent) && existingContent.parentNode == domElement) {
            domElement.scrollTop = existingContent.offsetTop - domElement.offsetTop;
        }
    }
    function onDelete() {
        if (!!onClick) { onClick.OnDelete(); onClick = null; }
        if (!!onHover) { onHover.OnDelete(); onHover = null; }
    }
    function onClickCallBack(notification) { if (!!onClickCB) { onClickCB(notification); } }
    function onHoverCallBack(notification) { if (!!onHoverCB) { onHoverCB(notification); } }
    function setOnClick(callBack, optionalScope, callBackSettings) {
        if (onClick == undefined) {
            onClick = new tf.events.DOMClickListener({ domObj: domObj, target: domElement, callBack: onClickCallBack, optionalScope: optionalScope, callBackSettings: callBackSettings });
        }
        else { onClick.ChangeCallBackSettings(callBackSettings); }
        onClickCB = tf.js.GetFunctionOrNull(callBack);
    }
    function setOnHover(callBack, optionalScope, callBackSettings) {
        if (onHover == undefined) {
            onHover = new tf.events.DOMHoverListener({ domObj: domObj, target: domElement, callBack: onHoverCallBack, optionalScope: optionalScope, callBackSettings: callBackSettings });
        }
        else { onHover.ChangeCallBackSettings(callBackSettings); }
        onHoverCB = tf.js.GetFunctionOrNull(callBack);
    }
    function initialize() {
        addTextContentAsSpan = false;
        if (!!(domObj = tf.js.GetIsValidObject(settings.domObj) ? settings.domObj : null)) {
            if (!(domElement = tf.dom.GetHTMLElementFrom(settings.domElement))) {
                domObj = null;
            }
            else {
                !!settings.id && (domElement.id = settings.id);
                tf.js.GetIsNonEmptyString(settings.cssClass) && (domElement.className = settings.cssClass);
                tf.js.GetIsNonEmptyString(settings.tooltip) && (domElement.title = settings.tooltip);
                tf.js.GetIsNonEmptyString(settings.value) && (domElement.value = settings.value);
                spanCSSClass = tf.js.GetNonEmptyString(settings.spanCSSClass, null);
                addTextContentAsSpan = tf.js.GetBoolFromValue(settings.addTextContentAsSpan, true);
            }
        }
        tf.dom.Insertable.call(theThis, settings);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.dom.Element, tf.dom.Insertable);
/**
 * @public
 * @class
 * @summary Div is an [Element]{@link tf.dom.Element} implementing the standard <b>'div'</b> HTML element
 * @param {tf.types.ElementSettings} settings - creation settings, including an additional {@link boolean} property <b>initiallyVisible</b> that, if set to <b>false</b>, creates an invisible <b>div</b> (display='none')
 * @extends {tf.dom.Element}
 */
tf.dom.Div = function (settings) {
    var theThis;
    /**
     * @public
     * @function
     * @summary - Retrieves the <b>div</b> {@link HTMLElement} associated with this instance
     * @returns {HTMLElement} - | {@link HTMLElement} the element
    */
    this.GetDiv = function () { return GetHTMLElement(); }
    function initialize() {
        var domElement = document.createElement('div');
        settings = tf.js.GetValidObjectFrom(settings);
        var cssClass = tf.js.GetIsNonEmptyString(settings.cssClass) ? settings.cssClass : tf.GetStyles().paddedBlockDivStyle;
        if (tf.js.GetIsFalseNotUndefined(settings.initiallyVisible)) { domElement.style.display = 'none'; }
        tf.dom.Element.call(theThis, { id: settings.id, domObj: theThis, domElement: domElement, cssClass: cssClass, tooltip: settings.tooltip });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.dom.Div, tf.dom.Element);
tf.dom.Button = function (settings) {
    var theThis, onHoverCB, hoverListener;
    this.GetButton = function () { return GetHTMLElement(); }
    this.OnDelete = function () {
        if (!!hoverListener) { hoverListener.OnDelete(); hoverListener = undefined; }
    }
    function notifyCB(theCB, notification) { if (!!theCB) { theCB({ sender: theThis, notification: notification }); } }
    function onHoverButton(notification) { notifyCB(onHoverCB, notification); }
    function initialize() {
        var domElement = document.createElement('button');
        settings = tf.js.GetValidObjectFrom(settings);
        var cssClass = tf.js.GetIsNonEmptyString(settings.cssClass) ? settings.cssClass : tf.GetStyles().unPaddedBlockDivStyle;
        if (tf.js.GetIsFalseNotUndefined(settings.initiallyVisible)) { domElement.style.display = 'none'; }
        tf.dom.Element.call(theThis, { id: settings.id, domObj: theThis, domElement: domElement, cssClass: cssClass, tooltip: settings.tooltip });
        theThis.SetOnClick(settings.onClick, settings.optionalScope, settings.onClickSettings);
        theThis.SetOnHover(settings.onHover, settings.optionalScope, settings.onHoverSettings);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.dom.Div, tf.dom.Element);
/**
 * @public
 * @class
 * @summary Text Input is an [Element]{@link tf.dom.Element} implementing the standard <b>'input'</b> HTML element of type <b>'text'</b>. 
 * Use this instance's inherited functions [SetValue]{@link tf.dom.Element#SetValue} and [GetValue]{@link tf.dom.Element#GetValue} to set/get the associated input text {@link string}
 * @param {tf.types.ElementSettings} settings - creation settings
 * @extends {tf.dom.Element}
 */
tf.dom.TextInput = function (settings) {
    var theThis = null;
    /**
     * @public
     * @function
     * @summary - Retrieves the <b>text input</b> {@link HTMLElement} associated with this instance
     * @returns {HTMLElement} - | {@link HTMLElement} the element
    */
    this.GetInput = function () { return GetHTMLElement(); }
    function initialize() {
        var domElement = document.createElement('input');
        settings = tf.js.GetValidObjectFrom(settings);
        var labelStr = tf.js.GetNonEmptyString(settings.label, "");
        var toolTipStr = tf.js.GetNonEmptyString(settings.tooltip, labelStr);
        var valueStr = tf.js.GetNonEmptyString(settings.value, "");
        var cssClass = tf.js.GetIsNonEmptyString(settings.cssClass) ? settings.cssClass : tf.GetStyles().inputTextClass;
        domElement.type = "text";
        domElement.placeholder = labelStr;
        tf.dom.Element.call(theThis, { id: settings.id, domObj: theThis, domElement: domElement, cssClass: cssClass, tooltip: toolTipStr, value: valueStr });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.dom.TextInput, tf.dom.Element);
/**
 * @public
 * @class
 * @summary Link is an [Element]{@link tf.dom.Element} implementing the standard <b>'a'</b> (hyperlink) HTML element
 * @param {tf.types.ElementSettings} settings - creation settings, including two additional {@link string} properties <b>href</b> and <b>target</b> used to create the hyperlink
 * @extends {tf.dom.Element}
 */
tf.dom.Link = function (settings) {
    var theThis, onClick, href, target;
    /**
     * @public
     * @function
     * @summary - Retrieves the <b>a</b> {@link HTMLElement} associated with this instance
     * @returns {HTMLElement} - | {@link HTMLElement} the element
    */
    this.GetLink = function () { return GetHTMLElement(); }
    function onClickLink() { window.open(href, target); }
    function initialize() {
        var domElement = document.createElement('a');
        settings = tf.js.GetValidObjectFrom(settings);
        href = domElement.href = settings.href;
        target = domElement.target = settings.target;
        tf.dom.Element.call(theThis, { id: settings.id, domObj: theThis, domElement: domElement, addTextContentAsSpan: false, tooltip: settings.tooltip, cssClass: settings.cssClass });
        if (tf.js.GetIsNonEmptyString(settings.label)) { theThis.AddContent(settings.label) }
        onClick = new tf.events.DOMClickListener({ target: domElement, callBack: onClickLink, optionalScope: theThis, callBackSettings: undefined });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.dom.Link, tf.dom.Element);
/**
 * @public
 * @class
 * @summary Span is an [Element]{@link tf.dom.Element} implementing the standard <b>'span'</b> HTML element
 * @param {tf.types.ElementSettings} settings - creation settings
 * @extends {tf.dom.Element}
 */
tf.dom.Span = function (settings) {
    var theThis;
    /**
     * @public
     * @function
     * @summary - Retrieves the <b>span</b> {@link HTMLElement} associated with this instance
     * @returns {HTMLElement} - | {@link HTMLElement} the element
    */
    this.GetSpan = function () { return GetHTMLElement(); }
    function initialize() {
        var domElement = document.createElement('span');
        settings = tf.js.GetValidObjectFrom(settings);
        var cssClass = tf.js.GetIsNonEmptyString(settings.cssClass) ? settings.cssClass : tf.GetStyles().spanClass;
        var spanClass = tf.js.GetIsNonEmptyString(settings.spanCSSClass) ? settings.spanCSSClass : tf.GetStyles().spanClass;
        tf.dom.Element.call(theThis, { id: settings.id, domObj: theThis, domElement: domElement, addTextContentAsSpan: true, spanCSSClass: spanClass, cssClass: cssClass });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.dom.Span, tf.dom.Element);
/**
 * @public
 * @class
 * @summary Link is an [Element]{@link tf.dom.Element} implementing the standard <b>'a'</b> (hyperlink) HTML element
 * @param {tf.types.ElementSettings} settings - creation settings, including an additional {@link string} property <b>src</b> used to create the <b>img</b>, and
 * an optional callback {@function} property <b>onLoad</b> that, when specified, is called when the image is loaded and is passed this instance as a parameter
 * @extends {tf.dom.Element}
 */
tf.dom.Img = function (settings) {
    var theThis, imgSrcUse, onLoadCallBack, isLoaded, isValid;
    this.GetSettings = function () { return settings; }
    /**
     * @public
     * @function
     * @summary - Determines if the {@link HTMLElement} associated with this instance is valid
     * @returns {boolean} - | {@link boolean} <b>true</b> if the image is valid, </b>false</b> otherwise, e.g. if the image failed to load from the given source
    */
    this.GetIsValid = function () { return isValid; }
    /**
     * @public
     * @function
     * @summary - Retrieves the <b>img</b> {@link HTMLElement} associated with this instance
     * @returns {HTMLElement} - | {@link HTMLElement} the element
    */
    this.GetImg = function () { return theThis.GetHTMLElement(); }
    /**
     * @public
     * @function
     * @summary - Checks if the image is loaded
     * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
    */
    this.GetIsLoaded = function () { return isLoaded; }
    /**
     * @public
     * @function
     * @summary - Retrieves the <b>src</b> {@link string} associated with this instance
     * @returns {string} - | {@link string} the src string
    */
    this.GetSrc = function () { return imgSrcUse; }
    /**
     * @public
     * @function
     * @summary - Retrieves the dimensions of the image associated with this instance
     * @returns dimensions - | array with width and height
    */
    this.GetDimensions = function () {
        var elem = theThis.GetHTMLElement();
        return !!elem ? [elem.width, elem.height] : [0, 0];
    }
    function privateLoadCallBack() {
        var elem = theThis.GetHTMLElement();
        elem.onload = elem.onabort = elem.onerror = undefined;
        isLoaded = true;
        if (!!onLoadCallBack) {
            var olcb = onLoadCallBack;
            onLoadCallBack = undefined;
            olcb(theThis);
        }
    }
    function privateLoadFailure() { isValid = false; privateLoadCallBack(); }
    function initialize() {
        var domElement = document.createElement('img');
        settings = tf.js.GetValidObjectFrom(settings);
        isLoaded = false;
        isValid = true;
        onLoadCallBack = tf.js.GetFunctionOrNull(settings.onLoad);
        domElement.onload = privateLoadCallBack;
        domElement.onabort = privateLoadFailure;
        domElement.onerror = privateLoadFailure;
        if (!!settings.crossOrigin) { domElement.crossOrigin = 'anonymous'; }
        if (imgSrcUse = tf.js.GetNonEmptyString(settings.src)) { domElement.src = imgSrcUse; }
        tf.dom.Element.call(theThis, { id: settings.id, domObj: theThis, domElement: domElement, cssClass: settings.cssClass, tooltip: settings.tooltip });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.dom.Img, tf.dom.Element);
/**
 * Settings used in the creation of [Imgs Pre Loader]{@link tf.dom.ImgsPreLoader} instances
 * @public
 * @typedef {object} tf.types.ImgsPreLoaderSettings
 * @property {enumerable<string>} imgSrcs - an enumerable containing the <b>src</b> properties of the images to preload
 * @property {function} onAllLoaded - an optional callback {@link function} that, when specified, is called when all images have been preloaded and is passed this instance as a parameter
*/
/**
 * @public
 * @class
 * @summary Imgs Pre Loader instances are created to pre-load one or more instances of [Img]{@link tf.dom.Img}
 * @param {tf.types.ImgsPreLoaderSettings} settings - creation settings
 */
tf.dom.ImgsPreLoader = function (settings) {
    var theThis, nLoading, nLoaded, isLoadComplete, onAllLoadedCallBack, imgs;
    /**
     * @public
     * @function
     * @summary - Checks if all images have been loaded
     * @returns {boolean} - | {@link boolean} <b>true</b> if all images have been loaded, <b>false</b> otherwise
    */
    this.GetIsLoadComplete = function () { return isLoadComplete; }
    /**
     * @public
     * @function
     * @summary - returns an enumerable of the preloaded images
     * @returns {enumerable<tf.dom.Img>} - | {@link enumerable}<{@link tf.dom.Img}> the preloaded images
    */
    this.GetImgs = function () { return imgs; }
    function notifyAllLoaded() { onAllLoadedCallBack(theThis); }
    function checkIfAllLoaded() {
        if (nLoading !== undefined) {
            if (nLoaded == nLoading) { isLoadComplete = true; if (!!onAllLoadedCallBack) { setTimeout(notifyAllLoaded, 10); } }
        }
    }
    function onImageLoaded(theImage, theIndex) { imgs[theIndex] = theImage; ++nLoaded; checkIfAllLoaded(); }
    function createImg(thisImgSrc, thisIndex) {
        new tf.dom.Img({ src: thisImgSrc, cssClass: settings.cssClassStr, onLoad: function (theImage) { return onImageLoaded(theImage, thisIndex) } });
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        nLoaded = 0;
        isLoadComplete = false;
        imgs = [];
        onAllLoadedCallBack = tf.js.GetFunctionOrNull(settings.onAllLoaded);
        var imgSrcs = settings.imgSrcs;
        if (tf.js.GetIsValidObject(imgSrcs)) {
            var nLoadingTemp = 0;
            for (var i in imgSrcs) { if (!!tf.js.GetNonEmptyString(imgSrcs[i])) { ++nLoadingTemp; } }
            var nLoadingIndex = 0;
            for (var i in imgSrcs) { var imgSrc = tf.js.GetNonEmptyString(imgSrcs[i]); if (!!imgSrc) { createImg(imgSrc, nLoadingIndex++); } }
            nLoading = nLoadingTemp;
            checkIfAllLoaded();
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * CSS Style specification of a [Text Button]{@link tf.ui.TextBtn} instance. May be set to a [CSS Style Name]{@link tf.types.CSSStyleName} created
 * with the function [CreateTextDivBtnClasses]{@link tf.styles.Styles#CreateTextDivBtnClasses}, or to a {@link boolean} value, in which case
 * a <b>true</b> value selects the API's default <b>light</b> style settings, otherwise the default <b>dark</b> style settings are used
 * @public
 * @typedef {boolean|tf.types.CSSStyleName} tf.types.TextBtnStyle
 */
/**
 * An object used in the creation of [Text Button]{@link tf.ui.TextBtn} instances
 * @public
 * @typedef {object} tf.types.TextBtnSettings
 * @property {tf.types.TextBtnStyle} style - the given style
 * @property {string} label - the given text
 * @property {HTMLElementSizeOrPxNumber} dim - the button's height dimension
 * @property {tf.types.MultiDOMEventListenerCallBack} onClick - sets a [Click Listener]{@link tf.events.DOMClickListener} for the button
 * @property {string} tooltip - tool tip text
 */
/**
 * @public
 * @class
 * @summary - Text Button is an [Insertable]{@link tf.dom.Insertable} containing text and implementing a user interface button
 * @param {tf.types.TextBtnSettings} settings - creation settings
 * @extends {tf.dom.Insertable}
*/
tf.ui.TextBtn = function (settings) {
    var theThis, defaultDim, styles, lightClass, darkClass, heightDeltaPx, div, style, dim, onCallBack;
    this.SetOnClick = function (callBack) { return setCallBack(callBack); }
    /**
     * @public
     * @function
     * @summary - Retrieves this instance's style
     * @returns {tf.types.TextBtnStyle} - | {@link tf.types.TextBtnStyle} the style
    */
    this.GetStyle = function () { return style }
    /**
     * @public
     * @function
     * @summary - Sets this instance's style to the given style
     * @param {tf.types.TextBtnStyle} style - the given style
     * @returns {void} - | {@link void} no return value
    */
    this.SetStyle = function (style) { return setStyle(style); }
    /**
     * @public
     * @function
     * @summary - Sets the text of this Text Button instance to the given text
     * @param {string} text - the given text
     * @returns {void} - | {@link void} no return value
    */
    this.SetText = function (text) { return setText(text); }
    this.GetText = function () { return div.textContent; }
    /**
     * @public
     * @function
     * @summary - Changes the tooltip text of this Text Button instance to the given text
     * @param {string} tooltip - the given text
     * @returns {void} - | {@link void} no return value
    */
    this.ChangeToolTip = function (tooltip) { return changeToolTip(tooltip); }
    function setText(textContentStr) { div.textContent = tf.js.GetNonEmptyString(textContentStr, ''); }
    function changeToolTip(toolTipStr) {
        if (tf.js.GetIsNonEmptyString(toolTipStr)) { div.title = toolTipStr; }
        else { if (div.title !== undefined) { delete div.title; } }
    }
    function setStyle(styleSet) {
        if (tf.js.GetIsNonEmptyString(styleSet)) {
            style = div.className = styleSet;
        }
        else if ((styleSet = !!styleSet) != style) {
            style = styleSet; div.className = style ? lightClass : darkClass;
        }
    }
    function setHeight(dimSet) {
        dim = tf.js.GetDimFromStrOrPxNumber(dimSet, defaultDim);
        //div.style.height = "calc(" + dim + " - " + heightDeltaPx + ")";
        div.style.fontSize = "calc(" + dim + " - " + heightDeltaPx + ")";
        //div.style.fontSize = dim;//"calc(" + dim + " - " + heightDeltaPx + " - 2px)";
        //height = !newHeight ? defaultHeight : newHeight;
        //div.style.height = (height - heightDelta + 2) + "px";
        //div.style.fontSize = (height - heightDelta - 2) + "px";
    }
    function setCallBack(onclickCallBack) {
        if (!!onCallBack) { onCallBack.OnDelete(); }
        if (tf.js.GetFunctionOrNull(onclickCallBack)) {
            onCallBack = new tf.events.DOMClickListener({ domObj: theThis, target: div, callBack: onclickCallBack, optionalScope: theThis, callBackSettings: undefined });
        }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        defaultDim = "1em";
        styles = tf.GetStyles();
        lightClass = styles.textDivBtnLightStyleClass;
        darkClass = styles.textDivBtnDarkStyleClass;
        heightDeltaPx = styles.GetSubStyles().textButtonHeightDelta + 'px';
        style = undefined;
        onCallBack = null;
        var divObj = new tf.dom.Div({ cssClass: styles.GetUnPaddedDivClassNames(false, false) });
        div = divObj.GetHTMLElement();
        setCallBack(settings.onClick);
        setText(settings.label);
        changeToolTip(settings.tooltip);
        setStyle(settings.style);
        setHeight(settings.dim);
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: div });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.ui.TextBtn, tf.dom.Insertable);
tf.js.ObjectCache = function (settings) {
    var theThis, objectsCache, nextIndexInCache;
    this.GetNext = function () {
        var nextObject, curLen = objectsCache.length;
        var createNewCB = !!tf.js.GetFunctionOrNull(settings.createNew) ? settings.createNew : createBlank;
        while (nextIndexInCache >= curLen) { objectsCache.push(createNewCB({ sender: theThis })); ++curLen; }
        nextObject = objectsCache[nextIndexInCache++];
        return nextObject;
    }
    this.Reset = function () { nextIndexInCache = 0; }
    this.GetObjects = function () { return objectsCache; }
    this.GetActiveCount = function () { return nextIndexInCache; }
    this.GetTotalCount = function () { return objectsCache.length; }
    this.OnDelete = function () { return onDelete(); }
    function createBlank() { return {}; }
    function onDelete() {
        var onDeleteCB = tf.js.GetFunctionOrNull(settings.onDelete);
        if (!!onDeleteCB) {
            var curLen = buttonsCache.length;
            for (var i = 0; i < curLen; ++i) { onDeleteCB({ sender: theThis, obj: objectsCache[i] }); }
        }
        initialize();
    }
    function initialize() {
        objectsCache = [];
        theThis.Reset();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.ui.TextButtonCache = function (settings) {
    var theThis, buttonsCache, nextIndexInCache, buttonDim, buttonStyle;
    this.GetNextButton = function () { return getNextButton(); }
    this.Reset = function () { return reset(); }
    this.GetButtons = function () { return buttonsCache; }
    this.GetActiveCount = function () { return nextIndexInCache; }
    this.GetTotalCount = function () { return buttonsCache.length; }
    this.OnDelete = function () { return onDelete(); }
    function onDelete() {
        var curLen = buttonsCache.length;
        for (var i = 0; i < curLen; ++i) { buttonsCache[i].OnDelete(); }
        buttonsCache = [];
        nextIndexInCache = 0;
    }
    function getNextButton() {
        var nextButton, curLen = buttonsCache.length;
        while (nextIndexInCache >= curLen) {
            buttonsCache.push(new tf.ui.TextBtn({ style: buttonStyle, label: '', dim: buttonDim, tooltip: '', onClick: undefined }));
            ++curLen;
        }
        nextButton = buttonsCache[nextIndexInCache++];
        return nextButton;
    }
    function reset() { nextIndexInCache = 0; }
    function initialize() {
        buttonDim = settings.buttonDim != undefined ? settings.buttonDim : "1rem";
        buttonStyle = settings.buttonStyle != undefined ? settings.buttonStyle : true;
        buttonsCache = [];
        reset();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.ui.LiveStreamPlayer = function (settings) {
    var theThis, isPlaying, jw_width, jw_height, container, playerContainer, divPlayer, divContainerStyle;
    var liveFeedContainerDivID = "liveFeedPlayerContainer", liveFeedPlayerDivID = "liveFeedPlayer";
    this.PlayStream = function (streamURL) { return playStream(streamURL); }
    this.PlayVideo = function (videoURL) { return playVideo(videoURL); }
    this.OnDelete = function () { stopPlay(); container.removeChild(playerContainer.GetHTMLElement()); }
    this.StopPlay = function () { return stopPlay(); }
    this.GetIsPlaying = function () { return isPlaying; }
    function playVideo(videoURL) {
        divContainerStyle.display = 'block';
        try {
            jwplayer(liveFeedPlayerDivID).setup({
                height: jw_height, width: jw_width, stretching: 'exactfit', file: videoURL
            });
            jwplayer(liveFeedPlayerDivID).play();
            isPlaying = true;
        }
        catch(e) {
            isPlaying = false;
        }
    }
    function playStream(streamURL) {
        divContainerStyle.display = 'block';
        try {
            jwplayer(liveFeedPlayerDivID).setup({
                height: jw_height, width: jw_width, stretching: 'exactfit', sources: [{ file: streamURL }], rtmp: { bufferlength: 3 }
            });
            jwplayer(liveFeedPlayerDivID).onMeta(function (event) { });
            jwplayer(liveFeedPlayerDivID).play();
            isPlaying = true;
        }
        catch (e) {
            isPlaying = false;
        }
    }
    function stopPlay() {
        if (isPlaying) {
            jwplayer(liveFeedPlayerDivID).stop();
            divContainerStyle.display = 'none';
            isPlaying = false;
        }
    }
    function createPlayerPopup() {
        if (!playerContainer) {
            /*var style = {
                position: "absolute", display: "none", backgroundColor: "#fff", width: jw_width + "px", height: jw_height + "px",
                right: "24em", bottom: "10em", margin: "0px", padding: "0px", border: "0px", zIndex: "2000"
            };*/
            var style = {
                position: "relative", display: "block", backgroundColor: "#fff", width: jw_width + "px", height: jw_height + "px",
                left: "0", top: "0", margin: "0px", padding: "0px", border: "0px", zIndex: "2000"
            };
            playerContainer = new tf.dom.Div({ id: liveFeedContainerDivID });
            divPlayer = new tf.dom.Div({ id: liveFeedPlayerDivID });
            divContainerStyle = playerContainer.GetHTMLElement().style;
            tf.GetStyles().ApplyStyleProperties(playerContainer, style);
            divPlayer.AppendTo(playerContainer);
            playerContainer.AppendTo(container);
        }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (!(container = tf.dom.GetHTMLElementFrom(settings.container))) { container = document.body; }
        liveFeedContainerDivID = tf.dom.CreateDomElementID("tf-live-player");
        liveFeedPlayerDivID = tf.dom.CreateDomElementID("tf-live-player");
        jw_width = settings.width !== undefined ? settings.width : 320;
        jw_height = settings.height !== undefined ? settings.height : 240;
        createPlayerPopup();
        isPlaying = false;
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.ui.ConfirmMsg = function (settings) {
    var theThis, container, styles, className, style, msgClassName, buttonsDivClassName, timeout, topDiv, topDivE, isShowing, closeTM;
    var msgDiv, msgDivE, thenCB;
    var yesLabel, noLabel, yesTooltip, noTooltip, yesButtonClasses, noButtonClasses;
    this.ConfirmMsg = function (then, text, overrideTimeout) { return confirmMsg(then, text, overrideTimeout); }
    function getTimeout(overrideTimeout) { var tm = overrideTimeout != undefined ? overrideTimeout : timeout; return tm == undefined ? 0 : tm; }
    function clearToasterTimeout() { if (!!closeTM) { clearTimeout(closeTM); closeTM = undefined; } }
    function doShow(showBool) { styles.ChangeOpacityVisibilityClass(topDiv, isShowing = !!showBool); }
    function closeToast(confirmed) {
        clearToasterTimeout(); if (isShowing) { doShow(false); } msgDiv.ClearContent();
        thenCB({ sender: theThis, confirmed: confirmed });
    }
    function startToast(overrideTimeout) {
        var timeoutUse = getTimeout(overrideTimeout);
        clearToasterTimeout();
        doShow(true);
        if (timeoutUse > 0) { closeTM = setTimeout(function () { return closeToast(false); }, timeoutUse); }
    }
    function confirmMsg(then, text, overrideTimeout) {
        if (tf.js.GetFunctionOrNull(then) && tf.js.GetIsNonEmptyString(text)) {
            if (isShowing) { closeToast(false); }
            thenCB = then;
            msgDivE.innerHTML = text;
            startToast(overrideTimeout);
        }
    }
    function getOnConfirmCancel(confirmed) { return function (notification) { closeToast(confirmed); return false; } }
    function createToast() {
        topDiv = new tf.dom.Div({});
        topDivE = topDiv.GetHTMLElement();
        if (className != undefined) { topDivE.className = className; }
        if (style != undefined) { styles.ApplyStyleProperties(topDiv, style); }
        //topDivE.addEventListener('click', onClick);
        msgDiv = new tf.dom.Div({ cssClass: msgClassName });
        msgDivE = msgDiv.GetHTMLElement();
        var buttonsDiv = new tf.dom.Div({ cssClass: buttonsDivClassName });
        var buttonDim = "18px", textDim = buttonDim;
        var confirmButton = styles.AddButtonDivMargins(new tf.ui.TextBtn({
            dim: textDim, style: yesButtonClasses, label: yesLabel, tooltip: yesTooltip, onClick: getOnConfirmCancel(true)
        }));
        var cancelButton = styles.AddButtonDivMargins(new tf.ui.TextBtn({
            dim: textDim, style: noButtonClasses, label: noLabel, tooltip: noTooltip, onClick: getOnConfirmCancel(false)
        }));
        var textShadowBlack = { textShadow: "1px 1px 1px #000" };
        styles.ApplyStyleProperties(confirmButton, textShadowBlack);
        styles.ApplyStyleProperties(cancelButton, textShadowBlack);
        buttonsDiv.AddContent(confirmButton, cancelButton);
        topDiv.AddContent(msgDiv, buttonsDiv);
        container.appendChild(topDivE);
        styles.ChangeOpacityVisibilityClass(topDiv, false);
    }
    function initialize() {
        styles = tf.GetStyles();
        yesButtonClasses = styles.CreateTextDivBtnClasses("white", "green", "white", "darkgreen");
        noButtonClasses = styles.CreateTextDivBtnClasses("white", "red", "white", "darkred");
        container = tf.dom.GetHTMLElementFrom(settings.container);
        style = settings.style;
        className = settings.className;
        msgClassName = settings.msgClassName;
        buttonsDivClassName = settings.buttonsDivClassName;
        timeout = settings.timeout;
        yesLabel = tf.js.GetNonEmptyString(settings.yesLabel, "Yes");
        noLabel = tf.js.GetNonEmptyString(settings.noLabel, "No");
        yesTooltip = tf.js.GetNonEmptyString(settings.yesTooltip, "Confirm");
        noTooltip = tf.js.GetNonEmptyString(settings.noTooltip, "Cancel");
        createToast();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.ui.OneToast = function (settings) {
    var theThis, styles, container, isShowing, isDeleted, topDiv, topDivE, topDivES, onCloseCB, style, className, closeTM, addBefore, closeOnClick, closeOnClickUse, count;
    this.Toast = function (toastSettings) { return toast(toastSettings); }
    this.GetIsShowing = function () { return isShowing; }
    this.GetIsDeleted = function () { return isDeleted; }
    this.Close = function () { return closeToast(); }
    function clearToasterTimeout() { if (!!closeTM) { clearTimeout(closeTM); closeTM = undefined; } }
    function doShow(showBool, addBefore) {
        if (isShowing != (showBool = !!showBool)) {
            if (isShowing = showBool) {
                if (!!addBefore) { container.InsertHead(topDiv); }
                else { container.AddContent(topDiv); }
            }
            else {
                container.RemoveContent(topDiv);
                if (!!onCloseCB) { onCloseCB({ sender: theThis }) };
            }
        }
    }
    function closeToast() { clearToasterTimeout(); if (isShowing) { doShow(false); } topDiv.ClearContent(); }
    var toastCallBacks = function (theToast, id, getCount) {
        this.IsShowing = function () { return id == getCount() && theToast.GetIsShowing(); }
        this.Close = function () { if (id == getCount()) { theToast.Close(); } }
    };
    function startToast(toastSettings) {
        var timeoutUse = toastSettings.timeout != undefined ? toastSettings.timeout : 2000;
        var addBeforeUse = settings.addBefore != undefined ? !!settings.addBefore : addBefore;
        ++count;
        var tcb = new toastCallBacks(theThis, count, function () { return count; });
        clearToasterTimeout();
        closeOnClickUse = settings.closeOnClick != undefined ? !!settings.closeOnClick : closeOnClick;
        topDivE.className = tf.js.GetIsNonEmptyString(toastSettings.className) ? toastSettings.className : className;
        if (tf.js.GetIsValidObject(toastSettings.style)) { topDivE.style = ""; styles.Apply(topDiv, toastSettings.style); } doShow(true, addBeforeUse);
        if (timeoutUse > 0) { closeTM = setTimeout(closeToast, timeoutUse); }
        return tcb;
    }
    function toast(toastSettings) {
        var toastCallBacks;
        if (!isDeleted && tf.js.GetIsValidObject(toastSettings)) {
            var doToast = false;
            topDiv.ClearContent();
            if (doToast = tf.js.GetIsNonEmptyString(toastSettings.text)) {
                topDivE.innerHTML = toastSettings.text;
            }
            else if (doToast = tf.dom.GetHTMLElementFrom(settings.content)) {
                topDiv.ReplaceContent(settings.content);
            }
            if (doToast) { toastCallBacks = startToast(toastSettings); }
        }
        return toastCallBacks;
    }
    function onClick(ev) { if (!!closeOnClickUse) { closeToast(); } return false; }
    function create() {
        topDiv = new tf.dom.Div({});
        topDivE = topDiv.GetHTMLElement();
        if (className != undefined) {
            topDivE.className = className;
        }
        if (style != undefined) { styles.ApplyStyleProperties(topDiv, style); }
        topDivE.addEventListener('click', onClick);
    }
    function initialize() {
        styles = tf.GetStyles();
        count = 0;
        if (!!tf.dom.GetHTMLElementFrom(settings.container) && !!tf.js.GetFunctionOrNull(settings.container.AddContent) && !!tf.js.GetFunctionOrNull(settings.container.RemoveContent)) {
            container = settings.container;
            isDeleted = false;
            onCloseCB = tf.js.GetFunctionOrNull(settings.onClose);
            closeOnClick = settings.closeOnClick != undefined ? !!settings.closeOnClick : true;
            addBefore = settings.addBefore != undefined ? !!settings.addBefore : true;
            style = tf.js.GetValidObjectFrom(settings.style);
            className = tf.js.GetNonEmptyString(settings.className, "");
            create();
        }
        else { isDeleted = true; }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.ui.Toaster = function (settings) {
    var theThis, container, styles, className, style, timeout, addBefore, closeOnClick, topDiv, topDivE, isShowing, closeTM;
    var availableToasts, nActiveToasts;
    this.GetNActiveToasts = function () { return nActiveToasts; }
    this.Toast = function (toastSettings) { return toast(toastSettings); }
    function getTimeout(overrideTimeout) { var tm = overrideTimeout != undefined ? overrideTimeout : timeout; return tm == undefined ? 0 : tm; }
    function doShow(showBool) { styles.ChangeOpacityVisibilityClass(topDiv, isShowing = !!showBool); }
    function getOrCreateNewToast() {
        if (++nActiveToasts == 1) { doShow(true); }
        if (availableToasts.length > 0) { return availableToasts.pop(); }
        return new tf.ui.OneToast({
            onClose: function (notification) { if (--nActiveToasts == 0) { doShow(false); }; availableToasts.push(notification.sender); },
            container: topDiv, className: settings.toastClassName, style: settings.toastStyle, closeOnClick: closeOnClick
        });
    }
    function toast(toastSettings) {
        var toastCallBacks;
        if (tf.js.GetIsValidObject(toastSettings)) {
            var isText = tf.js.GetIsNonEmptyString(toastSettings.text);
            var isContent = !isText && tf.dom.GetHTMLElementFrom(toastSettings.content);
            if (isText || isContent) {
                var oneToast;
                oneToast = getOrCreateNewToast();
                toastCallBacks = oneToast.Toast({
                    text: toastSettings.text,
                    content: toastSettings.content,
                    timeout: getTimeout(toastSettings.timeout),
                    addBefore: toastSettings.addBefore != undefined ? toastSettings.addBefore : addBefore,
                    className: toastSettings.className,
                    style: toastSettings.style,
                    closeOnClick: toastSettings.closeOnClick != undefined ? toastSettings.closeOnClick : closeOnClick
                });
                if (nActiveToasts == 1) { doShow(true); }
            }
        }
        return toastCallBacks;
    }
    function create() {
        topDiv = new tf.dom.Div({});
        topDivE = topDiv.GetHTMLElement();
        if (className != undefined) { topDivE.className = className; }
        if (style != undefined) { styles.ApplyStyleProperties(topDiv, style); }
        container.appendChild(topDivE);
        styles.ChangeOpacityVisibilityClass(topDiv, false);
    }
    function initialize() {
        styles = tf.GetStyles();
        container = tf.dom.GetHTMLElementFrom(settings.container);
        style = settings.style;
        className = settings.className;
        timeout = settings.timeout;
        closeOnClick = settings.closeOnClick != undefined ? !!settings.closeOnClick : true;
        addBefore = settings.addBefore != undefined ? !!settings.addBefore : true;
        nActiveToasts = 0;
        availableToasts = [];
        create();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.ui.FullScreenDiv = function (settings) {
    var theThis, styles;
    var eventDispatcher, resizeEventName, closeEventName;
    var topDiv, topDivE, topDivES;
    var onUpdateSizeDelayCallBack;
    var isDeleted, isShowing, zIndexShowing, zIndexNotShowing;
    var domEventListener;
    var customStyle;
    this.Show = function (showBool) { return show(showBool); }
    this.GetIsShowing = function () { return isShowing; }
    this.GetTopDiv = function () { return topDiv; }
    this.AddResizeListener = function (callBack) { return eventDispatcher.AddListener(resizeEventName, callBack); }
    this.AddCloseListener = function (callBack) { return eventDispatcher.AddListener(closeEventName, callBack); }
    this.OnDelete = function () { return onDelete(); }
    this.GetIsDeleted = function () { return isDeleted; }
    function onDelete() {
        if (!isDeleted) {
            show(false);
            if (!!domEventListener) { domEventListener.OnDelete(); }
            if (!!topDivE) { document.body.removeChild(topDivE); }
            if (!!topDiv) { topDiv.ClearContent(); topDiv.OnDelete(); }
            topDiv = topDivE = toDivES = eventDispatcher = domEventListener = onUpdateSizeDelayCallBack = undefined;
            isDeleted = true;
        }
    }
    function show(showBool) { if (!isDeleted) { if (isShowing != (showBool = !!showBool)) { setShowingAttributes(isShowing = showBool); } } }
    function doSetZIndex(zIndex) { topDivES.zIndex = zIndex; }
    function setZIndex(zIndex, delayBool) { if (delayBool) { setTimeout(function () { return doSetZIndex(zIndex); }, 1000); } else { doSetZIndex(zIndex); } }
    function setShowingAttributes(showBool) {
        var zIndex, opacity, pointerEvents;
        if (showBool) { zIndex = zIndexShowing; opacity = '1'; pointerEvents = 'all'; }
        else { zIndex = zIndexNotShowing; opacity = '0'; pointerEvents = 'none'; }
        topDivES.opacity = opacity;
        topDivES.pointerEvents = pointerEvents;
        setZIndex(zIndex, !showBool);
        if (showBool) { requestResize(); } else { notify(closeEventName); }
    }
    function notify(eventName) { eventDispatcher.Notify(eventName, { sender: theThis }); }
    function onWindowResize() { if (!isDeleted) { notify(resizeEventName); return false; } }
    function requestResize() { if (!isDeleted) { onUpdateSizeDelayCallBack.DelayCallBack(); } }
    function create() {
        topDiv = new tf.dom.Div();
        var topDivStyle = {
            "display": "block",
            "pointer-events": "none",
            "position": "absolute",
            "z-index": "0",
            "left": "0px",
            "top": "0px",
            "width": "100%",
            "height": "100%",
            "border": "none",
            "margin": "0px",
            "padding": "0px",
            "opacity": "0",
            "overflow": "hidden",
            "background-color": "rgba(255,255,255,0)",
            "-webkit-transition": "opacity 1s ease-in-out",
            "-moz-transition": "opacity 1s ease-in-out",
            "-ms-transition": "opacity 1s ease-in-out",
            "-o-transition": "opacity 1s ease-in-out",
            "transition": "opacity 1s ease-in-out"
        };
        topDivE = topDiv.GetHTMLElement();
        topDivES = topDivE.style;
        //topDivES = topDivStyle;
        styles.ApplyStyleProperties(topDiv, topDivStyle);
        if (tf.js.GetIsValidObject(customStyle)) { styles.ApplyStyleProperties(topDiv, customStyle); }
        setShowingAttributes(isShowing = false);
        document.body.appendChild(topDivE);
    }
    function initialize() {
        styles = tf.GetStyles();
        isDeleted = false;
        resizeEventName = "res";
        closeEventName = "clo";
        eventDispatcher = new tf.events.MultiEventNotifier({ eventNames: [resizeEventName] });
        settings = tf.js.GetValidObjectFrom(settings);
        zIndexShowing = settings.zIndexShowing != undefined ? settings.zIndexShowing : 100;
        zIndexNotShowing = settings.zIndexNotShowing != undefined ? settings.zIndexNotShowing : 0;
        customStyle = settings.customStyle;
        create();
        if (settings.onClose != undefined) { theThis.AddCloseListener(settings.onClose); }
        if (settings.onResize != undefined) { theThis.AddResizeListener(settings.onResize); }
        onUpdateSizeDelayCallBack = new tf.events.DelayedCallBack(250, onWindowResize);
        domEventListener = tf.events.AddDOMEventListener(window, tf.consts.DOMEventNamesResize, requestResize);
        requestResize();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.ui.MultiLineInput = function (settings) {
    var theThis, styles, styleCreator, onCloseCB, isEditing, statusButtonEnabledClasses, statusButtonDisabledClasses, topDiv, titleDivE;
    var buttonDim, textDim, topWrapper, topWrapperE, topWrapperES, controlWrapper, editProps, title;
    var textAreaDivE;
    var saveButton, cancelButton;
    var validatorCB;
    this.GetTopDiv = function () { return topWrapper; }
    this.GetIsEditing = function () { return isEditing; }
    this.Edit = function (editSettings) { return edit(editSettings); }
    this.OnClose = function (isConfirmed) { return onClose(isConfirmed); }
    function edit(editSettings) {
        if (!isEditing) {
            if (tf.js.GetIsValidObject(editSettings)) {
                isEditing = true;
                topWrapperES.display = 'block';
                title = tf.js.GetNonEmptyString(editSettings.title, "Text Input");
                saveButton.SetText(tf.js.GetNonEmptyString(editSettings.saveText, "Save"));
                cancelButton.SetText(tf.js.GetNonEmptyString(editSettings.cancelText, "Cancel"));
                saveButton.ChangeToolTip(tf.js.GetNonEmptyString(editSettings.saveToolTip, "Save"));
                cancelButton.ChangeToolTip(tf.js.GetNonEmptyString(editSettings.cancelToolTip, "Cancel"));
                textAreaDivE.value = tf.js.GetNonEmptyString(editSettings.text, "").trim();
                if (editSettings.nRows != undefined) { textAreaDivE.rows = '' + editSettings.nRows; }
                titleDivE.innerHTML = title;
                isEditing = true;
                editProps = editSettings.props;
                textAreaDivE.focus();
            }
        }
    }
    function onClose(isConfirmed) {
        if (isEditing) {
            var willClose = true;
            if (!!onCloseCB) {
                var text = isConfirmed ? textAreaDivE.value.trim() : '';
                var notification = { sender: theThis, isConfirmed: isConfirmed, props: editProps, text: text };
                var failedValidation = isConfirmed && !!validatorCB && !validatorCB(notification);
                if (willClose = !failedValidation) { onCloseCB(notification); }
            }
            if (willClose) { isEditing = false; topWrapperES.display = 'none'; }
        }
    }
    function confirm() { onClose(true); }
    function cancel() { onClose(false); }
    function getOnStopEdit(confirmed) { return function (notification) { return confirmed ? confirm() : cancel(); } }
    function create() {
        var controlWrapperStyles = { margin: "0px", padding: "0px", border: "none", display: "block" };
        var controlWrapperClassName = tf.GetNextDynCSSClassName();
        var titleStyles = { padding: "4px", fontSize: "90%", backgroundColor: "rgba(255, 255, 255, 0.7)", marginBottom: "4px", display: "block", borderBottom: "1px solid brown" };
        var titleClassName = tf.GetNextDynCSSClassName();
        var buttonsStyles = { display: "block", border: "none", padding: "2px", marginTop: "2px", borderTop: "1px solid rgba(255, 255, 255, 0.7)" };
        var buttonsClassName = tf.GetNextDynCSSClassName();
        var topStyles = {
            position: "absolute", margin: "4px", border: "2px solid red", borderRadius: "6px", fontSize: "18px", lineHeight: "20px", color: "darkblue",
            backgroundColor: "orange", textShadow: "2px 2px 3px white", cursor: "default", display: "block", zIndex: "10", textAlign: "center", boxShadow: "2px 2px 4px 1px rgba(0,0,0,0.75)"
        };
        var topClassName = tf.GetNextDynCSSClassName();
        var multiLineStyles = { left: "50%", top: "50%", transform: "translate(-50%, -50%)", width: "40%", overflow: "hidden" };
        var multiLineClassName = tf.GetNextDynCSSClassName();
        var cssStyles = [
            { styleName: '.' + controlWrapperClassName, inherits: controlWrapperStyles },
            { styleName: '.' + titleClassName, inherits: titleStyles },
            { styleName: '.' + buttonsClassName, inherits: buttonsStyles },
            { styleName: '.' + topClassName, inherits: topStyles },
            { styleName: '.' + multiLineClassName, inherits: multiLineStyles }
        ];
        styleCreator.CreateStyles(cssStyles);
        controlWrapper = new tf.dom.Div({ cssClass: controlWrapperClassName });
        var titleDiv = new tf.dom.Div({ cssClass: titleClassName });
        titleDivE = titleDiv.GetHTMLElement();
        titleDivE.innerHTML = '';
        titleDivE.title = '';
        var buttonsDiv = new tf.dom.Div({ cssClass: buttonsClassName });
        saveButton = styles.AddButtonDivMargins(new tf.ui.TextBtn({
            dim: textDim, style: statusButtonEnabledClasses, label: 'Save', tooltip: "Save", onClick: getOnStopEdit(true)
        }));
        cancelButton = styles.AddButtonDivMargins(new tf.ui.TextBtn({
            dim: textDim, style: statusButtonDisabledClasses, label: 'Cancel', tooltip: "Cancel", onClick: getOnStopEdit(false)
        }));
        var textShadowBlack = { textShadow: "1px 1px 1px #000" };
        styles.ApplyStyleProperties(saveButton, textShadowBlack);
        styles.ApplyStyleProperties(cancelButton, textShadowBlack);
        buttonsDiv.AddContent(saveButton, cancelButton);
        buttonsDiv.GetHTMLElement().style.textAlign = 'right';
        textAreaDivE = document.createElement('textarea');
        textAreaDivE.className = "multiLineInput";
        textAreaDivE.title = 'Paste or type text here';
        textAreaDivE.rows = 10;
        controlWrapper.AddContent(titleDiv, textAreaDivE, buttonsDiv)
        topWrapper = new tf.dom.Div({ cssClass: topClassName + " " + multiLineClassName });
        topWrapper.AddContent(controlWrapper);
        topWrapperE = topWrapper.GetHTMLElement();
        topWrapperES = topWrapperE.style;
        topWrapperES.display = 'none';
        if (settings.zIndex != undefined) { topWrapperES.zIndex = settings.zIndex; }
        topDiv.AddContent(topWrapper);
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        onCloseCB = tf.js.GetFunctionOrNull(settings.onClose);
        validatorCB = tf.js.GetFunctionOrNull(settings.validator);
        topDiv = settings.container;
        styles = tf.GetStyles();
        styleCreator = styles.GetStyleCreator();
        buttonDim = "16px";
        textDim = buttonDim;
        statusButtonEnabledClasses = styles.CreateTextDivBtnClasses("white", "green", "white", "darkgreen");
        statusButtonDisabledClasses = styles.CreateTextDivBtnClasses("white", "red", "white", "darkred");
        isEditing = false;
        create();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.ui.FullScreenMultiLineInput = function (settings) {
    var theThis, fullScreenDiv, multiLineInput, onCloseCB;
    this.GetIsEditing = function () { return multiLineInput.GetIsEditing(); }
    this.Edit = function (editSettings) { return edit(editSettings); }
    this.OnClose = function (isConfirmed) { return multiLineInput.OnClose(isConfirmed); }
    this.GetTopDiv = function () { return multiLineInput.GetTopDiv(); }
    function edit(editSettings) { if (!multiLineInput.GetIsEditing()) { fullScreenDiv.Show(true); multiLineInput.Edit(editSettings); } }
    function onClose(notification) { fullScreenDiv.Show(false); if (!!onCloseCB) { onCloseCB(notification); } }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        var mliSettings = tf.js.GetValidObjectFrom(settings.multiLineInputSettings);
        var fsdSettings = tf.js.GetValidObjectFrom(settings.fullScreenSettings);
        onCloseCB = tf.js.GetFunctionOrNull(mliSettings.onClose);
        fullScreenDiv = new tf.ui.FullScreenDiv(fsdSettings);
        multiLineInput = new tf.ui.MultiLineInput(tf.js.ShallowMerge(mliSettings, { onClose: onClose, container: fullScreenDiv.GetTopDiv() }));
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.ui.DatePicker = function (settings) {
    var theThis, styles, topDiv, topDivE, topDivS, curParent, calendar, maxRows, wdNames, monthNames,
        year, month, dayOfMonth, curYear, curMonth, curFirstWD, onClickCB, buttonDim;
    var calendarWrapperDivClassName, calendarDivClassName, calendarRowDivClassName, calendarWDRowDivClassName, calendarWDCellDivClassName, calendarCellDivClassName, calendarCellCurDayDivClassName,
        calendarTitleDivClassName, calendarPrevArrowDivClassName, calendarNextArrowDivClassName, calendarMonthYearDivClassName;
    var lastDateSet, minDate, maxDate;
    this.SetMinDate = function (minDateSet) { setMinDate(minDateSet, true); }
    this.SetMaxDate = function (minDateSet) { setMaxDate(maxDateSet, true); }
    this.SetDate = function (date) { return setDate(date); }
    this.AppendTo = function (parent, style) { return appendTo(parent, style); }
    this.Detach = function () { return detach(); }
    this.IsAttached = function () { return !!curParent; }
    this.GetHTMLElement = function () { return topDiv.GetHTMLElement(); }
    function detach() { if (!!curParent) { curParent.removeChild(topDivE); curParent = undefined; } }
    function appendTo(parent, style) {
        detach();
        styles.ApplyStyleProperties(topDiv, style);
        if (!!(curParent = tf.dom.GetHTMLElementFrom(parent))) { curParent.appendChild(topDivE); topDivE.focus(); } else { curParent = undefined; }
    }
    function onPrevNextMonth(isNext) {
        curMonth += (!!isNext ? 1 : -1);
        if (curMonth < 0) { curMonth = 11; --curYear; } else if (curMonth > 11) { curMonth = 0; ++curYear; }
        fillCalendar();
    }
    function notifyDateClicked(day) {
        if (!!onClickCB) {
            var date = new Date(curYear, curMonth, day), dow = date.getDay();
            onClickCB({ sender: theThis, month: curMonth, year: curYear, day: day, date: date, dow: dow });
        }
    }
    function getOnClickCalendarCell(cell) { return function (event) { if (!!onClickCB) { var day = cell.index - curFirstWD + 1; notifyDateClicked(day); } } }
    function setDate(newDate) {
        if (!!newDate) {
            newDate = newDate || new Date();
            if (minDate != undefined && newDate < minDate) { newDate = minDate; }
            if (maxDate != undefined && newDate > maxDate) { newDate = maxDate; }
            lastDateSet = newDate;
            month = newDate.getMonth();
            year = newDate.getFullYear();
            dayOfMonth = newDate.getDate();
            curYear = year;
            curMonth = month;
            fillCalendar();
        }
    }
    function showHide(divE, showHideBool) {
        var opacity, pointerEvents;
        if (!!showHideBool) { opacity = 1; pointerEvents = 'all'; } else { opacity = 0; pointerEvents = 'none'; }
        divE.style.opacity = opacity;
        divE.style.pointerEvents = pointerEvents;
    }
    function fillCalendar() {
        var monthName = monthNames[curMonth];
        var calendarFirstDay = new Date(curYear, curMonth, 1);
        var calendarLastDay = new Date(curYear, curMonth + 1, 0);
        var nDays = tf.units.GetDaysBetweenDates(calendarFirstDay, calendarLastDay) + 1;
        var hasCurDay = curMonth == month && curYear == year;
        var curDayClass = calendarCellCurDayDivClassName;
        calendar.titleDiv.myDivE.innerHTML = monthName + ' ' + curYear;
        curFirstWD = calendarFirstDay.getDay();
        var curRow = 0, curCol = curFirstWD;
        var rows = calendar.rows, row = rows[curRow], rowCols = row.cols;
        for (var i = 0; i < curFirstWD ; ++i) { showHide(rowCols[i].divE, false); }
        for (var i = 0; i < nDays ; ++i) {
            if (curCol > 6) { curCol = 0; row = rows[++curRow]; rowCols = row.cols; }
            var cell = rowCols[curCol], thisDayOfMonth = i + 1;
            showHide(cell.divE, true);
            if (hasCurDay && (dayOfMonth == thisDayOfMonth)) { tf.dom.AddCSSClass(cell.divE, curDayClass); }
            else { tf.dom.RemoveCSSClass(cell.divE, curDayClass); }
            cell.divE.innerHTML = '' + thisDayOfMonth;
            row.divE.style.display = 'block';
            ++curCol;
        }
        for (var i = curCol ; i < 7 ; ++i) { showHide(rowCols[i].divE, false); }
        for (var i = curRow + 1 ; i < maxRows ; ++i) { calendar.rows[i].divE.style.display = 'none'; }
    }
    function createCalendarWDCell(colNumber) {
        var calendarCellDiv = new tf.dom.Div({ cssClass: calendarWDCellDivClassName });
        calendarCellDiv.GetHTMLElement().innerHTML = wdNames[colNumber];
        return { div: calendarCellDiv, col: colNumber };
    }
    function createCalendarCell(rowNumber, colNumber) {
        var calendarCellDiv = new tf.dom.Div({ cssClass: calendarCellDivClassName });
        var calendarCellDivE = calendarCellDiv.GetHTMLElement();
        var index = rowNumber * 7 + colNumber;
        var calendarCell = { div: calendarCellDiv, divE: calendarCellDivE, row: rowNumber, col: colNumber, index: index };
        calendarCellDivE.innerHTML = '' + index;
        calendarCellDivE.addEventListener('click', getOnClickCalendarCell(calendarCell));
        return calendarCell;
    }
    function createCalendarRow(rowNumber) {
        var calendarCells = [], calendarRowDiv = new tf.dom.Div({ cssClass: calendarRowDivClassName });
        for (var i = 0 ; i < 7 ; ++i) { var calendarCell = createCalendarCell(rowNumber, i); calendarCells.push(calendarCell); calendarRowDiv.AddContent(calendarCell.div); }
        return { div: calendarRowDiv, divE: calendarRowDiv.GetHTMLElement(), cols: calendarCells };
    }
    function createCalendarWDDiv() {
        var calendarCells = [], calendarRowDiv = new tf.dom.Div({ cssClass: calendarWDRowDivClassName });
        for (var i = 0 ; i < 7 ; ++i) { var calendarCell = createCalendarWDCell(i); calendarCells.push(calendarCell); calendarRowDiv.AddContent(calendarCell.div); }
        return { div: calendarRowDiv, cols: calendarCells };
    }
    function createCalendarTitleDiv() {
        var calendarTitleDiv = new tf.dom.Div({ cssClass: calendarTitleDivClassName });
        var calendarMonthYearDiv = new tf.dom.Div({ cssClass: calendarMonthYearDivClassName });
        var calendarPrevArrowDiv = new tf.dom.Div({ cssClass: calendarPrevArrowDivClassName });
        var calendarNextArrowDiv = new tf.dom.Div({ cssClass: calendarNextArrowDivClassName });
        var calendarMonthYearDivE = calendarMonthYearDiv.GetHTMLElement();
        var prevButton = new tf.ui.SvgGlyphBtn({ style: true, glyph: tf.styles.SvgGlyphLeftArrowName, onClick: function () { onPrevNextMonth(false); }, tooltip: "Previous Month", dim: buttonDim });
        var nextButton = new tf.ui.SvgGlyphBtn({ style: true, glyph: tf.styles.SvgGlyphRightArrowName, onClick: function () { onPrevNextMonth(true); }, tooltip: "Next Month", dim: buttonDim });
        calendarPrevArrowDiv.AddContent(prevButton);
        calendarNextArrowDiv.AddContent(nextButton);
        calendarTitleDiv.AddContent(calendarNextArrowDiv);
        calendarTitleDiv.AddContent(calendarPrevArrowDiv);
        calendarTitleDiv.AddContent(calendarMonthYearDiv);
        return { div: calendarTitleDiv, prev: calendarPrevArrowDiv, next: calendarNextArrowDiv, myDiv: calendarMonthYearDiv, myDivE: calendarMonthYearDivE };
    }
    function createCalendar() {
        var calendarRows = [], calendarDiv = new tf.dom.Div({ cssClass: calendarDivClassName });
        var calendarTitleDiv = createCalendarTitleDiv(), calendarWDDiv = createCalendarWDDiv();
        calendarDiv.AddContent(calendarTitleDiv.div);
        calendarDiv.AddContent(calendarWDDiv.div);
        for (var i = 0 ; i < maxRows ; ++i) { var calendarRow = createCalendarRow(i); calendarRows.push(calendarRow); calendarDiv.AddContent(calendarRow.div); }
        return { div: calendarDiv, rows: calendarRows, wdDiv: calendarWDDiv, titleDiv: calendarTitleDiv };
    }
    function createControl() {
        topDiv = new tf.dom.Div({ cssClass: calendarWrapperDivClassName });
        topDivE = topDiv.GetHTMLElement();
        calendar = createCalendar();
        topDiv.AddContent(calendar.div);
        //topDivE.addEventListener('blur', function (event) { notifyDateClicked(thisDayOfMonth); return false; });
    }
    function createCSSClasses() {
        var calendarWrapperDivStyle = { backgroundColor: "rgb(0,68,152)", borderRadius: "6px", border: "2px solid navajowhite", display: "inline-block" };
        var calendarDivStyle = { padding: "2px", margin: "2px", display: "block", border: "1px solid green" };
        var calendarRowDivStyle = { whiteSpace: "nowrap", display: "block" };
        var calendarWDRowDivStyle = { whiteSpace: "nowrap", backgroundColor: "white", color: "navy", textShadow: "none", fontWeight: "600", marginBottom: "2px" };
        var calendarWDCellDivStyle = { padding: "2px", margin: "2px", display: "inline-block", border: "1px solid navy", lineHeight: "16px", fontSize: "14px", textAlign: "right", paddingRight: "6px", width: "24px" };
        var calendarCellDivStyle = { padding: "2px", margin: "2px", display: "inline-block", border: "1px solid navy", lineHeight: "16px", fontSize: "14px", textAlign: "right", paddingRight: "6px", width: "24px", color: "white", cursor: "pointer" };
        var calendarCellHoverDivStyle = { backgroundColor: "white", color: "navy", fontWeight: "600", fontSize: "16px" };
        var calendarCellCurDayDivStyle = { backgroundColor: "lightgreen", fontWeight: "600", fontSize: "15px", color: "navy" };
        var calendarTitleDivStyle = { verticalAlign: "middle", whiteSpace: "nowrap", backgroundColor: "white", color: "navy", textShadow: "none", fontWeight: "600", borderRadius: "4px", marginBottom: "4px", position: "relative", textAlign: "center", overflow: "hidden", lineHeight: "16px", fontSize: "14px" };
        var calendarPrevArrowDivStyle = { position: "absolute", left: "4px", top: "2px", height: "calc(100% - 4px)", overflow: "hidden" };
        var calendarNextArrowDivStyle = { position: "absolute", right: "4px", top: "2px", height: "calc(100% - 4px)", overflow: "hidden" };
        var calendarMonthYearDivStyle = { padding: "2px", margin: "2px", display: "inline-block" };
        calendarWrapperDivClassName = tf.GetNextDynCSSClassName();
        calendarRowDivClassName = tf.GetNextDynCSSClassName();
        calendarWDRowDivClassName = tf.GetNextDynCSSClassName();
        calendarWDCellDivClassName = tf.GetNextDynCSSClassName();
        calendarCellDivClassName = tf.GetNextDynCSSClassName();
        calendarCellCurDayDivClassName = tf.GetNextDynCSSClassName();
        calendarTitleDivClassName = tf.GetNextDynCSSClassName();
        calendarPrevArrowDivClassName = tf.GetNextDynCSSClassName();
        calendarNextArrowDivClassName = tf.GetNextDynCSSClassName();
        calendarMonthYearDivClassName = tf.GetNextDynCSSClassName();
        var cssStyles = [
            { styleName: '.' + calendarWrapperDivClassName, inherits: calendarWrapperDivStyle },
            { styleName: '.' + calendarDivClassName, inherits: calendarDivStyle },
            { styleName: '.' + calendarRowDivClassName, inherits: calendarRowDivStyle },
            { styleName: '.' + calendarWDRowDivClassName, inherits: calendarWDRowDivStyle },
            { styleName: '.' + calendarWDCellDivClassName, inherits: calendarWDCellDivStyle },
            { styleName: '.' + calendarCellDivClassName, inherits: calendarCellDivStyle },
            { styleName: '.' + calendarCellDivClassName + ':hover', inherits: calendarCellHoverDivStyle },
            { styleName: '.' + calendarCellCurDayDivClassName, inherits: calendarCellCurDayDivStyle },
            { styleName: '.' + calendarTitleDivClassName, inherits: calendarTitleDivStyle },
            { styleName: '.' + calendarPrevArrowDivClassName, inherits: calendarPrevArrowDivStyle },
            { styleName: '.' + calendarNextArrowDivClassName, inherits: calendarNextArrowDivStyle },
            { styleName: '.' + calendarMonthYearDivClassName, inherits: calendarMonthYearDivStyle }
        ];
        styles.GetStyleCreator().CreateStyles(cssStyles);
    };
    function setMinDate(minDateSet, clipDateAndRefill) { minDate = minDateSet; if (clipDateAndRefill) { setDate(lastDateSet); } }
    function setMaxDate(maxDateSet, clipDateAndRefill) { if (clipDateAndRefill) { setDate(lastDateSet); } }
    function initialize() {
        styles = tf.GetStyles();
        settings = tf.js.GetValidObjectFrom(settings);
        onClickCB = tf.js.GetFunctionOrNull(settings.onClick);
        maxRows = 6;
        wdNames = tf.js.GetIsArrayWithLength(settings.weekDayLetters, 7) && tf.js.GetIsStringWithMinLength(settings.weekDayLetters[0], 2) ? settings.weekDayLetters :
            ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'];
        monthNames = tf.js.GetIsArrayWithLength(settings.monthNames, 12) && tf.js.GetIsNonEmptyString(settings.monthNames[0]) ? settings.monthNames :
            ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        buttonDim = tf.js.GetIsNonEmptyString(settings.buttonDim) ? settings.buttonDim : "20px";
        createCSSClasses();
        createControl();
        setMinDate(settings.minDate, false);
        setMaxDate(settings.maxDate, false);
        setDate();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.ui.QuickMenu = function (settings) {
    var theThis, styles, topDiv, topDivE, topDivES, curParent, onClickCB, buttonDim, hoverListener, buttons;
    var topWrapperDivClassName, topDivClassName;
    this.GetTopDivStyle = function () { return topDivES; }
    this.AppendTo = function (parent, style) { return appendTo(parent, style); }
    this.Detach = function () { return detach(); }
    this.IsAttached = function () { return !!curParent; }
    this.GetHTMLElement = function () { return topDiv.GetHTMLElement(); }
    this.GetButtons = function () { return buttons; }
    function detach() { if (!!curParent) { curParent.removeChild(topDivE); curParent = undefined; } }
    function appendTo(parent, style) {
        detach();
        styles.ApplyStyleProperties(topDiv, style);
        if (!!(curParent = tf.dom.GetHTMLElementFrom(parent))) { curParent.appendChild(topDivE); topDivE.focus(); } else { curParent = undefined; }
    }
    function getNotifyPick(item, index) { return function () { if (!!onClickCB) { onClickCB({ sender: theThis, text: item.text, item: item, index: index }); } } }
    function createControl() {
        topDiv = new tf.dom.Div({ cssClass: topWrapperDivClassName });
        topDivE = topDiv.GetHTMLElement();
        topDivES = topDivE.style;
        buttons = [];
        var nItems = !!settings.items ? settings.items.length : 0;
        for (var i = 0; i < nItems ; ++i) {
            var item = settings.items[i];
            var button = new tf.ui.TextBtn({ style: true, label: item.text, buttonDim: buttonDim, tooltip: tf.js.GetIsNonEmptyString(item.toolTip) ? item.toolTip : item.text, onClick: getNotifyPick(item, i) });
            button.GetHTMLElement().style.display = 'block';
            topDiv.AddContent(button);
            buttons.push(button);
        }
    }
    function createCSSClasses() {
        var topWrapperDivStyle = { backgroundColor: "rgb(0,68,152)", borderRadius: "6px", border: "2px solid navajowhite", display: "inline-block", fontSize: "1.4em" };
        var topDivStyle = { padding: "2px", margin: "2px", display: "block", border: "1px solid green" };
        topWrapperDivClassName = tf.GetNextDynCSSClassName();
        topDivClassName = tf.GetNextDynCSSClassName();
        var cssStyles = [
            { styleName: '.' + topWrapperDivClassName, inherits: topWrapperDivStyle },
            { styleName: '.' + topDivClassName, inherits: topDivStyle }
        ];
        styles.GetStyleCreator().CreateStyles(cssStyles);
    };
    function initialize() {
        styles = tf.GetStyles();
        settings = tf.js.GetValidObjectFrom(settings);
        onClickCB = tf.js.GetFunctionOrNull(settings.onClick);
        buttonDim = tf.js.GetIsNonEmptyString(settings.buttonDim) ? settings.buttonDim : "1.6em";
        createCSSClasses();
        createControl();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.ui.MultiMenus = function (settings) {
    var theThis;
    var allMenus;
    this.AddMenu = function (menuToAdd) { return addMenu(menuToAdd); }
    this.CloseMenus = function (optionalExceptMenu) { return closeMenus(optionalExceptMenu); }
    this.UpdateMenuPositions = function () { return updateMenuPositions(); }
    function onMenuOpened(notification) { closeMenus(notification.sender); }
    function closeMenus(optionalExceptMenu) { for (var i in allMenus) { var thisMenu = allMenus[i]; if (thisMenu != optionalExceptMenu) { thisMenu.CloseIfOpen(); } } }
    function updateMenuPositions() { for (var i in allMenus) { var thisMenu = allMenus[i]; thisMenu.OnResize(); } }
    function onButtonClicked() { closeMenus(undefined); }
    function addMenu(menuToAdd) {
        if (!!menuToAdd) {
            if (!!tf.js.GetFunctionOrNull(menuToAdd.AddOpenListener) && !!tf.js.GetFunctionOrNull(menuToAdd.CloseIfOpen)) {
                allMenus.push(menuToAdd);
                menuToAdd.AddOpenListener(onMenuOpened);
            }
        }
    }
    function initialize() {
        allMenus = [];
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.ui.GuidedTour = function (settings) {
    var theThis, styles, buttonDim;
    var onPlayCB, onPauseCB;
    var fullScreenDiv;
    var playButton, playButtonClass, playButtonStyles, isPlaying, topWrapperDiv, titleDiv, contentDiv, buttonsDiv;
    var tourSteps, curTourStep;
    var firstStetButton, lastStepButton, prevStepButton, nextStepButton;
    var nextStepTimer, autoTourButton, isAutoTour;
    var highLightDiv, lastHiLightElem;
    var opacityTransitionCSSClass, hilightDivCSSClass, guidedWrapperCSSClass, guidedTitleCSSClass, guidedContentCSSClass, guidedButtonsCSSClass;
    this.ShowPlayButton = function (showStr) { playButton.GetHTMLElement().style.display = showStr; }
    this.GetIsPlaying = function () { return isPlaying; }
    this.HiLight = function (elem) { return highLightElem(elem); }
    this.DelayHiLight = function (elem) { return delayHiLightElem(elem); }
    this.HideHighLight = function (nodelay) { return hideHighLight(nodelay); }
    function updateAutoTourButton() { if (!!autoTourButton) { autoTourButton.SetIsToggled(!isAutoTour); } }
    function stopnextStepTimer() { if (!!nextStepTimer) { clearTimeout(nextStepTimer); nextStepTimer = undefined; } if (isAutoTour) { isAutoTour = false; updateAutoTourButton(); } }
    function tryStartnextStepTimer() { if (isAutoTour) { nextStepTimer = setTimeout(onNextStepTimer, tourSteps[curTourStep].duration_secs * 1000); } }
    function onNextStepTimer() { gotoGuidedTourStep(curTourStep + 1); }
    function onToggleAutoTour() { if (isAutoTour) { stopnextStepTimer(); } else { isAutoTour = true; tryStartnextStepTimer(); } }
    function onFullScreenResize() { reHighLight(); }
    function showPlayButton() { if (!!playButton) { playButton.GetHTMLElement().style.opacity = 1; } }
    function hidePlayButton() { if (!!playButton) { playButton.GetHTMLElement().style.opacity = 0; } }
    function notifyPlayPause() { var cb = isPlaying ? onPlayCB : onPauseCB; if (!!cb) { cb({ sender: theThis, isPlaying: isPlaying }); } }
    function pauseTour() { if (isPlaying) { fullScreenDiv.Show(isPlaying = false); showPlayButton(); notifyPlayPause(); } }
    function playTour() { if (!isPlaying) { addToFullScreenDiv(); hidePlayButton(); fullScreenDiv.Show(isPlaying = true); notifyPlayPause(); gotoGuidedTourStep(curTourStep); } }
    function onPrevNextTourStep(isPrev) { var inc = isPrev ? -1 : 1; gotoGuidedTourStep(curTourStep + inc); }
    function addRemoveOpacityTransition(elem, addBool) {
        if (!!elem && !!opacityTransitionCSSClass) {
            var method = !!addBool ? tf.dom.AddCSSClass : tf.dom.RemoveCSSClass;
            method(elem, opacityTransitionCSSClass);
        }
    }
    function addRemoveHilightOpacity(addBool) { return addRemoveOpacityTransition(highLightDiv, addBool); }
    function hideHighLight(nodelay) {
        if (!!highLightDiv) {
            lastHiLightElem = undefined;
            var hdes = highLightDiv.GetHTMLElement().style;
            if (!!nodelay) { addRemoveHilightOpacity(false); }
            hdes.opacity = 0;
            if (!!nodelay) { addRemoveHilightOpacity(true); }
        }
    }
    function reHighLight() { if (!!lastHiLightElem) { delayHiLightElem(lastHiLightElem); } }
    function delayHiLightElem(elem) { setTimeout(function () { highLightElem(elem); }, 300); }
    function highLightElem(elem) {
        if ((elem = tf.dom.GetHTMLElementFrom(elem))) {
            if (!!highLightDiv) {
                var rectObj = elem.getBoundingClientRect();
                if (!!rectObj) {
                    hideHighLight(true);
                    lastHiLightElem = elem;
                    var paddingPx = 4;
                    var borderPx = 4;
                    var addPx = paddingPx + borderPx;
                    var left = Math.trunc(rectObj.left) - addPx;
                    var top = Math.trunc(rectObj.top) - addPx;
                    var width = Math.trunc(rectObj.width);
                    var height = Math.trunc(rectObj.height);
                    var highLightDivE = highLightDiv.GetHTMLElement(), highLightDivES = highLightDivE.style;
                    highLightDivES.left = (left) + 'px';
                    highLightDivES.top = (top) + 'px';
                    highLightDivES.width = (width + borderPx) + 'px';
                    highLightDivES.height = (height + borderPx) + 'px';
                    highLightDivES.opacity = 1;
                }
            }
        }
    }
    function gotoGuidedTourStep(stepIndex) {
        var nSteps = tourSteps.length;
        if (stepIndex < 0) { stepIndex = nSteps - 1; } else if (stepIndex >= nSteps) { stepIndex = 0; }
        hideHighLight(true);
        var prevDisplay = stepIndex == 0 ? "none" : "inline-block";
        var nextDisplay = stepIndex < nSteps - 1 ? "inline-block" : "none";
        prevStepButton.GetHTMLElement().style.display = prevDisplay;
        nextStepButton.GetHTMLElement().style.display = nextDisplay;
        firstStetButton.GetHTMLElement().style.display = prevDisplay;
        lastStepButton.GetHTMLElement().style.display = nextDisplay;
        curTourStep = stepIndex;
        var step = tourSteps[stepIndex];
        titleDiv.GetHTMLElement().innerHTML = '[ ' + (stepIndex + 1) + '/' + nSteps + ' ] ' + step.title;
        contentDiv.GetHTMLElement().innerHTML = step.content;
        step.action();
        tryStartnextStepTimer();
    }
    function createGuidedTour() {
        isAutoTour = isPlaying = false;
        if (tf.dom.GetHTMLElementFrom(settings.playButtonContainer)) {
            var playButtonToolTip = tf.js.GetNonEmptyString(settings.playButtonToolTip, "Take a guided tour");
            playButton = new tf.ui.TextBtn({ style: playButtonClass, label: "Guided Tour", dim: "1.4rem", tooltip: playButtonToolTip, onClick: playTour });
            styles.ApplyStyleProperties(playButton, playButtonStyles);
            addRemoveOpacityTransition(playButton, true);
            settings.playButtonContainer.AddContent(playButton);
        }
        if (fullScreenDiv == undefined) { fullScreenDiv = new tf.ui.FullScreenDiv({ onResize: onFullScreenResize }); }
        else { fullScreenDiv.AddResizeListener(onFullScreenResize); }
        topWrapperDiv = new tf.dom.Div({ cssClass: guidedWrapperCSSClass });
        titleDiv = new tf.dom.Div({ cssClass: guidedTitleCSSClass });
        contentDiv = new tf.dom.Div({ cssClass: guidedContentCSSClass });
        buttonsDiv = new tf.dom.Div({ cssClass: guidedButtonsCSSClass });
        topWrapperDiv.AddContent(titleDiv, contentDiv, buttonsDiv);
        firstStetButton = styles.AddButtonDivRightMargin(
            new tf.ui.SvgGlyphBtn({
                style: true, glyph: tf.styles.SvgGlyphArrowToStartName, onClick: function () {
                    stopnextStepTimer();
                    gotoGuidedTourStep(0);
                }, tooltip: "First step in Tour", dim: buttonDim
            })
        );
        lastStepButton = styles.AddButtonDivRightMargin(
            new tf.ui.SvgGlyphBtn({
                style: true, glyph: tf.styles.SvgGlyphArrowToEndName, onClick: function () {
                    stopnextStepTimer();
                    gotoGuidedTourStep(tourSteps.length - 1);
                }, tooltip: "Last step in Tour", dim: buttonDim
            })
        );
        prevStepButton = styles.AddButtonDivRightMargin(
            new tf.ui.SvgGlyphBtn({
                style: true, glyph: tf.styles.SvgGlyphLeftArrowName, onClick: function () {
                    stopnextStepTimer();
                    onPrevNextTourStep(true);
                }, tooltip: "Previous step in Tour", dim: buttonDim
            })
        );
        nextStepButton = styles.AddButtonDivRightMargin(
            new tf.ui.SvgGlyphBtn({
                style: true, glyph: tf.styles.SvgGlyphRightArrowName, onClick: function () {
                    stopnextStepTimer();
                    onPrevNextTourStep(false);
                }, tooltip: "Next step in Tour", dim: buttonDim
            })
        );
        var leftSideDiv = new tf.dom.Div(), leftSideDivE = leftSideDiv.GetHTMLElement(), leftSideDivES = leftSideDivE.style;
        leftSideDivES.position = "absolute";
        leftSideDivES.left = "2px";
        leftSideDivES.top = "2px";
        var pauseButton = styles.AddButtonDivLeftRightMargins(
            new tf.ui.SvgGlyphBtn({
                style: true, glyph: tf.styles.SvgGlyphPauseName, onClick: function () {
                    stopnextStepTimer();
                    pauseTour();
                }, tooltip: "Pause Tour", dim: buttonDim
            })
        );
        var trailToolTip = ' advance to the next step of the tour';
        autoTourButton = styles.AddButtonDivRightMargin(new tf.ui.SvgGlyphToggleBtn({
            style: true, onClick: onToggleAutoTour, dim: buttonDim, isToggled: !isAutoTour,
            glyph: tf.styles.SvgGlyphAutoRepeatName, tooltip: "Manually" + trailToolTip, toggledGlyph: tf.styles.SvgGlyphNoAutoRepeatName, toggledTooltip: "Automatically" + trailToolTip
        }));
        leftSideDiv.AddContent(pauseButton, autoTourButton);
        buttonsDiv.AddContent(leftSideDiv, firstStetButton, lastStepButton, prevStepButton, nextStepButton);
        highLightDiv = new tf.dom.Div({ cssClass: hilightDivCSSClass });
        addRemoveHilightOpacity(true);
        curTourStep = settings.curTourStep != undefined ? settings.curTourStep : 0;
    }
    function addToFullScreenDiv() {
        var fullTopDiv = fullScreenDiv.GetTopDiv();
        fullTopDiv.ClearContent();
        fullTopDiv.AddContent(topWrapperDiv, highLightDiv);
    }
    function initialize() {
        styles = tf.GetStyles();
        fullScreenDiv = settings.fullScreenDiv;
        tourSteps = settings.tourSteps;
        onPlayCB = tf.js.GetFunctionOrNull(settings.onPlay);
        onPauseCB = tf.js.GetFunctionOrNull(settings.onPause);
        playButtonClass = settings.playButtonClass != undefined ? settings.playButtonClass : true;
        playButtonStyles = settings.playButtonStyles != undefined ? settings.playButtonStyles : { position: "absolute", left: "1rem", top: "1rem" };
        buttonDim = settings.buttonDim != undefined ? settings.buttonDim : "1rem";
        opacityTransitionCSSClass = settings.opacityTransitionCSSClass;
        hilightDivCSSClass = settings.hilightDivCSSClass;
        guidedWrapperCSSClass = settings.guidedWrapperCSSClass;
        guidedTitleCSSClass = settings.guidedTitleCSSClass;
        guidedContentCSSClass = settings.guidedContentCSSClass;
        guidedButtonsCSSClass = settings.guidedButtonsCSSClass;
        createGuidedTour();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.ui.TimeAnimationControl = function (settings) {
    var theThis, styles, container;
    var animationDisplayControl, minDate, maxDate, playPauseButton, wrapTime, playbackSpeed, speedButton;
    var currentTimeElem, scrubSlider;
    var timer, nMinutesInterval;
    var lastElapsedTime, lastElapsedTimeChecked;
    var totalTime;
    var playPauseEventName, eventDispatcher;
    var newCurrentTime;
    var isShowing;
    this.AddListener = function (callBack) { return eventDispatcher.AddListener(playPauseEventName, callBack); }
    this.GetIsShowing = function () { return isShowing; }
    this.Show = function (showBool) { return showAnimationControl(showBool); }
    this.SetMinMaxDate = function (minDateSet, maxDateSet) {
        newCurrentTime = new Date(minDateSet);
        minDate = minDateSet;
        maxDate = maxDateSet;
        totalTime = maxDate.getTime() - minDate.getTime();
        setLimit(totalTime)
        onStop();
    }
    this.Pause = function () { if (!theThis.GetIsPaused()) { theThis.OnPlayPause(); } }
    this.OnUpdate = function () { return updateCurrentTimeElem(); }
    this.GetIsPaused = function () { return timer.GetIsPaused(); }
    this.OnPlayPause = function () { return onPlayPause(); }
    this.OnStop = function () { return onStop(); }
    this.GetElapsedTime = function () { return lastElapsedTimeChecked; }
    this.GetCurrentDateTime = function () { return newCurrentTime; }
    function onNotify(verb, attrs) {
        eventDispatcher.Notify(verb, tf.js.ShallowMerge(attrs, { sender: theThis, isPaused: timer.GetIsPaused() }));
    }
    function onPlayPause() {
        var nextPaused = !timer.GetIsPaused();
        playPauseButton.SetIsToggled(nextPaused)
        timer.Pause(nextPaused);
        onNotify(playPauseEventName);
    }
    function onStop() { timer.Pause(true); timer.SetElapsedTime(0); playPauseButton.SetIsToggled(true); drawFrame(); }
    function onToggleAutoRepeat() { timer.SetWrap(wrapTime = !wrapTime); }
    function updateSpeedButtonLabel() { if (!!speedButton) { speedButton.SetText(playbackSpeed + 'x'); } }
    function onSpeedButtonClicked() { if ((playbackSpeed *= 10) > 100) { playbackSpeed = 1; } timer.SetSpeed(playbackSpeed); updateSpeedButtonLabel(); }
    function createAnimationControl() {
        var rightMarginPX = 8;
        var topStr = "3.5rem";
        var marginStr = rightMarginPX + "px";
        var style = {
            display: "block", overflow: "hidden",
            position: "absolute", right: marginStr, top: topStr, fontSize: "1.8em", backgroundColor: "rgba(255,255,255,0.75)", borderRadius: "8px", border: "2px solid navy",
            "tf-shadow": [0, 0, 4, "rgba(0,0,0,0.6)"], zIndex: 2, textAlign: "left", width: "24rem"
        };
        var lightBool = true;
        var buttonDim = "1.0em", textDim = buttonDim;
        var topDiv = new tf.dom.Div({ cssClass: styles.unPaddedBlockDivClass });
        speedButton = new tf.ui.TextBtn({ style: true, label: "", dim: buttonDim, tooltip: "Select playback speed", onClick: onSpeedButtonClicked });
        updateSpeedButtonLabel();
        speedButton.GetHTMLElement().style.minWidth = "3rem";
        var autoRepeatButton = new tf.ui.SvgGlyphToggleBtn({
            style: lightBool, onClick: onToggleAutoRepeat, dim: buttonDim, isToggled: wrapTime,
            glyph: tf.styles.SvgGlyphAutoRepeatName, tooltip: "Auto-repeat", toggledGlyph: tf.styles.SvgGlyphNoAutoRepeatName, toggledTooltip: "Auto-repeat"
        });
        playPauseButton = new tf.ui.SvgGlyphToggleBtn({
            style: lightBool, onClick: onPlayPause, dim: buttonDim, isToggled: false,
            glyph: tf.styles.SvgGlyphPauseName, tooltip: "Pause", toggledGlyph: tf.styles.SvgGlyphPlayName, toggledTooltip: "Play"
        });
        var stopButton = new tf.ui.SvgGlyphBtn({ style: lightBool, glyph: tf.styles.SvgGlyphStopName, onClick: onStop, tooltip: "Stop", dim: buttonDim });
        var currentTimeDivStyle = {
            verticalAlign: "middle",
            borderLeft: "1px solid #003377",
            padding: "6px",
            paddingBottom: "2px",
            display: "inline-block",
            cursor: "default",
            overflow: "hidden",
            textOverflow: "ellipsis",
            maxWidth: "calc(100% - 14px)",
            backgroundColor: "transparent",
            background: "none",
            textAlign: "center"
        };
        var currentTimeDiv = new tf.dom.Div();
        currentTimeElem = currentTimeDiv.GetHTMLElement();
        styles.ApplyStyleProperties(currentTimeDiv, currentTimeDivStyle);
        topDiv.AddContent(
            styles.AddButtonDivMargins(speedButton),
            styles.AddButtonDivRightMargin(stopButton),
            styles.AddButtonDivRightMargin(playPauseButton),
            styles.AddButtonDivRightMargin(autoRepeatButton),
            styles.AddButtonDivRightMargin(currentTimeElem));
        var barDiv = new tf.dom.Div({ cssClass: styles.unPaddedBlockDivClass });
        var barStyle = { overflow: "hidden", borderTop: "1px solid #003377" };
        styles.ApplyStyleProperties(barDiv, barStyle);
        scrubSlider = new tf.ui.CanvasSlider(0, "1.5rem", false);
        var scrubSliderElem = scrubSlider.GetHTMLElement();
        scrubSlider.SetOnClickListener(function (sender, pos01) {
            var elapsedTime = totalTime * pos01;
            timer.SetElapsedTime(elapsedTime);
            drawFrame();
            scrubSlider.SetPos01(pos01);
            if (timer.GetIsPaused()) {
                onNotify(playPauseEventName, { isSeek: true });
            }
        }, theThis);
        scrubSliderElem.title = 'Click to change time';
        scrubSliderElem.style.width = "calc(100% - 2px)";
        scrubSliderElem.style.display = "block";
        barDiv.AddContent(scrubSlider);
        topDiv.AddContent(barDiv);
        styles.ApplyStyleProperties(animationDisplayControl = topDiv, style);
        animationDisplayControl.AppendTo(container);
        showAnimationControl(false);
    }
    function updateCurrentTimeElem() {
        lastElapsedTimeChecked = timer.GetElapsedTime();
        if (!!currentTimeElem && !!minDate) {
            var doUpdate = lastElapsedTime == undefined;
            if (!doUpdate) { doUpdate = Math.abs(lastElapsedTimeChecked - lastElapsedTime) > 999; }
            if (doUpdate) {
                newCurrentTime = new Date();
                lastElapsedTime = lastElapsedTimeChecked;
                newCurrentTime.setTime(minDate.getTime() + lastElapsedTimeChecked);
                var timeStamp = tf.js.GetTimeStampFromDate(newCurrentTime);
                timeStamp = timeStamp.substring(0, 19);
                currentTimeElem.innerHTML = timeStamp;
                scrubSlider.SetPos01(totalTime != 0 ? lastElapsedTimeChecked / totalTime : 0);
                //logConsole(timeStamp);
            }
        }
    }
    function drawFrame() {
        updateCurrentTimeElem();
    }
    function showAnimationControl(showBool) { styles.ChangeOpacityVisibilityClass(animationDisplayControl, showBool); isShowing = !!showBool; }
    function setLimit(nMilliseconds) {
        timer.SetLimit(totalTime = nMilliseconds);
    }
    function createTimer() { timer = new tf.helpers.Timer(); timer.SetSpeed(playbackSpeed); timer.SetLimit(totalTime = 30 * 1000 * 60); timer.SetWrap(wrapTime = true); timer.Pause(true); }
    function initialize() {
        isShowing = false;
        newCurrentTime = new Date();
        playPauseEventName = "playpause";
        eventDispatcher = new tf.events.MultiEventNotifier({ eventNames: [playPauseEventName] });
        styles = tf.GetStyles();
        container = settings.container;
        playbackSpeed = 1;
        createTimer();
        createAnimationControl();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.ui.DateTimePicker = function (settings) {
    var theThis, styles, curParent, buttonDim, pickerStyle, buttonClasses, buttonSelectedClasses, onOpenMenuCB;
    var topDiv, datePicker, dateButton, hourMenu, hourButton, hourAMPMButton;
    var currentMenu, menuContainer;
    var dateForPicker, hourForMenu, name0HourStr, isAM, hourButtonLabel;
    var openEventName, eventDispatcher;
    this.AddOpenListener = function (callBack) { return eventDispatcher.AddListener(openEventName, callBack); }
    this.GetIsOpen = function () { return currentMenu != undefined; }
    this.CloseIfOpen = function () { return closeCurrentMenu(); }
    this.OnResize = function () { return updateMenuPositions(); }
    this.SetDateTime = function (dateSet) { return setDateForDatePicker(dateSet); }
    this.GetDateTime = function () { return getDateFromDatePicker(); }
    this.GetHTMLElement = function () { return topDiv.GetHTMLElement(); }
    this.GetTopDiv = function () { return topDiv; }
    function closeCurrentMenu() {
        if (!!currentMenu) {
            currentMenu.Detach();
            currentMenu = undefined;
            repaintButtons();
        }
    }
    function closeCurrentMenuAndCheck(thisMenu) { var isCurrent = currentMenu == thisMenu; closeCurrentMenu(); return isCurrent; }
    function openMenu(theMenu, styleSet) {
        closeCurrentMenu();
        if (!!theMenu) {
            (currentMenu = theMenu).AppendTo(menuContainer, styleSet);
            repaintButtons();
            if (!!onOpenMenuCB) { onOpenMenuCB({ sender: theThis }); }
            eventDispatcher.Notify(openEventName, { sender: theThis });
        }
    }
    function repaintButtons() {
        hourButton.SetStyle(currentMenu == hourMenu ? buttonSelectedClasses : buttonClasses);
        dateButton.SetStyle(currentMenu == datePicker ? buttonSelectedClasses : buttonClasses);
    }
    function updateMenuPositions() {
        var menuStyles;
        if (currentMenu == datePicker) { menuStyles = calcDatePickerStyle(); }
        else if (currentMenu == hourMenu) { menuStyles = calcHourMenuStyle(); }
        if (menuStyles != undefined) { styles.ApplyStyleProperties(currentMenu, menuStyles); }
    }
    function calcDatePickerStyle() {
        var targetRect = topDiv.GetHTMLElement().getBoundingClientRect();
        var topStr = targetRect.bottom + 'px';
        return { position: "absolute", left: targetRect.left + "px", top: topStr, zIndex: 10 };
    }
    function onDateButtonClicked() {
        if (!closeCurrentMenuAndCheck(datePicker)) {
            datePicker.SetDate(dateForPicker);
            openMenu(datePicker, calcDatePickerStyle());
        }
    }
    function calcHourMenuStyle() {
        var targetRect = hourButton.GetHTMLElement().getBoundingClientRect();
        var topStr = targetRect.bottom + 'px';
        return { position: "absolute", left: targetRect.left + 'px', top: topStr, zIndex: 10, fontSize: "1rem" };
    }
    function onHourButtonClicked() {
        if (!closeCurrentMenuAndCheck(hourMenu)) {
            openMenu(hourMenu, calcHourMenuStyle());
        }
    }
    function setDateButtonLabel() { if (!!dateButton) { dateButton.SetText(tf.js.GetMonthDayYearStr(dateForPicker)); } }
    function setHourButtonLabel() { if (!!hourButton) { hourButton.SetText(hourButtonLabel); } }
    function setHourAMPMButtonLabel() { if (!!hourAMPMButton) { hourAMPMButton.SetText(isAM ? 'am' : 'pm'); } }
    function onDatePickerDateClicked(notification) { dateForPicker = notification.date; closeCurrentMenu(); setDateButtonLabel(); }
    function onHourMenuClicked(notification) { hourForMenu = parseInt(notification.text, 10); hourButtonLabel = notification.text; closeCurrentMenu(); setHourButtonLabel(); }
    function onHourAMPMButtonClicked() { closeCurrentMenu(); isAM = !isAM; setHourAMPMButtonLabel(); }
    function getHour0to12(date) {
        var hours, isAM = true;
        if (!!date) { var hours = date.getHours(); if (hours > 12) { hours -= 12; isAM = false; } var minutes = date.getMinutes(); } else { hours = 0; }
        return { hours: hours, isAM: isAM };
    }
    function setDateForDatePicker(newDate) {
        closeCurrentMenu();
        var g = getHour0to12(newDate);
        dateForPicker = new Date(newDate.getFullYear(), newDate.getMonth(), newDate.getDate());
        hourForMenu = g.hours;
        hourButtonLabel = g.hours > 0 ? '' + g.hours : name0HourStr;
        isAM = g.isAM;
        //calcStartDate();
        setDateButtonLabel();
        setHourButtonLabel();
        setHourAMPMButtonLabel();
    }
    function getDateFromDatePicker() {
        var calcHours = hourForMenu; if (!isAM) { calcHours += 12; }
        var calcMins = 0;
        var startDate = new Date(dateForPicker.getFullYear(), dateForPicker.getMonth(), dateForPicker.getDate(), calcHours, calcMins, 0, 0);
        var startDateStr = tf.js.GetTimeStampFromDate(startDate);
        return { startDate: startDate, startDateStr: startDateStr };
    }
    function createControl() {
        datePicker = new tf.ui.DatePicker({ onClick: onDatePickerDateClicked });
        dateButton = new tf.ui.TextBtn({ style: buttonClasses, label: "", dim: buttonDim, tooltip: "Select date", onClick: onDateButtonClicked });
        setDateButtonLabel();
        var hourItems = [];
        for (var i = 0 ; i < 12 ; ++i) { var text = i == 0 ? name0HourStr : '' + i; hourItems.push({ text: text, toolTip: 'Select hour ' + text }); }
        hourMenu = new tf.ui.QuickMenu({ onClick: onHourMenuClicked, items: hourItems });
        hourButton = new tf.ui.TextBtn({ style: buttonClasses, label: "", dim: buttonDim, tooltip: "Select hour", onClick: onHourButtonClicked });
        setHourButtonLabel();
        var hourButtonES = hourButton.GetHTMLElement().style;
        hourButtonES.minWidth = "1.4rem";
        hourButtonES.textAlign = "right";
        hourAMPMButton = new tf.ui.TextBtn({ style: buttonClasses, label: "", dim: buttonDim, tooltip: "Select AM/PM", onClick: onHourAMPMButtonClicked });
        setHourAMPMButtonLabel();
        topDiv = new tf.dom.Div({ cssClass: styles.unPaddedBlockDivClass });
        styles.ApplyStyleProperties(topDiv, pickerStyle)
        topDiv.AddContent(dateButton, hourButton, hourAMPMButton);
    }
    function initialize() {
        styles = tf.GetStyles();
        openEventName = "open";
        eventDispatcher = new tf.events.MultiEventNotifier({ eventNames: [openEventName] });
        name0HourStr = '0/12';
        pickerStyle = settings.style != undefined ? settings.style : { borderRadius: "4px", padding: "2px", border: "1px solid #bfbfbf", color: "white", backgroundColor: "#61788c", textAlign: "left", position: 'relative' };
        buttonDim = settings.buttonDim != undefined ? settings.buttonDim : "1rem";
        buttonClasses = settings.buttonClasses != undefined ? settings.buttonClasses : true;
        buttonSelectedClasses = settings.buttonSelectedClasses != undefined ? settings.buttonSelectedClasses : false;
        menuContainer = settings.menuContainer;
        onOpenMenuCB = tf.js.GetFunctionOrNull(settings.onOpenMenu);
        createControl();
        setDateForDatePicker(new Date());
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.ui.QuickTextMenus = function (settings) {
    var theThis, styles, onOpenMenuCB, onSelectCB, items, menuContainer, currentMenu, itemsByName;
    var buttonDim, buttonClasses, buttonSelectedClasses;
    var openEventName, eventDispatcher;
    this.AddOpenListener = function (callBack) { return eventDispatcher.AddListener(openEventName, callBack); }
    this.GetIsOpen = function () { return currentMenu != undefined; }
    this.CloseIfOpen = function () { return closeCurrentMenu(); }
    this.OnResize = function () { return updateMenuPositions(); }
    this.GetItem = function (name) { return itemsByName[name]; }
    function closeCurrentMenu() { if (!!currentMenu) { currentMenu.menu.Detach(); currentMenu = undefined; repaintButtons(); } }
    function closeCurrentMenuAndCheck(thisMenu) { var isCurrent = currentMenu == thisMenu; closeCurrentMenu(); return isCurrent; }
    function openMenu(theMenu, styleSet) {
        closeCurrentMenu();
        if (!!theMenu) {
            (currentMenu = theMenu).menu.AppendTo(menuContainer, styleSet);
            repaintButtons();
            if (!!onOpenMenuCB) { onOpenMenuCB({ sender: theThis, isOpenMenu: true }); }
            eventDispatcher.Notify(openEventName, { sender: theThis });
        }
    }
    function repaintButtons() {
        for (var i in itemsByName) {
            var thisItem = itemsByName[i], isCurrent = currentMenu == thisItem;
            if (thisItem.isCurrent != isCurrent) {
                thisItem.button.SetStyle(isCurrent ? buttonSelectedClasses : buttonClasses);
                thisItem.isCurrent = isCurrent;
            }
        }
    }
    function updateMenuPositions() { if (!!currentMenu) { styles.ApplyStyleProperties(currentMenu.menu, calcMenuStyle(currentMenu.name)); } }
    function calcMenuStyle(name) {
        var item = itemsByName[name];
        var style = {};
        if (!!item) {
            var button = item.button;
            var targetRect = button.GetHTMLElement().getBoundingClientRect();
            var topStr = targetRect.bottom + 'px';
            style = { position: "absolute", left: targetRect.left + 'px', top: topStr, zIndex: 10, fontSize: "1rem" };
        }
        return style;
    }
    function getOnButtonClicked(name) {
        return function () {
            var item = itemsByName[name];
            if (!!item) {
                if (!closeCurrentMenuAndCheck(item)) {
                    openMenu(item, calcMenuStyle(name));
                }
            }
        };
    }
    function getOnMenuItemClicked(name) {
        return function (notification) {
            var item = itemsByName[name];
            if (!!item) {
                var button = item.button;
                var newText = notification.item.label != undefined ? notification.item.label : notification.text, curText = button.GetText();
                closeCurrentMenu();
                if (newText != curText) {
                    button.SetText(newText);
                    if (!!onSelectCB) { onSelectCB({ sender: theThis, isSelect: true, menuName: name, text: notification.text, menuitem: item, item: notification.item, index: notification.index }); }
                }
            }
            else { console.log('click without menu: ' + name); }
        }
    }
    function createButtonsAndMenus() {
        itemsByName = {};
        for (var i in items) {
            var item = settings.items[i];
            if (tf.js.GetIsValidObject(item)) {
                var name = item.name;
                if (tf.js.GetIsNonEmptyString(name)) {
                    if (itemsByName[name] == undefined) {
                        var itemItems = item.items;
                        if (tf.js.GetIsNonEmptyArray(itemItems)) {
                            var selIndex = item.selIndex != undefined ? item.selIndex : 0;
                            if (selIndex >= itemItems.length) { selIndex = 0; }
                            var buttonText = itemItems[selIndex].label != undefined ? itemItems[selIndex].label : itemItems[selIndex].text;
                            var thisMenu = new tf.ui.QuickMenu({ onClick: getOnMenuItemClicked(name), items: itemItems });
                            var thisButton = new tf.ui.TextBtn({
                                style: buttonClasses, label: buttonText, dim: buttonDim,
                                tooltip: tf.js.GetIsNonEmptyString(item.toolTip) ? item.toolTip : buttonText, onClick: getOnButtonClicked(name)
                            });
                            var thisItem = { name: name, menu: thisMenu, button: thisButton, isCurrent: false };
                            itemsByName[name] = thisItem;
                        }
                    }
                    else {
                        console.log('duplicate menu name: ' + name);
                    }
                }
            }
        }
    }
    function initialize() {
        styles = tf.GetStyles();
        openEventName = "open";
        eventDispatcher = new tf.events.MultiEventNotifier({ eventNames: [openEventName] });
        buttonDim = settings.buttonDim != undefined ? settings.buttonDim : "1rem";
        buttonClasses = settings.buttonClasses != undefined ? settings.buttonClasses : true;
        buttonSelectedClasses = settings.buttonSelectedClasses != undefined ? settings.buttonSelectedClasses : false;
        items = tf.js.GetIsNonEmptyArray(settings.items) ? settings.items : [];
        onOpenMenuCB = tf.js.GetFunctionOrNull(settings.onOpenMenu);
        onSelectCB = tf.js.GetFunctionOrNull(settings.onSelect);
        menuContainer = settings.menuContainer;
        createButtonsAndMenus();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: cookies.js
/*\
|*|
|*|  :: cookies.js ::
|*|
|*|  A complete cookies reader/writer framework with full unicode support.
|*|
|*|  Revision #1 - September 4, 2014
|*|
|*|  https://developer.mozilla.org/en-US/docs/Web/API/document.cookie
|*|  https://developer.mozilla.org/User:fusionchess
|*|
|*|  This framework is released under the GNU Public License, version 3 or later.
|*|  http://www.gnu.org/licenses/gpl-3.0-standalone.html
|*|
|*|  Syntaxes:
|*|
|*|  * docCookies.setItem(name, value[, end[, path[, domain[, secure]]]])
|*|  * docCookies.getItem(name)
|*|  * docCookies.removeItem(name[, path[, domain]])
|*|  * docCookies.hasItem(name)
|*|  * docCookies.keys()
|*|
\*/
tf.helpers.DocCookies = {
    getItem: function (sKey) {
        if (!sKey) { return null; }
        return decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;
    },
    setItem: function (sKey, sValue, vEnd, sPath, sDomain, bSecure) {
        if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) { return false; }
        var sExpires = "";
        if (vEnd) {
            switch (vEnd.constructor) {
                case Number:
                    sExpires = vEnd === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" : "; max-age=" + vEnd;
                    break;
                case String:
                    sExpires = "; expires=" + vEnd;
                    break;
                case Date:
                    sExpires = "; expires=" + vEnd.toUTCString();
                    break;
            }
        }
        document.cookie = encodeURIComponent(sKey) + "=" + encodeURIComponent(sValue) + sExpires + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "") + (bSecure ? "; secure" : "");
        return true;
    },
    removeItem: function (sKey, sPath, sDomain) {
        if (!tf.helpers.DocCookies.hasItem(sKey)) { return false; }
        document.cookie = encodeURIComponent(sKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT" + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "");
        return true;
    },
    hasItem: function (sKey) {
        if (!sKey) { return false; }
        return (new RegExp("(?:^|;\\s*)" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(document.cookie);
    },
    keys: function () {
        var aKeys = document.cookie.replace(/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g, "").split(/\s*(?:\=[^;]*)?;\s*/);
        for (var nLen = aKeys.length, nIdx = 0; nIdx < nLen; nIdx++) { aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]); }
        return aKeys;
    }
};

// SOURCE FILE: routingservice.js
/*
enum class TurnInstruction : unsigned char
{
    NoTurn = 0,
    1   GoStraight,
    2   TurnSlightRight,
    3   TurnRight,
    4   TurnSharpRight,
    5   UTurn,
    6   TurnSharpLeft,
    7   TurnLeft,
    8   TurnSlightLeft,
    9   ReachViaLocation,
    10  HeadOn,
    11  EnterRoundAbout,
    12  LeaveRoundAbout,
    13  StayOnRoundAbout,
    14  StartAtEndOfStreet,
    15  ReachedYourDestination,
    16  EnterAgainstAllowedDirection,
    17  LeaveAgainstAllowedDirection,
    InverseAccessRestrictionFlag = 127,
    AccessRestrictionFlag = 128,
    AccessRestrictionPenalty = 129
};
*/
tf.services.TranslateRoutingInstruction = function(routingInstruction) {
    var instructions = {};
  
    var instructionNumber = parseInt(routingInstruction, 10);
    var instruction = instructionNumber & 63;
    //var flag = (instructionNumber >> 7);
    var instructionStr = '' + instruction;
    instructions["0"] = "No turn";
    instructions["1"] = "Straight";
    instructions["2"] = "Slight right turn";
    instructions["3"] = "Right turn ";
    instructions["4"] = "Sharp right turn";
    instructions["5"] = "U-Turn";
    instructions["6"] = "Sharp left turn";
    instructions["7"] = "Left turn";
    instructions["8"] = "Slight left turn";
    instructions["9"] = "Reach via location";
    instructions["10"] = "Head on";
    instructions["11"] = "Enter round about";
    instructions["12"] = "Leave round about";
    instructions["13"] = "Stay in round about";
    instructions["14"] = "Start at end of street";
    instructions["15"] = "Enter against allowed direction";
    instructions["16"] = "Leave against allowed direction";
    return instructions[instructionStr];
}
/**
 * A callback function that can be used in the creation of TerraFly API Service requests, such as
 * [Raster Source Lists]{@link tf.services.RasterSourceList} and [Routing]{@link tf.services.Routing}
 * @public
 * @callback tf.types.ServiceCallBack
 * @param {object} serviceObject - the object returned by the TerraFly service, its contents depend on the type of service being used
 * @returns {void} - | {@link void} no return value
 */
/**
 * Settings used in the creation of [Base Service]{@link tf.services.BaseJSONService} instances
 * @private
 * @typedef {object} tf.types.BaseServiceSettings
 * @property {string} serviceURL - the service URL complete with parameters
 * @property {boolean} useRedirect - if <b>true</b> the service is accessed with a redirect proxy, defaults to {@link void}
 * @property {boolean} useAjax - if <b>true</b> the service is accessed via ajax, otherwise JSON is used, defaults to {@link void}
 * @property {tf.types.ServiceCallBack} callBack - to receive the object retrieved from the service
 * @property {object} optionalScope - optional JavaScript scope used with <b>callBack</b>
*/
/**
 * @public
 * @class
 * @summary - Base Service implements functionality common to TerraFly API Service instances
 * @param {tf.types.BaseServiceSettings} settings - creation settings
*/
tf.services.BaseJSONService = function (settings) {
    var theThis, downloadObj, callBack, optionalScope, data, filterData, wasCancelled;
    /**
     * @public
     * @function
     * @summary - Checks if the request is in progress (was sent, but a response has not been received)
     * @returns {boolean} - | {@link boolean } <b>true</b> if the request is in progress, <b>false</b> otherwise
    */
    this.GetIsInProgress = function () { return !!downloadObj && downloadObj.GetIsInProgress(); }
    /**
     * @public
     * @function
     * @summary - Cancels an ongoing request
     * @returns {void} - | {@link void} no return value
    */
    this.Cancel = function () {
        //console.log('cancelled');
        return cancel();
    }
    this.WasCancelled = function () { return wasCancelled; }
    function cancel() { if (downloadObj) { downloadObj.Cancel(); downloadObj = null; wasCancelled = true; } }
    function doCalBack() { callBack.call(optionalScope, data); data = null; }
    function privateCallBack(notification) {
        data = notification.data;
        if (!!filterData) { data = filterData(data); }
        if (!!data) { data.requestProps = notification.requestProps; }
        setTimeout(doCalBack, 0);
    }
    function initialize() {
        wasCancelled = false;
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsNonEmptyString(settings.serviceURL)) {
            if (!!(callBack = tf.js.GetFunctionOrNull(settings.callBack))) {
                filterData = tf.js.GetFunctionOrNull(settings.filterData);
                optionalScope = settings.optionalScope;
                if (settings.skipRemoteService) {
                    data = { failed: true, requestProps: settings.requestProps };
                    setTimeout(function () { doCalBack(); }, 0); }
                else {
                    if (settings.useAjax) {
                        downloadObj = new tf.ajax.GetRequest({ requestProps: settings.requestProps, url: settings.serviceURL, useRedirect: settings.useRedirect, autoSend: true, optionalScope: theThis, onDataLoaded: privateCallBack });
                    }
                    else {
                        downloadObj = new tf.ajax.JSONGet();
                        downloadObj.Request(settings.serviceURL, privateCallBack, theThis, settings.requestProps, settings.useRedirect, settings.overrideMimeType, settings.JSONDecode);
                    }
                }
            }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * The accuracy of the result returned by the [Geocoder Service]{@link tf.services.Geocoder}, one of:<br>
 * 0 - Service failed,<br>
 * 1 - Exact match,<br>
 * 2 - Approx match - the program could not find the exact range, but found the nearest syntactic match or range,<br>
 * 3 - Zip center - the returned coordinate is the zip code center,<br>
 * 4 - City Center - the returned coordinate is the city center,<br>
 * 5 - Not Found - the address could not be located
 * @public
 * @typedef {number} tf.types.geocoderAccuracy
 */
/**
 * Object retrieved by [Geocoder Service]{@link tf.services.Geocoder} instances
 * @public
 * @typedef {object} tf.types.GeocoderData
 * @property {tf.types.mapCoordinates} pointCoords - the retrieved coordinates
 * @property {tf.types.geocoderAccuracy} geocoderAccuracy - the accuracy of <b>pointCoords</b>
 * @property {string} errorMsg - if the service fails contains an error message, otherwise {@link void}
*/
/**
 * Settings used in the creation of [Geocoder Service]{@link tf.services.Geocoder} instances
 * @public
 * @typedef {object} tf.types.GeocoderSettings
 * @property {string} address - the address for which to retrieve map coordinates
 * @property {tf.types.ServiceCallBack} callBack - to receive a the object retrieved from the service
 * @property {object} optionalScope - optional JavaScript scope used with <b>callBack</b>
*/
/**
 * @public
 * @class
 * @summary - Geocoder Service instances are created to retrieve the map coordinates corresponding to a given address.
 * This service passes an instance of [GeocoderData]{@link tf.types.GeocoderData} to its callBack
 * @param {tf.types.GeocoderSettings} settings - creation settings
 * @extends {tf.services.BaseJSONService}
*/
tf.services.Geocoder = function (settings) {
    var theThis, callBack, optionalScope, localSettings;
    this.GetSettings = function () { return tf.js.ShallowMerge(localSettings); }
    function decode(httpRequest) {
        var data = { pointCoords: [0, 0], geocoderAccuracy: 0 };
        if (!!httpRequest && !!httpRequest.responseText) {
            var rawData = tf.helpers.XMLString2Object(httpRequest.responseText);
            if (tf.js.GetIsValidObject(data)) {
                if (tf.js.GetIsNonEmptyString(rawData.GeocoderErrorMsg)) {
                    data.errorMsg = rawData.GeocoderErrorMsg;
                }
                else {
                    data.pointCoords = [tf.js.GetLongitudeFrom(rawData.Longitude), tf.js.GetLongitudeFrom(rawData.Latitude)];
                    data.geocoderAccuracy = parseInt(rawData.GeocoderLevel, 10);
                }
            }
            //tf.GetDebug().LogIfTest(JSON.stringify(data));
        }
        return data;
    }
    function initialize() {
        localSettings = tf.js.ShallowMerge(settings);
        if (!!(callBack = tf.js.GetFunctionOrNull(localSettings.callBack))) {
            optionalScope = localSettings.optionalScope;
            var address = encodeURI(tf.js.GetNonEmptyString(localSettings.address));
            var geocoderServiceURL = "http://vn4.cs.fiu.edu/cgi-bin/geocoder.cgi?";
            localSettings.serviceURL = geocoderServiceURL + "street=" + address + "&filetype=.xml";
            localSettings.overrideMimeType = "text/xml";
            localSettings.JSONDecode = decode;
            //tf.GetDebug().LogIfTest("Geocoder: " + localSettings.serviceURL);
            tf.services.BaseJSONService.call(theThis, localSettings);
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.services.Geocoder, tf.services.BaseJSONService);
tf.services.TFReverseGeocoder = function (settings) {
    var theThis, callBack, optionalScope, localSettings;
    this.GetSettings = function () { return tf.js.ShallowMerge(localSettings); }
    function decode(httpRequest) {
        var data = !!httpRequest ? tf.js.GetNonEmptyString(unescape(httpRequest.responseText), undefined) : undefined
        return { pointCoords: settings.pointCoords, HTML: data };
    }
    function filterTFReverseGeocodeData(rawData) {
        var data = { success : false, sender: theThis };
        if (tf.js.GetIsValidObject(rawData) && tf.js.GetIsNonEmptyString(rawData.address)) {
            data.success = true;
            data = tf.js.ShallowMerge(data, rawData);
        }
        return data;
    }
    function initialize() {
        localSettings = tf.js.ShallowMerge(settings);
        if (!!(callBack = tf.js.GetFunctionOrNull(localSettings.callBack))) {
            optionalScope = localSettings.optionalScope;
            var strURL = "http://vn4.cs.fiu.edu/cgi-bin/reversegeocoder.cgi?Lat=" + settings.pointCoords[1] + "&Long=" + settings.pointCoords[0];
            if (settings.resolution != undefined) { strURL += "&Res=" + settings.resolution; }
            var usingJSON = !!settings.getJSON;
            if (tf.js.GetIsNonEmptyString(settings.vidParam)) { strURL += "&vid=" + settings.vidParam; }
            if (tf.js.GetIsNonEmptyString(settings.passThrough)) {
                var passThrough = settings.passThrough;
                if (passThrough.charAt(0) != "&") { passThrough = "&" + passThrough; }
                strURL += passThrough;
            }
            if (usingJSON) { strURL += '&filetype=.json'; }
            localSettings.serviceURL = strURL;
            if (usingJSON) {
                localSettings.filterData = filterTFReverseGeocodeData;
            }
            else {
                localSettings.overrideMimeType = "text/html";
                localSettings.JSONDecode = decode;
            }
            tf.services.BaseJSONService.call(theThis, localSettings);
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.services.TFReverseGeocoder, tf.services.BaseJSONService);
/**
 * Object retrieved by [Reverse Geocoder Service]{@link tf.services.ReverseGeocoder} instances
 * @public
 * @typedef {object} tf.types.ReverseGeocoderData
 * @property {boolean} success - <b>true</b> if the service succeeded, <b>false</b> otherwise
 * @property {tf.types.mapCoordinates} pointCoords - the coordinates associated with the address
 * @property {string} address - the street address
 * @property {string} stdAddress - the street address
 * @property {string} city - the city
 * @property {string} stdCity - the city
 * @property {string} stdState - the state
 * @property {string} stdZip - the zip code
 * @property {string} stdZipPlus - the zip code extension
*/
/**
 * Settings used in the creation of [Reverse Geocoder Service]{@link tf.services.ReverseGeocoder} instances
 * @public
 * @typedef {object} tf.types.ReverseGeocoderSettings
 * @property {tf.types.mapCoordinates} pointCoords - the coordinates for which an address will be retrieved
 * @property {tf.types.ServiceCallBack} callBack - to receive a the object retrieved from the service
 * @property {object} optionalScope - optional JavaScript scope used with <b>callBack</b>
*/
/**
 * @public
 * @class
 * @summary - Reverse Geocoder Service instances are created to retrieve the address corresponding to the given map coordinates.
 * This service passes an instance of [ReverseGeocoderData]{@link tf.types.ReverseGeocoderData} to its callBack
 * @param {tf.types.ReverseGeocoderSettings} settings - creation settings
 * @extends {tf.services.BaseJSONService}
*/
tf.services.ReverseGeocoder = function (settings) {
    var theThis, callBack, optionalScope, localSettings;
    this.GetSettings = function () { return tf.js.ShallowMerge(localSettings); }
    function filterReverseGeocodeData(rawData) {
        var data = { success : false, sender: theThis };
        if (tf.js.GetIsValidObject(rawData) && tf.js.GetIsArrayWithMinLength(rawData = rawData.features, 1)) {
            if (tf.js.GetIsValidObject(rawData = rawData[0].properties)){
                data.success = true;
                data.pointCoords = [tf.js.GetLongitudeFrom(rawData.lon), tf.js.GetLatitudeFrom(rawData.lat)];
                data.address = rawData.ADDR;
                data.city = rawData.CITY;
                data.stdAddress = rawData.STD_ADDR;
                data.stdCity = rawData.STD_CITY;
                data.stdState = rawData.STD_STATE;
                data.stdZip = rawData.STD_ZIP;
                data.stdZipPlus = rawData.STD_PLUS;
            }
        }
        return data;
    }
    function initialize() {
        localSettings = tf.js.ShallowMerge(settings);
        if (!!(callBack = tf.js.GetFunctionOrNull(localSettings.callBack)) && tf.js.GetIsArrayWithMinLength(localSettings.pointCoords, 2)) {
            optionalScope = localSettings.optionalScope;
            var lon = tf.js.GetLongitudeFrom(localSettings.pointCoords[0]);
            var lat = tf.js.GetLatitudeFrom(localSettings.pointCoords[1]);
            //var geocoderServiceURL = "http://vn4.cs.fiu.edu/cgi-bin/arquery.cgi?&tfaction=shortdisplayflash&numfind=1&category=firstamerican_points_2014&filetype=.json";
            var geocoderServiceURL = "http://vn4.cs.fiu.edu/cgi-bin/arquery.cgi?&tfaction=shortdisplayflash&numfind=1&category=firstamerican_points_2014&filetype=.json";
            localSettings.serviceURL = geocoderServiceURL + "&lat=" + lat + "&lon=" + lon;
            localSettings.filterData = filterReverseGeocodeData;
            //tf.GetDebug().LogIfTest("ReverseGeocoder: " + localSettings.serviceURL);
            tf.services.BaseJSONService.call(theThis, localSettings);
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.services.ReverseGeocoder, tf.services.BaseJSONService);
tf.services.GetDirectionModeFrom = function (modeSet, defaultMode, allowBus) {
    var mode = tf.js.GetNonEmptyString(modeSet, defaultMode);
    switch (mode = mode.toLowerCase()) {
        case tf.consts.routingServiceModeFoot:
        case tf.consts.routingServiceModeBicycle:
        case tf.consts.routingServiceModeCar:
            break;
        case tf.consts.routingServiceModeBus: if (!allowBus) { mode = defaultMode; } break;
        default: mode = defaultMode; break;
    }
    return mode;
};
/**
 * Settings used in the creation of [Routing Service]{@link tf.services.RoutingService} instances
 * @public
 * @typedef {object} tf.types.RoutingServiceSettings
 * @property {array<tf.types.mapCoordinates>} lineStringCoords - the given via point coordinates for routing, in [GeoJSON linestring format]{@link tf.types.GeoJSONGeometryType}, a maximum of 25 points can be used
 * @property {tf.types.routingServiceMode} mode - defaults to {@link tf.consts.routingServiceModeFoot}
 * @property {tf.types.mapCoordinates} coords - the given via point coordinates for locating or finding a nearest point, used in conjunction with <b>locateOnly<b> or <b>nearestOnly</b>
 * @property {boolean} locateOnly - if set to <b>true</b> requests the location of the nearest node of the road network to the given <b>coords</b>, defaults to {@link void}, takes precedence over <b>nearestOnly</b>
 * @property {boolean} nearestOnly - if set to <b>true</b> requests the location of the nearest point in any street segment of the road network to the given <b>coords</b>, defaults to {@link void}
 * @property {boolean} findAlternatives - if set to <b>false</b> prevents the service from attempting to find alternative routes, defaults to <b>true</b>
 * @property {boolean} instructions - if set to <b>true</b> requests guidance instructions from the service, defaults to {@link void}
 * @property {tf.types.mapLevel} level - a map level, defaults to <b>18</b>
 * @property {tf.types.ServiceCallBack} callBack - to receive the object retrieved from the service
 * @property {object} optionalScope - optional JavaScript scope used with <b>callBack</b>
*/
/**
 * @public
 * @class
 * @summary - Routing Service instances are created to retrieve directions from the TerraFly Routing Service
 * @param {tf.types.RoutingServiceSettings} settings - creation settings
 * @extends {tf.services.BaseJSONService}
*/
tf.services.Routing = function (settings) {
    var theThis, localSettings;
    var serverURL, useDefaultServer;
    this.GetSettings = function () { return tf.js.ShallowMerge(localSettings); }
    function filterLocateNearestData(data) {
        if (tf.js.GetIsValidObject(data)) {
            if (data.status == 0 || data.status == 200) {
                if (tf.js.GetIsArrayWithMinLength(data.mapped_coordinate, 2)) {
                    var coords = data.mapped_coordinate;
                    var t = coords[0]; coords[0] = coords[1]; coords[1] = t;
                    data.mapped_coordinate = coords;
                }
                else {
                    data.status = 400;
                    data.status_message = "Invalid route";
                }
            }
        }
        return data;
    }
    function filterViaRouteData(data) {
        if (tf.js.GetIsValidObject(data)) {
            if ((data.status !== 0 && data.status !== 200) || ! tf.js.GetLooksLikeLineStringCoords(data.route_geometry)) {
                data.route_geometry = [];
            }
            else {
                var coords = data.route_geometry;
                for (var i in coords) { var c = coords[i], t = c[0]; c[0] = c[1]; c[1] = t; }
                var viaIndices = data.via_indices;
                if (tf.js.GetIsArrayWithMinLength(viaIndices, 2)) {
                    var len = viaIndices.length;
                    if (viaIndices[len - 1] == coords.length) {
                        //tf.GetDebug().LogIfTest('Routing service: fixing via indices');
                        for (var i = 1 ; i < len ; ++i) { viaIndices[i] -= 1; }
                    }
                }
            }
            data.sender = theThis;
        }
        else {
            data = { sender : theThis };
        }
        return data;
    }
    function getModeFrom(mode) {
        return tf.services.GetDirectionModeFrom(localSettings.mode, tf.consts.routingServiceModeFoot, false);
    }
    function initialize() {
        var callRemoteService = false;
        localSettings = tf.js.GetValidObjectFrom(settings);
        serverURL = tf.js.GetNonEmptyString(settings.serverURL, null);
        useDefaultServer = !serverURL;
    
        if (!!(localSettings.locateOnly || localSettings.nearestOnly)) {
            var coords = localSettings.coords;
            if (tf.js.GetIsArrayWithMinLength(coords, 2)) {
                var mode = getModeFrom(localSettings.mode);
                var serviceVerb = !!localSettings.locateOnly ? "/locate?" : "/nearest?";
                var strPoints = "loc=" + coords[1] + ',' + coords[0];
                if (useDefaultServer) {
                    localSettings.serviceURL = tf.consts.RoutingServiceURL + mode + serviceVerb + strPoints;
                }
                else {
                    localSettings.serviceURL = serverURL + serviceVerb + strPoints;
                }
                localSettings.filterData = filterLocateNearestData;
                callRemoteService = true;
            }
        }
        else {
            var coords = localSettings.lineStringCoords;
            if (tf.js.GetLooksLikeLineStringCoords(coords)) {
                var mode = getModeFrom(localSettings.mode);
                switch (mode = mode.toLowerCase()) {
                    case tf.consts.routingServiceModeFoot:
                    case tf.consts.routingServiceModeBicycle:
                    case tf.consts.routingServiceModeCar:
                        break;
                    default:
                        mode = tf.consts.routingServiceModeCar;
                        break;
                }
                var strPoints = "";
                var maxViaPoints = 25, nViaPoints = coords.length;
                var strLevel = "", strAlt = "", strInstructions = "";
                if (localSettings.level !== undefined) { var level = tf.js.GetLevelFrom(localSettings.level); strLevel = "&z=" + level; }
                if (tf.js.GetIsFalseNotUndefined(localSettings.findAlternatives)) { strAlt = "&alt=false"; }
                if (!!localSettings.instructions) { strInstructions = "&instructions=true"; }
                if (nViaPoints > maxViaPoints) { nViaPoints = maxViaPoints; }
                for (var i = 0 ; i < nViaPoints ; ++i) { var coord = coords[i]; strPoints += "&loc=" + coord[1] + "," + coord[0]; }
                if (useDefaultServer) {
                    localSettings.serviceURL = tf.consts.RoutingServiceURL + mode + "/viaroute?compression=false" + strPoints + strAlt + strInstructions;
                }
                else {
                    localSettings.serviceURL = serverURL + "/viaroute?compression=false" + strPoints + strAlt + strInstructions;
                }
                localSettings.filterData = filterViaRouteData;
                callRemoteService = true;
            }
        }
        //callRemoteService = false;
        localSettings.skipRemoteService = !callRemoteService;
        tf.services.BaseJSONService.call(theThis, localSettings);
        /*if (false && callRemoteService) {
            //tf.GetDebug().LogIfTest("Routing: " + localSettings.serviceURL);
            tf.services.BaseJSONService.call(theThis, localSettings);
        }
        else {
            var callBack;
            if (!!(callBack = tf.js.GetFunctionOrNull(settings.callBack))) {
                setTimeout(function () {
                    callBack.call(localSettings.optionalScope, { data: undefined, requestProps: localSettings.requestProps });
                }, 0);
            }
        }*/
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.services.Routing, tf.services.BaseJSONService);
/**
 * Object passed to [Raster Source List Service]{@link tf.services.RasterSourceList} callbacks
 * @public
 * @typedef {object} tf.types.RasterSourceListResult
 * @property {boolean} success - <b>true</b> on succes, <b>false</b> otherwise, in which case the contents of <b>error_message</b> should be checked
 * @property {string} error_message - if <b>success</b> is <b>false</b> contains an explanation of the reason(s) for failure
 * @property {array<object>} sources - an {@link array} of available sources at the requested location, each element of which contains:
 * @property {string} sources.name - the name of the source
 * @property {array<string>} sources.dates - the dates for which raster information is available for the source, each in the format "YYYYMMDD", as in "20150109"
 * @example {"success":true, "error_message":"", "sources":[{"name":"BEST_AVAILABLE", "dates":["20150109", "20150709"]}]}
*/
/**
 * Settings used in the creation of [Raster Source List]{@link tf.services.RasterSourceList} instances. Use either <b>pointCoordinates</b> or
 * a <b>extent</b>
 * @public
 * @typedef {object} tf.types.RasterSourceListSettings
 * @property {tf.types.mapLevel} level - map level, defaults to {@link tf.consts.defaultLevel}
 * @property {tf.types.mapCoordinates} pointCoordinates - if defined, takes precedence over <b>extent</b>
 * @property {tf.types.mapExtent} extent - map extent
 * @property {tf.types.ServiceCallBack} callBack - to receive a [RasterSourceListResult]{@link tf.types.RasterSourceListResult} object retrieved from the service
 * @property {object} optionalScope - optional JavaScript scope used with <b>callBack</b>
*/
/**
 * @public
 * @class
 * @summary - Raster Source List Service instances are created to retrieve a list of available raster sources and dates from the TerraFly Tile Service
 * @param {tf.types.RasterSourceListSettings} settings - creation settings
 * @extends {tf.services.BaseJSONService}
*/
tf.services.RasterSourceList = function (settings) {
    var theThis, localSettings;
    this.GetSettings = function () { return tf.js.ShallowMerge(localSettings); }
    function initialize() {
        localSettings = tf.js.ShallowMerge(settings);
        var level = tf.js.GetLevelFrom(localSettings.level);
        var extent ;
        
        if (localSettings.pointCoordinates !== undefined) {
            extent = tf.js.GetMapCoordsFrom(localSettings.pointCoordinates);
            extent = [extent[0], extent[1], extent[0], extent[1]];
        }
        else {
            extent = tf.js.GetMapExtentFrom(localSettings.extent);
        }
        
        var tileServiceURL = "http://131.94.133.184/TileService/";
        localSettings.serviceURL = tileServiceURL + "rsourcelist.aspx?projection=bing&z=" + level +
            "&bbox=" + extent[1] + ',' + extent[2] + ',' + extent[3] + ',' + extent[0];
        //tf.GetDebug().LogIfTest("RasterSourceList: " + localSettings.serviceURL);
        tf.services.BaseJSONService.call(theThis, localSettings);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.services.RasterSourceList, tf.services.BaseJSONService);
/**
 * Settings used in the creation of [Raster Mosaic]{@link tf.services.RasterMosaic} instances. The mosaic area can be
 * specified to the service by either providing it with <b>level</b> and <b>leftTop</b> parameters, or with an <b>extent</b>
 * parameter. In both cases the mosaic is created with the given <b>dim</b> dimensions. Use the former invocation 
 * to efficiently construct mosaics at the discrete [resolution]{@link tf.types.mapResolution} values corresponding to valid
 * [levels]{@link tf.types.mapLevel}.
 * Use the latter invocation to construct mosaics of any resolution, at the expense of additional processing time by the service
 * @public
 * @typedef {object} tf.types.RasterMosaicSettings
 * @property {tf.types.mapLevel} level - map level, if defined, together with <b>leftTop</b>, takes precedence over <b>extent</b>, defaults to {@link void}
 * @property {tf.types.mapCoordinates} leftTop - if defined, together with <b>level</b>, takes precedence over <b>extent</b>, defaults to {@link void}
 * @property {tf.types.mapExtent} extent - mosaic's extent coordinates, required when either <b>level</b> or <b>leftTop</b> are undefined
 * @property {tf.types.pixelCoordinates} dims - mosaic's dimensions
 * @property {tf.types.mapAerialSource} source - mosaic's source, defaults to [Best Available]{@link tf.consts.sourceName_best_available}
 * @property {string} date - mosaic's date, in the format "YYYYMMDD", as in "20151007", if not defined tiles from all dates are used to create the mosaic
 * @property {tf.types.ServiceCallBack} callBack - to receive an [Img]{@link tf.dom.Img} instance, whose [GetIsValid]{@link tf.dom.Img#GetIsValid} function can be used to determined success or failure
 * @property {object} optionalScope - optional JavaScript scope used with <b>callBack</b>
*/
/**
 * @public
 * @class
 * @summary - Raster Source List Service instances are created to retrieve a raster mosaic tile from the available aerial images in the TerraFly Tile Service.
 * This service passes an [Img]{@link tf.dom.Img} instance containing the mosaic image to its callback, whose [GetIsValid]{@link tf.dom.Img#GetIsValid} function 
 * can be used to determined success or failure.
 * @param {tf.types.RasterMosaicSettings} settings - creation settings
*/
tf.services.RasterMosaic = function (settings) {
    var theThis, callBack, optionalScope, localSettings, img;
    this.GetSettings = function () { return tf.js.ShallowMerge(localSettings); }
    function onImgLoaded() { setTimeout(doCalBack, 50); }
    function doCalBack() { callBack.call(optionalScope, img); img = null; }
    function initialize() {
        localSettings = tf.js.ShallowMerge(settings);
        if (!!(callBack = tf.js.GetFunctionOrNull(localSettings.callBack))) {
            optionalScope = localSettings.optionalScope;
            var level = tf.js.GetLevelFrom(localSettings.level);
            var leftTop = tf.js.GetMapCoordsFrom(localSettings.leftTop);
            var extent = tf.js.GetMapExtentFrom(localSettings.extent);
            var dim = tf.js.GetIsArrayWithMinLength(settings.dim, 2) ? settings.dim : [16, 16];
            var source = tf.js.GetNonEmptyString(localSettings.source);
            var date = tf.js.GetNonEmptyString(localSettings.date);
            var tileServiceURL = "http://131.94.133.184/TileService/";
            if (localSettings.level !== undefined && localSettings.leftTop !== undefined) {
                localSettings.serviceURL = tileServiceURL + "rmosaic.aspx?projection=bing&z=" + level +
                    "&left=" + leftTop[0] + '&top=' + leftTop[1] + '&width=' + dim[0] + '&height=' + dim[1];
            }
            else {
                var xMinYMin = tf.units.TM2OL([extent[0], extent[3]]);
                var xMaxYMax = tf.units.TM2OL([extent[2], extent[1]]);
                localSettings.serviceURL = tileServiceURL + "rmosaic.aspx?projection=bing" +
                    "&bbox=" + xMinYMin[0] + ',' + xMinYMin[1] + ',' + xMaxYMax[0] + ',' + xMaxYMax[1] + '&width=' + dim[0] + '&height=' + dim[1];
            }
            if (!!source) { localSettings.serviceURL += '&source=' + source; }
            if (!!date) { localSettings.serviceURL += '&date=' + date; }
            //tf.GetDebug().LogIfTest("RasterMosaic: " + localSettings.serviceURL);
            img = new tf.dom.Img({ src: localSettings.serviceURL, onLoad: onImgLoaded, crossOrigin: true });
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.services.Uber = function (settings) {
    var theThis, serverToken, clientId;
    var uberApiVersionStr, startUrl;
    this.GetPriceEstimate = function (then, fromCoords, toCoords, seatCount) { return getPriceEstimate(fromCoords, toCoords, seatCount, then); }
    this.GetTimeEstimate = function (then, fromCoords) { return getTimeEstimate(fromCoords, then); }
    this.GetProducts = function (then, fromCoords) { return getProducts(fromCoords, then); }
    this.SetPickup = function (then, fromCoords, fromName, toCoords, toName, productId) { return setPickup(then, fromCoords, fromName, toCoords, toName, productId); }
    this.MakeSetPickupUrl = function (fromCoords, fromName, toCoords, toName, productId) { return makeSetPickupUrl(fromCoords, fromName, toCoords, toName, productId); }
    function makeSetPickupUrl(fromCoords, fromName, toCoords, toName, productId) {
        var url = startUrl + "?client_id=" + clientId + "&action=setPickup&pickup[latitude]=" + fromCoords[1] +
            "&pickup[longitude]=" + fromCoords[0] + "&pickup[formatted_address]=" + fromName + "&dropoff[latitude]=" + toCoords[1] +
            "&dropoff[longitude]=" + toCoords[0] + "&dropoff[formatted_address]=" + toName;
        if (productId != undefined) { url += "&product_id=" + productId; }
        return url;
    }
    function makeUberStartEndSeatCountParams(fromCoords, toCoords, seatCount) {
        var str = 'start_latitude=' + fromCoords[1] + '&start_longitude=' + fromCoords[0] + '&end_latitude=' + toCoords[1] + '&end_longitude=' + toCoords[0];
        if (seatCount != undefined) { str += '&seat_count=' + seatCount; }
        return str;
    }
    function makeUberStartParams(fromCoords, toCoords) { return 'start_latitude=' + fromCoords[1] + '&start_longitude=' + fromCoords[0]; }
    function makeUberLocationParams(coords) { return 'latitude=' + coords[1] + '&longitude=' + coords[0]; }
    function doUberCall(url, then) {
        if (tf.js.GetFunctionOrNull(then)) {
            /*var req = { method: 'GET', url: 'https://api.uber.com/' + url, headers: { 'Authorization': 'Token ' + serverToken } };
            $http(req).
            success(function (data, status, headers, config) { then(data, status, headers, config); }).
            error(function (data, status, headers, config) { then(data, status, headers, config); });*/
            var header = { 'Authorization': 'Token ' + serverToken };
            new tf.ajax.JSONGet().Request('https://api.uber.com/' + uberApiVersionStr + url, function (notification) {
                then(!!notification ? notification.data : undefined);
            }, theThis, undefined, false, undefined, undefined, undefined, header);
        }
    }
    function getPriceEstimate(fromCoords, toCoords, seatCount, then) { return doUberCall('/estimates/price?' + makeUberStartEndSeatCountParams(fromCoords, toCoords, seatCount), then); }
    function getTimeEstimate(coords, then) { return doUberCall('/estimates/time?' + makeUberStartParams(coords), then); }
    function getProducts(coords, then) { return doUberCall('/products?' + makeUberLocationParams(coords), then); }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        uberApiVersionStr = tf.js.GetNonEmptyString(settings.uperApiVersion, "v1.2");
        serverToken = tf.js.GetNonEmptyString(settings.serverToken, "");
        clientId = tf.js.GetNonEmptyString(settings.clientId, "");
        startUrl = !!settings.useDeepLink ? "uber://" : "https://m.uber.com/ul/";
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.services.MDTServiceAPI = function (settings) {
    var theThis, nRequestsPending;
    var baseServiceUrl, busRoutesService, directionsForRouteIdService, routeShapeIdsForRouteIdAndDirectionService, shapeForShapeIdService, routeServicesService;
    var routeStopsForRouteIdAndDirectionService, busShedulesService, busesService, busTrackerService;
    this.GetHasRequestsPending = function () { return nRequestsPending > 0; }
    this.GetBuses = function (then) { return loadMDTServiceThen(busesService, then); }
    this.GetBusRoutes = function (then) { return loadMDTServiceThen(busRoutesService, then); }
    this.GetDirectionsForRouteId = function (routeId, then) { return loadMDTServiceThen(routeId != undefined ? directionsForRouteIdService + routeId : directionsForRouteIdService, then); }
    this.GetShapeIdsForRouteIdAndDirection = function (routeId, direction, then) { return loadMDTServiceThen(routeShapeIdsForRouteIdAndDirectionService + routeId + '&Dir=' + direction, then); }
    this.GetShapeForShapeId = function (shapeId, then) { return loadMDTServiceThen(shapeForShapeIdService + shapeId, then); }
    this.GetRouteServices = function (then) { return loadMDTServiceThen(routeServicesService, then); }
    this.GetBusRouteStops = function (routeId, direction, then) { return loadMDTServiceThen(routeStopsForRouteIdAndDirectionService + routeId + '&Dir=' + direction, then); }
    this.GetBusTrackerURL = function (stopId, routeId, direction) { return baseServiceUrl + makeBusTrackerUrl(stopId, routeId, direction); }
    this.GetBusTracker = function (stopId, routeId, direction, then) { return loadMDTServiceThen(makeBusTrackerUrl(stopId, routeId, direction), then); }
    this.GetBusSchedules = function (routeId, serviceId, direction, stopId, sequence, then) {
        var fullURL = busShedulesService + routeId + '&Service=' + serviceId + '&Dir=' + direction + '&StopID=' + stopId;
        if (sequence != undefined) { fullURL += '&Sequence=' + sequence; }
        return loadMDTServiceThen(fullURL, then);
    }
    function makeBusTrackerUrl(stopId, routeId, direction) {
        var url = busTrackerService + stopId;
        if (routeId != undefined) { url += "&RouteID=" + routeId; }
        if (direction != undefined) { url += "&Dir=" + direction; }
        return url;
    }
    function loadAjaxThen(url, then) {
        if (tf.js.GetFunctionOrNull(then)) {
            ++nRequestsPending;
            new tf.ajax.GetRequest({
                onDataLoaded: function (notification) {
                    --nRequestsPending;
                    if (nRequestsPending < 0) { console.log('MDTServiceAPI has negative number of pending requests: ' + nRequestsPending); }
                    var data, httpRequest = notification.httpRequest;
                    if (httpRequest.status == 200 && !!httpRequest.responseXML) {
                        data = tf.helpers.XML2Object(httpRequest.responseXML.documentElement);
                    }
                    then(data);
                }, optionalScope: theThis, url: url, autoSend: true, useRedirect: true
            });
        }
    }
    function loadMDTServiceThen(serviceStr, then) { return loadAjaxThen(baseServiceUrl + serviceStr, then); }
    function initialize() {
        nRequestsPending = 0;
        baseServiceUrl = "http://www.miamidade.gov/transit/WebServices/";
        busesService = "Buses";
        busRoutesService = "BusRoutes/";
        directionsForRouteIdService = "BusRouteDirections/?RouteID=";
        routeStopsForRouteIdAndDirectionService = "BusRouteStops/?RouteID=";
        shapeForShapeIdService = "BusRouteShape/?ShapeID=";
        routeServicesService = "BusRouteService";
        busShedulesService = "BusSchedules/?RouteID=";
        busTrackerService = "BusTracker/?StopID=";
        routeShapeIdsForRouteIdAndDirectionService = "BusRouteShapesByRoute/?RouteID="; //95&Dir=Northbound";
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: ajax.js
/**
 * Notifications sent by {@link tf.ajax.GetRequest} instances
 * @public
 * @typedef {object} tf.types.AjaxNotification
 * @property {tf.ajax.GetRequest} sender - the instance sending the notification
 * @property {object} httpRequest - the request object
 * @property {object} requestProps - the object that was used in the creation of the [GetRequest]{@link tf.ajax.GetRequest} instance
*/
/**
 * A callback function that can be used in the creation of instances of [GetRequest]{@link tf.ajax.GetRequest}
 * @public
 * @callback tf.types.AjaxCallBack
 * @param {tf.types.AjaxNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * Settings used in the creation of [GetRequest]{@link tf.ajax.GetRequest} instances
 * @public
 * @typedef {object} tf.types.AjaxSettings
 * @property {string} url - the url to access
 * @property {tf.types.AjaxCallBack} onDataLoaded - the callback function that receives the data after it is retrieved
 * @property {boolean} useRedirect - if set to <b>true</b> the request is sent using a redirect proxy, to avoid cross domain violations
 * @property {string} overrideMimeType - a string containing the desired Mime type of the resource being retrieved
 * @property {object} requestProps - an object that will be passed to the callback function
 * @property {boolean} autoSend - if set to <b>true</b> the request is sent automatically upon creation of the {@link tf.ajax.GetRequest} instance, defaults to <b>false</b>
 * @property {object} optionalScope - optional scope used when applying the callback function
*/
/**
 * @public
 * @class
 * @summary Create an instance of this class to retrieve data from a given url pointing to a service or data file
 * @param {tf.types.AjaxSettings} settings - request creation settings
 */
tf.ajax.GetRequest = function (settings) {
    var theThis, httpRequest, urlToDownload, onDataLoaded, requestProps, autoSendBool, wasSent, wasAborted, wasReceived, isValid, overrideMimeType, usePost, postParams, contentType, requestHeaders;
    /**
     * @public
     * @function
     * @summary - Sends the request if it is valid and has not been previously sent
     * @returns {void} - | {@link void} no return value
    */
    this.Send = function () { return send(); }
    /**
     * @public
     * @function
     * @summary - Cancels the request if it is in progress
     * @returns {void} - | {@link void} no return value
    */
    this.Cancel = function () { return cancel(); }
    /**
     * @public
     * @function
     * @summary - Checks if the request was cancelled
     * @returns {boolean} - | {@link boolean } <b>true</b> if the request was cancelled, <b>false</b> otherwise
    */
    this.WasCancelled = function () { return wasAborted; }
    /**
     * @public
     * @function
     * @summary - Checks if the request is valid
     * @returns {boolean} - | {@link boolean } <b>true</b> if the request if valid, <b>false</b> otherwise
    */
    this.GetIsValid = function () { return isValid; }
    /**
     * @public
     * @function
     * @summary - Checks if the request was sent
     * @returns {boolean} - | {@link boolean } <b>true</b> if the request was sent, <b>false</b> otherwise
    */
    this.WasSent = function () { return wasSent; }
    /**
     * @public
     * @function
     * @summary - Checks if the request is in progress (was sent, but a response has not been received)
     * @returns {boolean} - | {@link boolean } <b>true</b> if the request is in progress, <b>false</b> otherwise
    */
    this.GetIsInProgress = function () { return getIsInProgress(); }
    /**
     * @public
     * @function
     * @summary - Checks if a response for the request was received
     * @returns {boolean} - | {@link boolean } <b>true</b> if a response was received, <b>false</b> otherwise
    */
    this.WasReceived = function () { return wasReceived; }
    function getIsInProgress() { return wasSent && !wasAborted && !wasReceived; }
    function send() {
        if (!wasSent && isValid) {
            try {
                var verb = usePost ? 'POST' : 'GET';
                httpRequest.open(verb, urlToDownload, true);
                if (httpRequest.setRequestHeader) {
                    if (contentType != undefined) { httpRequest.setRequestHeader("Content-type", contentType); }
                    if (!!requestHeaders) {
                        for (var key in requestHeaders) {
                            var value = requestHeaders[key];
                            if (!!value) {
                                httpRequest.setRequestHeader(key, value);
                            }
                        }
                    }
                }
                httpRequest.onreadystatechange = onReadyStateChange;
                httpRequest.send(postParams);
            }
            catch (Exception) {
                isValid = false;
            }
            wasSent = isValid;
            if (!isValid) { notify(undefined, requestProps); }
        }
    }
    function cancel() { if (getIsInProgress()) { if (httpRequest) { httpRequest.abort(); httpRequest = null; wasAborted = true; } } }
    function notify(httpRequest, requestProps) {
        if (!!onDataLoaded) {
            try {
                onDataLoaded.call(settings.optionalScope, { sender: theThis, httpRequest: httpRequest, requestProps: requestProps });
            }
            catch (e) {
                console.log('exception during AJAX notification');
            }
        }
    }
    function onReadyStateChange() {
        if (!wasAborted) {
            if (httpRequest.readyState == 4) {
                //if (!!onDataLoaded) { onDataLoaded(httpRequest, httpRequest.status, requestProps); }
                //if (!!onDataLoaded) { onDataLoaded.call(settings.optionalScope, { sender: theThis, httpRequest: httpRequest, requestProps: requestProps }); }
                notify(httpRequest, requestProps);
                wasReceived = true;
                httpRequest = null;
            }
            else {
                //tf.GetDebug().LogIfTest( "state:" + httpRequest.readyState);
                //	0: not initialized.
                //	1: connection established.
                //	2: request received.
                //	3: answer in process.
                //	4: finished.
            }
        }
    }
    function createHttpRequest() {
        if (window.XMLHttpRequest) {
            // Mozilla, Safari,...
            try {
                httpRequest = new XMLHttpRequest({ mozSystem: true });
                if (httpRequest.overrideMimeType) {
                    if (!!overrideMimeType) { httpRequest.overrideMimeType(overrideMimeType); }
                }
            }
            catch (e) { httpRequest = null; }
        }
        else if (window.ActiveXObject) {
            // IE
            try { httpRequest = new ActiveXObject("Msxml2.XMLHTTP"); }
            catch (e) { try { httpRequest = new ActiveXObject("Microsoft.XMLHTTP"); } catch (e) { httpRequest = null; } }
        }
        //if (httpRequest) { httpRequest.onreadystatechange = onReadyStateChange; } else { isValid = false; }
        isValid = !!httpRequest;
    }
    function initialize() {
        wasSent = wasAborted = wasReceived = false;
        onDataLoaded = tf.js.GetFunctionOrNull(settings.onDataLoaded);
        urlToDownload = tf.js.GetNonEmptyString(settings.url, null);
        if (isValid = (!!urlToDownload && !!onDataLoaded)) {
            if (!!settings.useRedirect) { urlToDownload = tf.platform.GetURL() + "RedirectStream.aspx?URL=" + escape(urlToDownload); }
            //tf.GetDebug().LogIfTest(urlToDownload);
            overrideMimeType = tf.js.GetNonEmptyString(settings.overrideMimeType, 'text/xml');
            requestProps = settings.requestProps;
            autoSendBool = !!settings.autoSend;
            usePost = !!settings.usePost;
            postParams = !!settings.postParams ? settings.postParams : null;
            contentType = settings.contentType;
            requestHeaders = settings.requestHeaders;
            createHttpRequest();
            if (!!autoSendBool) {
                if (isValid) { send(); }
                else { setTimeout(function () { notify(undefined, requestProps); }, 10); }
            }
        }
    }
    (function construct(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Notifications sent by {@link tf.ajax.JSONGet} instances
 * @public
 * @typedef {object} tf.types.JSONNotification
 * @property {tf.ajax.JSONGet} sender - the instance sending the notification
 * @property {object} data - the JavaScript object obtained from the JSON data
 * @property {object} requestProps - the object that was used in the call to {tf.ajax.JSONGet#Request}
*/
/**
 * A callback function that can be passed to the function {@link tf.ajax.JSONGet#Request} to receive the result of the request
 * @public
 * @callback tf.types.JSONCallBack
 * @param {tf.types.JSONNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * A callback function that can be passed to the function {@link tf.ajax.JSONGet#Request} to provide an url string
 * @public
 * @callback tf.types.GetUrlFunction
 * @returns {string} - | {@link string} an url string
 */
/**
 * @public
 * @class
 * @summary Create an instance of this class to retrieve JavaScript objects from JSON data obtained from a given url pointing to a service or data file
 */
tf.ajax.JSONGet = function () {
    var theThis, downloadObj, callBack, optionalScope, overrideMimeType, JSONDecode;
    /**
     * @public
     * @function
     * @summary - Sends the request specified by the parameters
     * @param {string | tf.types.GetUrlFunction} url - the url to access, either the url string itself or a function that returns an url string
     * @param {tf.types.JSONCallBack} onDataLoaded - the callback function that receives the JavaScript object after it is retrieved
     * @param {object} optionalScope - optional scope used when applying the callback function
     * @param {object} requestProps - an object that will be passed to the callback function
     * @param {boolean} useRedirect - if set to <b>true</b> the request is sent using a redirect proxy, to avoid cross domain violations
     * @returns {void} - | {@link void} no return value
    */
    this.Request = function (url, onDataLoaded, optionalScope, requestProps, useRedirect, overrideMimeType, JSONDecode, postParams, requestHeaders) {
        return request(url, onDataLoaded, optionalScope, requestProps, useRedirect, overrideMimeType, JSONDecode, postParams, requestHeaders);
    }
    /**
     * @public
     * @function
     * @summary - Checks if the request is in progress (was sent, but a response has not been received)
     * @returns {boolean} - | {@link boolean } <b>true</b> if the request is in progress, <b>false</b> otherwise
    */
    this.GetIsInProgress = function () { return !!downloadObj && downloadObj.GetIsInProgress(); }
    /**
     * @public
     * @function
     * @summary - Cancels the request if it is in progress
     * @returns {void} - | {@link void} no return value
    */
    this.Cancel = function () { return cancel(); }
    function cancel() { if (downloadObj) { downloadObj.Cancel(); downloadObj = null; } }
    function request(fromURL, callBackSet, optionalScopeSet, requestPropsSet, useRedirectSet, overrideMimeType, JSONDecode, postParams, requestHeaders) {
        if (tf.js.GetFunctionOrNull(fromURL)) { fromURL = fromURL(); }
        if (tf.js.GetNonEmptyString(fromURL)) {
            //tf.GetDebug().LogIfTest(fromURL);
            var mimeType = tf.js.GetNonEmptyString(overrideMimeType, 'application/json');
            var decode = tf.js.GetFunctionOrNull(JSONDecode);
            callBack = tf.js.GetFunctionOrNull(callBackSet);
            optionalScope = optionalScopeSet;
            cancel();
            var usePost, contentType;
            //if (postParams != undefined) { usePost = true, contentType = "application/json"; }
            if (postParams != undefined) { usePost = true, contentType = "application/json; charset=utf-8"; }
            downloadObj = new tf.ajax.GetRequest({
                optionalScope: theThis, url: fromURL, onDataLoaded: onDataLoaded,
                requestProps: { clientProps: requestPropsSet, JSONDecode: decode },
                contentType: contentType,
                usePost: usePost,
                postParams: postParams,
                requestHeaders: requestHeaders,
                overrideMimeType: mimeType, useRedirect: useRedirectSet, autoSend: true
            });
        }
    }
    function onDataLoaded(notification) {
        downloadObj = null;
        var notificationProps = notification.requestProps;
        var decode = notificationProps.JSONDecode;
        var data, httpRequest = notification.httpRequest;
        if (httpRequest.status >= 200 && httpRequest.status < 300 || httpRequest.status === 304) {
            if (!!decode) { data = decode(httpRequest); }
            else { data = httpRequest.responseText; if (!!data) { data = tf.js.JSONParse(data); } }
        }
        if (!!callBack) { callBack.call(optionalScope, { sender: theThis, data: data, requestProps: notificationProps.clientProps }); }
        data = null;
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; })(this);
};
/**
 * A callback function that can be used in the creation of instances of {@link tf.ajax.PeriodicJSONGet}
 * @public
 * @callback tf.types.PeriodicJSONCallBack
 * @param {tf.types.PeriodicJSONNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * Notifications sent by {@link tf.ajax.PeriodicJSONGet} instances
 * @public
 * @typedef {object} tf.types.PeriodicJSONNotification
 * @property {tf.ajax.PeriodicJSONGet} sender - the instance sending the notification
 * @property {object} data - the JavaScript object obtained from the JSON data
 * @property {object} requestProps - the object that was used in the creation of the call to {tf.ajax.JSONGet#Request}
*/
/**
 * Settings used in the creation of {@link tf.ajax.PeriodicJSONGet} instances
 * @public
 * @typedef {object} tf.types.PeriodicJSONSettings
 * @property {string | tf.types.GetUrlFunction} url - the url to access, either the url string itself or a function that returns an url string
 * @property {tf.types.PeriodicJSONCallBack} OnRefresh - the callback function that receives JavaScript objects that are retrieved
 * @property {object} optionalScope - optional scope used when applying the callback function
 * @property {boolean} autoRefresh - if set to <b>true</b> requests are sent periodically
 * @property {number} refreshMillis - The desired number of milliseconds between periodic refreshes
 * @property {boolean} useRedirect - if set to <b>true</b> requests are sent using a redirect proxy, to avoid cross domain violations
 *
*/
/**
 * @public
 * @class
 * @summary Create an instance of this class to periodically retrieve JavaScript objects from JSON data obtained from a given url pointing to a service or data file
 * @param {tf.types.PeriodicJSONSettings} settings - request creation settings
 */
tf.ajax.PeriodicJSONGet = function (settings) {
    var theThis, refreshCallBack, isDeleted, lastRefreshTime, actualLastRefreshTime, refreshTimeoutObj;
    var downloadObj, lastData, lastProps, minRefreshTimeOut, maxRefreshTimeOut, defRefreshTimeOut, optionalScope, url, useRedirect, refreshTimeOutMillis, autoRefresh;
    var JSONDecode, postParams, requestHeaders;
    var debug;
    /**
     * @public
     * @function
     * @summary - Returns the last time a JavaScript object was retrieved
     * @returns {Date} - | {@link Date} a Date
    */
    this.GetLastRefreshTime = function () { return actualLastRefreshTime; }
    /**
     * @public
     * @function
     * @summary - Checks if the request is in progress (was sent, but a response has not been received)
     * @returns {boolean} - | {@link boolean } <b>true</b> if the request is in progress, <b>false</b> otherwise
    */
    this.GetIsRefreshing = function () { return !!downloadObj && downloadObj.GetIsInProgress(); }
    /**
     * @public
     * @function
     * @summary - This function must be called when the {@link tf.ajax.PeriodicJSONGet} instance is no longer needed
     * @returns {void} - | {@link void} no return value
    */
    this.OnDelete = function () { return onDelete(); }
    /**
     * @public
     * @function
     * @summary - Call this function to change the callBack function
     * @param {tf.types.PeriodicJSONCallBack} newRefreshCallBack - a new callback function to receive JavaScript objects
     * @returns {void} - | {@link void} no return value
    */
    this.ChangeCallBack = function (newRefreshCallBack) { return changeCallBack(newRefreshCallBack); }
    /**
     * @public
     * @function
     * @summary - Triggers an immediate refresh
     * @returns {void} - | {@link void} no return value
    */
    this.RefreshNow = function () { return onRefresh(); }
    /**
     * @public
     * @function
     * @summary - Cancels the current request if one is in progress
     * @returns {void} - | {@link void} no return value
    */
    this.Cancel = function () { return cancel(); }
    function cancel() { if (downloadObj) { downloadObj.Cancel(); } }
    function onDelete() {
        isDeleted = true;
        if (downloadObj) { downloadObj.Cancel(); }
        destroyRefreshTimeOut();
        refreshCallBack = null;
    }
    function notifyRefreshCallBack() {
        if (!!refreshCallBack) {
            try {
                refreshCallBack.call(optionalScope, { sender: theThis, data: lastData }); lastData = null;
            }
            catch (e) { console.log('exception during Periodic notification'); }
        }
    }
    function onDataLoaded(notification) {
        if (notification.requestProps == lastProps) {
            actualLastRefreshTime = lastRefreshTime = new Date();
            lastData = notification.data;
            //if (!!debug) { debug.LogIfTest("lastProps: " + lastProps); }
            if (lastProps > 10000) { lastProps = 0; }
            //setTimeout(notifyRefreshCallBack, 10);
            notifyRefreshCallBack();
            resetRefreshTimeout();
        }
        else { if (!!debug) { debug.LogIfTest("PeriodicJSONGet: skipping stale response: " + notification.requestProps + ' last requested ' + lastProps); } }
    }
    function onRefresh() { downloadObj.Request(url, onDataLoaded, theThis, lastProps = ++lastProps, useRedirect, undefined, JSONDecode, postParams, requestHeaders); }
    function destroyRefreshTimeOut() { if (!!refreshTimeoutObj) { clearTimeout(refreshTimeoutObj); refreshTimeoutObj = null; } }
    function resetRefreshTimeout() { destroyRefreshTimeOut(); if (!!autoRefresh) { refreshTimeoutObj = setTimeout(onRefresh, refreshTimeOutMillis); } }
    function doSetRefreshTimeOutMillis(newRefreshTimeOutMillis) {
        refreshTimeOutMillis = tf.js.GetFloatNumberInRange(newRefreshTimeOutMillis, minRefreshTimeOut, maxRefreshTimeOut, defRefreshTimeOut);
    }
    function setRefreshTimeOutMillis(newRefreshTimeOutMillis) {
        doSetRefreshTimeOutMillis(newRefreshTimeOutMillis);
        resetRefreshTimeout();
        if (!!lastRefreshTime) { lastRefreshTime = new Date(); }
    }
    function changeCallBack(newRefreshCallBack) { if (!isDeleted) { refreshCallBack = tf.js.GetFunctionOrNull(newRefreshCallBack); } }
    function setAutoRefresh(autoRefreshSet) { autoRefresh = tf.js.GetBoolFromValue(autoRefreshSet, true); }
    function initialize() {
        debug = tf.GetDebug();
        JSONDecode = settings.JSONDecode;
        postParams = settings.postParams;
        requestHeaders = settings.requestHeaders;
        optionalScope = settings.optionalScope;
        url = settings.url;
        useRedirect = tf.js.GetBoolFromValue(settings.useRedirect, false);
        setAutoRefresh(settings.autoRefresh);
        lastProps = 0;
        minRefreshTimeOut = 1000; // two seconds
        maxRefreshTimeOut = 1000 * 60 * 60 * 24; // once a day
        defRefreshTimeOut = 5 * minRefreshTimeOut;
        downloadObj = new tf.ajax.JSONGet();
        isDeleted = false;
        changeCallBack(settings.onRefresh);
        if ((!!refreshCallBack) && (!!url)) { setRefreshTimeOutMillis(settings.refreshMillis); }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: cssstylecreator.js
/**
 * An {@link object} with two [CSS Style Specifications]{@link tf.types.CSSStyleSpecs}, for normal and hover states
 * @public
 * @typedef {object} tf.types.CSSStyleAndHoverSpecifications
 * @property {tf.types.CSSStyleSpecs} style - regular style used by the {@link HTMLElementLike} 
 * @property {tf.types.CSSStyleSpecs} hoverStyle - style used by the {@link HTMLElementLike} when the mouse pointer is hovering over it
*/
/**
 * A string containing the name of a Cascading Style Sheet style created by [CSS Style Creator]{@link tf.styles.CSSStyleCreator} 
 * or one of the pre-defined class names provided by [Styles]{@link tf.styles.Styles}. CSSStyleNames can be assigned to the <b>class</b> attribute of an [HTMLElement]{@link HTMLElement}
 * either directly or using the function [AddCSSClass]{@link tf.dom.AddCSSClass}
 * @public
 * @typedef {string} tf.types.CSSStyleName
 */
/**
 * A single CSS Style statement, a component part of [CSS Style Specs]{@link tf.types.CSSStyleSpecs}. Examples: backgroundColor: "#f0f", or, textAlign: "left"
 * @public
 * @typedef {object} tf.types.CSSStyleStatement
 * @property {string} propertyName - the string value of a camelized <b>propertyName</b> is assigned to the corresponding unCamelized <b>propertyname</b>, if it is a known HTML css style property
*/
/**
 * CSS Style definitions, used by [CSS Style Creator]{@link tf.styles.CSSStyleCreator}, [Sub Styles]{@link tf.styles.SubStyles}, and [Styles]{@link tf.styles.Styles}
 * @public
 * @typedef {object} tf.types.CSSStyleSpecs
 * @property {tf.types.CSSStyleName} styleName - the name of the style being created, a mandatory property
 * @property {tf.types.CSSStyleSpecs|enumerable<tf.types.CSSStyleSpecs>} inherits - an optional property implementing style inheritance
 * @property {...tf.types.CSSStyleStatement} statements - zero or more style statements
 * @example
 * // creates a style specification for background color
 * var backgroundSpecs = { backgroundColor: "#707" };
 * // creates a style specification for text color
 * var textColorSpecs = { color: "#42f831" };
 * // creates a style specification for font size
 * var fontSizeSpecs = { fontSize: "1em" };
 * // creates a style specification combining previously defined specifications and adding a new one
 * var textSpecs = { inherits: [textColorSpecs, fontSizeSpecs], fontWeight: "500" };
 * // creates a style specification combining inherited specifications, and specifying a styleName
 * var containerSpecs = { styleName: "myContainerClass", inherits: [textSpecs, backgroundSpecs], border: "1px solid #000" };
*/
/**
 * @public
 * @class
 * @summary The {@link singleton} instance of this class, obtainable by calling {@link tf.GetStyles}().[GetStyleCreator]{@link tf.styles.Styles#GetStyleCreator}(),
 * implements programmatic / run time creation of global CSS classes and application of custom CSS styles to individual {@link HTMLElementLike} instances
 * @param {tf.styles.Styles} styles - the {@link singleton} [Styles]{@link tf.styles.Styles} instance
 */
tf.styles.CSSStyleCreator = function (styles) {
    var theThis, hasHead, head, allRules, styleSheetForNewStyles, styleSheetForNewStylesRules;
    /**
     * @public
     * @function
     * @summary - Creates a new CSS style based on the given specifications
     * @param {tf.types.CSSStyleSpecs} cssStyleSpecs - the given specifications
     * @returns {void} - | {@link void} no return value
    */
    this.CreateStyle = function (cssStyleSpecs) { return createStyle(cssStyleSpecs); }
    /**
     * @public
     * @function
     * @summary - Creates an arbitrary number of new CSS styles based on the given specifications
     * @param {enumerable<tf.types.CSSStyleSpecs>} cssStyleSpecs - an enumerable of specifications
     * @returns {void} - | {@link void} no return value
    */
    this.CreateStyles = function (cssStyleSpecs) { return createStyles(cssStyleSpecs); }
    /**
     * @public
     * @function
     * @summary - Creates a new CSS style with the given name based on the given raw style string
     * @param {tf.types.CSSStyleName} styleName - the style name
     * @param {string } styleStr - a style specification in CSS file syntax
     * @returns {void} - | {@link void} no return value
    */
    this.CreateRawStyle = function (styleName, styleStr) { return createRawStyle(styleName, styleStr); }
    /**
     * @public
     * @function
     * @summary - Applies the given style specifications to the given element
     * @param {HTMLElementLike} elem - the given element
     * @param {tf.types.CSSStyleSpecs} cssStyleSpecs - the given specifications
     * @returns {void} - | {@link void} no return value
    */
    this.ApplyStyleProperties = function (elem, style) { return applyStyleProperties(elem, style); }
    /**
     * @private
     * @function
     * @summary - Debugging mechanism used internally by the API
     * @returns {void} - | {@link void} no return value
    */
    this.LogStyles = function () { return logStyles(); }
    function applyStyleProperties(elem, style) {
        var prop;
        if (elem = tf.dom.GetHTMLElementFrom(elem)) {
            for (var property in style) {
                if (style.hasOwnProperty(property)) {
                    if (property != 'styleName') {
                        if (property == 'inherits') {
                            if (typeof (prop = style[property]) === "object") {
                                if (prop.length) { for (var p in prop) { if (prop.hasOwnProperty(p)) { applyStyleProperties(elem, prop[p]); } } }
                                else { applyStyleProperties(elem, prop) }
                            }
                        }
                        else switch (property) {
                            case "tf-shadow":
                                var shadowData = style[property];
                                if (tf.js.GetIsArrayWithMinLength(shadowData, 4)) {
                                    applyStyleProperties(elem, styles.GetSubStyles().CreateShadowStyle(shadowData[0], shadowData[1], shadowData[2], shadowData[3]));
                                }
                                break;
                            default:
                                elem.style[property] = style[property];
                                break;
                        }
                    }
                }
            }
        }
    }
    function addStyleProperties(style, styleStr) {
        typeof styleStr !== "string" && (styleStr = '');
        var prop;
        for (var property in style) {
            if (style.hasOwnProperty(property)) {
                if (property != 'styleName') {
                    if (property == 'inherits') {
                        if (typeof (prop = style[property]) === "object") {
                            if (prop.length) { for (var p in prop) { if (prop.hasOwnProperty(p)) { styleStr = addStyleProperties(prop[p], styleStr); } } }
                            else { styleStr = addStyleProperties(prop, styleStr) }
                        }
                    }
                    else switch (property) {
                        case "tf-shadow":
                            var shadowData = style[property];
                            if (tf.js.GetIsArrayWithMinLength(shadowData, 4)) {
                                styleStr = addStyleProperties(styles.GetSubStyles().CreateShadowStyle(shadowData[0], shadowData[1], shadowData[2], shadowData[3]), styleStr);
                            }
                            break;
                        default:
                            prop = style[property]; property = tf.js.UnCamelize(property); styleStr += property + ' : ' + prop + '; ';
                            break;
                    }
                }
            }
        }
        return styleStr;
    }
    function createStyles(styleArray) {
        if (tf.js.GetIsValidObject(styleArray)) { for (var i in styleArray) { createStyle(styleArray[i]); } }
    }
    function createStyle(style) {
        if (tf.js.GetIsValidObject(style) && tf.js.GetIsNonEmptyString(style.styleName)) {
            var styleStr = '';
            createRawStyle(style.styleName, addStyleProperties(style, styleStr));
        }
    }
    function getStyleSheetRules(styleSheet) {
        var rules = null;
        if (!!styleSheet) {
            try {
                var mediaType = typeof styleSheet.media;
                rules = mediaType == "string" ? styleSheet.rules : (mediaType == "object" ? styleSheet.cssRules : null);
                if (!rules) {
                    if (!!styleSheet.sheet && !!styleSheet.sheet.cssRules) {
                        rules = styleSheet.sheet.cssRules;
                    }
                }
            } catch (e) { rules = null; }
        }
        return rules;
    }
    function getLastAvailableStyleSheet() {
        var styleSheet = null, rules = null, styleSheets = document.styleSheets, nStyleSheets = !!styleSheets ? styleSheets.length : 0;
        if (nStyleSheets > 0) {
            for (var i = nStyleSheets - 1; i >= 0 && !styleSheet ; --i) {
                var thisStyleSheet = styleSheets[i];
                try {
                    if (!thisStyleSheet.disabled) {
                        var media = thisStyleSheet.media;
                        var mediaType = typeof media;
                        var mediaText = mediaType == "string" ? media : (mediaType == "object" ? media.mediaText : null);
                        if (mediaText == "" || (mediaText.indexOf("screen") != -1) || (mediaText.indexOf("all") != -1)) {
                            if (!(rules = getStyleSheetRules(styleSheet = thisStyleSheet))) { styleSheet = null; }
                        }
                    }
                }
                catch (exception){
                    //console.log(exception);
                }
            }
        }
        return { styleSheet: styleSheet, rules: rules };
    }
    function createNewStyleSheet() {
        var styleSheet = null, rules = null;
        if (hasHead) {
            var styleElem;
            if (styleElem = document.createElement("style")) {
                styleElem.type = "text/css"; head[0].appendChild(styleElem);
                if (styleElem.sheet != undefined) {
                    styleSheet = styleElem.sheet;
                }
                else if (styleElem.styleSheet != undefined) {
                    styleSheet = styleElem.styleSheet;
                }
                if (!!styleSheet) {
                    if (!(rules = getStyleSheetRules(styleSheet))) { styleSheet = null; }
                }
            }
        }
        return { styleSheet: styleSheet, rules: rules };
    }
    function getLastOrCreateNewStyleSheet() {
        var lastAvailableStyleSheet = getLastAvailableStyleSheet();
        if (!lastAvailableStyleSheet.styleSheet) { lastAvailableStyleSheet = createNewStyleSheet(); }
        styleSheetForNewStyles = lastAvailableStyleSheet.styleSheet;
        styleSheetForNewStylesRules = lastAvailableStyleSheet.rules;
    }
    function createRawStyle(selector, style) {
        if (typeof selector === "string" && selector.length > 0 && typeof style === "string" && style.length > 0) {
            var lowerCaseSelector = selector.toLowerCase(), existingRule = allRules[lowerCaseSelector];
            if (!!existingRule) {
                try {
                    existingRule.style.cssText = style;
                }
                catch (exception) {
                    //tf.GetDebug().LogIfTest("css exception (change existing rule)" + selector + " " + exception);
                }
            }
            else if (!!styleSheetForNewStylesRules) {
                try {
                    var nRules = styleSheetForNewStylesRules.length;
                    if (typeof styleSheetForNewStyles.insertRule === "function") {
                        styleSheetForNewStyles.insertRule(selector + "{" + style + "}", nRules);
                    }
                    else {
                        styleSheetForNewStyles.addRule(selector, style);
                    }
                    allRules[lowerCaseSelector] = styleSheetForNewStylesRules[nRules];
                }
                catch (exception) {
                    //tf.GetDebug().LogIfTest("css exception (insert new rule)" + selector + " " + exception);
                }
            }
        }
    }
    function loadAllRules() {
        var styleSheets = document.styleSheets, nStyleSheets = !!styleSheets ? styleSheets.length : 0;
        allRules = [];
        if (nStyleSheets > 0) {
            for (var styleSheet in styleSheets) {
                if (styleSheets.hasOwnProperty(styleSheet)) {
                    var thisStyleSheet = styleSheets[styleSheet];
                    if (!thisStyleSheet.disabled) {
                        try {
                            var rules = getStyleSheetRules(thisStyleSheet);
                            if (!!rules) {
                                for (var rule in rules) {
                                    if (rules.hasOwnProperty(rule)) {
                                        var thisRule = rules[rule];
                                        if (thisRule.selectorText) { allRules[thisRule.selectorText.toLowerCase()] = thisRule; }
                                        else {
                                            // @ something
                                        }
                                    }
                                }
                            }
                        }
                        catch (exception) {
                        }
                    }
                }
            }
        }
    }
    function logStyles() {
        var styleSheets = document.styleSheets, nStyleSheets = !!styleSheets ? styleSheets.length : 0;
        if (nStyleSheets > 0) {
            var logStr = '';
            for (var styleSheet in styleSheets) {
                if (styleSheets.hasOwnProperty(styleSheet)) {
                    var thisStyleSheet = styleSheets[styleSheet];
                    if (!thisStyleSheet.disabled) {
                        var rules = getStyleSheetRules(thisStyleSheet);
                        var nRules = rules ? rules.length : 0;
                        for (var rule in rules) {
                            if (rules.hasOwnProperty(rule)) {
                                var thisRule = rules[rule];
                                logStr += thisRule.cssText;
                            }
                        }
                    }
                }
            }
            tf.GetDebug().SaveAsTextFile("stylesheets", logStr);
        }
    }
    function initialize() {
        head = document.getElementsByTagName("head");
        hasHead = head && head.length > 0;
        loadAllRules();
        getLastOrCreateNewStyleSheet();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: styles.js
tf.dom.StyleSheet = function (settings) {
    var theThis, allRules, usingInsert, styleElem, styleSheet, rules, nRules;
    this.GetAllRules = function () { return allRules; }
    this.GetIsActive = function () { return styleElem != undefined; }
    this.AddStyles = function (styleOrStyleArray) {
        if (styleOrStyleArray != undefined) {
            if (styleOrStyleArray.length == undefined) { styleOrStyleArray = [styleOrStyleArray]; }
            var nStyles = styleOrStyleArray.length;
            for (var i = 0; i < nStyles; ++i) {
                var thisStyle = styleOrStyleArray[i];
                if (thisStyle != undefined && thisStyle.styleName != undefined) {
                    updateOrInsertRule(thisStyle.styleName, addStyleProperties(thisStyle));
                }
            }
        }
    }
    function unCamelize(name) {
        var newName = '', nChars = typeof name === "string" ? name.length : 0;
        for (var i = 0; i < nChars; ++i) {
            var thisChar = name[i], thisCharLower = thisChar.toLowerCase();
            newName += thisChar == thisCharLower ? thisChar : "-" + thisCharLower;
        }
        return newName;
    };
    function addStyleProperties(style, styleStr) {
        typeof styleStr !== "string" && (styleStr = '');
        var prop;
        for (var property in style) {
            if (style.hasOwnProperty(property)) {
                if (property != 'styleName') {
                    if (property == 'inherits') {
                        if (typeof (prop = style[property]) === "object") {
                            if (prop.length) { for (var p in prop) { if (prop.hasOwnProperty(p)) { styleStr = addStyleProperties(prop[p], styleStr); } } }
                            else { styleStr = addStyleProperties(prop, styleStr) }
                        }
                    }
                    else switch (property) {
                        case "tf-shadow":
                            break;
                        default:
                            prop = style[property]; property = unCamelize(property); styleStr += property + ' : ' + prop + '; ';
                            break;
                    }
                }
            }
        }
        return styleStr;
    }
    function updateOrInsertRule(selector, style) { return updateRule(selector, style) || insertRule(selector, style); }
    function updateRule(selector, style) {
        var updatedOK = false;
        var existingRule = allRules[selector];
        if (!!existingRule) {
            try {
                existingRule.style.cssText = style;
                updatedOK = true;
                allRules[selector] = style;
            }
            catch (exception) {
                updatedOK = false;
                //console.log('failed to update css selector ' + selector + ' ' + exception);
            }
            allRules[selector] = styleSheet[nRules];
        }
        return updatedOK
    }
    function insertRule(selector, style) {
        var insertedOK = false;
        if (!!styleSheet) {
            nRules = rules.length;
            try {
                if (usingInsert) { styleSheet.insertRule(selector + "{" + style + "}", nRules); } else { styleSheet.addRule(selector, style); }
                insertedOK = true;
                allRules[selector] = style;
            }
            catch (exception) {
                insertedOK = false;
            }
        }
        return insertedOK;
    }
    function createStyleSheet() {
        var head = settings.document.getElementsByTagName("head");
        if (head != undefined && head.length > 0) {
            styleElem = settings.document.createElement("style");
            styleElem.type = "text/css";
            head[0].appendChild(styleElem);
            if (!!(styleSheet = styleElem.sheet != undefined ? styleElem.sheet : (styleElem.styleSheet != undefined ? styleElem.styleSheet : undefined))) {
                if (!(rules = getStyleSheetRules(styleSheet))) { styleSheet = undefined; }
            }
            if (styleSheet != undefined) {
                if (!(usingInsert = (typeof styleSheet.insertRule == "function"))) {
                    if (typeof styleSheet.addRule != "function") {
                        styleSheet = undefined;
                    }
                }
            }
            if (styleSheet == undefined) { styleElem = undefined; }
        }
    }
    function getStyleSheetRules(styleSheet) {
        var rules;
        if (!!styleSheet) {
            try {
                var mediaType = typeof styleSheet.media;
                rules = mediaType == "string" ? styleSheet.rules : (mediaType == "object" ? styleSheet.cssRules : null);
                if (!rules) {
                    if (!!styleSheet.sheet && !!styleSheet.sheet.cssRules) {
                        rules = styleSheet.sheet.cssRules;
                    }
                }
            } catch (e) {
                //console.log('could not find style sheet rules');
                rules = undefined;
            }
        }
        return rules;
    }
    function initialize() {
        usingInsert = false;
        allRules = {};
        createStyleSheet();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * An object whose properties specify some of the visual attributes used by the TerraFly API, used in the creation of the [Styles]{@link tf.styles.Styles} {@link singleton}
 * @private
 * @typedef {object} tf.types.APIStyleSpecs
 * @property {string} fontFamily - default font family
 * @property {string} markerFontFamily - default font family for displaying text features on the map
 * @property {number} mapButtonDimEmNumber - dimension of map buttons
 * @property {number} mapButtonMarginEmNumber - margin of map buttons
 * @property {number} mapButtonSpacingEmNumber - spacing of map buttons
 * @property {number} mapScaleLineBkColor - background color of the map scale line
 * @property {colorWithOptionalAlpha} mapScaleLineBkColor - background color of the map scale line
 * @property {number} mapScaleLineBorderRadiusPxNumber - border radius of the map scale line
 * @property {number} mapScaleLinePaddingPxNumber - padding of the map scale line
 * @property {string} mapScaleLineBorder - border of the map scale line, example: "1px solid #07375f"
 * @property {number} mapScaleLineFontSizeEmNumber - font size of the map scale line
 * @property {number} mapScaleLineMarginPxNumber - line margin of the map scale line
 * @property {colorWithOptionalAlpha} mapScaleLineFontColor - text color of the map scale line
 * @property {number} overviewMapWidthPxNumber - width of the overview map, in pixels
 * @property {number} overviewMapHeightPxNumber - height of the overview map, in pixels
 * @property {number} overviewMapBorderWidthPxNumberNumber - border width of the overview map border, in pixels
 * @property {string} overviewMapBoxBorder - border of the overview map inner box, example: "2px dotted rgba(255,255,255,1.0)"
 * @property {string} tfLogoBorderRadius - border radius of the TerraFly logo displayed on the map, example: "10%"
 * @property {HTMLElementSize} tfLogoWidth - width of the TerraFly logo displayed on the map, example: "8em"
 * @property {HTMLElementSize} tfLogoHeight - height of the TerraFly logo displayed on the map, example: "8em"
 * @property {tf.types.opacity01} tfLogoOpacity - opacity of the TerraFly logo displayed on the map, example: 0.8
 * @property {colorWithOptionalAlpha} tfLogoBkColor - background color of the TerraFly logo displayed on the map
 * @property {string}  tfLogoBorder - border of the TerraFly logo displayed on the map, example: "1px solid rgba(128,128,128,0.3)"
 * @property {number} mapControlLineHeightEmNumber - line height of text in map controls
 * @property {colorWithOptionalAlpha} mapControlTextColor - text color of map controls
 * @property {number} maxHeightLogoImageEmNumber - maximum height of logos
 * @property {number} maxWidthLogoImageEmNumber - maximum width of logos
 * @property {number} imageThumbWidthEmNumber - maximum dimension of thumbnail images
 * @property {number} infoPopupContentFontSizeEmNumber - font size for map Info Popups
 * @property {number} locationPopupContentFontSizeEmNumber - font size for map Location Popups
 * @property {number} mapControlFontSizeEmNumber - font size for map buttons
 * @property {string} mapControlFontWeight - font weight for for map buttons, example: "700"
 * @property {number} popupContentFontSizeEmNumber - font size for popup contents
 * @property {number} topFontSizePXNumber - font size for top container, changing this default also impacts any element sizes that are defined in EM units
 * @property {number} markerFontSizePXNumber - default font size for displaying text features on the map
 * @property {number} buttonBorderRadiusPxNumber - button border radius
 * @property {number} buttonMarginTopBottomPxNumber - button vertical margins
 * @property {number} buttonMarginLeftRightPxNumber - button horizontal margins
 * @property {number} textButtonPaddingTopBottomPxNumber - text button vertical padding
 * @property {number} textButtonPaddingLeftRightPxNumber - text button horizontal padding
 * @property {number} paddingPxNumber - padding for padded containers
 * @property {number} popupContainerPaddingPxNumber - padding for padded popup containers
 * @property {number} popupCaptionBorderRadiusPXNumber - border radius for popup captions
 * @property {number} popupCaptionBorderRadiusPXNumber - border radius for popup captions
 * @property {number} popupContentPaddingPXNumber - popup content padding
 * @property {number} popupContentBorderRadiusPXNumber - popup content border radius
 * @property {number} svgButtonBorderRadiusPercentNumber - border radius for svg buttons
 * @property {colorWithOptionalAlpha} lightTextColor - light style text color
 * @property {colorWithOptionalAlpha} darkTextColor - dark style text color
 * @property {colorWithOptionalAlpha} disabledTextColor - color for disabled or grayed out text
 * @property {colorWithOptionalAlpha} borderLightColor - light style container separator color
 * @property {colorWithOptionalAlpha} borderDarkColor - dark style container separator color
 * @property {colorWithOptionalAlpha} defaultButtonBk - default button background color
 * @property {colorWithOptionalAlpha} defaultButtonFill - default button fill color
 * @property {colorWithOptionalAlpha} buttonShapedLinkBkColor - background color for links shaped like buttons
 * @property {colorWithOptionalAlpha} buttonShapedLinkTextColor - text color for links shaped like buttons
 * @property {number} buttonShapedLinkMarginPxNumber - margin for links shaped like buttons
 * @property {string} buttonShapedLinkTextShadow - text shadow for links shaped like buttons, example: "1px 1px 1px #333"
 * @property {string} buttonShapedLinkTextShadowHover - text shadow for links shaped like buttons, example: "1px 1px 1px #ccc"
 * @property {colorWithOptionalAlpha} buttonShapedLinkHoverBkColor - background color for links shaped like buttons
 * @property {colorWithOptionalAlpha} buttonShapedLinkHoverTextColor - text color for links shaped like buttons
 * @property {colorWithOptionalAlpha} mapControlBkColor - map control background color
 * @property {colorWithOptionalAlpha} mapControlHoverBkColor - map control background color on hover
 * @property {colorWithOptionalAlpha} mapControlButtonBkColor- map button background color
 * @property {colorWithOptionalAlpha} mapControlButtonHoverBkColor - map button background color on hover
 * @property {colorWithOptionalAlpha} popupContentBkColor - popup content background color
 * @property {colorWithOptionalAlpha} containerDarkBackgroundColor - dark style container background color
 * @property {colorWithOptionalAlpha} containerDarkSelBackgroundColor - dark style selected container background color
 * @property {colorWithOptionalAlpha} hcfLayoutContainerBkColor - {@link tf.layout.HeaderContentFooter} container default background color
 * @property {colorWithOptionalAlpha} popupCaptionBackgroundColor - popup caption background color
 * @property {colorWithOptionalAlpha} separatorBackgroundColor - layout separator background color
 * @property {colorWithOptionalAlpha} buttonLightBkg - light style button background color
 * @property {colorWithOptionalAlpha} buttonLightFill - light style button fill/text color
 * @property {colorWithOptionalAlpha} buttonDarkBkg - dark style button background color
 * @property {colorWithOptionalAlpha} buttonDarkFill - dark style button fill/text color
 * @property {colorWithOptionalAlpha} lightTextDivBtnColor - light style text button text color
 * @property {colorWithOptionalAlpha} darkTextDivBtnColor - dark style text button text color
 * @property {colorWithOptionalAlpha} textInputBackgroundColor - background color for text input
 * @property {colorWithOptionalAlpha} dLayerSpanBackgroundColor - background color for dLayer text spans
 * @property {colorWithOptionalAlpha} mapPopupTextButtonTextColor - text color of map buttons in popups
 * @property {colorWithOptionalAlpha} mapPopupTextButtonBkColor - background color of map buttons in popups
 * @property {colorWithOptionalAlpha} dLayerSpanBackgroundColor - background color for dLayer text spans
 * @property {colorWithOptionalAlpha} inputFormBkColor - background color for input forms
 * @property {number} inputFormBorderRadiusPxNumber - border radius for input forms
 * @property {number} imgFramePaddingBorderWidthEmNumber - padding used in image frames, for best results coordinate size with <b>imgFrameBorder</b>
 * @property {string} imgFrameBorder - border used in image frames, for best results coordinate size with <b>imgFramePaddingBorderWidthEmNumber</b>
 * @property {string} textShadow -default text shadow style, with light color shadow, example: "1px 1px 1px #eee"
 * @property {string} darkTextShadow - default text shadow style, with dark color shadow, example: "1px 1px 1px #333"
 * @property {string} textShadowSelRadioCheckStyle - text shadow for selected radio button and check box labels, example: "1px 2px 2px #ddd"
 * @property {string} borderSeparatorLineSpecs - used for border separators, example: "1px solid"
 * @property {string} mapZoomInBorderRadius - used for the map's zoom in button, example: "2px 2px 0 0"
 * @property {string} mapZoomOutBorderRadius - used for the map's zoom out button, example: "0 0 2px 2px"
 * @property {number} verticalSeparatorWidthEMNumber - width of vertical layout separators
 * @property {number} horizontalSeparatorHeightEMNumber - height of horizontal layout separators
*/
/**
 * @public
 * @function
 * @summary - Returns the default TerraFly style specifications, used in the creation of the [Styles]{@link tf.styles.Styles} {@link singleton}
 * @returns {tf.types.APIStyleSpecs} - the default specifications
*/
tf.styles.GetDefaultAPIStyleSpecifications = function () {
    var mapButtonDimEmNumber = 2.25;
    var mapControlFontSizeEmNumber = mapButtonDimEmNumber - 0.5;
    var popupContentFontSizeEmNumber = mapButtonDimEmNumber - 0.75;
    var fontFamily = "Arial,Verdana,Geneva,Lucida,Arial,Helvetica,sans-serif";
    //var fontFamily = "'SourceSansPro-regular',Verdana,Geneva,Lucida,Arial,Helvetica,sans-serif";
    var niceDarkColor = "#07375f";
    var niceLightTextColor = "#fff";
    var niceButtonBkColor = "#456DA7";
    var niceButtonFillColor = "#fff";
    var imgFramePaddingBorderWidthEmNumber = 0.15;
    var dLayerSpanBackgroundColor = "#ffd";
    var textShadow = '1px 1px 1px #eee';
    var darkTextShadow = '1px 1px 1px #333';
    var textShadowSelRadioCheck = '1px 2px 2px #ddd';
    var borderSeparatorLineSpecs = "1px solid";
    var textInputBackgroundColor = "#fff";
    var mapZoomInBorderRadius = "2px 2px 0 0";
    var mapZoomOutBorderRadius = "0 0 2px 2px";
    var mapControlLineHeightEmNumber = 0.4;
    var mapControlTextColor = "#00618b";
    var mapScaleLineBkColor = "rgba(255,255,255,0.7)";
    var mapScaleLineBorderRadiusPxNumber = 4;
    var mapScaleLinePaddingPxNumber = 2;
    var mapScaleLineBorder = "1px solid " + mapControlTextColor;
    var mapScaleLineFontSizeEmNumber = 0.9;
    var mapScaleLineMarginPxNumber = 1;
    var mapScaleLineFontColor = mapControlTextColor;
    var mapSubLegendBkColor = "#e4f4ff";
    var tfLogoBorderRadius = "10%";
    var tfLogoWidth = "8em";
    var tfLogoHeight = "8em";
    var tfLogoOpacity = "0.8";
    var tfLogoBkColor = "rgba(255,255,255,0.3)";
    var tfLogoBorder = "1px solid rgba(128,128,128,0.3)";
    var mapControlFontWeight = "700";
    var overviewMapWidthPxNumber = 200;
    var overviewMapHeightPxNumber = 200;
    var overviewMapBorderWidthPxNumberNumber = 2;
    var overviewMapBoxBorder = "2px dotted rgba(255,255,255,1.0)";
    var buttonShapedLinkBkColor = niceButtonBkColor;
    var buttonShapedLinkTextColor = niceButtonFillColor;
    var buttonShapedLinkHoverBkColor = "#0869bf";
    var buttonShapedLinkHoverTextColor = "#fdfff0";
    //var mapPopupTextButtonTextColor = niceButtonBkColor;
    //var mapPopupTextButtonBkColor = "#fff";
    var mapPopupTextButtonTextColor = "#fff";
    var mapPopupTextButtonBkColor = niceButtonBkColor;
    var buttonShapedLinkTextShadow = "1px 1px 1px #333";
    var buttonShapedLinkTextShadowHover = "1px 1px 1px #999";
    var buttonShapedLinkMarginPxNumber = 2;
    var inputFormBkColor = "#fff";
    var inputFormBorderRadiusPxNumber = 6;
    //this.QuietJSDoc = function() { }
    return {
        fontFamily: fontFamily,
        markerFontFamily: fontFamily,
        inputFormBkColor: inputFormBkColor,
        inputFormBorderRadiusPxNumber: inputFormBorderRadiusPxNumber,
        mapZoomInBorderRadius: mapZoomInBorderRadius,
        mapZoomOutBorderRadius: mapZoomOutBorderRadius,
        mapPopupTextButtonTextColor:mapPopupTextButtonTextColor,
        mapPopupTextButtonBkColor:mapPopupTextButtonBkColor,
        textInputBackgroundColor: textInputBackgroundColor,
        borderSeparatorLineSpecs: borderSeparatorLineSpecs,
        textShadow: textShadow,
        darkTextShadow: darkTextShadow,
        textShadowSelRadioCheck: textShadowSelRadioCheck,
        dLayerSpanBackgroundColor: dLayerSpanBackgroundColor,
        overviewMapWidthPxNumber :overviewMapWidthPxNumber,
        overviewMapHeightPxNumber :overviewMapHeightPxNumber,
        overviewMapBorderWidthPxNumberNumber :overviewMapBorderWidthPxNumberNumber,
        overviewMapBoxBorder : overviewMapBoxBorder,
        mapButtonDimEmNumber: mapButtonDimEmNumber,
        mapButtonMarginEmNumber: 0.33,
        mapButtonSpacingEmNumber: 0.75,
        mapScaleLineBkColor: mapScaleLineBkColor,
        mapScaleLineBorderRadiusPxNumber: mapScaleLineBorderRadiusPxNumber,
        mapScaleLinePaddingPxNumber: mapScaleLinePaddingPxNumber,
        mapScaleLineBorder: mapScaleLineBorder,
        mapScaleLineFontSizeEmNumber: mapScaleLineFontSizeEmNumber,
        mapScaleLineMarginPxNumber: mapScaleLineMarginPxNumber,
        mapScaleLineFontColor: mapScaleLineFontColor,
        mapControlFontWeight: mapControlFontWeight,
        mapSubLegendBkColor: mapSubLegendBkColor,
        tfLogoBorderRadius: tfLogoBorderRadius,
        tfLogoWidth: tfLogoWidth,
        tfLogoHeight: tfLogoHeight,
        tfLogoOpacity: tfLogoOpacity,
        tfLogoBkColor: tfLogoBkColor,
        tfLogoBorder: tfLogoBorder,
        mapControlLineHeightEmNumber: mapControlLineHeightEmNumber,
        mapControlTextColor: mapControlTextColor,
        maxHeightLogoImageEmNumber: 4.5,
        maxWidthLogoImageEmNumber: 12,
        imageThumbWidthEmNumber: 8,
        infoPopupContentFontSizeEmNumber: 1.2,
        locationPopupContentFontSizeEmNumber: 1,
        mapControlFontSizeEmNumber: mapControlFontSizeEmNumber,
        popupContentFontSizeEmNumber: popupContentFontSizeEmNumber,
        topFontSizePXNumber: 12,
        markerFontSizePXNumber: 14,
        buttonBorderRadiusPxNumber: 3,
        buttonMarginTopBottomPxNumber: 2,
        buttonMarginLeftRightPxNumber: 6,
        textButtonPaddingTopBottomPxNumber: 2,
        textButtonPaddingLeftRightPxNumber: 5,
        paddingPxNumber: 4,
        popupContainerPaddingPxNumber: 8,
        popupCaptionBorderRadiusPXNumber: 5,
        popupContentPaddingPXNumber: 5,
        popupContentBorderRadiusPXNumber: 10,
        svgButtonBorderRadiusPercentNumber: 20,
        lightTextColor: niceLightTextColor,
        darkTextColor: niceDarkColor,
        disabledTextColor: "#a4a4a4",
        borderLightColor: "#BFBFBF",
        borderDarkColor: niceDarkColor,
        defaultButtonBk: niceButtonBkColor,
        defaultButtonFill: niceButtonFillColor,
        buttonShapedLinkBkColor: buttonShapedLinkBkColor,
        buttonShapedLinkTextColor: buttonShapedLinkTextColor,
        buttonShapedLinkTextShadow: buttonShapedLinkTextShadow,
        buttonShapedLinkHoverBkColor: buttonShapedLinkHoverBkColor,
        buttonShapedLinkHoverTextColor: buttonShapedLinkHoverTextColor,
        buttonShapedLinkTextShadowHover: buttonShapedLinkTextShadowHover,
        buttonShapedLinkMarginPxNumber: buttonShapedLinkMarginPxNumber,
        mapControlBkColor: "rgba(244,244,254,.75)",
        mapControlHoverBkColor: "rgba(244,244,254,0.9)",
        mapControlButtonHoverBkColor: "rgba(255,255,255,1)",
        mapControlButtonBkColor: "rgba(244,244,254,.6)",
        popupContentBkColor: "rgb(219, 232, 241)",
        containerDarkBackgroundColor: niceDarkColor,
        containerDarkSelBackgroundColor: "rgb(25,182,0)",
        hcfLayoutContainerBkColor: niceDarkColor,
        popupCaptionBackgroundColor: "#eeeeee",
        separatorBackgroundColor: "#FF8800",
        buttonLightBkg: niceButtonBkColor,
        buttonLightFill: niceButtonFillColor,
        buttonDarkBkg: niceButtonFillColor,
        buttonDarkFill: niceButtonBkColor,
        lightTextDivBtnColor: niceLightTextColor,
        darkTextDivBtnColor: niceDarkColor,
        imgFramePaddingBorderWidthEmNumber: imgFramePaddingBorderWidthEmNumber,
        imgFrameBorder: imgFramePaddingBorderWidthEmNumber + "em solid " + niceDarkColor,
        verticalSeparatorWidthEMNumber: 0.85,
        horizontalSeparatorHeightEMNumber: 0.85
    };
};
/**
 * @public
 * @function
 * @summary - Returns the default TerraFly style specifications, used in the creation of the [Styles]{@link tf.styles.Styles} {@link singleton}
 * @returns {tf.types.APIStyleSpecs} - the default specifications
*/
tf.styles.GetGraphiteAPIStyleSpecifications = function () {
    var APIStyleSpecs = {
        separatorBackgroundColor: "rgba(0,107,133, 0.8)",
        inputFormBkColor: "rgba(128,128,128,0.5)",
        mapPopupTextButtonTextColor: "rgba(255,255,255,1)",
        mapPopupTextButtonBkColor: "rgba(0,0,0,0.7)",
        mapSubLegendBkColor: "rgba(0,0,0,0.5)",
        buttonShapedLinkBkColor: "rgba(0,0,0,0.5)",
        buttonShapedLinkTextColor: "rgba(255,255,255,1)",
        buttonShapedLinkHoverBkColor: "#fff",
        buttonShapedLinkMarginPxNumber: 1,
        buttonShapedLinkHoverTextColor: "rgba(0,0,0,1)",
        topFontSizePXNumber: 12,
        darkTextColor: "#eef",
        paddingPxNumber: "6",
        popupCaptionBorderRadiusPXNumber: 16,
        popupContentBkColor: "rgba(192, 192, 192, 0.6)",
        popupCaptionBackgroundColor: "rgba(210, 210, 210, 0.6)",
        mapControlButtonBkColor: "rgba(192, 192, 192, 0.7)",
        mapControlButtonHoverBkColor: "rgba(244, 244, 244, 0.7)",
        buttonDarkFill: "rgba(0, 0, 0, 0.7)",
        dLayerSpanBackgroundColor: "rgba(32, 32, 32, 1)",
        textShadow: '1px 1px 1px #000',
        darkTextShadow: '1px 1px 1px #fff',
        textShadowSelRadioCheck: '1px 1px 1px #333',
        borderSeparatorLineSpecs: "1px solid",
        textInputBackgroundColor: "#000",
        mapZoomInBorderRadius: "5px 5px 0 0",
        mapZoomOutBorderRadius: "0 0 5px 5px",
        mapControlFontWeight: "700",
        mapScaleLineBkColor: "rgba(255,255,255,0.5)",
        mapScaleLineBorderRadiusPxNumber: 4,
        mapScaleLinePaddingPxNumber: 2,
        mapScaleLineBorder: "1px solid #07375f",
        mapScaleLineFontSizeEmNumber: 0.9,
        mapScaleLineMarginPxNumber: 4,
        mapScaleLineFontColor: "rgba(0, 0, 0, 0.7)",
        tfLogoBorderRadius: "10%",
        tfLogoWidth: "8em",
        tfLogoHeight: "8em",
        tfLogoOpacity: 0.8,
        tfLogoBkColor: "rgba(255,255,255,0.3)",
        tfLogoBorder: "1px solid rgba(128,128,128,0.3)",
        mapControlLineHeightEmNumber: 0,
        mapControlTextColor: "rgba(0, 0, 0, 1)",
        overviewMapWidthPxNumber: 300,
        overviewMapHeightPxNumber: 200,
        overviewMapBorderWidthPxNumberNumber: 1,
        overviewMapBoxBorder: "2px dotted red"
    };
    return tf.js.ShallowMerge(tf.styles.GetDefaultAPIStyleSpecifications(), APIStyleSpecs);
};
/**
 * @public
 * @class
 * @summary - The {@link singleton} instance of this class, obtainable by calling {@link tf.GetStyles}().[GetSubStyles]{@link tf.styles.Styles#GetSubStyles}(),
 * includes the pre-defined [CSS Style Specifications]{@link tf.types.CSSStyleSpecs} used by the API
 * @param {tf.styles.Styles} styles - the {@link singleton} [Styles]{@link tf.styles.Styles} instance
 * @param {tf.types.APIStyleSpecs} alternativeSpecs - if defined, overrides the default API style specifications
*/
tf.styles.SubStyles = function (styles, alternativeSpecs) {
    var theThis;
    var mapButtonDimEmNumber, mapButtonMarginEmNumber, mapButtonSpacingEmNumber, topLeftButtonEmNumber, topRightButtonEmNumber;
    var maxHeightLogoImageEmNumber, maxWidthLogoImageEmNumber, borderSeparatorLightSpecs, borderSeparatorDarkSpecs, borderSeparatorButtonBkSpecs;
    var textButtonPaddingTopBottomPxNumber, textButtonPaddingLeftRightPxNumber;
    var buttonBorderRadiusPxNumber, buttonMarginTopBottomPxNumber, buttonMarginLeftRightPxNumber;
    var svgButtonBorderRadiusPercentNumber;
    var verticalSeparatorWidthEMNumber, horizontalSeparatorHeightEMNumber;
    var paddingPxNumber, popupCaptionBorderRadiusPXNumber, popupContentPaddingPXNumber, popupContentBorderRadiusPXNumber, dLayerSpanBackgroundColor;
    var textShadow, darkTextShadow, textShadowSelRadioCheck, borderSeparatorLineSpecs, textInputBackgroundColor, mapZoomInBorderRadius, mapZoomOutBorderRadius;
    var mapScaleLineBkColor;
    var mapScaleLineBorderRadiusPxNumber;
    var mapScaleLinePaddingPxNumber;
    var mapScaleLineBorder;
    var mapScaleLineFontSizeEmNumber;
    var mapScaleLineMarginPxNumber;
    var mapScaleLineFontColor, mapControlFontWeight;
    var tfLogoBorderRadius;
    var tfLogoWidth;
    var tfLogoHeight;
    var tfLogoOpacity;
    var tfLogoBkColor;
    var tfLogoBorder;
    var mapControlLineHeightEmNumber;
    var mapControlTextColor;
    var overviewMapWidthPxNumber;
    var overviewMapHeightPxNumber;
    var overviewMapBorderWidthPxNumberNumber;
    var overviewMapBoxBorder;
    var mapPopupTextButtonTextColor, mapPopupTextButtonBkColor;
    var buttonShapedLinkTextShadow, buttonShapedLinkTextShadowHover;
    var buttonShapedLinkMarginPxNumber;
    var inputFormBkColor;
    var inputFormBorderRadiusPxNumber;
    /*this.popupContainerPaddingPxNumber=null;
    this.lightTextColor=null; this.darkTextColor=null; this.disabledTextColor=null; this.borderLightColor=null; this.defaultButtonBk=null; this.defaultButtonFill=null; 
    this.buttonShapedLinkBkColor=null; this.buttonShapedLinkTextColor=null;
    this.buttonShapedLinkHoverBkColor=null; this.buttonShapedLinkHoverTextColor=null;
    this.topFontSizePXNumber=null; this.markerFontSizePXNumber=null;
    this.textButtonHeightDelta=null;
    this.imageThumbWidthEmNumber=null; this.imageThumbSquareHeightEmNumber=null; this.imageThumbRectHeightEmNumber=null;
    this.mapButtonDimEmNumber=null; this.mapButtonMarginEmNumber=null;
    this.mapLocationButtonTopEmNumber=null;
    this.mapControlBkColor=null; this.mapControlHoverBkColor=null; this.mapControlButtonHoverBkColor=null; this.mapControlButtonBkColor=null;
    this.containerDarkBackgroundColor=null; this.containerDarkSelBackgroundColor=null; this.hcfLayoutContainerBkColor=null; this.popupCaptionBackgroundColor=null; this.separatorBackgroundColor=null;
    this.buttonLightBkg=null; this.buttonLightFill=null; this.buttonDarkBkg=null; this.buttonDarkFill=null; this.lightTextDivBtnColor=null; this.darkTextDivBtnColor=null;
    this.imgFramePaddingBorderWidthEmNumber=null; this.imgFrameBorder=null; this.mapSubLegendBkColor = null*/
    /**
     * @public
     * @function
     * @summary - Retrieves the [Styles]{@link tf.styles.Styles} {@link singleton}
     * @returns {tf.styles.Styles} - | {@link tf.styles.Styles} the {@link singleton}
    */
    this.GetStyles = function () { return styles; }
    /**
     * @public
     * @function
     * @summary - Creates HTML Shadow [Style Specifications]{@link tf.types.CSSStyleSpecs} that can be applied
     * with the function [ApplyStyleProperties]{@link tf.style.Styles#ApplyStyleProperties} or used as a building block of
     * another style specification
     * @param {number} offXPxNumber - horizontal offset, in pixels
     * @param {number} offYPxNumber - vertical offset, in pixels
     * @param {number} blurPxNumber - blur radius, in pixels
     * @param {colorWithOptionalAlpha} shadowColorStr - color
     * @returns {tf.types.CSSStyleSpecs} - | {@link tf.types.CSSStyleSpecs} the specifications
    */
    this.CreateShadowStyle = function (offXPxNumber, offYPxNumber, blurPxNumber, shadowColorStr) { return createShadowStyle(offXPxNumber, offYPxNumber, blurPxNumber, shadowColorStr); }
    /**
     * @public
     * @function
     * @summary - Creates custom [Style Specifications]{@link tf.types.CSSStyleSpecs} used by [SVG Glyph Button]{@link tf.ui.SvgGlyphBtn} instances to customize 
     * the <b>glyph</b> and <b>background</b> colors displayed in normal and hover states
     * @param {color} glyphColor - normal glyph color
     * @param {color} backgroundColor - normal background color
     * @param {color} glyphColorHover - glyph color on hover
     * @param {color} backgroundColorHover - background color on hover
     * @returns {tf.types.CSSStyleAndHoverSpecifications} - | {@link tf.types.CSSStyleAndHoverSpecifications} the style specifications
    */
    this.CreateSvgGlyphStyles = function (glyphColor, backgroundColor, glyphColorHover, backgroundColorHover) { return createSvgGlyphStyles(glyphColor, backgroundColor, glyphColorHover, backgroundColorHover); }
    /**
     * @public
     * @function
     * @summary - Creates custom [Style Specifications]{@link tf.types.CSSStyleSpecs} used by [Text Button]{@link tf.ui.TextBtn} instances to customize the <b>text</b> and <b>background</b> colors displayed 
     * in normal and hover states
     * @param {color} textColor - normal text color
     * @param {color} backgroundColor - normal background color
     * @param {color} textColorHover - text color on hover
     * @param {color} backgroundColorHover - background color on hover
     * @returns {tf.types.CSSStyleAndHoverSpecifications} - | {@link tf.types.CSSStyleAndHoverSpecifications} the style specifications
    */
    this.CreateTextDivBtnStyles = function (textColor, backgroundColor, textColorHover, backgroundColorHover) { return createTextDivBtnStyles(textColor, backgroundColor, textColorHover, backgroundColorHover); }
    this.mapControlFontSizeEmNumber = null;
    this.popupContentFontSizeEmNumber = null;
    this.popupContentBkColor = null;
    this.addressBarFontSize = null;
    this.infoPopupContentFontSizeEmNumber = null;
    this.locationPopupContentFontSizeEmNumber = null;
    /*
    this.fontFaceStyleContentStr=null;
    this.popupCaptionBorderRadiusStyle=null; this.popupContentPaddingStyle=null; this.popupContentBorderRadiusStyle=null; this.textShadowStyle=null; this.darkTextShadowStyle=null;
    this.seShadowStyle=null; this.horShadowStyle=null;
    this.textShadowSelRadioCheckStyle=null; this.defaultWidthHeightRadioCheckStyle=null; this.defaultRightPaddingRadioCheckStyle=null;
    this.paddingStyle=null; this.paddingLeftRightStyle=null; this.separatorBkColorStyle=null; this.rightSideContainerBkColorStyle=null; this.hcfLayoutContainerBkColorStyle =null;
    this.popupCaptionBackgroundColorStyle=null; this.divIconCursorStyle=null; this.noBorderMarginPaddingStyle=null; this.verticalSeparatorWidthStyle=null; this.horizontalSeparatorHeightStyle=null;
    this.darkTextColorStyle=null; this.lightTextColorStyle=null; this.disabledTextColorStyle=null; this.defaultButtonBkStyle=null; this.buttonBorderRadiusStyle=null;
    this.appContainerStyle=null; this.mapContainerStyle=null; this.mapSubContainerStyle=null; this.popupMapToolBarBaseStyle=null; this.mapToolBarContainerStyle=null;
    this.topSeparatorLightStyle=null; this.bottomBorderSeparatorLightStyle=null;
    this.bottomBorderSeparatorDarkStyle=null; this.rightBorderSeparatorLightStyle=null; this.rightBorderSeparatorDarkStyle=null;
    this.popupContainerStyle=null; this.popupContentStyle=null; this.spanStyle=null; this.spanCursorPointerStyle=null;
    this.appContainerBaseStyle=null; this.hcfLayoutStyle=null; this.hcfLayoutHeaderStyle=null; this.hcfLayoutFooterStyle=null; this.hcfLayoutContentStyle=null;
    this.buttonShapedLinkStyle=null; this.buttonShapedLinkHoverStyle=null; this.dLayerInfoStyle=null; this.dLayerInfoImgStyle=null; this.dLayerInfoLinkStyle=null; this.dLayerInfoLinkHoverStyle=null; this.dLayerInfoSpanStyle=null;
    this.inputTextPlaceholderStyle=null; this.inputTextStyle=null; this.radioCheckStyle=null; this.radioCheckWithDimStyle=null; this.radioCheckLabelStyle=null; this.radioCheckRemoveDefaultStyle=null; this.radioCheckLabelCheckedStyle=null;
    this.radioLabelStyle=null; this.radioRadioStyle=null; this.radioRadioAndLabelCheckedStyle=null; this.radioRadioAndLabelStyleBefore=null; this.radioRadioAndLabelSelStyleBefore=null;
    this.checkLabelStyle=null; this.checkCheckStyle=null; this.checkCheckAndLabelCheckedStyle=null; this.checkCheckAndLabelStyleBefore=null; this.checkCheckAndLabelSelStyleBefore=null;
    this.mapMeasureOverlayDivStyle=null; this.imgStyleBase=null; this.logoMaxWidthHeightStyle=null; this.imgLogoStyle=null;
    this.imgFullWidthHeightStyle=null; this.imgDefaultFrameStyle=null; this.divWithImgBkkSizeStyle=null;
    this.divWithImgBkStyle=null; this.imgForInfoWindowStyle=null; this.buttonStyleBase=null; this.svgGlyphStyleBase=null; this.svgGlyphLightNoHoverStyle=null; this.svgGlyphLightStyle=null; this.svgGlyphLightStyleHover=null;
    this.svgGlyphDarkNoHoverStyle=null; this.svgGlyphDarkStyle=null; this.svgGlyphDarkStyleHover=null; this.divSvgGlyphStyle=null;
    this.buttonDivMarginTopStyle=null; this.buttonDivMarginBotStyle=null; this.buttonDivTopBotMarginsStyle=null; this.buttonDivMarginLeftStyle=null; this.buttonDivMarginRightStyle=null; this.buttonDivLeftRightMarginsStyle=null;
    this.buttonDivAllMarginsStyle=null; this.divSvgGlyphBtnStyle=null; this.divSvgGlyphIconStyle=null;
    this.textButtonStyleBase=null; this.textDivBtnLightStyle=null; this.textDivBtnLightStyleHover=null; this.textDivBtnDarkStyle=null; this.textDivBtnDarkStyleHover=null;
    this.paddedBlockDivStyle=null; this.paddedInlineBlockDivStyle=null; this.paddedBlockDivWithBorderSeparatorStyle=null; this.paddedInlineBlockDivWithBorderSeparatorStyle=null;
    this.unPaddedBlockDivStyle=null; this.unPaddedInlineBlockDivStyle=null; this.leftSideContainerStyle=null; this.floatLeftSideContainerStyle=null; this.leftRightSideSeparatorStyle=null;
    this.rightSideContainerStyle=null; this.bottomContainerStyle=null; this.topBottomSeparatorStyle=null;
    this.listContentStyle=null; this.inputFormStyle=null; this.mapButtonLeftMarginStyle=null; this.mapButtonRightMarginStyle=null;
    this.mapAddressButtonStyle=null; this.mapZoomStyle=null; this.mapLayersButtonStyle=null; this.mapTypeButtonStyle=null; this.mapMeasureButtonStyle=null;
    this.mapDownloadButtonStyle=null; this.mapSourceButtonStyle=null; this.mapFullScreenButtonStyle=null;
    this.mapViewPortUnSelectableStyle=null; this.mapZoomInBorderRadiusStyle=null; this.mapZoomOutBorderRadiusStyle=null; this.mapZoomSliderStyle=null;
    this.transitionOpacityToVisibleStyle=null; this.transitionOpacityToInvisibleStyle=null;
    this.mapLocationButtonStyle=null; this.mapUserLocationButtonStyle=null; this.mapRotateStyle=null; this.mapRotateHiddenStyle=null;
    this.popupContentBkColorStyle=null; this.mapCompassStyle=null; this.mapButtonTextSpanStyle=null; this.mapScaleLineStyle=null; this.mapScaleLineInnerStyle=null;
    this.mapControlBkColorStyle=null; this.mapControlHoverBkColorStyle=null; this.mapControlButtonHoverBkColorStyle=null; this.mapControlButtonBkColorStyle=null;
    this.mapControlStyle=null; this.mapControlHoverStyle=null;
    this.mapControlButtonLineHeightStyle=null; this.mapControlButtonTextColorStyle=null; this.mapControlButtonWidthHeightStyle=null;
    this.mapControlButtonStyle=null; this.mapControlButtonFocusHoverStyle=null; this.mapControlButtonMozFocusInnerStyle=null;
    this.mapOverviewMapStyle=null; this.mapOverviewMapUnCollapsibleStyle=null; this.mapOverviewMapButtonStyle=null; this.mapOverviewMapMapStyle=null;
    this.mapOverviewMapButtonNotCollapsedStyle=null; this.mapOverviewMapButtonCollapsedStyle=null; this.mapOverviewMapNotCollapsedStyle=null;
    this.mapOverviewMapBoxStyle=null;
    this.mapTFLogoControlStyle=null; this.popupCaptionStyle=null; this.bodyStyle=null;*/
    /**
     * specifies 1px margin
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.margin1PXStyle = null;
    /**
     * specifies opacity 0 and visibility hidden, used in transitions
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.opacityVisibilityHideStyle = null;
    /**
     * specifies opacity 1 and visibility show, used in transitions
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.opacityVisibilityShowStyle = null;
    /**
     * specifies the default visibility transition
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.defaultOpacityVisibilityTransitionStyle = null;
    /**
     * specifies a visibility transition faster than the default
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.fasterOpacityVisibilityTransitionStyle = null;
    /**
     * specifies float left used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.floatLeftStyle = null;
    /**
     * specifies float right used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.floatRightStyle = null;
    /**
     * specifies float none used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.floatNoneStyle = null;
    /**
     * specifies the top container font size, inherited by sub containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.topFontSizeStyle = null;
    /**
     * specifies the default fount style, inherited by sub containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.defaultFontStyle = null;
    /**
     * specifies font size inheritance
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.fontSizeInheritStyle = null;
    /**
     * specifies radio button checked
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.defaultRadioCheckedStyle = null;
    /**
     * specifies radio button unchecked
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.defaultRadioUnCheckedStyle = null;
    /**
     * specifies check box checked
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.defaultCheckCheckedStyle = null;
    /**
     * specifies check box unchecked
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.defaultCheckUnCheckedStyle = null;
    /**
     * specifies default font size and style, inherited by sub containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.defaultFontAndTopSizeStyle = null;
    /**
     * specifies inheritance of font size
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.defaultFontSizeInheritStyle = null;
    /**
     * specifies visibility hidden, used in transitions
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.visibilityHiddenStyle = null;
    /**
     * specifies visibility visible, used in transitions
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.visibilityVisibleStyle = null;
    /**
     * specifies opacity 0 (fully transparent), used in transitions
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.opacityZeroStyle = null;
    /**
     * specifies opacity 1 (fully opaque), used in transitions
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.opacityOneStyle = null;
    /**
     * specifies no border, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.noBorderStyle = null;
    /**
     * specifies no border spacing, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.noBorderSpacingStyle = null;
    /**
     * specifies no margin, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.noMarginStyle = null;
    /**
     * specifies no padding, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.noPaddingStyle = null;
    /**
     * specifies position absolute, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.positionAbsoluteStyle = null;
    /**
     * specifies position relative, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.positionRelativeStyle = null;
    /**
     * specifies transparent background, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.transparentBackgroundStyle = null;
    /**
     * specifies the light background used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.whiteBackgroundStyle = null;
    /**
     * specifies the background used in text input boxes
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.textInputBackgroundStyle = null;
    /**
     * specifies no pointer events, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.noPointerEventsStyle = null;
    /**
     * specifies all pointer events, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.allPointerEventsStyle = null;
    /**
     * specifies a mouse pointer suitable for clickable interface items (usually a hand)
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.cursorPointerStyle = null;
    /**
     * specifies the default mouse pointer (usually the regular arrow pointer)
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.cursorDefaultStyle = null;
    /**
     * specifies that an element's transform will frequently be changed
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.willChangeTransformStyle = null;
    /**
     * specifies no outline, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.noOutlineStyle = null;
    /**
     * specifies 100% width
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.fullWidthStyle = null;
    /**
     * specifies 100% height
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.fullHeightStyle = null;
    /**
     * specifies inherited width
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.inheritWidthStyle = null;
    /**
     * specifies inherited height
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.inheritHeightStyle = null;
    /**
     * specifies auto width
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.autoWidthStyle = null;
    /**
     * specifies auto height
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.autoHeightStyle = null;
    /**
     * specifies auto width and height
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.autoWidthAutoHeightStyle = null;
    /**
     * specifies 100% width and height
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.fullWidthHeightStyle = null;
    /**
     * specifies 100% width and auto height
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.fullWidthAutoHeightStyle = null;
    /**
     * specifies auto width and 100% height
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.autoWidthFullHeightStyle = null;
    /**
     * specifies inherited width and height
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.inheritWidthHeightStyle = null;
    /**
     * specifies inline-block display, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.inlineBlockStyle = null;
    /**
     * specifies block display, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.blockStyle = null;
    /**
     * specifies none display (hides the element), used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.noneDisplayStyle = null;
    /**
     * specifies overflow hidden, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.overflowHiddenStyle = null;
    /**
     * specifies overflow auto, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.overflowAutoStyle = null;
    /**
     * specifies overflow scroll in the vertical direction, used on some containers like vertical lists and tables
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.overflowYScrollStyle = null;
    /**
     * specifies middle vertical align, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.middleVerticalAlignStyle = null;
    /**
     * specifies inherit vertical align, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.inheritVerticalAlignStyle = null;
    /**
     * specifies center text alignment, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.textAlignCenterStyle = null;
    /**
     * specifies left text alignment, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.textAlignLeftStyle = null;
    /**
     * specifies no border radius, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.noBorderRadiusStyle = null;
    /**
     * specifies no border, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.borderNoneStyle = null;
    /**
     * specifies no user selection allowed, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.noSelectStyle = null;
    /**
     * specifies an image is not draggable, used on some images
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.notDraggableStyle = null;
    /**
     * specifies no text decoration, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.noTextDecorationStyle = null;
    /**
     * specifies subcontainer positioning to the left edge of the parent container, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.snapLeftStyle = null;
    /**
     * specifies subcontainer positioning to the right edge of the parent container, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.snapRightStyle = null;
    /**
     * specifies subcontainer positioning to the top edge of the parent container, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.snapTopStyle = null;
    /**
     * specifies subcontainer positioning to the bottom edge of the parent container, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.snapBotStyle = null;
    /**
     * specifies subcontainer positioning to the horizontal center of the parent container, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.snapCenterHorStyle = null;
    /**
     * specifies subcontainer positioning to the vertical center of the parent container, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.snapCenterVerStyle = null;
    /**
     * specifies subcontainer positioning to both the horizontal and vertical center of the parent container, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.snapCenterStyle = null;
    /**
     * specifies subcontainer positioning to the left top corner of the parent container, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.snapLeftTopStyle = null;
    /**
     * specifies subcontainer positioning to the right top corner of the parent container, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.snapRightTopStyle = null;
    /**
     * specifies subcontainer positioning to the left bottom corner of the parent container, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.snapLeftBotStyle = null;
    /**
     * specifies subcontainer positioning to the right top corner of the parent container, used on some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.snapRightBotStyle = null;
    /**
     * specifies popup caption border radius, used with popups
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.popupCaptionBorderRadiusStyle = null;
    /**
     * specifies popup content padding border radius, used with popups
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.popupContentPaddingStyle = null;
    /**
     * specifies popup content border radius, used with popups
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.popupContentBorderRadiusStyle = null;
    /**
     * specifies the default text shadow
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.textShadowStyle = null;
    /**
     * specifies a text shadow darker than the default
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.darkTextShadowStyle = null;
    /**
     * specifies a South East shadow, used by some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.seShadowStyle = null;
    /**
     * specifies a horizontal (East) shadow, used by some containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.horShadowStyle = null;
    /**
     * specifies the text shadow used by selected radio buttons and check boxes
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.textShadowSelRadioCheckStyle = null;
    /**
     * specifies the dimensions used by radio button and check box images
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.defaultWidthHeightRadioCheckStyle = null;
    /**
     * specifies the right padding used by radio button and check box images to separate the label from the button/box
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.defaultRightPaddingRadioCheckStyle = null;
    /**
     * specifies padding used by padded containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.paddingStyle = null;
    /**
     * specifies padding used by padded containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.paddingLeftRightStyle = null;
    /**
     * specifies background color for containers used as layout separators
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.separatorBkColorStyle = null;
    /**
     * specifies background color for containers used on the right side of layouts
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.rightSideContainerBkColorStyle = null;
    /**
     * specifies background color for head content footer layout container
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.hcfLayoutContainerBkColorStyle = null;
    /**
     * specifies background color for popup captions
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.popupCaptionBackgroundColorStyle = null;
    /**
     * specifies cursor for non-clickable icons
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.divIconCursorStyle = null;
    /**
     * specifies no border, margin, padding, used on unpadded containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.noBorderMarginPaddingStyle = null;
    /**
     * specifies width for containers used as vertical layout separators
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.verticalSeparatorWidthStyle = null;
    /**
     * specifies height for containers used as horizontal layout separators
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.horizontalSeparatorHeightStyle = null;
    /**
     * specifies text color used in the API's dark style settings
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.darkTextColorStyle = null;
    /**
     * specifies text color used in the API's light style settings
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.lightTextColorStyle = null;
    /**
     * specifies disabled text color
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.disabledTextColorStyle = null;
    /**
     * specifies default button background color
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.defaultButtonBkStyle = null;
    /**
     * specifies default button background color
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.buttonBorderRadiusStyle = null;
    /**
     * specifies application containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.appContainerStyle = null;
    /**
     * specifies map containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.mapContainerStyle = null;
    /**
     * specifies map sub containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.mapSubContainerStyle = null;
    /**
     * specifies map popup and toolbar containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.popupMapToolBarBaseStyle = null;
    /**
     * specifies map toolbar containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.mapToolBarContainerStyle = null;
    /**
     * specifies top separators used in the API's light style settings
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.topSeparatorLightStyle = null;
    /**
     * specifies bottom separators used in the API's light style settings
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.bottomBorderSeparatorLightStyle = null;
    /**
     * specifies bottom separators used in the API's dark style settings
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.bottomBorderSeparatorDarkStyle = null;
    /**
     * specifies right separators used in the API's light style settings
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.rightBorderSeparatorLightStyle = null;
    /**
     * specifies right separators used in the API's dark style settings
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.rightBorderSeparatorDarkStyle = null;
    /**
     * specifies left separators used in the API's light style settings
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.leftBorderSeparatorLightStyle = null;
    /**
     * specifies left separators used in the API's dark style settings
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.leftBorderSeparatorDarkStyle = null;
    /**
     * specifies popup containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.popupContainerStyle = null;
    /**
     * specifies popup content
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.popupContentStyle = null;
    /**
     * specifies spans
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.spanStyle = null;
    /**
     * specifies clickable spans with a pointer cursor
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.spanCursorPointerStyle = null;
    /**
     * specifies application containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.appContainerBaseStyle = null;
    /**
     * specifies header content footer layout containers
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.hcfLayoutStyle = null;
    /**
     * specifies header containers in header content footer layouts
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.hcfLayoutHeaderStyle = null;
    /**
     * specifies footer containers in header content footer layouts
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.hcfLayoutFooterStyle = null;
    /**
     * specifies content containers in header content footer layouts
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.hcfLayoutContentStyle = null;
    /**
     * specifies button shaped links
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.buttonShapedLinkStyle = null;
    /**
     * specifies button shaped links in hover state
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.buttonShapedLinkHoverStyle = null;
    /**
     * specifies dlayer info popup content
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.dLayerInfoStyle = null;
    /**
     * specifies dlayer info popup image content
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.dLayerInfoImgStyle = null;
    /**
     * specifies dlayer info popup link content
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.dLayerInfoLinkStyle = null;
    /**
     * specifies dlayer info popup link content in hover state
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.dLayerInfoLinkHoverStyle = null;
    /**
     * specifies dlayer info popup span content
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.dLayerInfoSpanStyle = null;
    /**
     * specifies text input placeholders
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.inputTextPlaceholderStyle = null;
    /**
     * specifies the background color for input forms
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.inputFormBkStyle = null;
    /**
     * specifies text input text
     * @public
     * @type {tf.types.CSSStyleSpecs}
    */
    this.inputTextStyle = null;
    /**
     * specifies custom radio button part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.radioCheckStyle = null;
    /**
     * specifies custom radio button part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.radioCheckWithDimStyle = null;
    /**
     * specifies custom radio button part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.radioCheckLabelStyle = null;
    /**
     * specifies custom radio button part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.radioCheckRemoveDefaultStyle = null;
    /**
     * specifies custom radio button part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.radioCheckLabelCheckedStyle = null;
    /**
     * specifies custom radio button part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.radioLabelStyle = null;
    /**
     * specifies custom radio button part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.radioRadioStyle = null;
    /**
     * specifies custom radio button part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.radioRadioAndLabelCheckedStyle = null;
    /**
     * specifies custom radio button part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.radioRadioAndLabelStyleBefore = null;
    /**
     * specifies custom radio button part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.radioRadioAndLabelSelStyleBefore = null;
    /**
     * specifies custom check box part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.checkLabelStyle = null;
    /**
     * specifies custom check box part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.checkCheckStyle = null;
    /**
     * specifies custom check box part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.checkCheckAndLabelCheckedStyle = null;
    /**
     * specifies custom check box part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.checkCheckAndLabelStyleBefore = null;
    /**
     * specifies custom check box part. Used internally by the API
     * @private
     * @type {tf.types.CSSStyleSpecs}
    */
    this.checkCheckAndLabelSelStyleBefore = null;
    this.mapMeasureOverlayDivStyle = null;
    this.imgStyleBase = null;
    this.logoMaxWidthHeightStyle = null;
    this.imgLogoStyle = null;
    this.imgFullWidthHeightStyle = null;
    this.imgDefaultFrameStyle = null;
    this.divWithImgBkkSizeStyle = null;
    this.divWithImgBkStyle = null;
    this.imgForInfoWindowStyle = null;
    this.buttonStyleBase = null;
    this.svgGlyphStyleBase = null;
    this.svgGlyphLightNoHoverStyle = null;
    this.svgGlyphLightStyle = null;
    this.svgGlyphLightStyleHover = null;
    this.svgGlyphDarkNoHoverStyle = null;
    this.mapSvgGlyphInButtonStyle = null;
    this.mapSvgGlyphInPopupStyle = null;
    this.mapSvgGlyphInPopupHoverStyle = null;
    this.svgGlyphDarkStyle = null;
    this.svgGlyphDarkStyleHover = null;
    this.divSvgGlyphStyle = null;
    this.buttonDivMarginTopStyle = null;
    this.buttonDivMarginBotStyle = null;
    this.buttonDivTopBotMarginsStyle = null;
    this.buttonDivMarginLeftStyle = null;
    this.buttonDivMarginRightStyle = null;
    this.buttonDivLeftRightMarginsStyle = null;
    this.buttonDivAllMarginsStyle = null;
    this.divSvgGlyphBtnStyle = null;
    this.divSvgGlyphIconStyle = null;
    this.textButtonStyleBase = null;
    this.textDivBtnLightStyle = null;
    this.textDivBtnLightStyleHover = null;
    this.textDivBtnDarkStyle = null;
    this.textDivBtnDarkStyleHover = null;
    this.paddedBlockDivStyle = null;
    this.paddedInlineBlockDivStyle = null;
    this.paddedBlockDivWithBorderSeparatorStyle = null;
    this.paddedInlineBlockDivWithBorderSeparatorStyle = null;
    this.unPaddedBlockDivStyle = null;
    this.unPaddedInlineBlockDivStyle = null;
    this.leftSideContainerStyle = null;
    this.floatLeftSideContainerStyle = null;
    this.leftRightSideSeparatorStyle = null;
    this.rightSideContainerStyle = null;
    this.bottomContainerStyle = null;
    this.topBottomSeparatorStyle = null;
    this.listContentStyle = null;
    this.inputFormStyle = null;
    this.mapButtonLeftMarginStyle = null;
    this.mapButtonRightMarginStyle = null;
    this.mapAddressButtonStyle = null;
    this.mapZoomStyle = null;
    this.mapLayersButtonStyle = null;
    this.mapTypeButtonStyle = null;
    this.mapMeasureButtonStyle = null;
    this.mapDownloadButtonStyle = null;
    this.mapSourceButtonStyle = null;
    this.mapFullScreenButtonStyle = null;
    this.mapViewPortUnSelectableStyle = null;
    this.mapZoomInBorderRadiusStyle = null;
    this.mapZoomOutBorderRadiusStyle = null;
    this.mapZoomSliderStyle = null;
    this.transitionOpacityToVisibleStyle = null;
    this.transitionOpacityToInvisibleStyle = null;
    this.mapLocationButtonStyle = null;
    this.mapUserLocationButtonStyle = null;
    this.mapRotateStyle = null;
    this.mapRotateHiddenStyle = null;
    this.popupContentBkColorStyle = null;
    this.mapCompassStyle = null;
    this.mapButtonTextSpanStyle = null;
    this.mapScaleLineStyle = null;
    this.mapScaleLineInnerStyle = null;
    this.mapControlBkColorStyle = null;
    this.mapControlHoverBkColorStyle = null;
    this.mapControlButtonHoverBkColorStyle = null;
    this.mapControlButtonBkColorStyle = null;
    this.mapControlStyle = null;
    this.mapControlHoverStyle = null;
    this.mapControlButtonLineHeightStyle = null;
    this.mapControlButtonTextColorStyle = null;
    this.mapControlButtonWidthHeightStyle = null;
    this.mapControlButtonStyle = null;
    this.mapControlButtonFocusHoverStyle = null;
    this.mapControlButtonMozFocusInnerStyle = null;
    this.mapOverviewMapStyle = null;
    //this.mapOverviewMapUnCollapsibleStyle = null;
    this.mapOverviewMapButtonStyle = null;
    this.mapOverviewMapMapStyle = null;
    this.mapOverviewMapButtonNotCollapsedStyle = null;
    this.mapOverviewMapButtonCollapsedStyle = null;
    this.mapOverviewMapNotCollapsedStyle = null;
    this.mapOverviewMapBoxStyle = null;
    this.mapTFLogoControlStyle = null;
    this.popupCaptionStyle = null;
    this.bodyStyle = null;
    function createConstantStyles() {
        var zeroDim = "0px";
        borderSeparatorLightSpecs = borderSeparatorLineSpecs + " " + theThis.borderLightColor;
        borderSeparatorDarkSpecs = borderSeparatorLineSpecs + " " + theThis.borderDarkColor;
        borderSeparatorButtonBkSpecs = borderSeparatorLineSpecs + " " + theThis.defaultButtonBk;
        theThis.margin1PXStyle = { margin: "1px" };
        theThis.defaultOpacityVisibilityTransitionStyle = { transition: "opacity .15s ease-in-out, visibility 0.15s ease-in-out, margin-top 0s 1s" };
        theThis.fasterOpacityVisibilityTransitionStyle = { transition: "opacity .10s ease-in-out, visibility .10s ease-in-out, margin-top 0s 1s" };
        theThis.floatLeftStyle = { "float": "left" };
        theThis.floatRightStyle = { "float": "right" };
        theThis.floatNoneStyle = { "float": "none" };
        theThis.defaultRadioCheckedStyle = { content: "'\\25cf'" };
        theThis.defaultRadioUnCheckedStyle = { content: "'\\25cb'" };
        theThis.defaultCheckCheckedStyle = { content: "'\\2611'" };
        theThis.defaultCheckUnCheckedStyle = { content: "'\\2610'" };
        theThis.topFontSizeStyle = { fontSize: theThis.topFontSizePXNumber + "px" };
        theThis.defaultFontStyle = { fontFamily: theThis.fontFamily };
        theThis.fontSizeInheritStyle = { fontSize: 'inherit' };
        theThis.defaultFontAndTopSizeStyle = { inherits: [theThis.defaultFontStyle, theThis.topFontSizeStyle] };
        theThis.defaultFontSizeInheritStyle = { inherits: [theThis.defaultFontStyle, theThis.fontSizeInheritStyle] };
        theThis.visibilityHiddenStyle = { visibility: 'hidden' };
        theThis.visibilityVisibleStyle = { visibility: 'visible' };
        theThis.opacityZeroStyle = { opacity: '0' };
        theThis.opacityOneStyle = { opacity: '1' };
        theThis.opacityVisibilityHideStyle = { inherits: [theThis.opacityZeroStyle, theThis.visibilityHiddenStyle], marginTop: "-10000px" };
        theThis.opacityVisibilityShowStyle = { inherits: [theThis.opacityOneStyle, theThis.visibilityVisibleStyle], marginTop: "auto" };
        theThis.noBorderStyle = { border: zeroDim };
        theThis.noBorderSpacingStyle = { borderSpacing: zeroDim };
        theThis.noMarginStyle = { margin: zeroDim };
        theThis.noPaddingStyle = { padding: zeroDim };
        theThis.positionAbsoluteStyle = { position: 'absolute' };
        theThis.positionRelativeStyle = { position: 'relative' };
        theThis.transparentBackgroundStyle = { backgroundColor: 'rgba(0,0,0,0.0)' };
        theThis.whiteBackgroundStyle = { backgroundColor: '#fff' };
        theThis.textInputBackgroundStyle = { background: textInputBackgroundColor };
        theThis.noPointerEventsStyle = { pointerEvents: 'none' };
        theThis.allPointerEventsStyle = { pointerEvents: 'all' };
        theThis.cursorPointerStyle = { cursor: 'pointer' };
        theThis.cursorDefaultStyle = { cursor: 'default' };
        theThis.willChangeTransformStyle = { willChange: "transform" };
        theThis.noOutlineStyle = { outline: 0 };
        theThis.fullWidthStyle = { width: "100%" };
        theThis.fullHeightStyle = { height: "100%" }
        theThis.inheritWidthStyle = { width: "inherit" };
        theThis.inheritHeightStyle = { height: "inherit" };
        theThis.autoWidthStyle = { width: 'auto' };
        theThis.autoHeightStyle = { height: 'auto' };
        theThis.autoWidthAutoHeightStyle = { inherits: [theThis.autoWidthStyle, theThis.autoHeightStyle] }
        theThis.fullWidthHeightStyle = { inherits: [theThis.fullWidthStyle, theThis.fullHeightStyle] }
        theThis.fullWidthAutoHeightStyle = { inherits: [theThis.fullWidthStyle, theThis.autoHeightStyle] };
        theThis.autoWidthFullHeightStyle = { inherits: [theThis.autoWidthStyle, theThis.fullHeightStyle] };
        theThis.inheritWidthHeightStyle = { inherits: [theThis.inheritWidthStyle, theThis.inheritHeightStyle] }
        theThis.inlineBlockStyle = { display: 'inline-block' };
        theThis.blockStyle = { display: 'block' };
        theThis.noneDisplayStyle = { display: 'none' };
        theThis.overflowHiddenStyle = { overflow: 'hidden' };
        theThis.overflowAutoStyle = { overflow: 'auto' };
        theThis.overflowYScrollStyle = { overflowY: 'scroll' };
        theThis.middleVerticalAlignStyle = { verticalAlign: 'middle' };
        theThis.inheritVerticalAlignStyle = { verticalAlign: 'inherit' };
        theThis.textAlignCenterStyle = { textAlign: 'center' };
        theThis.textAlignLeftStyle = { textAlign: 'left' };
        theThis.noBorderRadiusStyle = { borderRadius: "0px" };
        theThis.borderNoneStyle = { border: 'none' };
        theThis.noSelectStyle = {
            "-webkit-touch-callout": "none",
            "-webkit-user-select": "none",
            "-khtml-user-select": "none",
            "-moz-user-select": "none",
            "-ms-user-select": "none",
            "user-select": "none",
            "-webkit-tap-highlight-color": "transparent"
        };
        theThis.notDraggableStyle = { draggable: "false" };
        theThis.noTextDecorationStyle = { textDecoration: 'none' };
        theThis.snapLeftStyle = { left: zeroDim };
        theThis.snapRightStyle = { right: zeroDim };
        theThis.snapTopStyle = { top: zeroDim };
        theThis.snapBotStyle = { bottom: zeroDim };
        theThis.snapCenterHorStyle = { left: "50%", transform: "translate(-50%, 0)" };
        theThis.snapCenterVerStyle = { top: "50%", transform: "translate(0, -50%)" };
        theThis.snapCenterStyle = { left: "50%", top: "50%", transform: "translate(-50%, -50%)" };
        theThis.snapLeftTopStyle = { inherits: [theThis.snapLeftStyle, theThis.snapTopStyle] };
        theThis.snapRightTopStyle = { inherits: [theThis.snapRightStyle, theThis.snapTopStyle] };
        theThis.snapLeftBotStyle = { inherits: [theThis.snapLeftStyle, theThis.snapBotStyle] };
        theThis.snapRightBotStyle = { inherits: [theThis.snapRightStyle, theThis.snapBotStyle] };
        theThis.mapViewPortUnSelectableStyle = { inherits: [theThis.noSelectStyle] };
        theThis.mapZoomSliderStyle = { inherits: [theThis.transparentBackgroundStyle, theThis.opacityZeroStyle, theThis.visibilityHiddenStyle], top: "-100em" };
        theThis.divWithImgBkkSizeStyle = { backgroundSize: "100% 100%" };
    }
    function getMapButtonTopEmNumber(isLeft, indexTopToBottom) {
        var top = !!isLeft ? topLeftButtonEmNumber : topRightButtonEmNumber;
        return top + indexTopToBottom * (mapButtonDimEmNumber + 2 * mapButtonSpacingEmNumber);
    }
    function createMapButtonStyle(isLeft, indexTopToBottom) {
        var inheritStyle = !!isLeft ? theThis.mapButtonLeftMarginStyle : theThis.mapButtonRightMarginStyle;
        var top = getMapButtonTopEmNumber(isLeft, indexTopToBottom);
        return { inherits: [inheritStyle], top: top + "em" };
    }
    function createMapComponentsStyles() {
        theThis.mapZoomInBorderRadiusStyle = { borderRadius: mapZoomInBorderRadius };
        theThis.mapZoomOutBorderRadiusStyle = { borderRadius: mapZoomOutBorderRadius };
        var addressBarTopEmNumber = mapButtonMarginEmNumber;
        var zoomTopEmNumber = addressBarTopEmNumber + mapButtonDimEmNumber + 2 * mapButtonSpacingEmNumber;
        topRightButtonEmNumber = mapButtonMarginEmNumber;
        topLeftButtonEmNumber = zoomTopEmNumber + 2 * mapButtonDimEmNumber + 3 * mapButtonSpacingEmNumber;
        theThis.addressBarFontSize = (mapButtonDimEmNumber / 2 + 0.2) + "em";
        var mapButtonDimEmStr = mapButtonDimEmNumber + "em";
        var mapButtonMarginEmStr = mapButtonMarginEmNumber + "em";
        theThis.mapButtonLeftMarginStyle = { left: mapButtonMarginEmStr };
        theThis.mapButtonRightMarginStyle = { right: mapButtonMarginEmStr };
        theThis.mapAddressButtonStyle = { inherits: [theThis.mapButtonLeftMarginStyle], top: addressBarTopEmNumber + "em" };
        theThis.mapZoomStyle = { inherits: [theThis.mapButtonLeftMarginStyle], top: zoomTopEmNumber + "em", zIndex: 1 };
        theThis.mapLayersButtonStyle = createMapButtonStyle(true, 0);
        theThis.mapTypeButtonStyle = createMapButtonStyle(true, 1);
        theThis.mapMeasureButtonStyle = createMapButtonStyle(true, 2);
        theThis.mapDownloadButtonStyle = createMapButtonStyle(true, 3);
        theThis.mapSourceButtonStyle = createMapButtonStyle(true, 4);
        theThis.mapFullScreenButtonStyle = createMapButtonStyle(false, 0);
        theThis.mapLocationButtonStyle = createMapButtonStyle(false, 1);
        theThis.mapUserLocationButtonStyle = createMapButtonStyle(false, 2);
        theThis.mapRotateStyle = { inherits: [theThis.transitionOpacityToVisibleStyle, theThis.mapButtonRightMarginStyle], top: getMapButtonTopEmNumber(false, 3) + "em" };
        theThis.mapRotateHiddenStyle = { inherits: [theThis.opacityZeroStyle, theThis.visibilityHiddenStyle, theThis.transitionOpacityToInvisibleStyle] };
        theThis.mapLocationButtonTopEmNumber = getMapButtonTopEmNumber(false, 1);
        var mapControlFontSizeStyle = { fontSize: theThis.mapControlFontSizeEmNumber + "em" };
        var mapControlButtonFontWeightStyle = { fontWeight: mapControlFontWeight };
        theThis.mapScaleLineStyle = {
            inherits: [theThis.mapButtonLeftMarginStyle], background: mapScaleLineBkColor, borderRadius: mapScaleLineBorderRadiusPxNumber + "px", bottom: mapButtonMarginEmStr,
            padding: mapScaleLinePaddingPxNumber + "px", position: "absolute", zIndex: 1, cursor: "pointer"
        };
        theThis.mapScaleLineInnerStyle = {
            inherits: [mapControlButtonFontWeightStyle],
            border: mapScaleLineBorder, borderTop: "none", color: mapScaleLineFontColor,
            fontSize: mapScaleLineFontSizeEmNumber + "em", textAlign: "center", margin: mapScaleLineMarginPxNumber + "px", willChange: "contents,width"
        };
        theThis.mapControlButtonWidthHeightStyle = { width: mapButtonDimEmStr, height: mapButtonDimEmStr };
        theThis.mapOverviewMapStyle = { inherits: [theThis.mapButtonRightMarginStyle], bottom: mapButtonMarginEmStr, zIndex: 1 };
        var tfLogoTop = (2 * mapButtonMarginEmNumber + zoomTopEmNumber) + "em";
        var tfLogoLeft = (3 * mapButtonMarginEmNumber + 2 * mapButtonDimEmNumber) + "em";
        theThis.mapTFLogoControlStyle = {
            inherits: [theThis.positionAbsoluteStyle, theThis.noPointerEventsStyle],
            borderRadius: tfLogoBorderRadius, top: tfLogoTop, left: tfLogoLeft, width: tfLogoHeight, height: tfLogoWidth, opacity: tfLogoOpacity,
            backgroundColor: tfLogoBkColor,
            border: tfLogoBorder
        };
        theThis.mapCompassStyle = { inherits: [theThis.blockStyle, theThis.willChangeTransformStyle, mapControlFontSizeStyle, mapControlButtonFontWeightStyle] };
        theThis.mapButtonTextSpanStyle = { inherits: [theThis.blockStyle, mapControlFontSizeStyle, mapControlButtonFontWeightStyle, theThis.cursorPointerStyle] };
        theThis.mapControlBkColorStyle = { backgroundColor: theThis.mapControlBkColor };
        theThis.mapControlHoverBkColorStyle = { backgroundColor: theThis.mapControlBkColor };
        theThis.mapControlButtonHoverBkColorStyle = { backgroundColor: theThis.mapControlButtonHoverBkColor };
        theThis.mapControlButtonBkColorStyle = { backgroundColor: theThis.mapControlButtonBkColor };
        theThis.mapControlButtonLineHeightStyle = { lineHeight: mapControlLineHeightEmNumber + "em" };
        theThis.mapControlButtonTextColorStyle = { color: mapControlTextColor };
        theThis.mapControlStyle = { inherits: [theThis.horShadowStyle, theThis.positionAbsoluteStyle, theThis.mapControlBkColorStyle, theThis.cursorPointerStyle], borderRadius: "3px", padding: "1px" };
        theThis.mapControlHoverStyle = { inherits: [theThis.mapControlHoverBkColorStyle] };
        theThis.mapControlButtonFocusHoverStyle = { inherits: [theThis.noTextDecorationStyle, theThis.mapControlButtonHoverBkColorStyle] };
        theThis.mapControlButtonStyle = {
            inherits: [theThis.noPaddingStyle, theThis.blockStyle, theThis.noTextDecorationStyle, theThis.borderNoneStyle, theThis.textAlignCenterStyle, theThis.mapControlButtonBkColorStyle,
            theThis.mapControlButtonWidthHeightStyle, mapControlButtonFontWeightStyle, theThis.margin1PXStyle, theThis.noBorderRadiusStyle, theThis.mapControlButtonLineHeightStyle,
            theThis.mapControlButtonTextColorStyle]
        };
        theThis.mapControlButtonMozFocusInnerStyle = { inherits: [theThis.borderNoneStyle, theThis.noPaddingStyle] };
        var ovewviewMapBorderWidthPxNumber = overviewMapBorderWidthPxNumberNumber + "px";
        //theThis.mapOverviewMapUnCollapsibleStyle = { bottom: "0", left: "0", borderRadius: "0 4px 0 0" };
        //theThis.mapOverviewMapButtonStyle = { inherits: [theThis.inlineBlockStyle] };
        theThis.mapOverviewMapButtonStyle = { inherits: [theThis.mapControlButtonStyle] };
        //theThis.mapOverviewMapMapStyle = { border: "1px solid #000", height: "200px", margin: "2px", width: "200px" };
        theThis.mapOverviewMapMapStyle = { margin: ovewviewMapBorderWidthPxNumber, width: overviewMapWidthPxNumber + "px", height: overviewMapHeightPxNumber + "px" };
        theThis.mapOverviewMapButtonNotCollapsedStyle = { inherits: [theThis.positionAbsoluteStyle], bottom: ovewviewMapBorderWidthPxNumber, left: ovewviewMapBorderWidthPxNumber };
        theThis.mapOverviewMapButtonCollapsedStyle = { inherits: [theThis.noneDisplayStyle] };
        theThis.mapOverviewMapNotCollapsedStyle = { inherits: [theThis.seShadowStyle], backgroundColor: theThis.mapControlBkColor };
        theThis.mapOverviewMapBoxStyle = { border: overviewMapBoxBorder };
    }
    function createDLayerStyles() {
        theThis.dLayerInfoStyle = { inherits: [theThis.noBorderMarginPaddingStyle, theThis.inlineBlockStyle, theThis.textShadowStyle], maxWidth: "17em" };
        theThis.dLayerInfoImgStyle = { inherits: [theThis.fullWidthAutoHeightStyle, theThis.middleVerticalAlignStyle] };
        theThis.dLayerInfoLinkStyle = { inherits: [theThis.buttonShapedLinkStyle] };
        theThis.dLayerInfoLinkHoverStyle = { inherits: [theThis.buttonShapedLinkHoverStyle] };
        theThis.dLayerInfoSpanStyle = { inherits: [theThis.blockStyle, theThis.textShadowStyle], backgroundColor: dLayerSpanBackgroundColor, margin: "0.15em" };
    }
    function createShadowStyle(offXPxNumber, offYPxNumber, blurPxNumber, shadowColorStr) {
        var paramStr = offXPxNumber + "px " + offYPxNumber + "px " + blurPxNumber + "px " + shadowColorStr;
        var dropShadowParamStr = "drop-shadow(" + paramStr + ")";
        return { "-moz-box-shadow": paramStr, "-webkit-filter": dropShadowParamStr, filter: dropShadowParamStr };
    }
    function createRadioCheckStyles() {
        theThis.radioCheckStyle = { inherits: [theThis.noBorderMarginPaddingStyle, theThis.middleVerticalAlignStyle] };
        theThis.radioCheckWithDimStyle = { inherits: [theThis.radioCheckStyle, theThis.defaultRightPaddingRadioCheckStyle] };
        //theThis.radioCheckWithDimStyle = { inherits: [theThis.radioCheckStyle, theThis.defaultWidthHeightRadioCheckStyle, theThis.defaultRightPaddingRadioCheckStyle] };
        theThis.radioCheckLabelStyle = { inherits: [theThis.radioCheckStyle, theThis.blockStyle, theThis.cursorPointerStyle, theThis.textAlignLeftStyle/*, theThis.autoWidthAutoHeightStyle*/, theThis.floatNoneStyle] };
        theThis.radioCheckRemoveDefaultStyle = { inherits: [theThis.radioCheckStyle, theThis.positionAbsoluteStyle, theThis.opacityZeroStyle, theThis.visibilityHiddenStyle] };
        theThis.radioCheckLabelCheckedStyle = { inherits: [theThis.radioCheckStyle, theThis.textShadowSelRadioCheckStyle] };
        theThis.radioLabelStyle = { inherits: [theThis.radioCheckLabelStyle] };
        theThis.radioRadioStyle = { inherits: [theThis.radioCheckRemoveDefaultStyle] };
        theThis.radioRadioAndLabelCheckedStyle = { inherits: [theThis.radioCheckLabelCheckedStyle] };
        theThis.radioRadioAndLabelStyleBefore = { inherits: [theThis.radioCheckWithDimStyle, theThis.defaultRadioUnCheckedStyle] };
        theThis.radioRadioAndLabelSelStyleBefore = { inherits: [theThis.radioCheckWithDimStyle, theThis.defaultRadioCheckedStyle] };
        theThis.checkLabelStyle = { inherits: [theThis.radioCheckLabelStyle] };
        theThis.checkCheckStyle = { inherits: [theThis.radioCheckRemoveDefaultStyle] };
        theThis.checkCheckAndLabelCheckedStyle = { inherits: [theThis.radioCheckLabelCheckedStyle] };
        theThis.checkCheckAndLabelStyleBefore = { inherits: [theThis.radioCheckWithDimStyle, theThis.defaultCheckUnCheckedStyle] };
        theThis.checkCheckAndLabelSelStyleBefore = { inherits: [theThis.radioCheckWithDimStyle, theThis.defaultCheckCheckedStyle] };
    }
    function createSvgGlyphStyles(glyphColor, backgroundColor, glyphColorHover, backgroundColorHover) {
        var style = { inherits: [theThis.svgGlyphStyleBase, theThis.cursorPointerStyle], backgroundColor: backgroundColor, fill: glyphColor };
        var hoverStyle = { backgroundColor: backgroundColorHover, fill: glyphColorHover };
        return { style: style, hoverStyle: hoverStyle };
    }
    function createTextDivBtnStyles(textColor, backgroundColor, textColorHover, backgroundColorHover) {
        var style = { inherits: [theThis.textButtonStyleBase], backgroundColor: backgroundColor, color: textColor };
        var hoverStyle = { backgroundColor: backgroundColorHover, color: textColorHover };
        return { style: style, hoverStyle: hoverStyle };
    }
    function createAppStyles() {
        theThis.popupCaptionBorderRadiusStyle = { borderRadius: popupCaptionBorderRadiusPXNumber + 'px' };
        theThis.popupContentPaddingStyle = { padding: popupContentPaddingPXNumber + "px" }
        theThis.popupContentBorderRadiusStyle = { borderRadius: popupContentBorderRadiusPXNumber + "px" }
        theThis.textShadowStyle = { textShadow: textShadow };
        theThis.darkTextShadowStyle = { textShadow: darkTextShadow };
        theThis.seShadowStyle = createShadowStyle(3, 3, 3, "rgba(0,0,0,0.6)");
        theThis.horShadowStyle = createShadowStyle(0, 1, 4, "rgba(0,0,0,0.6)");
        //theThis.seShadowStyle = { "tf-shadow": [3, 3, 3, "rgba(0,0,0,0.6)"] };
        //theThis.horShadowStyle = { "tf-shadow": [0, 1, 4, "rgba(0,0,0,0.6)"] };
        theThis.textShadowSelRadioCheckStyle = { textShadow: textShadowSelRadioCheck };
        theThis.defaultWidthHeightRadioCheckStyle = { width: "1em", height: "1em" };    // not actually shown, because check or radio image component is hidden and replaced by content before
        theThis.defaultRightPaddingRadioCheckStyle = { paddingRight: "0.2em" };
        theThis.paddingStyle = { padding: paddingPxNumber + "px" };
        theThis.paddingLeftRightStyle = { paddingLeft: paddingPxNumber + "px", paddingRight: paddingPxNumber + "px" };
        theThis.separatorBkColorStyle = { backgroundColor: theThis.separatorBackgroundColor };
        theThis.rightSideContainerBkColorStyle = { backgroundColor: theThis.containerDarkBackgroundColor };
        theThis.hcfLayoutContainerBkColorStyle = { backgroundColor: theThis.hcfLayoutContainerBkColor };
        theThis.popupCaptionBackgroundColorStyle = { backgroundColor: theThis.popupCaptionBackgroundColor };
        theThis.divIconCursorStyle = { inherits: theThis.cursorDefaultStyle };
        theThis.noBorderMarginPaddingStyle = { inherits: [theThis.noBorderStyle, theThis.noBorderSpacingStyle, theThis.noMarginStyle, theThis.noPaddingStyle] };
        theThis.verticalSeparatorWidthStyle = { width: verticalSeparatorWidthEMNumber + "em"};
        theThis.horizontalSeparatorHeightStyle = { height: horizontalSeparatorHeightEMNumber + "em" };
        theThis.darkTextColorStyle = { color: theThis.darkTextColor };
        theThis.lightTextColorStyle = { color: theThis.lightTextColor };
        theThis.disabledTextColorStyle = { color: theThis.disabledTextColor };
        theThis.defaultButtonBkStyle = { backgroundColor: theThis.defaultButtonBk };
        theThis.buttonBorderRadiusStyle = { borderRadius: buttonBorderRadiusPxNumber + "px" };
        theThis.appContainerStyle = {
            inherits: [theThis.fullWidthHeightStyle, theThis.blockStyle, theThis.overflowHiddenStyle, theThis.defaultFontAndTopSizeStyle, theThis.noSelectStyle, theThis.positionRelativeStyle],
            lineHeight: "initial"
        };
        theThis.mapContainerStyle = {
            inherits: [theThis.fullWidthHeightStyle, theThis.blockStyle, theThis.overflowHiddenStyle, theThis.noSelectStyle, theThis.middleVerticalAlignStyle,
                theThis.defaultFontAndTopSizeStyle, theThis.positionRelativeStyle], borderRadius: "inherit",
            lineHeight: "initial"
        };
        theThis.mapSubContainerStyle = {
            inherits: [theThis.fullWidthHeightStyle, theThis.blockStyle, theThis.overflowHiddenStyle, theThis.noSelectStyle, theThis.middleVerticalAlignStyle,
                theThis.fontSizeInheritStyle, theThis.positionRelativeStyle], borderRadius: "inherit",
            lineHeight: "initial"
        };
        theThis.popupMapToolBarBaseStyle = {
            inherits: [theThis.noBorderMarginPaddingStyle, theThis.blockStyle, theThis.positionAbsoluteStyle, theThis.noSelectStyle,
                theThis.darkTextColorStyle, theThis.defaultFontStyle]
        };
        theThis.mapToolBarContainerStyle = {
            inherits: [theThis.popupMapToolBarBaseStyle, theThis.fasterOpacityVisibilityTransitionStyle, theThis.middleVerticalAlignStyle, theThis.popupCaptionBackgroundColorStyle,
                theThis.seShadowStyle, theThis.popupCaptionBorderRadiusStyle]
        };
        theThis.topSeparatorLightStyle = { borderTop: borderSeparatorLightSpecs };
        theThis.bottomBorderSeparatorLightStyle = { borderBottom: borderSeparatorLightSpecs };
        theThis.rightBorderSeparatorLightStyle = { borderRight: borderSeparatorLightSpecs };
        theThis.leftBorderSeparatorLightStyle = { borderLeft: borderSeparatorLightSpecs };
        theThis.topBorderSeparatorDarkStyle = { borderTop: borderSeparatorDarkSpecs };
        theThis.bottomBorderSeparatorDarkStyle = { borderBottom: borderSeparatorDarkSpecs };
        theThis.rightBorderSeparatorDarkStyle = { borderRight: borderSeparatorDarkSpecs };
        theThis.leftBorderSeparatorDarkStyle = { borderLeft: borderSeparatorDarkSpecs };
        theThis.popupContainerStyle = {
            inherits: [theThis.popupMapToolBarBaseStyle, theThis.defaultOpacityVisibilityTransitionStyle, theThis.overflowHiddenStyle,
                theThis.textAlignLeftStyle, theThis.transparentBackgroundStyle, theThis.seShadowStyle, theThis.noPointerEventsStyle],
            padding: theThis.popupContainerPaddingPxNumber + "px"
        };
        theThis.popupContentStyle = {
            inherits: [theThis.noBorderMarginPaddingStyle, theThis.blockStyle, theThis.popupContentBkColorStyle, theThis.borderLightStyle,
                theThis.popupContentBorderRadiusStyle, theThis.popupContentPaddingStyle, theThis.textAlignLeftStyle, theThis.allPointerEventsStyle]
        };
        theThis.spanStyle = { inherits: [theThis.noBorderMarginPaddingStyle, theThis.middleVerticalAlignStyle, theThis.transparentBackgroundStyle, theThis.cursorDefaultStyle] };
        theThis.spanCursorPointerStyle = { inherits: [theThis.spanStyle, theThis.cursorPointerStyle] };
        theThis.appContainerBaseStyle = { inherits: [theThis.unPaddedBlockDivStyle, theThis.lightTextColor, theThis.hcfLayoutContainerBkColorStyle, theThis.overflowHiddenStyle] };
        theThis.hcfLayoutStyle = { inherits: [theThis.appContainerBaseStyle, theThis.fullHeightStyle] };
        theThis.hcfLayoutHeaderStyle = { inherits: [theThis.appContainerBaseStyle, theThis.textAlignCenterStyle, theThis.bottomBorderSeparatorLightStyle], top: "0em" };
        theThis.hcfLayoutFooterStyle = { inherits: [theThis.appContainerBaseStyle, theThis.textAlignCenterStyle, theThis.topSeparatorLightStyle], bottom: "0em" };
        theThis.hcfLayoutContentStyle = { inherits: [theThis.appContainerBaseStyle, theThis.overflowYScrollStyle] };
        theThis.inputTextPlaceholderStyle = { inherits: [theThis.defaultFontSizeInheritStyle, theThis.disabledTextColorStyle] };
        theThis.inputTextStyle = {
            inherits: [theThis.noBorderMarginPaddingStyle, theThis.noOutlineStyle, theThis.defaultFontSizeInheritStyle, theThis.darkTextColorStyle, theThis.seShadowStyle,
            theThis.textShadowStyle, theThis.textInputBackgroundStyle, theThis.paddingLeftRightStyle]
        };
        createRadioCheckStyles();
        theThis.mapMeasureOverlayDivStyle = {
            inherits: [theThis.blockStyle, theThis.cursorDefaultStyle, theThis.noBorderMarginPaddingStyle, theThis.paddingStyle, theThis.textAlignCenterStyle,
            theThis.middleVerticalAlignStyle, theThis.noPointerEventsStyle, theThis.noSelectStyle], fontSize: "1.2em", color: "#128", borderRadius: "0.5em",
            border: "1px solid #3e3e3e", backgroundColor: "rgba(255, 255, 255, 0.6)", textShadow: "2px 3px 3px #ddd"
        };
        theThis.imgStyleBase = { inherits: [theThis.noBorderMarginPaddingStyle, theThis.notDraggableStyle, theThis.noSelectStyle] };
        theThis.logoMaxWidthHeightStyle = { minWidth: (maxWidthLogoImageEmNumber / 2) + "em", maxWidth: maxWidthLogoImageEmNumber + "em", maxHeight: maxHeightLogoImageEmNumber + "em" };
        theThis.imgLogoStyle = { inherits: [theThis.imgStyleBase, theThis.inheritHeightStyle, theThis.autoWidthStyle, theThis.noPointerEventsStyle, theThis.logoMaxWidthHeightStyle, theThis.middleVerticalAlignStyle] };
        theThis.imgFullWidthHeightStyle = { inherits: [theThis.imgStyleBase, theThis.fullWidthHeightStyle] };
        theThis.imgDefaultFrameStyle = {
            inherits: [theThis.whiteBackgroundStyle],
            border: theThis.imgFrameBorder,
            margin: theThis.imgFramePaddingBorderWidthEmNumber + "em",
            color: "#FFFFFF"
        };
        theThis.divWithImgBkStyle = {
            inherits: [theThis.noBorderMarginPaddingStyle, theThis.imgDefaultFrameStyle, theThis.inheritVerticalAlignStyle,
                theThis.divWithImgBkkSizeStyle, theThis.inlineBlockStyle, theThis.middleVerticalAlignStyle],
            width: theThis.imageThumbWidthEmNumber + "em"
        };
        theThis.imgForInfoWindowStyle = { inherits: [theThis.imgDefaultFrameStyle], align: "center", padding: "0px", height: "12em", width: "auto" };
        theThis.buttonStyleBase = {
            inherits: [theThis.noBorderMarginPaddingStyle, theThis.middleVerticalAlignStyle, theThis.textAlignCenterStyle, theThis.buttonBorderRadiusStyle, theThis.cursorPointerStyle]
        };
        theThis.svgGlyphStyleBase = {
            inherits: [theThis.buttonStyleBase, theThis.blockStyle, theThis.transparentBackgroundStyle],
            stroke: "#000", strokeWidth: "0%", strokeLinejoin: "round",
            borderRadius: svgButtonBorderRadiusPercentNumber + "%"
        };
        theThis.svgGlyphLightNoHoverStyle = { inherits: [theThis.svgGlyphStyleBase, theThis.divIconCursorStyle], fill: theThis.buttonLightFill };
        theThis.svgGlyphLightStyle = { inherits: [theThis.svgGlyphLightNoHoverStyle, theThis.cursorPointerStyle], backgroundColor: theThis.buttonLightBkg };
        theThis.svgGlyphLightStyleHover = { backgroundColor: theThis.buttonLightFill, fill: theThis.buttonLightBkg };
        theThis.svgGlyphDarkNoHoverStyle = { inherits: [theThis.svgGlyphStyleBase, theThis.divIconCursorStyle], fill: theThis.buttonDarkFill };
        theThis.mapSvgGlyphInButtonStyle = { inherits: [theThis.svgGlyphStyleBase, theThis.divIconCursorStyle], fill: mapControlTextColor };
        theThis.mapSvgGlyphInPopupStyle = { inherits: [theThis.svgGlyphStyleBase, theThis.divIconCursorStyle], fill: mapControlTextColor };
        theThis.mapSvgGlyphInPopupHoverStyle = { inherits: [theThis.svgGlyphStyleBase, theThis.divIconCursorStyle], backgroundColor: mapControlTextColor, fill: theThis.mapControlButtonHoverBkColor };
        theThis.svgGlyphDarkStyle = { inherits: [theThis.svgGlyphDarkNoHoverStyle, theThis.cursorPointerStyle] };
        theThis.svgGlyphDarkStyleHover = { backgroundColor: theThis.buttonDarkFill, fill: theThis.buttonDarkBkg };
        theThis.divSvgGlyphStyle = { inherits: [theThis.noBorderMarginPaddingStyle, theThis.inlineBlockStyle, theThis.middleVerticalAlignStyle] };
        theThis.buttonDivMarginTopStyle = { marginTop: buttonMarginTopBottomPxNumber + "px" };
        theThis.buttonDivMarginBotStyle = { marginBottom: buttonMarginTopBottomPxNumber + "px" };
        theThis.buttonDivTopBotMarginsStyle = { inherits: [theThis.buttonDivMarginTopStyle, theThis.buttonDivMarginBotStyle] };
        theThis.buttonDivMarginLeftStyle = { marginLeft: buttonMarginLeftRightPxNumber + "px" };
        theThis.buttonDivMarginRightStyle = { marginRight: buttonMarginLeftRightPxNumber + "px" };
        theThis.buttonDivLeftRightMarginsStyle = { inherits: [theThis.buttonDivMarginLeftStyle, theThis.buttonDivMarginRightStyle] };
        theThis.buttonDivAllMarginsStyle = { inherits: [theThis.buttonDivTopBotMarginsStyle, theThis.buttonDivLeftRightMarginsStyle] };
        theThis.divSvgGlyphBtnStyle = { inherits: [theThis.divSvgGlyphStyle] };
        theThis.divSvgGlyphIconStyle = { inherits: [theThis.divSvgGlyphStyle, theThis.divIconCursorStyle] };
        theThis.textButtonStyleBase = {
            inherits: [theThis.buttonStyleBase, theThis.inlineBlockStyle, theThis.autoWidthStyle, theThis.buttonBorderRadiusStyle],
            paddingTop: textButtonPaddingTopBottomPxNumber + "px",
            paddingBottom: textButtonPaddingTopBottomPxNumber + "px",
            paddingLeft: textButtonPaddingLeftRightPxNumber + "px",
            paddingRight: textButtonPaddingLeftRightPxNumber + "px"
        };
        theThis.textDivBtnLightStyle = { inherits: theThis.textButtonStyleBase, color: theThis.lightTextDivBtnColor, backgroundColor: theThis.buttonLightBkg, textShadow: buttonShapedLinkTextShadow };
        theThis.textDivBtnLightStyleHover = { color: theThis.darkTextDivBtnColor, backgroundColor: theThis.buttonLightFill, textShadow: "none" };
        theThis.textDivBtnDarkStyle = { inherits: theThis.textButtonStyleBase, color: theThis.darkTextDivBtnColor, backgroundColor: theThis.buttonDarkBkg };
        theThis.textDivBtnDarkStyleHover = { color: theThis.lightTextDivBtnColor, backgroundColor: theThis.buttonDarkFill };
        theThis.mapTextBtnStyle = { inherits: [theThis.textButtonStyleBase], color: mapPopupTextButtonTextColor, backgroundColor: mapPopupTextButtonBkColor, textShadow: buttonShapedLinkTextShadow };
        theThis.mapTextBtnStyleHover = { inherits: [theThis.darkTextShadowStyle], backgroundColor: mapPopupTextButtonTextColor, color: mapPopupTextButtonBkColor, textShadow: buttonShapedLinkTextShadowHover };
        theThis.buttonShapedLinkStyle = {
            inherits: [theThis.textButtonStyleBase, theThis.noTextDecorationStyle],
            borderTop: borderSeparatorLightSpecs,
            borderLeft: borderSeparatorLightSpecs,
            borderBottom: borderSeparatorButtonBkSpecs,
            borderRight: borderSeparatorButtonBkSpecs,
            color: theThis.buttonShapedLinkTextColor,
            backgroundColor: theThis.buttonShapedLinkBkColor,
            textShadow: buttonShapedLinkTextShadow,
            margin: buttonShapedLinkMarginPxNumber + "px"
        };
        theThis.buttonShapedLinkHoverStyle = {
            borderTop: borderSeparatorButtonBkSpecs,
            borderLeft: borderSeparatorButtonBkSpecs,
            borderBottom: borderSeparatorLightSpecs,
            borderRight: borderSeparatorLightSpecs,
            color: theThis.buttonShapedLinkHoverTextColor,
            backgroundColor: theThis.buttonShapedLinkHoverBkColor,
            textShadow: buttonShapedLinkTextShadowHover
        };
        createDLayerStyles();
        theThis.paddedBlockDivStyle = { inherits: [theThis.noBorderMarginPaddingStyle, theThis.paddingStyle, theThis.blockStyle] };
        theThis.paddedInlineBlockDivStyle = { inherits: [theThis.noBorderMarginPaddingStyle, theThis.paddingStyle, theThis.inlineBlockStyle] };
        theThis.paddedBlockDivWithBorderSeparatorStyle = { inherits: [theThis.paddedBlockDivStyle, theThis.bottomBorderSeparatorLightStyle] };
        theThis.paddedInlineBlockDivWithBorderSeparatorStyle = { inherits: [theThis.paddedInlineBlockDivStyle, theThis.rightBorderSeparatorLightStyle] };
        theThis.unPaddedBlockDivStyle = { inherits: [theThis.noBorderMarginPaddingStyle, theThis.blockStyle] };
        theThis.unPaddedInlineBlockDivStyle = { inherits: [theThis.noBorderMarginPaddingStyle, theThis.inlineBlockStyle] };
        theThis.leftSideContainerStyle = { inherits: [theThis.unPaddedBlockDivStyle, theThis.autoWidthFullHeightStyle, theThis.overflowHiddenStyle] };
        theThis.floatLeftSideContainerStyle = { inherits: [theThis.unPaddedBlockDivStyle, theThis.autoWidthFullHeightStyle, theThis.overflowHiddenStyle, theThis.floatLeftStyle] };
        theThis.leftRightSideSeparatorStyle = {
            inherits: [theThis.unPaddedBlockDivStyle, theThis.fullHeightStyle, theThis.overflowHiddenStyle, theThis.separatorBkColorStyle,
                theThis.middleVerticalAlignStyle, theThis.textAlignCenterStyle, theThis.floatRightStyle, theThis.verticalSeparatorWidthStyle, theThis.positionRelativeStyle,
            theThis.leftBorderSeparatorLightStyle, theThis.rightBorderSeparatorDarkStyle]
        };
        theThis.rightSideContainerStyle = { inherits: [theThis.unPaddedBlockDivStyle, theThis.fullHeightStyle, theThis.overflowHiddenStyle, theThis.floatRightStyle, theThis.rightSideContainerBkColorStyle, theThis.lightTextColorStyle] };
        theThis.bottomContainerStyle = { inherits: [theThis.unPaddedBlockDivStyle, theThis.fullWidthStyle, theThis.overflowHiddenStyle, theThis.whiteBackgroundStyle] };
        theThis.topBottomSeparatorStyle = {
            inherits: [theThis.unPaddedBlockDivStyle, theThis.fullWidthStyle, theThis.overflowHiddenStyle, theThis.separatorBkColorStyle, theThis.middleVerticalAlignStyle, theThis.textAlignCenterStyle, theThis.horizontalSeparatorHeightStyle]
        };
        theThis.listContentStyle = { inherits: [theThis.unPaddedBlockDivStyle, theThis.bottomBorderSeparatorLightStyle, theThis.hcfLayoutContainerBkColorStyle] };
        theThis.inputFormBkStyle = { backgroundColor: theThis.inputFormBkColor };
        theThis.inputFormStyle = { inherits: [theThis.unPaddedBlockDivStyle, theThis.inputFormBkStyle, theThis.darkTextColorStyle, theThis.textAlignCenterStyle], borderRadius: inputFormBorderRadiusPxNumber + "px" };
        var platformURL = tf.platform.GetURL();
        theThis.fontFaceStyleContentStr =
            "font-family: 'SourceSansPro-Regular';" +
            "src: url('" + platformURL + "fonts/SourceSansPro-Regular.eot');" +
            "src: local('?'), url('" + platformURL + "fonts/SourceSansPro-Regular.woff') format('woff'), url('" + platformURL +
            "fonts/SourceSansPro-Regular.ttf') format('truetype'), url('" + platformURL + "fonts/SourceSansPro-Regular.svg') format('svg');" +
            "font-weight: normal;" +
            "font-style: normal;";
        theThis.transitionOpacityToVisibleStyle = { transition: "opacity .25s linear,visibility 0s linear" };
        theThis.transitionOpacityToInvisibleStyle = { transition: "opacity .25s linear,visibility 0s linear .25s" };
        createMapComponentsStyles();
        theThis.popupContentBkColorStyle = { backgroundColor: theThis.popupContentBkColor };
        theThis.popupCaptionStyle = {
            inherits: [theThis.inlineBlockStyle, theThis.noBorderMarginPaddingStyle, theThis.popupCaptionBackgroundColorStyle, theThis.seShadowStyle, theThis.bottomBorderSeparatorLightStyle,
                theThis.rightBorderSeparatorLightStyle, theThis.textShadowStyle, theThis.cursorDefaultStyle, theThis.darkTextColorStyle, theThis.positionRelativeStyle,
                theThis.popupCaptionBorderRadiusStyle, theThis.allPointerEventsStyle],
                fontSize: theThis.mapControlFontSizeEmNumber + "em"
        };
        theThis.bodyStyle = { inherits: [theThis.noBorderMarginPaddingStyle, theThis.fullWidthHeightStyle, theThis.whiteBackgroundStyle, theThis.defaultFontStyle, theThis.topFontSizeStyle] };
    }
    function initLiteralValues(specifications) {
        borderSeparatorLineSpecs = specifications.borderSeparatorLineSpecs;
        textInputBackgroundColor = specifications.textInputBackgroundColor;
        mapPopupTextButtonTextColor = specifications.mapPopupTextButtonTextColor;
        mapPopupTextButtonBkColor = specifications.mapPopupTextButtonBkColor;
        mapScaleLineBkColor = specifications.mapScaleLineBkColor ;
        mapScaleLineBorderRadiusPxNumber = specifications.mapScaleLineBorderRadiusPxNumber ;
        mapScaleLinePaddingPxNumber = specifications.mapScaleLinePaddingPxNumber ;
        mapScaleLineBorder = specifications.mapScaleLineBorder ;
        mapScaleLineFontSizeEmNumber = specifications.mapScaleLineFontSizeEmNumber ;
        mapScaleLineMarginPxNumber = specifications.mapScaleLineMarginPxNumber ;
        mapScaleLineFontColor = specifications.mapScaleLineFontColor;
        mapControlFontWeight = specifications.mapControlFontWeight;
        theThis.mapSubLegendBkColor = specifications.mapSubLegendBkColor;
        tfLogoBorderRadius = specifications.tfLogoBorderRadius ;
        tfLogoWidth = specifications.tfLogoWidth ;
        tfLogoHeight = specifications.tfLogoHeight ;
        tfLogoOpacity = specifications.tfLogoOpacity ;
        tfLogoBkColor = specifications.tfLogoBkColor ;
        tfLogoBorder = specifications.tfLogoBorder ;
        mapControlLineHeightEmNumber = specifications.mapControlLineHeightEmNumber ;
        mapControlTextColor = specifications.mapControlTextColor;
        overviewMapWidthPxNumber = specifications.overviewMapWidthPxNumber;
        overviewMapHeightPxNumber = specifications.overviewMapHeightPxNumber;
        overviewMapBorderWidthPxNumberNumber = specifications.overviewMapBorderWidthPxNumberNumber;
        overviewMapBoxBorder = specifications.overviewMapBoxBorder;
        mapZoomInBorderRadius = specifications.mapZoomInBorderRadius;
        mapZoomOutBorderRadius = specifications.mapZoomOutBorderRadius;
        dLayerSpanBackgroundColor = specifications.dLayerSpanBackgroundColor;
        textShadow = specifications.textShadow;
        darkTextShadow = specifications.darkTextShadow;
        textShadowSelRadioCheck = specifications.textShadowSelRadioCheck;
        mapButtonDimEmNumber = specifications.mapButtonDimEmNumber;
        mapButtonMarginEmNumber = specifications.mapButtonMarginEmNumber;
        mapButtonSpacingEmNumber = specifications.mapButtonSpacingEmNumber;
        maxHeightLogoImageEmNumber = specifications.maxHeightLogoImageEmNumber;
        maxWidthLogoImageEmNumber = specifications.maxWidthLogoImageEmNumber;
        theThis.mapButtonDimEmNumber = mapButtonDimEmNumber;
        theThis.mapButtonMarginEmNumber = mapButtonMarginEmNumber;
        theThis.mapControlBkColor = specifications.mapControlBkColor;
        theThis.mapControlHoverBkColor = specifications.mapControlHoverBkColor;
        theThis.mapControlButtonHoverBkColor = specifications.mapControlButtonHoverBkColor;
        theThis.mapControlButtonBkColor = specifications.mapControlButtonBkColor;
        buttonMarginTopBottomPxNumber = specifications.buttonMarginTopBottomPxNumber;
        buttonMarginLeftRightPxNumber = specifications.buttonMarginLeftRightPxNumber;
        buttonBorderRadiusPxNumber = specifications.buttonBorderRadiusPxNumber;
        textButtonPaddingTopBottomPxNumber = specifications.textButtonPaddingTopBottomPxNumber;
        textButtonPaddingLeftRightPxNumber = specifications.textButtonPaddingLeftRightPxNumber;
        theThis.lightTextColor = specifications.lightTextColor;
        theThis.darkTextColor = specifications.darkTextColor;
        theThis.disabledTextColor = specifications.disabledTextColor;
        theThis.borderLightColor = specifications.borderLightColor;
        theThis.defaultButtonBk = specifications.defaultButtonBk;
        theThis.defaultButtonFill = specifications.defaultButtonFill;
        theThis.buttonShapedLinkBkColor = specifications.buttonShapedLinkBkColor;
        theThis.buttonShapedLinkTextColor = specifications.buttonShapedLinkTextColor;
        theThis.buttonShapedLinkHoverBkColor = specifications.buttonShapedLinkHoverBkColor;
        theThis.buttonShapedLinkHoverTextColor = specifications.buttonShapedLinkHoverTextColor;
        buttonShapedLinkTextShadow = specifications.buttonShapedLinkTextShadow;
        buttonShapedLinkTextShadowHover = specifications.buttonShapedLinkTextShadowHover;
        buttonShapedLinkMarginPxNumber = specifications.buttonShapedLinkMarginPxNumber;
        svgButtonBorderRadiusPercentNumber = specifications.svgButtonBorderRadiusPercentNumber;
        verticalSeparatorWidthEMNumber = specifications.verticalSeparatorWidthEMNumber;
        horizontalSeparatorHeightEMNumber = specifications.horizontalSeparatorHeightEMNumber;
        paddingPxNumber = specifications.paddingPxNumber;
        theThis.popupContainerPaddingPxNumber = specifications.popupContainerPaddingPxNumber;
        popupCaptionBorderRadiusPXNumber = specifications.popupCaptionBorderRadiusPXNumber;
        popupContentPaddingPXNumber = specifications.popupContentPaddingPXNumber;
        popupContentBorderRadiusPXNumber = specifications.popupContentBorderRadiusPXNumber;
        theThis.textButtonHeightDelta = textButtonPaddingTopBottomPxNumber * 2;
        theThis.topFontSizePXNumber = specifications.topFontSizePXNumber;
        theThis.markerFontSizePXNumber = specifications.markerFontSizePXNumber;
        theThis.imageThumbWidthEmNumber = specifications.imageThumbWidthEmNumber;
        theThis.imageThumbSquareHeightEmNumber = theThis.imageThumbWidthEmNumber;
        theThis.imageThumbRectHeightEmNumber = theThis.imageThumbWidthEmNumber * 9 / 16;
        theThis.popupContentBkColor = specifications.popupContentBkColor;
        theThis.mapControlFontSizeEmNumber = specifications.mapControlFontSizeEmNumber;
        theThis.popupContentFontSizeEmNumber = specifications.popupContentFontSizeEmNumber;
        theThis.infoPopupContentFontSizeEmNumber = specifications.infoPopupContentFontSizeEmNumber;
        theThis.locationPopupContentFontSizeEmNumber = specifications.locationPopupContentFontSizeEmNumber;
        theThis.fontFamily = specifications.fontFamily;
        theThis.markerFontFamily = specifications.markerFontFamily;
        theThis.containerDarkBackgroundColor = specifications.containerDarkBackgroundColor;
        theThis.containerDarkSelBackgroundColor = specifications.containerDarkSelBackgroundColor;
        theThis.hcfLayoutContainerBkColor = specifications.hcfLayoutContainerBkColor;
        theThis.popupCaptionBackgroundColor = specifications.popupCaptionBackgroundColor;
        theThis.separatorBackgroundColor = specifications.separatorBackgroundColor;
        theThis.buttonLightBkg = specifications.buttonLightBkg;
        theThis.buttonLightFill = specifications.buttonLightFill;
        theThis.buttonDarkBkg = specifications.buttonDarkBkg;
        theThis.buttonDarkFill = specifications.buttonDarkFill;
        theThis.lightTextDivBtnColor = specifications.lightTextDivBtnColor;
        theThis.darkTextDivBtnColor = specifications.darkTextDivBtnColor;
        theThis.imgFramePaddingBorderWidthEmNumber = specifications.imgFramePaddingBorderWidthEmNumber;
        theThis.imgFrameBorder = specifications.imgFrameBorder;
        theThis.inputFormBkColor = specifications.inputFormBkColor;
        inputFormBorderRadiusPxNumber = specifications.inputFormBorderRadiusPxNumber;
    }
    function initialize() {
        var specs = tf.styles.GetDefaultAPIStyleSpecifications();
        //var specs = tf.styles.GetGraphiteAPIStyleSpecifications();
        if (tf.js.GetIsValidObject(alternativeSpecs)) { specs = tf.js.ShallowMerge(specs, alternativeSpecs); }
        initLiteralValues(specs);
        createConstantStyles();
        createAppStyles();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * @public
 * @class
 * @summary The {@link singleton} instance of this class, obtainable by calling {@link tf.GetStyles}(),
 * includes the pre-defined [CSS Style Names]{@link tf.types.CSSStyleName} used by the API, 
 * style related functions, and access to other style [singletons]{@link singleton}, like
 * the [CSS Style Creator]{@link tf.styles.CSSStyleCreator}, and [Sub Styles]{@link tf.styles.SubStyles},
 * containing pre-defined [CSS Style Specifications]{@link tf.types.CSSStyleSpecs}
 * @param {tf.types.APIStyleSpecs} alternativeSpecs - if defined, overrides the default API style specifications
 */
tf.styles.Styles = function (alternativeSpecs) {
    var theThis, styleCreator, subStyles, hiddenCanvas, supportedTransformProp;
    var dotPrefix = '.';
    var lightClassName = "light", darkClassName = "dark";
    var cssClassPrefix = "tf-";
    var divBaseClass = cssClassPrefix + "div-";
    var imgBaseClass = cssClassPrefix + "img-";
    var spanBaseClass = cssClassPrefix + "span-";
    var linkBaseClass = cssClassPrefix + "link-";
    var inputBaseClass = cssClassPrefix + "input-";
    var mapBaseClass = cssClassPrefix + "map-";
    var utilBaseClass = cssClassPrefix + "u-";
    var svgGlyphStyleBaseClass = cssClassPrefix + "glyph-svg-";
    var textDivBtnStyleBaseClass = cssClassPrefix + "btn-div-";
    var borderBaseClass = cssClassPrefix + "border-";
    var svgGlyphStyleNoHoverClass = "nohover-";
    var imgPreSelectorStr = "img.", svgPreSelectorStr = "svg.", divPreSelectorStr = 'div.', linkPreSelectorStr = 'a.';
    var imgPosSelectorStr = " img", spanPosSelectorStr = " span", linkPosSelectorStr = " a", labelPosSelectorStr = " label";
    var buttonPosSelectorStr = " button", inputPosSelectorStr = " input";
    var inputTypeRadioPosSelectorStr = inputPosSelectorStr + '[type="radio"]';
    var inputTypeCheckPosSelectorStr = inputPosSelectorStr + '[type="checkbox"]';
    var focusSelectorStr = ":focus", hoverSelectorStr = ":hover", checkedSelectorStr = ":checked";
    var linkSelectorStr = ":link", visitedSelectorStr = ":visited", activeSelectorStr = ":active";
    var beforeSelectorStr = "::before";
    var blockSuffix = "block-", inlineBlockSuffix = "inlineblock-", paddedSuffix = "padded", unPaddedSuffix = "un" + paddedSuffix;
    /**
     * @public
     * @function
     * @summary - Retrieves the {@link singleton} instance of [CSS Style Creator]{@link tf.styles.CSSStyleCreator}
     * @returns {tf.styles.CSSStyleCreator} - | {@link tf.styles.CSSStyleCreator} the {@link singleton}
    */
    this.GetStyleCreator = function () { return styleCreator; }
    /**
     * @public
     * @function
     * @summary - Retrieves the {@link singleton} instance of [Sub Styles]{@link tf.styles.SubStyles}
     * @returns {tf.styles.SubStyles} - | {@link tf.styles.SubStyles} the {@link singleton}
    */
    this.GetSubStyles = function () { return subStyles; }
    /**
     * @protected
     * @function
     * @summary - Retrieves a pre-created HTML5 canvas for internal use by the API
     * @returns {HTMLElement} - | {@link HTMLElement} the hidden canvas
    */
    this.GetHiddenCanvas = function () { return hiddenCanvas; }
    /**
     * @public
     * @function
     * @summary - Creates custom CSS styles and classes used by [SVG Glyph Button]{@link tf.ui.SvgGlyphBtn} instances to customize 
     * the <b>glyph</b> and <b>background</b> colors displayed in normal and hover states
     * @param {color} glyphColor - normal glyph color
     * @param {color} backgroundColor - normal background color
     * @param {color} glyphColorHover - glyph color on hover
     * @param {color} backgroundColorHover - background color on hover
     * @returns {tf.types.CSSStyleName} - | {@link tf.types.CSSStyleName} a CSS style/class
    */
    this.CreateSvgGlyphClasses = function (glyphColor, backgroundColor, glyphColorHover, backgroundColorHover) {
        return createSvgGlyphClasses(glyphColor, backgroundColor, glyphColorHover, backgroundColorHover);
    }
    /**
     * @public
     * @function
     * @summary - Creates custom CSS styles and classes used by [Text Button]{@link tf.ui.TextBtn} instances to customize the <b>text</b> and <b>background</b> colors displayed 
     * in normal and hover states
     * @param {color} textColor - normal text color
     * @param {color} backgroundColor - normal background color
     * @param {color} textColorHover - text color on hover
     * @param {color} backgroundColorHover - background color on hover
     * @returns {tf.types.CSSStyleName} - | {@link tf.types.CSSStyleName} a CSS style/class
    */
    this.CreateTextDivBtnClasses = function (textColor, backgroundColor, textColorHover, backgroundColorHover, addStyle, addStyleHover) {
        return createTextDivBtnClasses(textColor, backgroundColor, textColorHover, backgroundColorHover, addStyle, addStyleHover);
    }
    /**
     * @public
     * @function
     * @summary - Rotates the given element by the given angle, in degrees, by changing a specific [CSS style statement]{@link tf.types.CSSStyleStatement} of that element
     * @param {HTMLElementLike} elem - the given element
     * @param {number} angle - the given angle in degrees
     * @returns {void} - | {@link void} no return value
    */
    this.RotateByDegree = function (elem, angle) {
        var transformStr = theThis.GetSupportedTransformProperty();
        if (!!transformStr) {
            if (elem = tf.dom.GetHTMLElementFrom(elem)) {
                elem.style[transformStr] = theThis.GetRotateByDegreeTransformStr(angle);
            }
        }
    }
    this.GetSupportedTransformProperty = function () { return supportedTransformProp; }
    this.GetRotateByDegreeTransformStr = function (angle) {
        var degStr = tf.js.GetFloatNumberInRange(angle, -360 * 10, 360 * 10, 0) + "deg";
        return "rotate(" + degStr + ")";
    }
    /**
     * @public
     * @function
     * @summary - Gradually changes the visibility state of the given element to the given state by changing specific [CSS style statements]{@link tf.types.CSSStyleStatement} of that element
     * @param {HTMLElementLike} elem - the given element
     * @param {boolean} bool - <b>true</b> to make the element visible, <b>false</b> to make it invisible
     * @returns {void} - | {@link void} no return value
    */
    this.ChangeOpacityVisibilityClass = function (elem, bool) {
        if (elem = tf.dom.GetHTMLElementFrom(elem)) {
            var classIn, classOut;
            if (!!bool) { classIn = theThis.opacityVisibilityShowClass; classOut = theThis.opacityVisibilityHideClass; }
            else { classOut = theThis.opacityVisibilityShowClass; classIn = theThis.opacityVisibilityHideClass; }
            tf.dom.ReplaceCSSClass(elem, classOut, classIn);
            /*var style = !!bool ? subStyles.opacityVisibilityShowStyle : subStyles.opacityVisibilityHideStyle;
            theThis.ApplyStyleProperties(elem, style);*/
        }
    }
    /**
     * @public
     * @function
     * @summary - Applies the given style specifications to the given element
     * @param {HTMLElementLike} elem - the given element
     * @param {tf.types.CSSStyleSpecs} cssStyleSpecs - the given specifications
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.ApplyStyleProperties = function (elem, cssStyleSpecs) { styleCreator.ApplyStyleProperties(elem, cssStyleSpecs); return elem; }
    /**
     * @public
     * @function
     * @summary - Adds a default bottom border separator to the given element
     * @param {HTMLElementLike} elem - the given element
     * @param {boolean} lightBool - set to <b>true</b> to use the API's default <b>light</b> style settings, otherwise the default <b>dark</b> style settings are used
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.AddBorderBottom = function (elem, lightBool) {
        return theThis.ApplyStyleProperties (elem, !!lightBool ? subStyles.bottomBorderSeparatorLightStyle : subStyles.bottomBorderSeparatorDarkStyle);
    }
    /**
     * @public
     * @function
     * @summary - Adds a default top border separator to the given element
     * @param {HTMLElementLike} elem - the given element
     * @param {boolean} lightBool - set to <b>true</b> to use the API's default <b>light</b> style settings, otherwise the default <b>dark</b> style settings are used
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.AddBorderTop = function (elem, lightBool) {
        return theThis.ApplyStyleProperties(elem, !!lightBool ? subStyles.topSeparatorLightStyle : subStyles.topBorderSeparatorDarkStyle);
    }
    /**
     * @public
     * @function
     * @summary - Retrieves button background color used by the API
     * @param {boolean} selectedBool - set to <b>true</b> to retrieve the selected state color, otherwise the normal state color is returned
     * @returns {color} - | {@link color} the color
    */
    this.GetButtonBGColor = function (selectedBool) { return !!selectedBool ? subStyles.defaultButtonBk : subStyles.defaultButtonFill }
    /**
     * @public
     * @function
     * @summary - Retrieves CSS style/class name used by API border separators, always returns the <b>light</b> style settings class/style
     * @param {boolean} inlineBool - set to <b>true</b> to retrieve a right border separator, otherwise the bottom separator is returned
     * @returns {tf.types.CSSStyleName} - | {@link tf.types.CSSStyleName} the s
    */
    this.GetBorderSeparatorClassName = function (inlineBool) { return !!inlineBool ? this.rightBorderSeparatorLightClass : this.bottomBorderSeparatorLightClass; }
    /**
     * @public
     * @function
     * @summary - Retrieves CSS style/class name used by API in the creation of <b>padded</b> [Div]{@link tf.dom.Div} instances
     * @param {boolean} inlineBool - set to <b>true</b> to retrieve an <b>inline-block</b> style with optional right border separator, otherwise a <b>block</b> div style with optional bottom separator is returned
     * @param {boolean} borderSeparatorBool - set to <b>true</b> to add a border separator, defaults to {@link void}
     * @returns {tf.types.CSSStyleName} - | {@link tf.types.CSSStyleName} the color
    */
    this.GetPaddedDivClassNames = function (inlineBool, borderSeparatorBool) {
        var classNames = '';
        if (!!inlineBool) { classNames = this.paddedInlineBlockDivClass; } else { classNames = this.paddedBlockDivClass; }
        if (!!borderSeparatorBool) { classNames += ' ' + theThis.GetBorderSeparatorClassName(inlineBool); }
        return classNames;
    }
    /**
     * @public
     * @function
     * @summary - Retrieves CSS style/class name used by API in the creation of <b>unpadded</b> [Div]{@link tf.dom.Div} instances
     * @param {boolean} inlineBool - set to <b>true</b> to retrieve an <b>inline-block</b> style with optional right border separator, otherwise a <b>block</b> div style with optional bottom separator is returned
     * @param {boolean} borderSeparatorBool - set to <b>true</b> to add a border separator, defaults to {@link void}
     * @returns {tf.types.CSSStyleName} - | {@link tf.types.CSSStyleName} the color
    */
    this.GetUnPaddedDivClassNames = function (inlineBool, borderSeparatorBool) {
        var classNames = '';
        if (!!inlineBool) { classNames = this.unPaddedInlineBlockDivClass; } else { classNames = this.unPaddedBlockDivClass; }
        if (!!borderSeparatorBool) { classNames += ' ' + theThis.GetBorderSeparatorClassName(inlineBool); }
        return classNames;
    }
    /**
     * @public
     * @function
     * @summary - Retrieves a <b>unicode</b> character suitable for display as a double horizontal arrow
     * @returns {character} - | {@link character} the character
    */
    this.GetUnicodeDoubleHorArrow = function () { return '\u2194'; }
    /**
     * @public
     * @function
     * @summary - Retrieves a <b>unicode</b> character suitable for display as an X that resembles a "close" button
     * @returns {character} - | {@link character} the character
    */
    this.GetUnicodeXClose = function () { return '\u00d7'; }
    /**
     * @public
     * @function
     * @summary - Retrieves CSS style/class name used by API in the creation of [Radio Button Lists]{@link tf.ui.RadioButtonList}
     * @returns {tf.types.CSSStyleName} - | {@link tf.types.CSSStyleName} the color
    */
    this.GetRadioItemClasses = function () { return theThis.radioClass + " " + theThis.radioLabelClass; }
    /**
     * @public
     * @function
     * @summary - Retrieves CSS style/class name used by API in the creation of [Check Box Lists]{@link tf.ui.CheckBoxList}
     * @returns {tf.types.CSSStyleName} - | {@link tf.types.CSSStyleName} the color
    */
    this.GetCheckItemClasses = function () { return theThis.checkClass + " " + theThis.checkLabelClass; }
    /**
     * @public
     * @function
     * @summary - Changes the position style of the given element to 'relative'
     * @param {HTMLElementLike} elem - the given element
     * @returns {void} - | {@link void} no return value
    */
    this.ApplyPositionRelativeStyle = function (elem) { return theThis.ApplyStyleProperties(elem, subStyles.positionRelativeStyle); }
    /**
     * @public
     * @function
     * @summary - Changes the position style of the given element to 'absolute'
     * @param {HTMLElementLike} elem - the given element
     * @returns {void} - | {@link void} no return value
    */
    this.ApplyPositionAbsoluteStyle = function (elem) { return theThis.ApplyStyleProperties(elem, subStyles.positionAbsoluteStyle); }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances with image backgrounds
     * @param {HTMLElementLike} elem - the given element
     * @returns {void} - | {@link void} no return value
    */
    this.ApplyDivWithImgBkStyle = function (elem) { return theThis.ApplyStyleProperties(elem, subStyles.divWithImgBkStyle); }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances containing text
     * @param {HTMLElementLike} elem - the given element
     * @param {boolean} darkTextColorBool - set to <b>true</b> to use the API's default <b>dark</b> text color style settings, otherwise the default <b>light</b> style settings are used
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.ApplyTextColorStyle = function (elem, darkTextColorBool) { return theThis.ApplyStyleProperties(elem, !!darkTextColorBool ? subStyles.darkTextColorStyle : subStyles.lightTextColorStyle); }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances to align items vertically
     * @param {HTMLElementLike} elem - the given element
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.ApplyMiddleVerticalAlignStyle = function (elem) { return theThis.ApplyStyleProperties(elem, subStyles.middleVerticalAlignStyle); }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances to align text on the center
     * @param {HTMLElementLike} elem - the given element
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.ApplyTextAlignCenterStyle = function (elem) { return theThis.ApplyStyleProperties(elem, subStyles.textAlignCenterStyle); }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances to float them
     * @param {HTMLElementLike} elem - the given element
     * @param {boolean} isLeftBool - set to <b>true</b> for float <b>left</b> styles, otherwise float <b>right</b> styles are applied
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.ApplyFloatStyle = function (elem, isLeftBool) { styleCreator.ApplyStyleProperties(tf.dom.GetHTMLElementFrom(elem), !!isLeftBool ? subStyles.floatLeftStyle : subStyles.floatRightStyle); return elem; }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances to achieve opacity transition effects
     * @param {HTMLElementLike} elem - the given element
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.AddDefaultOpacityTransitionStyle = function (elem) { return theThis.ApplyStyleProperties(elem, subStyles.defaultOpacityVisibilityTransitionStyle); }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances to achieve the API's default shadow effect
     * @param {HTMLElementLike} elem - the given element
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.AddDefaultShadowStyle = function (elem) { styleCreator.ApplyStyleProperties(tf.dom.GetHTMLElementFrom(elem), subStyles.seShadowStyle); return elem; }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances to achieve the API's alternative shadow effect
     * @param {HTMLElementLike} elem - the given element
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.AddHorShadowStyle = function (elem) { styleCreator.ApplyStyleProperties(tf.dom.GetHTMLElementFrom(elem), subStyles.horShadowStyle); return elem; }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances to set their horizontal and vertical button margins
     * @param {HTMLElementLike} elem - the given element
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.AddButtonDivMargins = function (elem) { styleCreator.ApplyStyleProperties(tf.dom.GetHTMLElementFrom(elem), subStyles.buttonDivAllMarginsStyle); return elem; }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances to set their vertical button margins
     * @param {HTMLElementLike} elem - the given element
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.AddButtonDivTopBottMargins = function (elem) { styleCreator.ApplyStyleProperties(tf.dom.GetHTMLElementFrom(elem), subStyles.buttonDivTopBotMarginsStyle); return elem; }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances to set their horizontal button margins
     * @param {HTMLElementLike} elem - the given element
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.AddButtonDivLeftRightMargins = function (elem) { styleCreator.ApplyStyleProperties(tf.dom.GetHTMLElementFrom(elem), subStyles.buttonDivLeftRightMarginsStyle); return elem; }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances to set their left button margin
     * @param {HTMLElementLike} elem - the given element
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.AddButtonDivLeftMargin = function (elem) { styleCreator.ApplyStyleProperties(tf.dom.GetHTMLElementFrom(elem), subStyles.buttonDivMarginLeftStyle); return elem; }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances to set their right button margin
     * @param {HTMLElementLike} elem - the given element
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.AddButtonDivRightMargin = function (elem) { styleCreator.ApplyStyleProperties(tf.dom.GetHTMLElementFrom(elem), subStyles.buttonDivMarginRightStyle); return elem; }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances to center them relative to their containers
     * @param {HTMLElementLike} elem - the given element
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.ApplySnapToCenterStyle = function (elem) {
        if (!!elem) {
            var domElement = !!elem.GetHTMLElement ? tf.dom.GetHTMLElementFrom(elem) : elem;
            if (!!domElement) { styleCreator.ApplyStyleProperties(domElement, subStyles.snapCenterStyle); }
        }
        return elem;
    }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on [Div]{@link tf.dom.Div} instances to position them relative to their containers
     * @param {HTMLElementLike} elem - the given element
     * @param {object} options - snap positioning options
     * @param {tf.types.horizontalPositioning} options.horPos - horizontal positioning
     * @param {tf.types.verticalPositioning} options.verPos - vertical positioning
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the given element
    */
    this.ApplySnapStyle = function (elem, options) {
        var domElement = tf.dom.GetHTMLElementFrom(elem);
        if (!!domElement) {
            var snapStyleHor;
            var snapStyleVer;
            var singleSnapStyle;
            switch (options.horPos) {
                case tf.consts.positioningLeft: snapStyleHor = subStyles.snapLeftStyle; break;
                case tf.consts.positioningRight: snapStyleHor = subStyles.snapRightStyle; break;
            }
            switch (options.verPos) {
                case tf.consts.positioningTop: snapStyleVer = subStyles.snapTopStyle; break;
                case tf.consts.positioningBottom: snapStyleVer = subStyles.snapBotStyle; break;
            }
            if (!snapStyleHor) {
                if (!snapStyleVer) { singleSnapStyle = subStyles.snapCenterStyle; }
                else { snapStyleHor = subStyles.snapCenterHorStyle; }
            }
            if (!snapStyleVer) { snapStyleVer = subStyles.snapCenterVerStyle; }
            if (singleSnapStyle) { styleCreator.ApplyStyleProperties(domElement, singleSnapStyle); }
            else {
                styleCreator.ApplyStyleProperties(domElement, snapStyleHor);
                styleCreator.ApplyStyleProperties(domElement, snapStyleVer);
            }
        }
        return elem;
    }
    /**
     * @public
     * @function
     * @summary - Creates an [SVG Glyph Button]{@link tf.ui.SvgGlyphBtn} with an X glyph that can be used as a <b>close</b> button on popups and elsewhere
     * @param {boolean} lightBool - set to <b>true</b> to use the API's default <b>light</b> style settings, otherwise the default <b>dark</b> style settings are used
     * @param {tf.types.MultiDOMEventListenerCallBack} onClickCallBack - callback for [Click]{@link tf.consts.DOMEventNamesClick} events
     * @param {HTMLElementSizeOrPxNumber} dim - button dimension
     * @param {string} toolTipStr - optional tooltip
     * @returns {tf.ui.SvgGlyphBtn} - the instance
    */
    this.CloseXButtonForPopup = function (lightBool, onClickCallBack, dim, toolTipStr) {
        !!dim && (dim = subStyles.mapControlFontSizeEmNumber + "em");
        !!!toolTipStr && (toolTipStr = 'Close');
        var btn = new tf.ui.SvgGlyphBtn({ style: lightBool, glyph: tf.styles.SvgGlyphCloseXName, onClick: onClickCallBack, tooltip: toolTipStr, dim: dim });
        var btnDiv = btn.GetHTMLElement();
        //btnDiv.style.top = "50%";
        //btnDiv.style.transform = "translateY(-25%)";
        //btnDiv.style.transform = "translateY(-50%)";
        styleCreator.ApplyStyleProperties(btnDiv, subStyles.buttonDivMarginLeftStyle);
        return btn;
    }
    /**
     * @public
     * @function
     * @summary - Creates an [Img]{@link tf.dom.Img} instance from the given source, will "100%" width and height styles
     * @param {string} imgSrc - the given source
     * @returns {tf.dom.Img} - | {@link tf.dom.Img} the instance
    */
    this.CreateImageFullWidthHeight = function (imgSrc) { return new tf.dom.Img({ src: imgSrc, cssClass: tf.GetStyles().imgFullWidthHeightClass }); }
    /**
     * @public
     * @function
     * @summary - Creates a [Div]{@link tf.dom.Div} instance with the given text settings
     * @param {boolean} darkTextColorBool - set to <b>true</b> to use the API's default <b>dark</b> text color style settings, otherwise the default <b>light</b> style settings are used
     * @returns {tf.dom.Div} - | {@link tf.dom.Div} the instance
    */
    this.CreateListContentItem = function (darkTextColorBool) {
        var styles = tf.GetStyles();
        return styles.ApplyTextColorStyle(styles.ApplyMiddleVerticalAlignStyle(new tf.dom.Div({ cssClass: styles.paddedInlineBlockDivClass })), darkTextColorBool);
    }
    /**
     * @public
     * @function
     * @summary - Creates a [Div]{@link tf.dom.Div} instance with a background image from the given source
     * @param {string} imgSrc - the given source
     * @param {boolean} rectangularImageBool - set to <b>true</b> to create with 16x9 aspect ratio, otherwise a square is created
     * @returns {tf.dom.Div} - | {@link tf.dom.Div} the instance
    */
    this.CreateListContentItemWithImgBk = function (imgSrc, rectangularImageBool) {
        var styles = tf.GetStyles(), subStyles = styles.GetSubStyles();
        var divObj = styles.ApplyDivWithImgBkStyle(theThis.CreateListContentItem(false)), div = divObj.GetHTMLElement();
        div.style.height = (!!rectangularImageBool ? subStyles.imageThumbRectHeightEmNumber : subStyles.imageThumbSquareHeightEmNumber) + "em";
        div.style.backgroundImage = "url('" + imgSrc + "')";
        return divObj;
    }
    /**
     * @public
     * @function
     * @summary - Applies styles used by the API on the HTML document body
     * @returns {void} - | {@link void} no return value
    */
    this.AddBodyStyle = function () { return addBodyStyle(); }
    /**
     * used for application containers
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.appContainerClass = divBaseClass + "app";
    /**
     * used for [Map]{@link tf.map.Map} containers
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.mapContainerClass = divBaseClass + "map-container";
    /**
     * used for [Map]{@link tf.map.Map} sub-containers
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapSubContainerClass = divBaseClass + "map";
    /**
     * used for layout sub-containers
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.leftSideContainerClass = divBaseClass + "left";
    /**
     * used for layout sub-containers
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.floatLeftSideContainerClass = divBaseClass + "floatLeft";
    /**
     * used for layout sub-containers
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.leftRightSideSeparatorClass = divBaseClass + "leftright";
    /**
     * used for layout sub-containers
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.rightSideContainerClass = divBaseClass + "right";
    /**
     * used for layout sub-containers
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.bottomContainerClass = divBaseClass + "bot";
    /**
     * used for layout sub-containers
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.topBottomSeparatorClass = divBaseClass + "topbot";
    /**
     * used for layout sub-containers
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.listContentClass = divBaseClass + "listcnt";
    /**
     * default used by {@link tf.dom.TextInput}
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.inputFormClass = divBaseClass + "inputForm";
    /**
     * block display padded div 
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.paddedBlockDivClass = divBaseClass + blockSuffix + paddedSuffix;
    /**
     * inline-block display padded div 
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.paddedInlineBlockDivClass = divBaseClass + inlineBlockSuffix + paddedSuffix;
    /**
     * block display padded div with a bottom border separator
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.paddedBlockDivWithBorderSeparatorClass = divBaseClass + "block-padded-bordersep";
    /**
     * inline-block display padded div with a right border separator
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.paddedInlineBlockDivWithBorderSeparatorClass = divBaseClass + "inline-block-padded-bordersep";
    /**
     * block display unpadded div
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.unPaddedBlockDivClass = divBaseClass + blockSuffix + unPaddedSuffix;
    /**
     * inline-block display unpadded div
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.unPaddedInlineBlockDivClass = divBaseClass + inlineBlockSuffix + unPaddedSuffix;
    /**
     * div with background image
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.divWithImgBkClass = divBaseClass + "imgbk";
    /**
     * div used with map measure
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapMeasureOverlayDivClass = divBaseClass + "mapoverlay";
    /**
     * div used with logos
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.imgLogoStyleClass = imgBaseClass + "logo";
    /**
     * used by {@link tf.dom.Img} with "100%" width and height
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.imgFullWidthHeightClass = imgBaseClass + "fullwh";
    /**
     * used by {@link tf.dom.Img} in map's info window
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.imgForInfoWindowClass = imgBaseClass + "infow";
    /**
     * used by {@link tf.ui.SvgGlyph} light style without hover
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.svgGlyphLightNoHoverStyleClass = svgGlyphStyleBaseClass + svgGlyphStyleNoHoverClass + lightClassName;
    /**
     * used by {@link tf.ui.SvgGlyph} light style
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.svgGlyphLightStyleClass = svgGlyphStyleBaseClass + lightClassName;
    /**
     * used by {@link tf.ui.SvgGlyph} dark style without hover
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.svgGlyphDarkNoHoverStyleClass = svgGlyphStyleBaseClass + svgGlyphStyleNoHoverClass + darkClassName;
    /**
     * used by {@link tf.ui.SvgGlyph} dark style
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.svgGlyphDarkStyleClass = svgGlyphStyleBaseClass + darkClassName;
    /**
     * used by {@link tf.ui.SvgGlyphBtn}
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.divSvgGlyphBtnClass = svgGlyphStyleBaseClass + "svgglyphbtndiv";
    /**
     * used by {@link tf.ui.TextBtn} light style
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.textDivBtnLightStyleClass = textDivBtnStyleBaseClass + lightClassName;
    /**
     * used by {@link tf.ui.TextBtn} dark style
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.textDivBtnDarkStyleClass = textDivBtnStyleBaseClass + darkClassName;
    /**
     * used by {@link tf.ui.TextBtn} map style
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.mapTextBtnClass = textDivBtnStyleBaseClass + "map";
    /**
     * bottom separator light style
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.bottomBorderSeparatorLightClass = borderBaseClass + "botlight";
    /**
     * bottom separator dark style
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.bottomBorderSeparatorDarkClass = borderBaseClass + "botdark";
    /**
     * right separator light style
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.rightBorderSeparatorLightClass = borderBaseClass + "rightlight";
    /**
     * right separator dark style
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.rightBorderSeparatorDarkClass = borderBaseClass + "rightdark";
    /**
     * used by {@link tf.ui.RadioButtonWithLabel}
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.radioClass = "tf-radio";
    /**
     * used by {@link tf.ui.RadioButtonWithLabel}
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.radioLabelClass = this.radioClass + "-label";
    /**
     * used by {@link tf.ui.CheckBoxWithLabel}
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.checkClass = "tf-check";
    /**
     * used by {@link tf.ui.CheckBoxWithLabel}
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.checkLabelClass = this.checkClass + "-label";
    /**
     * used by {@link tf.ui.Popup} captions
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.popupCaptionClass = divBaseClass + "popupcaption";
    /**
     * used by {@link tf.ui.Popup} container
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.popupContainerClass = divBaseClass + "popupcontainer";
    /**
     * used by {@link tf.ui.Popup} content
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.popupContentClass = divBaseClass + "popupcontent";
    /**
     * used by map toolbars
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapToolBarContainerClass = divBaseClass + "maptoolbarcontainer";
    /**
     * used by {@link tf.dom.Span}
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.spanClass = spanBaseClass + "span";
    /**
     * used by {@link tf.dom.Span}
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.spanCursorPointerClass = spanBaseClass + "spanCursorPointer";
    /**
     * used by {@link tf.urlapi.DLayer} in map Info Popups
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.dLayerInfoClass = divBaseClass + "dLayerInfo";
    /**
     * used by {@link tf.layout.HeaderContentFooter} layouts
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.hcfLayoutClass = divBaseClass + "hcfpage";
    /**
     * used by {@link tf.layout.HeaderContentFooter} layouts
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.hcfLayoutHeaderClass = divBaseClass + "hcfhrd";
    /**
     * used by {@link tf.layout.HeaderContentFooter} layouts
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.hcfLayoutFooterClass = divBaseClass + "hcfftr";
    /**
     * used by {@link tf.layout.HeaderContentFooter} layouts
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.hcfLayoutContentClass = divBaseClass + "hcfcnt";
    /**
     * used by {@link tf.dom.Link}
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.buttonShapedLinkClass = linkBaseClass + "buttonshape";
    /**
     * used by {@link tf.dom.TextInput}
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.inputTextClass = inputBaseClass + "input";
    /**
     * used by map controls
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapTFLogoControlClass = mapBaseClass + "tflogo";
    /**
     * used by map controls
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapAddressButtonClass = mapBaseClass + "addressbtn";
    /**
     * used by map controls
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapLayersButtonClass = mapBaseClass + "layersbtn";
    /**
     * used by map controls
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapTypeButtonClass = mapBaseClass + "typebtn";
    /**
     * used by map controls
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapMeasureButtonClass = mapBaseClass + "measurebtn";
    /**
     * used by map controls
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapDownloadButtonClass = mapBaseClass + "downloadbtn";
    /**
     * used by map controls
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapSourceButtonClass = mapBaseClass + "sourcebtn";
    /**
     * used by map controls
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapLocationButtonClass = mapBaseClass + "centerbtn";
    /**
     * used by map controls
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapUserLocationButtonClass = mapBaseClass + "userlocbtn";
    /**
     * used by map controls
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapFullScreenButtonClass = mapBaseClass + "fullscreenbtn";
    /**
     * used for visibility transitions
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.opacityVisibilityShowClass = utilBaseClass + "show";
    /**
     * used for visibility transitions
     * @public
     * @type {tf.types.CSSStyleName}
    */
    this.opacityVisibilityHideClass = utilBaseClass + "hide";
    /**
     * used by map controls
     * @private
     * @type {tf.types.CSSStyleName}
    */
    this.mapSvgGlyphInButtonClass = mapBaseClass + "svgglyphinbutton";
    function createSvgGlyphClasses(glyphColor, backgroundColor, glyphColorHover, backgroundColorHover) {
        var className = svgGlyphStyleBaseClass + tf.GetGlobalCounter().GetNext();
        var svgStyles = subStyles.CreateSvgGlyphStyles(glyphColor, backgroundColor, glyphColorHover, backgroundColorHover);
        var styles = [
            { styleName: svgPreSelectorStr + className, inherits: svgStyles.style },
            { styleName: svgPreSelectorStr + className + hoverSelectorStr, inherits: svgStyles.hoverStyle }
        ];
        styleCreator.CreateStyles(styles);
        return className;
    }
    function createTextDivBtnClasses(textColor, backgroundColor, textColorHover, backgroundColorHover, addStyle, addStyleHover) {
        var className = textDivBtnStyleBaseClass + tf.GetGlobalCounter().GetNext();
        var divStyles = subStyles.CreateTextDivBtnStyles(textColor, backgroundColor, textColorHover, backgroundColorHover);
        var styles = [
            { styleName: divPreSelectorStr + className, inherits: tf.js.ShallowMerge(addStyle, divStyles.style) },
            { styleName: divPreSelectorStr + className + hoverSelectorStr, inherits: tf.js.ShallowMerge(addStyleHover, divStyles.hoverStyle) }
        ];
        styleCreator.CreateStyles(styles);
        return className;
    }
    function addBodyStyle() { styleCreator.CreateStyle({ styleName: "body", inherits: subStyles.bodyStyle }); }
    function getFirstSupportedElementProp (propArrayOrObject) {
        var propFound = null;
        if (tf.js.GetIsValidObject(propArrayOrObject)) {
            var rootStyle = document.documentElement.style;
            for (var i in propArrayOrObject) { var thisProp = propArrayOrObject[i]; if (thisProp in rootStyle) { propFound = thisProp; break; } }
        }
        return propFound;
    }
    function findSupportedElementProps() {
        supportedTransformProp = getFirstSupportedElementProp(['transform', 'MozTransform', 'WebkitTransform', 'msTransform', 'OTransform']);
    }
    function createHiddenCanvas() {
        hiddenCanvas = document.createElement('canvas');
        var hiddenCanvasStyle = hiddenCanvas.style;
        hiddenCanvasStyle.display = 'none';
        hiddenCanvasStyle.width = "10em";
        hiddenCanvasStyle.height = "10em";
        hiddenCanvasStyle.zIndex = -100;
    }
    function createLiteralStyles() {
        var literalStyles = [];
        for (var literalStyle in literalStyles) { var thisStyle = literalStyles[literalStyle]; if (thisStyle.styleName) { styleCreator.CreateRawStyle(thisStyle.selector, thisStyle.style); } }
    }
    function createStyles() {
        var styles = [
            { styleName: dotPrefix + theThis.appContainerClass, inherits: subStyles.appContainerStyle },
            { styleName: dotPrefix + theThis.mapContainerClass, inherits: subStyles.mapContainerStyle },
            { styleName: dotPrefix + theThis.mapSubContainerClass, inherits: subStyles.mapSubContainerStyle },
            { styleName: dotPrefix + theThis.leftSideContainerClass, inherits: subStyles.leftSideContainerStyle },
            { styleName: dotPrefix + theThis.floatLeftSideContainerClass, inherits: subStyles.floatLeftSideContainerStyle },
            { styleName: dotPrefix + theThis.leftRightSideSeparatorClass, inherits: subStyles.leftRightSideSeparatorStyle },
            { styleName: dotPrefix + theThis.rightSideContainerClass, inherits: subStyles.rightSideContainerStyle },
            { styleName: dotPrefix + theThis.bottomContainerClass, inherits: subStyles.bottomContainerStyle },
            { styleName: dotPrefix + theThis.topBottomSeparatorClass, inherits: subStyles.topBottomSeparatorStyle },
            { styleName: dotPrefix + theThis.listContentClass, inherits: subStyles.listContentStyle },
            { styleName: dotPrefix + theThis.inputFormClass, inherits: subStyles.inputFormStyle },
            { styleName: dotPrefix + theThis.popupContainerClass, inherits: subStyles.popupContainerStyle },
            { styleName: dotPrefix + theThis.popupContentClass, inherits: subStyles.popupContentStyle },
            { styleName: dotPrefix + theThis.mapToolBarContainerClass, inherits: subStyles.mapToolBarContainerStyle },
            { styleName: dotPrefix + theThis.paddedBlockDivClass, inherits: subStyles.paddedBlockDivStyle },
            { styleName: dotPrefix + theThis.paddedInlineBlockDivClass, inherits: subStyles.paddedInlineBlockDivStyle },
            { styleName: dotPrefix + theThis.paddedBlockDivWithBorderSeparatorClass, inherits: subStyles.paddedBlockDivWithBorderSeparatorStyle },
            { styleName: dotPrefix + theThis.paddedInlineBlockDivWithBorderSeparatorClass, inherits: subStyles.paddedInlineBlockDivWithBorderSeparatorStyle },
            { styleName: dotPrefix + theThis.unPaddedBlockDivClass, inherits: subStyles.unPaddedBlockDivStyle },
            { styleName: dotPrefix + theThis.unPaddedInlineBlockDivClass, inherits: subStyles.unPaddedInlineBlockDivStyle },
            { styleName: dotPrefix + theThis.divWithImgBkClass, inherits: subStyles.divWithImgBkStyle },
            { styleName: dotPrefix + theThis.inputTextClass + ":-moz-placeholder", inherits: subStyles.inputTextPlaceholderStyle },
            { styleName: dotPrefix + theThis.inputTextClass + "::-moz-placeholder", inherits: subStyles.inputTextPlaceholderStyle },
            { styleName: dotPrefix + theThis.inputTextClass + ":-ms-input-placeholder", inherits: subStyles.inputTextPlaceholderStyle },
            { styleName: dotPrefix + theThis.inputTextClass + "::-webkit-input-placeholder", inherits: subStyles.inputTextPlaceholderStyle },
            { styleName: dotPrefix + theThis.inputTextClass + "::-ms-clear", inherits: subStyles.noneDisplayStyle },
            { styleName: dotPrefix + theThis.inputTextClass + ", " + dotPrefix + theThis.inputTextClass + inputPosSelectorStr + ", " + dotPrefix + theThis.inputTextClass + inputPosSelectorStr + focusSelectorStr, inherits: subStyles.inputTextStyle },
            { styleName: dotPrefix + theThis.radioLabelClass + labelPosSelectorStr, inherits: subStyles.radioLabelStyle },
            { styleName: dotPrefix + theThis.radioClass + inputTypeRadioPosSelectorStr, inherits: subStyles.radioRadioStyle },
            { styleName: dotPrefix + theThis.radioClass + inputTypeRadioPosSelectorStr + checkedSelectorStr + " +" + labelPosSelectorStr, inherits: subStyles.radioRadioAndLabelCheckedStyle },
            { styleName: dotPrefix + theThis.radioClass + inputTypeRadioPosSelectorStr + ", " + dotPrefix + theThis.radioLabelClass + labelPosSelectorStr + beforeSelectorStr, inherits: subStyles.radioRadioAndLabelStyleBefore },
            { styleName: dotPrefix + theThis.radioClass + inputTypeRadioPosSelectorStr + checkedSelectorStr + " +" + labelPosSelectorStr + beforeSelectorStr, inherits: subStyles.radioRadioAndLabelSelStyleBefore },
            { styleName: dotPrefix + theThis.checkLabelClass + labelPosSelectorStr, inherits: subStyles.checkLabelStyle },
            { styleName: dotPrefix + theThis.checkClass + inputTypeCheckPosSelectorStr, inherits: subStyles.checkCheckStyle },
            { styleName: dotPrefix + theThis.checkClass + inputTypeCheckPosSelectorStr + checkedSelectorStr + " +" + labelPosSelectorStr, inherits: subStyles.checkCheckAndLabelCheckedStyle },
            { styleName: dotPrefix + theThis.checkClass + inputTypeCheckPosSelectorStr + ", " + dotPrefix + theThis.checkLabelClass + labelPosSelectorStr + beforeSelectorStr, inherits: subStyles.checkCheckAndLabelStyleBefore },
            { styleName: dotPrefix + theThis.checkClass + inputTypeCheckPosSelectorStr + checkedSelectorStr + " +" + labelPosSelectorStr + beforeSelectorStr, inherits: subStyles.checkCheckAndLabelSelStyleBefore },
            { styleName: dotPrefix + theThis.mapMeasureOverlayDivClass, inherits: subStyles.mapMeasureOverlayDivStyle },
            { styleName: dotPrefix + theThis.hcfLayoutClass, inherits: subStyles.hcfLayoutStyle },
            { styleName: dotPrefix + theThis.hcfLayoutHeaderClass, inherits: subStyles.hcfLayoutHeaderStyle },
            { styleName: dotPrefix + theThis.hcfLayoutFooterClass, inherits: subStyles.hcfLayoutFooterStyle },
            { styleName: dotPrefix + theThis.hcfLayoutContentClass, inherits: subStyles.hcfLayoutContentStyle },
            { styleName: dotPrefix + theThis.popupCaptionClass, inherits: subStyles.popupCaptionStyle },
            { styleName: dotPrefix + theThis.spanClass, inherits: subStyles.spanStyle },
            { styleName: dotPrefix + theThis.spanCursorPointerClass, inherits: subStyles.spanCursorPointerStyle },
            { styleName: dotPrefix + theThis.dLayerInfoClass, inherits: subStyles.dLayerInfoStyle },
            { styleName: dotPrefix + theThis.dLayerInfoClass + imgPosSelectorStr, inherits: subStyles.dLayerInfoImgStyle },
            { styleName: dotPrefix + theThis.dLayerInfoClass + linkPosSelectorStr, inherits: subStyles.dLayerInfoLinkStyle },
            { styleName: dotPrefix + theThis.dLayerInfoClass + linkPosSelectorStr + linkSelectorStr, inherits: subStyles.dLayerInfoLinkStyle },
            { styleName: dotPrefix + theThis.dLayerInfoClass + linkPosSelectorStr + visitedSelectorStr, inherits: subStyles.dLayerInfoLinkStyle },
            { styleName: dotPrefix + theThis.dLayerInfoClass + linkPosSelectorStr + hoverSelectorStr, inherits: subStyles.dLayerInfoLinkHoverStyle },
            { styleName: dotPrefix + theThis.dLayerInfoClass + linkPosSelectorStr + activeSelectorStr, inherits: subStyles.dLayerInfoLinkStyle },
            { styleName: dotPrefix + theThis.dLayerInfoClass + spanPosSelectorStr, inherits: subStyles.dLayerInfoSpanStyle },
            { styleName: linkPreSelectorStr + theThis.buttonShapedLinkClass, inherits: subStyles.buttonShapedLinkStyle },
            { styleName: linkPreSelectorStr + theThis.buttonShapedLinkClass + hoverSelectorStr, inherits: subStyles.buttonShapedLinkHoverStyle },
            { styleName: imgPreSelectorStr + theThis.imgLogoStyleClass, inherits: subStyles.imgLogoStyle },
            { styleName: imgPreSelectorStr + theThis.imgFullWidthHeightClass, inherits: subStyles.imgFullWidthHeightStyle },
            { styleName: imgPreSelectorStr + theThis.imgForInfoWindowClass, inherits: subStyles.imgForInfoWindowStyle },
            { styleName: svgPreSelectorStr + theThis.svgGlyphLightNoHoverStyleClass, inherits: subStyles.svgGlyphLightNoHoverStyle },
            { styleName: svgPreSelectorStr + theThis.svgGlyphLightStyleClass, inherits: subStyles.svgGlyphLightStyle },
            { styleName: svgPreSelectorStr + theThis.svgGlyphLightStyleClass + hoverSelectorStr, inherits: subStyles.svgGlyphLightStyleHover },
            { styleName: svgPreSelectorStr + theThis.svgGlyphDarkNoHoverStyleClass, inherits: subStyles.svgGlyphDarkNoHoverStyle },
            { styleName: svgPreSelectorStr + theThis.svgGlyphDarkStyleClass, inherits: subStyles.svgGlyphDarkStyle },
            { styleName: svgPreSelectorStr + theThis.svgGlyphDarkStyleClass + hoverSelectorStr, inherits: subStyles.svgGlyphDarkStyleHover },
            { styleName: svgPreSelectorStr + theThis.mapSvgGlyphInPopupClass, inherits: subStyles.mapSvgGlyphInPopupStyle },
            { styleName: svgPreSelectorStr + theThis.mapSvgGlyphInPopupClass + hoverSelectorStr, inherits: subStyles.mapSvgGlyphInPopupHoverStyle },
            { styleName: svgPreSelectorStr + theThis.mapSvgGlyphInButtonClass, inherits: subStyles.mapSvgGlyphInButtonStyle },
            { styleName: dotPrefix + theThis.divSvgGlyphBtnClass, inherits: subStyles.divSvgGlyphBtnStyle },
            { styleName: divPreSelectorStr + theThis.textDivBtnLightStyleClass, inherits: subStyles.textDivBtnLightStyle },
            { styleName: divPreSelectorStr + theThis.textDivBtnLightStyleClass + hoverSelectorStr, inherits: subStyles.textDivBtnLightStyleHover },
            { styleName: divPreSelectorStr + theThis.textDivBtnDarkStyleClass, inherits: subStyles.textDivBtnDarkStyle },
            { styleName: divPreSelectorStr + theThis.textDivBtnDarkStyleClass + hoverSelectorStr, inherits: subStyles.textDivBtnDarkStyleHover },
            { styleName: divPreSelectorStr + theThis.mapTextBtnClass, inherits: subStyles.mapTextBtnStyle },
            { styleName: divPreSelectorStr + theThis.mapTextBtnClass + hoverSelectorStr, inherits: subStyles.mapTextBtnStyleHover },
            { styleName: dotPrefix + theThis.bottomBorderSeparatorLightClass, inherits: subStyles.bottomBorderSeparatorLightStyle },
            { styleName: dotPrefix + theThis.bottomBorderSeparatorDarkClass, inherits: subStyles.bottomBorderSeparatorDarkStyle },
            { styleName: dotPrefix + theThis.rightBorderSeparatorLightClass, inherits: subStyles.rightBorderSeparatorLightStyle },
            { styleName: dotPrefix + theThis.rightBorderSeparatorDarkClass, inherits: subStyles.rightBorderSeparatorDarkStyle },
            { styleName: dotPrefix + theThis.mapTFLogoControlClass, inherits: subStyles.mapTFLogoControlStyle },
            { styleName: dotPrefix + theThis.mapAddressButtonClass, inherits: subStyles.mapAddressButtonStyle },
            { styleName: dotPrefix + theThis.mapLayersButtonClass, inherits: subStyles.mapLayersButtonStyle },
            { styleName: dotPrefix + theThis.mapTypeButtonClass, inherits: subStyles.mapTypeButtonStyle },
            { styleName: dotPrefix + theThis.mapMeasureButtonClass, inherits: subStyles.mapMeasureButtonStyle },
            { styleName: dotPrefix + theThis.mapDownloadButtonClass, inherits: subStyles.mapDownloadButtonStyle },
            { styleName: dotPrefix + theThis.mapSourceButtonClass, inherits: subStyles.mapSourceButtonStyle },
            { styleName: dotPrefix + theThis.mapLocationButtonClass, inherits: subStyles.mapLocationButtonStyle },
            { styleName: dotPrefix + theThis.mapUserLocationButtonClass, inherits: subStyles.mapUserLocationButtonStyle },
            { styleName: dotPrefix + theThis.mapFullScreenButtonClass, inherits: subStyles.mapFullScreenButtonStyle },
            { styleName: ".ol-viewport .ol-unselectable", inherits: subStyles.mapViewPortUnSelectableStyle },
            { styleName: ".ol-zoom", inherits: subStyles.mapZoomStyle },
            { styleName: ".ol-zoom .ol-zoom-in", inherits: subStyles.mapZoomInBorderRadiusStyle },
            { styleName: ".ol-zoom .ol-zoom-out", inherits: subStyles.mapZoomOutBorderRadiusStyle },
            { styleName: ".ol-zoomslider", inherits: subStyles.mapZoomSliderStyle },
            { styleName: ".ol-rotate", inherits: subStyles.mapRotateStyle },
            { styleName: ".ol-rotate.ol-hidden", inherits: subStyles.mapRotateHiddenStyle },
            { styleName: ".ol-compass", inherits: subStyles.mapCompassStyle },
            { styleName: ".ol-scale-line", inherits: subStyles.mapScaleLineStyle },
            { styleName: ".ol-scale-line-inner", inherits: subStyles.mapScaleLineInnerStyle },
            { styleName: ".ol-control", inherits: subStyles.mapControlStyle },
            { styleName: ".ol-control" + hoverSelectorStr, inherits: subStyles.mapControlHoverStyle },
            { styleName: ".ol-control" + buttonPosSelectorStr + focusSelectorStr + ", " + ".ol-control" + buttonPosSelectorStr + hoverSelectorStr, inherits: subStyles.mapControlButtonFocusHoverStyle },
            { styleName: ".ol-control" + buttonPosSelectorStr, inherits: subStyles.mapControlButtonStyle },
            { styleName: ".ol-control" + buttonPosSelectorStr + "::-moz-focus-inner", inherits: subStyles.mapControlButtonMozFocusInnerStyle },
            { styleName: ".ol-overviewmap", inherits: subStyles.mapOverviewMapStyle },
            { styleName: ".ol-overviewmap.ol-uncollapsible", inherits: subStyles.mapOverviewMapUnCollapsibleStyle },
            { styleName: ".ol-overviewmap .ol-overviewmap-map, .ol-overviewmap" + buttonPosSelectorStr, inherits: subStyles.mapControlButtonStyle },
            { styleName: ".ol-overviewmap .ol-overviewmap-map", inherits: subStyles.mapOverviewMapMapStyle },
            { styleName: ".ol-overviewmap:not(.ol-collapsed)" + buttonPosSelectorStr, inherits: subStyles.mapOverviewMapButtonNotCollapsedStyle },
            { styleName: ".ol-overviewmap.ol-collapsed .ol-overviewmap-map, .ol-overviewmap.ol-uncollapsible" + buttonPosSelectorStr, inherits: subStyles.mapOverviewMapButtonCollapsedStyle },
            { styleName: ".ol-overviewmap:not(.ol-collapsed)", inherits: subStyles.mapOverviewMapNotCollapsedStyle },
            { styleName: ".ol-overviewmap-box", inherits: subStyles.mapOverviewMapBoxStyle },
            { styleName: ".ol-button-text-span", inherits: subStyles.mapButtonTextSpanStyle },
            { styleName: dotPrefix + theThis.opacityVisibilityShowClass, inherits: subStyles.opacityVisibilityShowStyle },
            { styleName: dotPrefix + theThis.opacityVisibilityHideClass, inherits: subStyles.opacityVisibilityHideStyle },
            {}
        ];
        styleCreator.CreateStyles(styles);
    }
    function initialize() {
        styleCreator = new tf.styles.CSSStyleCreator(theThis);
        subStyles = new tf.styles.SubStyles(theThis, alternativeSpecs);
        createHiddenCanvas();
        findSupportedElementProps();
        //styleCreator.CreateRawStyle("@font-face", subStyles.fontFaceStyleContentStr);
        createLiteralStyles();
        createStyles();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: debug.js
/**
 * @public
 * @class
 * @summary - Counter instances are used to generate unique numbers
*/
tf.js.Counter = function () {
    var counter = 0;
    /**
     * @public
     * @function
     * @summary - Retrieves the next number, returns <b>1</b> the first time it is called
     * @returns {number} - | {@link number} the next number
    */
    this.GetNext = function () { return ++counter; }
};
/**
 * @public
 * @class
 * @summary - The {@link singleton} instance of this class, obtainable by calling {@link tf.units.GetDebug}, aids in debugging
*/
tf.Debug = function () {
    var theThis, isTest;
    this.AddExtent = function(extent, layer, lineColor) {
        var coords = [
            [extent[0], extent[1]],
            [extent[0], extent[3]],
            [extent[2], extent[3]],
            [extent[2], extent[1]],
            [extent[0], extent[1]]
        ];
        var line_color = lineColor !== undefined ? lineColor : "#f00";
        var style = { line: true, line_color: line_color, line_width: 5, zindex: 10 };
        var extentFeature = new tf.map.Feature({ type: "linestring", coordinates: coords, style: style });
        layer.AddMapFeature(extentFeature);
    }
   /**
     * @public
     * @function
     * @summary - Logs the given string to the Browser's console only if using the Test platform of the API
     * @param {string} logString - the given string
     * @returns {void} - | {@link void} no return value
     * @see {@link tf.platform.GetIsTest}
    */
    this.LogIfTest = function (logString) { return logIfTest(logString); }
    /**
     * @public
     * @function
     * @summary - Converts the given object to JSON format and writes it to a file of the given name, works on Firefox and not on all Browsers
     * @param {string} name - the given name
     * @param {object} object - the given object
     * @returns {void} - | {@link void} no return value
    */
    this.FileLog = function (name, object) { if (isTest) { saveTextAsFile(name, "var " + name + " = " + JSON.stringify(object)); } }
    /**
     * @public
     * @function
     * @summary - Writes the given string to a file of the given name, works on Firefox and not on all Browsers
     * @param {string} name - the given name
     * @param {string} textToWrite - the given text
     * @returns {void} - | {@link void} no return value
    */
    this.SaveAsTextFile = function (name, textToWrite) { return saveTextAsFile(name, textToWrite); }
    /**
     * @public
     * @function
     * @summary - Logs any arguments passed to the console
     * @returns {void} - | {@link void} no return value
    */
    this.DebugArguments = function () { for (var a in arguments) { logIfTest(a + ': ' + arguments[a]); } }
    function logIfTest(string) { if (isTest) { console.log(string); } }
    function saveTextAsFile(name, textToWrite) {
        var textFileAsBlob = new Blob([textToWrite], { type: 'text/plain' });
        var downloadLink = document.createElement("a");
        downloadLink.download = name;
        downloadLink.innerHTML = "Download File";
        if (window.webkitURL != null) { downloadLink.href = window.webkitURL.createObjectURL(textFileAsBlob); }
        else {
            downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
            downloadLink.onclick = function (event) { (function () { document.body.removeChild(event.target); })(); };
            downloadLink.style.display = "none";
            document.body.appendChild(downloadLink);
        }
        downloadLink.click();
    }
    function initialize() {
        isTest = tf.platform.GetIsTest();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/*tf.debug.RotationTester = function (settings) {
    var theThis, map, actualAngle, anglePopup, anglesStr, isDeleted, debug;
    this.OnDelete = function () { return onDelete(); }
    function onDelete() { if (!isDeleted) { isDeleted = true; if (anglePopup) { anglePopup.Show(false); anglePopup = null; } } }
    function showActualAngle() { debug.LogIfTest('t: ' + actualAngle); }
    function onChangeAngle(newAngleStr) {
        actualAngle = anglesStr[newAngleStr];
        if (actualAngle !== undefined) {
            //map.SetRotationRad(actualAngle);
            var stepMillis = 1000;
            showActualAngle();
            map.StartAnimation(function (request) {
                var nextStep;
                if (request.step == 0) {
                    nextStep = { duration: stepMillis, easing: tf.units.EaseLinear, rotation: actualAngle, notifyListeners: false };
                }
                else if (nextStep != -1) { setTimeout(showActualAngle, 100); }
                return nextStep;
            }, theThis);
        }
    }
    function onCloseAngles() { if (!isDeleted) { setTimeout(function () { anglePopup.Show(true); }, 100); } }
    function createAnglePopup() {
        var angleNames = [];
        anglesStr = {};
        for (var i = 0 ; i < 360 ; i += 30) {
            var angleRad = tf.units.DegreesToRadians(i), angleStr = '' + i;
            anglesStr[angleStr] = angleRad; angleNames.push(angleStr);
        }
        anglePopup = new tf.ui.RadioOrCheckPopupFromData({
            isRadioList: true, optionalScope: theThis, title: "Angles", data: angleNames, isInline: true, onClick: onChangeAngle,
            onClose: onCloseAngles, container: map.GetMapContainer(), horPos: "center", verPos: "bottom", marginVer: "0.5em", zIndex: 1000
        });
        anglePopup.Show(true);
    }
    function initialize() {
        debug = tf.GetDebug();
        settings = tf.js.GetValidObjectFrom(settings);
        if (map = tf.js.GetMapFrom(settings.map)) { createAnglePopup(); }
        else { isDeleted = true; }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};*/
/**
 * Settings used in the creation of [Route Tracker]{@link tf.map.RouteTracker} instances
 * @private
 * @typedef {object} tf.types.RouteTrackerSettings
 * @property {tf.map.Map} map - the given map instance
 * @property {array<tf.types.mapCoordinates>} lineStringCoords - the given route coordinates, in [GeoJSON linestring format]{@link tf.types.GeoJSONGeometryType}
*/
/**
 * @private
 * @class
 * @summary - Route Tracker instances are created to display and follow a given route on a given [map]{@link tf.map.Map} instance
 * @param {tf.types.RouteTrackerSettings} settings - creation settings
*/
/*
tf.map.RouteTracker = function (settings) {
    var theThis, map, coords, routeFeature, postComposeListener, curIndex, directions, routePointFeature, autoPlay;
    this.GoToIndex = function (index, timeInMillis) { return goToIndex(index, timeInMillis); }
    this.GetCurrentIndex = function () { return curIndex; }
    this.SetAutoPlay = function (bool) { autoPlay = !!bool; }
    this.GetAutoPlay = function () { return autoPlay; }
    this.OnDelete = function () { return onDelete(); }
    function onDelete() {
        if (!!map) {
            if (!!postComposeListener) { postComposeListener.OnDelete(); postComposeListener = null; }
            routeFeature = null;
            routePointFeature = null;
            map.Render();
            map = null;
        }
    }
    function onPostCompose(notification) {
        if (!!map) {
            var show = notification.showFeatureImmediately;
            if (!!routeFeature) { show(routeFeature); }
            if (!!routePointFeature) { show(routePointFeature); }
        }
    }
    function goToIndex(index, timeInMillis) {
        if (!!map) {
            //var stepMillis = 100;
            //var stepMillis = 1000;
            //var stepMillis = 3000;
            var stepMillis = tf.js.GetFloatNumberInRange(timeInMillis, 100, 1000000, 1000);
            index = tf.js.GetIntNumberInRange(index, 0, coords.length - 1, 0);
            curIndex = index;
            map.StartAnimation(function (request) {
                var nextStep;
                if (request.step == 0) {
                    var nextRotation = !!directions ? directions[index] : undefined;
                    if (nextRotation !== undefined) { nextRotation -= Math.PI / 2; }
                    nextStep = { duration: stepMillis, center: coords[index], rotation: nextRotation, easing: tf.units.EaseLinear, notifyListeners: false };
                }
                return nextStep;
            }, theThis);
            if (autoPlay) { setTimeout(function () { if (++index == coords.length) { index = 0; } goToIndex(index, timeInMillis); }, stepMillis + 50); }
        }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (!!(map = tf.js.GetMapFrom(settings.map)) && tf.js.GetLooksLikeLineStringCoords(coords = settings.lineStringCoords)) {
            var routeStyle = settings.routeStyle, pointStyle = settings.pointStyle;
            map.ShowPanel(tf.consts.panelNameMapLocation, false);
            var routeStyle = [{ line: true, line_width: 8, line_color: "#f00", zindex: 1, snaptopixel: false }, {
                line: true, line_width: 2, line_color: "#fff", zindex: 2, line_dash: [16, 4], snaptopixel: false
            }];
            //pointStyle = [{ circle: true, circle_radius: 6, line: true, line_color: "#000", fill: true, fill_color: "#f00", fill_opacity: 30, zindex: 3, snaptopixel: false }];
            if (tf.js.GetIsValidObject(routeStyle)) {
                routeFeature = new tf.map.Feature({ type: "linestring", coordinates: coords, style: routeStyle });
            }
            if (tf.js.GetIsValidObject(pointStyle)) {
                routePointFeature = new tf.map.Feature({ type: "multipoint", coordinates: coords, style: pointStyle });
            }
            directions = tf.js.GetIsArrayWithMinLength(settings.directions, settings.lineStringCoords.length) ? settings.directions : null;
            postComposeListener = map.AddListener(tf.consts.mapPostComposeEvent, onPostCompose);
            curIndex = settings.startIndex !== undefined ? tf.js.GetIntNumberInRange(settings.startIndex, 0, coords.length, 0) : 0;
            if (autoPlay = tf.js.GetBoolFromValue(settings.autoPlay, false)) { goToIndex(curIndex, settings.stepTimeInMillis); }
            else { map.Render(); }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
*/

// SOURCE FILE: keyedlist.js
/**
 * A {@link string} that uniquely identifies a JavaScript {@link object} within a collection of JavaScript [objects]{@link object}
 * @public
 * @typedef {string} tf.types.Key
 */
/**
 * A callback function that can be passed in the creation of [Keyed List]{@link tf.js.KeyedList} instances to selectively prevent data items from being added to that list.<br>
 * This callback can also be used selectively alter the contents of data retrieved from remote services before it is incorporated into a [Keyed Item]{@link tf.js.KeyedItem}
 * @public
 * @callback tf.types.FilterAddItem
 * @param {object} itemData - the candidate data object, which this callback is allowed to alter
 * @returns {boolean} - | {@link boolean} <b>true</b> if the item data can be added to the list, <b>false</b> otherwise
 */
/**
 * An object passed to {@link tf.types.NeedsUpdateItemData} callbacks containing the current data object associated with a [Keyed Item]{@link tf.js.KeyedItem} and a new data item to replace it
 * @public
 * @typedef {object} tf.types.NeedsUpdateItemDataObject
 * @property {object} itemData - the data object currently associated with the keyed item instance
 * @property {object} itemDataSet - the candidate new data object
 */
/**
 * A callback function that can be passed in the creation of [Keyed Item]{@link tf.js.KeyedItem} instances to determine if the instance's data needs 
 * to be updated from a new data object. Use this callback to compare freshly retrieved data from a remote service with the data currently stored
 * in the instance, and prevent unnecessary update notifications if the data has not changed
 * @public
 * @callback tf.types.NeedsUpdateItemData
 * @param {tf.types.NeedsUpdateItemDataObject} updateObj - contains the data object currently associated with the keyed item instance and the candidate new data object
 * @returns {boolean} - | {@link boolean} <b>true</b> if an update is needed, <b>false</b> otherwise
 */
/**
 * A callback function that must be provided in the creation of [Keyed List]{@link tf.js.KeyedList} instances to extract [Keys]{@link tf.types.Key} from the type of [data objects]{@link object} 
 * that are associated with the [Keyed Items]{@link tf.js.KeyedItem} in the list
 * @public
 * @callback tf.types.GetKeyFromData
 * @param {object} data - an object of the type stored by the [Keyed Items]{@link tf.js.KeyedItem} in the list
 * @returns {tf.types.Key} - | {@link tf.types.Key} the key extracted from <b>data</b>, or {@link void} if a key could not be extracted
 */
/**
 * Settings used in the creation of [Keyed Item]{@link tf.js.KeyedItem} instances
 * @public
 * @typedef {object} tf.types.KeyedItemSettings
 * @property {tf.js.KeyedList} list - the associated [Keyed List]{@link tf.js.KeyedList} instance
 * @property {tf.types.Key} key - the key
 * @property {object} itemData - the data
 * @property {tf.types.NeedsUpdateItemData} needsUpdateItemData - a callback that determines if the item's data needs to be updated from a new data object
*/
/**
 * @public
 * @class
 * @summary Each Keyed Item instance implements a standard key/value pair data structure, and belongs to a single [Keyed List]{@link tf.js.KeyedList} instance.
 * Keyed Items are created by calling the [AddOrGetItem]{@link tf.js.KeyedList#AddOrGetItem} function of a Keyed List
 * @param {tf.types.KeyedItemSettings} settings - keyed item creation settings
 */
tf.js.KeyedItem = function (settings) {
    var theThis, list, lastTimeUpdated, itemData, key, needsUpdateDataMethod;
    this.GetListName = function () { return !!list ? list.GetName() : ""; }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Keyed list]{@link tf.js.KeyedList} instance associated with this keyed item instance
     * @returns {tf.js.KeyedList} - | {@link tf.js.KeyedList} the list instance
    */
    this.GetList = function () { return list; }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Key]{@link tf.types.Key} associated with this keyed item instance
     * @returns {tf.types.Key} - | {@link tf.types.Key} the key
    */
    this.GetKey = function () { return key; }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Data object]{@link object} associated with this keyed item instance
     * @returns {tf.types.Key} - | {@link tf.types.Key} the key
    */
    this.GetData = function () { return itemData; }
    /**
     * @public
     * @function
     * @summary - Retrieves the last time the data associated with this keyed item instance was updated
     * @returns {Date} - | {@link Date} the date
    */
    this.GetLastTimeUpdated = function () { return lastTimeUpdated; }
    /**
     * @public
     * @function
     * @summary - Notifies registered listeners of the [Items Updated Event]{@link tf.consts.keyedListUpdatedItemsEvent} of the associated 
     * [KeyedList]{@link tf.js.KeyedList} that this Keyed Item instance has been updated. 
     * Use this function instead of [Update]{@link tf.js.KeyedItem#Update] when the data associated with a Keyed Item instance is retrieved with 
     * the [GetData]{@link tf.js.KeyedItem#GetData] function and then directly modified in place
     * @returns {void} - | {@link void} no return value
    */
    this.NotifyUpdated = function () { notifyUpdated(); }
    /**
     * @public
     * @function
     * @summary - Replaces the data object associated with this Keyed Item instance with the given new data object, provided
     * that <b>itemDataSet</b> is a valid object and that the [Key]{@link tf.types.Key} extracted from it matches this instance's Key.
     * Registered listeners of the [Items Updated Event]{@link tf.consts.keyedListUpdatedItemsEvent} of the associated 
     * [KeyedList]{@link tf.js.KeyedList} are notified if the update occurs
     * @param {object} itemDataSet - the new data
     * @returns {boolean} - | {@link boolean} <b>true</b> if an update was performed, <b>false</b> otherwise
    */
    this.Update = function (itemDataSet) { return update(itemDataSet, false); }
    /**
     * @private
     * @function
     * @summary - Marks this instance for deletion
     * @returns {void} - | {@link void} no return value
    */
    this.OnDelete = function () { return onDelete(); }
    /**
     * @private
     * @function
     * @summary - Updates the data object associated with this keyed item from the given data object. This function bypasses the associated [KeyedList]{@link tf.js.KeyedList} notification
     * and is meant to be used internally by the API
     * @param {object} itemDataSet - the new data
     * @returns {boolean} - | {@link boolean} <b>true</b> if an update was performed, <b>false</b> otherwise
    */
    this.privateUpdate = function (itemDataSet) { return update(itemDataSet, true); }
    function doUpdate(itemDataSet) {
        var wasUpdated = false;
        lastTimeUpdated = new Date();
        if (tf.js.GetIsValidObject(itemDataSet)) {
            if (wasUpdated = ((!itemData) || (!needsUpdateDataMethod) || (needsUpdateDataMethod({ sender: theThis, itemData: itemData, itemDataSet: itemDataSet })))) {
                itemData = itemDataSet;
            }
        }
        return wasUpdated;
    }
    function notifyUpdated() {
        if (!!list && !!key) {
            list.NotifyItemUpdated(theThis);
        }
    }
    function update(itemDataSet, isUpdateFromList) {
        var updated ;
        if (!!list && !!key && list.GetKeyFromData(itemDataSet) == key) {
            if (isUpdateFromList) { updated = doUpdate(itemDataSet); }
            else { itemData = null; updated = doUpdate(itemDataSet); list.NotifyItemUpdated(theThis); }
        }
        return updated;
    }
    function onDelete() { }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        list = tf.js.GetIsInstanceOf(settings.list, tf.js.KeyedList) ? settings.list : null;
        key = settings.key;
        needsUpdateDataMethod = tf.js.GetFunctionOrNull(settings.needsUpdateItemData);
        doUpdate(settings.itemData);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Notifications sent by {@link tf.js.KeyedList} instances. Properties are available in notifications that require them
 * @public
 * @typedef {object} tf.types.KeyedListEventNotification
 * @property {tf.map.KeyedList} sender - the instance sending the notification
 * @property {tf.types.keyedListEventName} eventName - the name of the event
 * @property {enumerable<tf.js.KeyedItem>} items - the associated keyed items
 * @property {enumerable<tf.types.Key>} keyes - the associated keys
*/
/**
 * A callback function that can be passed to the function {@link tf.js.KeyedList#AddListener} to start receiving keyed list event notifications
 * @public
 * @callback tf.types.KeyedListEventCallBack
 * @param {tf.types.KeyedListEventNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * Settings used in the creation of [Keyed IteList]{@link tf.js.KeyedList} instances
 * @public
 * @typedef {object} tf.types.KeyedListSettings
 * @property {string} name - the name associated with the Keyed List instance
 * @property {tf.types.GetKeyFromData | enumerable<tf.types.GetKeyFromData>} getKeyFromItemData - a mandatory callback capable of extracting a [Key]{@link tf.types.Key} from 
 * the type of data stored by the [Keyed Items]{@link tf.js.KeyedItem} in this Keyed List.
 * <br>To create nested Keyed Lists of depth <b>N</b> use an {@link enumerable}
 * containing <b>N</b> instances of {@link tf.types.GetKeyFromData}; each {@link tf.types.GetKeyFromData} is used in the creation of a nested Keyed List, beginning with the topmost list
 * @property {tf.types.FilterAddItem} filterAddItem - an optional callback to selectivelly prevent data items from being added to this Keyed List instance
 * @property {tf.types.NeedsUpdateItemData} needsUpdateItemData - an optional callback that determines if an item's data needs to be updated from a new data object
 * @property {boolean} keepNotUpdated - if set to <b>true</b> prevents the Keyed List from removing items that were not updated from a new data set, defaults to {@link void}
 * @property {tf.types.Key} key - <b>applications do not define this property directly.</b> It is only meaningful for Keyed List instances that are items in another Keyed List, and it is 
 * automatically defined by the parent Keyed List during the creation of nested Keyed Lists
*/
/**
 * @public
 * @class
 * @summary - Each Keyed List instance implements a standard collection of key/value pairs with unique keys.<br>
 * - Keyed Lists dispatch notifications to registered [Event Listeners]{@link tf.events.EventListener} when standard list operations (Add, Update, and Delete) are performed on it.<br>
 * - Keyed Lists may be used to store key/value pairs retrieved from a remote service.<br>
 * - One or more [Keyed Feature Lists]{@link tf.map.KeyedFeatureList} can be associated with a Keyed List to automate the creation, update, and deletion of [Keyed Features]{@link tf.map.KeyedFeature} 
 * specified by the the list's [Keyed Items]{@link tf.js.KeyedItem}<br>
 * - Keyed Lists are created to either store instances of [Keyed Items]{@link tf.js.KeyedItem} or to store sub-instances of Keyed Lists, which are all updated from the same data set, 
 * and can be nested to arbitraty depths.<br>
 * - Nested Keyed Lists may be used to automatically maintain and query binary relationships (of cardinalities 1:n, n:1, or n:m) between [Keyed Items]{@link tf.js.KeyedItem} stored in other Keyed Lists.<br>
 * - The creation of nested Keyed List instances is automatically performed during the creation of the topmost Keyed List instance, based on the number and order of 
 * [Key extraction callbacks]{@link tf.types.GetKeyFromData} that are specified for it.
 * @param {tf.types.KeyedListSettings} settings - keyed list creation settings
*/
tf.js.KeyedList = function (settings) {
    var theThis, lastTimeUpdated, makePrivateKey, list, keyList, itemCount, itemCountAfterUpdate, name, keepNotUpdated, needsUpdateItemData;
    var allEventDispatchers, filterAddItemCallBack, getKeyFromDataFunction, settingsGetKeyFromData, isListOfLists, key, cachedItemDatas;
    var aggregateDispatcher;
    /**
     * @public
     * @function
     * @summary - Retrieves the name of this keyed list
     * @returns {string} - | {@link string} the name
    */
    this.GetName = function () { return name; }
    /**
     * @public
     * @function
     * @summary - Checks if the items in this Keyed List instance are also Keyed Lists
     * @returns {boolean} - | {@link boolean} <b>true</b> if items are also Keyed Lists, <b>false</b> otherwise
    */
    this.GetIsListOfLists = function () { return isListOfLists; }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Key]{@link tf.types.Key} associated with this Keyed List instance. This Key is only meaningful if this Keyed List instance is an item of another Keyed List instance
     * @returns {tf.types.Key} - | {@link tf.types.Key} the key
    */
    this.GetKey = function () { return key; }
    /**
     * @public
     * @function
     * @summary - Assuming that a [Key]{@link tf.types.Key} is extracted from the given [itemData]{@link object}, this function performs one of the following actions:<br>
     * -- if this Keyed List instance contains a [Keyed Item]{@link tf.js.KeyedItem} with a matching Key, this function returns that item, and itemData is otherwise ignored<br>
     * -- if this Keyed List instance does not contain a [Keyed Item]{@link tf.js.KeyedItem} with a matching Key, this function creates a new one using 
     * Key and itemData, adds it to the list, and returns the newly created item
     * @param {object} itemData - a custom, application defined, JavaScript object from which a [Key]{@link tf.types.Key} can extracted using the {@link tf.types.GetKeyFromData} callback
     * provided on the creation settings of this Keyed List instance
     * @returns {tf.js.KeyedItem} - | {@link tf.js.KeyedItem} a Keyed Item instance - either pre-existing or newly created with <b>itemData</b>, or {@link void} if a Key cannot be extracted from <b>itemData</b>
    */
    this.AddOrGetItem = function (itemData) { return addOrGetItem(itemData, true).item; }
    /**
     * @public
     * @function
     * @summary - Removes the given [Keyed Item]{@link tf.js.KeyedItem} from this Keyed List instance
     * @param {tf.js.KeyedItem} keyedItem - the Keyed Item to be removed
     * @returns {boolean} - | {@link boolean} <b>true</b> if the item was removed, <b>false</b> if the the list does not contain the item
    */
    this.RemoveItem = function (keyedItem, skipNofify, skipAggregateNotify) { return removeItem(keyedItem, !skipNofify, skipAggregateNotify); }
    /**
     * @public
     * @function
     * @summary - Removes the [Keyed Item]{@link tf.js.KeyedItem} matching the given [Key]{@link {tf.types.Key} from this Keyed List instance
     * @param {tf.types.Key} itemKey - the given Key
     * @returns {boolean} - | {@link boolean} <b>true</b> if the item was removed, <b>false</b> if the the list does not contain an item matching <b>itemKey</b>
    */
    this.RemoveItemByKey = function (itemKey, skipNofify, skipAggregateNotify) { return removeItemByKey(itemKey, !skipNofify, skipAggregateNotify); }
    /**
     * @public
     * @function
     * @summary - Removes all [Keyed Items]{@link tf.js.KeyedItem} from this Keyed List instance
     * @returns {void} - | {@link void} no return value
    */
    this.RemoveAllItems = function (skipNotify, skipAggregateNotify) { return removeAll(!skipNotify, skipAggregateNotify); }
    /**
     * @public
     * @function
     * @summary - Checks if this Keyed List instance contains a [Keyed Item]{@link tf.js.KeyedItem} matching the given [Key]{@link {tf.types.Key}
     * @param {tf.types.Key} itemKey - the given Key
     * @returns {boolean} - | {@link boolean} <b>true</b> if the list contains a matching item for <b>itemKey</b>, <b>false</b> otherwise
    */
    this.HasKey = function (itemKey) { return hasKey(itemKey); }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Keyed Item]{@link tf.js.KeyedItem} matching the given [Key]{@link {tf.types.Key}, if any
     * @param {tf.types.Key} itemKey - the given Key
     * @returns {tf.js.KeyedItem} - | {@link tf.js.KeyedItem} the Keyed Item instance matching <b>itemKey</b>, or {@link void} if no matching item is found
    */
    this.GetItem = function (itemKey) { return getItem(itemKey); }
    /**
     * @public
     * @function
     * @summary - Retrieves the number of [Keyed Items]{@link tf.js.KeyedItem} currently in this Keyed List instance
     * @returns {number} - | {@link number} the number of items
    */
    this.GetItemCount = function () { return itemCount; }
    this.GetItemCountAfterUpdate = function () { return itemCountAfterUpdate; }
    /**
     * @public
     * @function
     * @summary - Retrieves an enumerable containing all the Keyed Items in this Keyed List instance. Applications should not alter the contents of these items, only retrieve information from them
     * @returns {enumerable<tf.js.KeyedItem>} - | {@link enumerable}<{@link tf.js.KeyedItem}> all the items
    */
    this.GetKeyedItemList = function () { return tf.js.ShallowMerge(list); }
    /**
     * @public
     * @function
     * @summary - Retrieves an enumerable containing all the Keys in this Keyed List instance. Applications should not alter the contents of these keys, only retrieve information from them
     * @returns {enumerable<tf.types.Key>} - | {@link enumerable}<{@link tf.types.Key}> all the keyes
    */
    this.GetKeyList = function () { return tf.js.ShallowMerge(keyList); }
    /**
     * @public
     * @function
     * @summary - Extracts a [Key]{@link tf.types.Key} from the given [itemData]{@link object}
     * @param {object} itemData - a custom, application defined, JavaScript object from which a [Key]{@link tf.types.Key} can extracted using the {@link tf.types.GetKeyFromData} callback
     * provided on the creation settings of this Keyed List instance
     * @returns {tf.types.Key} - | {@link tf.types.Key} the extracted Key, or {@link void} if a Key cannot be extracted from <b>itemData</b>
    */
    this.GetKeyFromData = function (data) { return getKeyFromDataFunction(data); }
    /**
     * @public
     * @function
     * @summary - Retrieves the last time this Keyed List instance was [updated from a new list]{@link tf.js.KeyedList#UpdateFromNewData}
     * @returns {Date} - | {@link Date} the date
    */
    this.GetLastTimeUpdated = function () { return lastTimeUpdated; }
    /**
     * @public
     * @function
     * @summary - Updates this Keyed List instance with the contents of the given <b>newData</b>. Removes from the list any [Keyed Items]{@link tf.js.KeyedItem} whose
     * keys are not present in <b>newData</b>, unless the property [keepNotUpdated]{@link tf.types.KeyedListSettings} was set to <b>true</b> during the creation of this Keyed List instance.
     * Notifies listeners of any events that occur during the update.
     * @param {enumerable<object>} newData - an enumerable containing custom, application defined, JavaScript objects from which [Keys]{@link tf.types.Key} can extracted using the {@link tf.types.GetKeyFromData} callback
     * provided on the creation settings of this Keyed List instance
     * @returns {void} - | {@link void} no return value
    */
    this.UpdateFromNewData = function (newData) { return updateFromNewData(newData); }
    this.AddAggregateListener = function (callBack) { return aggregateDispatcher.Add(callBack); }
    /**
     * @public
     * @function
     * @summary - Adds a listener for the given event name
     * @param {tf.types.keyedListEventName} eventName - the name of the event
     * @param {tf.types.KeyedListEventCallBack} callBack - the callback for event notifications
     * @returns {tf.events.EventListener} - | {@link tf.events.EventListener} the event listener
    */
    this.AddListener = function (eventName, callbackFunction) { return allEventDispatchers.AddListener(eventName, callbackFunction); }
    /**
     * @public
     * @function
     * @summary - Adds one or more listeners for the given event names
     * @param {tf.types.EventNamesAndCallBacks} eventNamesAndCallBacks - the event names and callbacks
     * @returns {tf.types.EventNamesAndListeners} - | {@link tf.types.EventNamesAndListeners} the event names and listeners
    */
    this.AddListeners = function (eventNamesAndCallBacks) { return allEventDispatchers.AddListeners(eventNamesAndCallBacks); }
    /**
     * @public
     * @function
     * @summary - Sends the given <b>callBack</b> a [Items Added Event]{@link tf.consts.keyedListAddedItemsEvent} with all keyed items currently in this list
     * @param {tf.types.KeyedListEventCallBack} callBack - the callback
     * @returns {void} - | {@link void} no return value
    */
    this.NotifyItemsAdded = function (callBack) {
        if (tf.js.GetFunctionOrNull(callBack)) {
            if (itemCount > 0) {
                callBack(makeEventNotification(tf.consts.keyedListAddedItemsEvent, list, keyList));
            }
        }
    }
    this.NotifyItemsUpdatedByKeys = function (keyList) {
        if (keyList != undefined) {
            var notifyItems = [], notifyKeys = [];
            for (var i in keyList) {
                var thisKey = keyList[i], thisItem = getItem(thisKey);
                if (!!thisItem) { notifyItems.push(thisItem); notifyKeys.push(thisKey); }
            }
            if (notifyItems.length > 0) { notifyListItemUpdate(notifyItems, notifyKeys); }
        }
    }
    /**
     * @public
     * @function
     * @summary - Notifies listeners of the [Items Updated Event]{@link tf.consts.keyedListUpdatedItemsEvent} with all keyed items currently in this list
     * @param {tf.types.KeyedListEventCallBack} callBack - the callback
     * @returns {void} - | {@link void} no return value
    */
    this.NotifyItemsUpdated = function (itemList) {
        if (itemCount > 0) {
            if (itemList != undefined) {
                var notifyItems = [], notifyKeys = [];
                for (var i in itemList) {
                    var thisItem = itemList[i];
                    if (hasItem(thisItem)) { notifyItems.push(thisItem); notifyKeys.push(thisItem.GetKey()); }
                }
                if (notifyItems.length > 0) { notifyListItemUpdate(notifyItems, notifyKeys); }
            }
            else {
                notifyListItemUpdate(list, keyList);
            }
        }
    }
    /**
     * @private
     * @function
     * @summary - This function is used internally by the API to implement Keyed Item / List Update notifications
     * @param {tf.js.KeyedItem} keyedItem - the item
     * @returns {void} - | {@link void} no return value
    */
    this.NotifyItemUpdated = function (keyedItem) { if (hasItem(keyedItem)) { notifyListItemUpdate([keyedItem], [keyedItem.GetKey()]); } }
    /**
     * @private
     * @function
     * @summary - Adds the given given [itemData]{@link object} to the update cache for later update by the function {@link tf.js.KeyedList#UpdateFromItemDataCache}.
     * This function is used internally by the API to implement Keyed List nesting
     * @param {object} itemData - a custom, application defined, JavaScript object from which a [Key]{@link tf.types.Key} can extracted using the {@link tf.types.GetKeyFromData} callback
     * provided on the creation settings of this Keyed List instance
     * @returns {void} - | {@link void} no return value
    */
    this.AddItemDataToUpdateCache = function (itemData) { return addItemDataToUpdateCache(itemData); }
    /**
     * @private
     * @function
     * @summary - Updates this Keyed List instance from the contents added to its update by the function {@link tf.js.KeyedList#AddItemDataToUpdateCache}.
     * This function is used internally by the API to implement Keyed List nesting
     * @returns {void} - | {@link void} no return value
    */
    this.UpdateFromItemDataCache = function (itemData) { return updateFromItemDataCache(); }
    /**
     * @private
     * @function
     * @summary - Marks this instance for deletion
     * @returns {void} - | {@link void} no return value
    */
    this.OnDelete = function () { return onDelete(); }
    function onDelete() { notifyListEvent(tf.consts.keyedListDeleteEvent, list, keyList); removeAll(false, true); allEventDispatchers.OnDelete(); }
    function makeEventNotification(eventName, items, keys) { return { sender: theThis, eventName: eventName, items: items, keys: keys }; }
    function notifyListEvent(eventName, items, keys, aggregateNotifySettings) {
        var notified = allEventDispatchers.Notify(eventName, makeEventNotification(eventName, items, keys));
        aggregateNotify(aggregateNotifySettings);
        return notified;
    }
    function notifyListItemAdd(items, keys, skipAggregateNotify) {
        notifyListEvent(tf.consts.keyedListAddedItemsEvent, items, keys, (skipAggregateNotify ? undefined : { added: true, addedItems: items, addedKeys: keys }));
    }
    function notifyListItemUpdate(items, keys, skipAggregateNotify) {
        notifyListEvent(tf.consts.keyedListUpdatedItemsEvent, items, keys, (skipAggregateNotify ? undefined : { updated: true, updatedItems: items, updatedKeys: keys }));
    }
    function notifyListItemDelete(items, keys, skipAggregateNotify) {
        notifyListEvent(tf.consts.keyedListDeletedItemsEvent, items, keys, (skipAggregateNotify ? undefined : { deleted: true, deletedItems: items, deletedKeys: keys }));
    }
    function removeItemByKey(itemKey, notify, skipAggregateNotify) { var item = getItem(itemKey); return !!item ? removeItem(item, notify, skipAggregateNotify) : false; }
    function hasKey(theKey) { return !!list[tf.js.MakeObjectKey (theKey)]; }
    function hasItem(theItem) { return !!theItem && (isListOfLists ? theItem instanceof tf.js.KeyedList : theItem instanceof tf.js.KeyedItem) && hasKey(theItem.GetKey()); }
    function getItem(theKey) { return hasKey(theKey) ? list[tf.js.MakeObjectKey (theKey)] : null; }
    function removeAll(doNotify, skipAggregateNotify) { for (var i in list) { removeItem(list[i], doNotify, skipAggregateNotify); } }
    function removeItems(items, keys, skipAggregateNotify) {
        if (!!items) {
            notifyListItemDelete(items, keys, skipAggregateNotify);
            for (var i in items) { removeItem(items[i], false, true); }
        }
    }
    function removeItem(theItem, notify, skipAggregateNotify) {
        if (hasItem(theItem)) {
            var itemKey = theItem.GetKey();
            var privateKey = makePrivateKey(itemKey);
            if (!!notify) { notifyListItemDelete([theItem], [itemKey], skipAggregateNotify); }
            theItem.OnDelete();
            delete keyList[privateKey];
            delete list[privateKey];
            --itemCount;
            return true;
        }
        return false;
    }
    function getNotUpdated() {
        var items = [], keys = [];
        for (var i in list) { var theItem = list[i]; if (theItem.GetLastTimeUpdated() < lastTimeUpdated) { items.push(theItem); keys.push(theItem.GetKey()); } }
        return { foundSome: !!items.length, items: items, keys: keys };
    }
    function addOrGetItem(itemData, notify) {
        var item = null;
        var itemKey = getKeyFromDataFunction(itemData);
        var isExisting = false;
        if (!!itemKey) {
            if (!(isExisting = !!(item = getItem(itemKey)))) {
                if (!filterAddItemCallBack || filterAddItemCallBack(itemData)) {
                    if (isListOfLists) {
                        item = new tf.js.KeyedList({
                            key: itemKey,
                            getKeyFromItemData: settingsGetKeyFromData,
                            needsUpdateItemData: needsUpdateItemData
                        });
                    }
                    else {
                        item = new tf.js.KeyedItem({
                            list: theThis,
                            key: itemKey,
                            itemData: itemData,
                            needsUpdateItemData: needsUpdateItemData
                        });
                    }
                    var privateKey = makePrivateKey(itemKey);
                    keyList[privateKey] = itemKey;
                    list[privateKey] = item;
                    ++itemCount;
                    if (!!notify) { notifyListItemAdd([item], [itemKey]); }
                }
            }
        }
        return { isExisting: isExisting, item: item, key: itemKey };
    }
    function addItemDataToUpdateCache (itemData) { if (!!itemData) { if (!cachedItemDatas) { cachedItemDatas = [] } cachedItemDatas.push(itemData); } }
    function updateFromItemDataCache() { var updated = false; if (!!cachedItemDatas) { updated = updateFromNewData(cachedItemDatas); cachedItemDatas = null; } return updated; }
    function updateFromNewData(newData) {
        var addedItems = [], addedKeys = [];
        var updatedItems = [], updatedKeys = [], notUpdated;
        var seenKeys = {}, seenUpdatedKeys = {}, listsToUpdate = {};
        lastTimeUpdated = new Date();
        if (!!newData) {
            var newListUse = tf.js.GetIsArray(newData) ? newData : [newData];
            for (var i in newListUse) {
                var itemData = newListUse[i];
                var addedOrGotten = addOrGetItem(itemData, false);
                var isExistingItem = addedOrGotten.isExisting, item = addedOrGotten.item, key = addedOrGotten.key;
                if (isExistingItem) {
                    if (isListOfLists) {
                        item.AddItemDataToUpdateCache(itemData);
                        if (!seenKeys[key]) { if (!listsToUpdate[key]) { listsToUpdate[key] = item; } }
                    }
                    else {
                        if (item.privateUpdate(itemData)) {
                            if (!seenKeys[key]) { if (!seenUpdatedKeys[key]) { seenUpdatedKeys[key] = key; updatedItems.push(item); updatedKeys.push(key); } }
                        }
                    }
                }
                else if (!!item) {
                    if (isListOfLists) { item.AddItemDataToUpdateCache(itemData); }
                    seenKeys[key] = item;
                    addedItems.push(item); addedKeys.push(key);
                }
            }
        }
        var addedSome = addedItems.length > 0;
        if (addedSome) { if (isListOfLists) { for (var i in addedItems) { addedItems[i].UpdateFromItemDataCache(); } } }
        if (isListOfLists) { for (var i in listsToUpdate) { var listItem = listsToUpdate[i]; if (listItem.UpdateFromItemDataCache()) { updatedKeys.push(i); updatedItems.push(listItem); } } }
        var updatedSome = updatedItems.length > 0, deletedSome;
        itemCountAfterUpdate = itemCount;
        if (!keepNotUpdated) {
            notUpdated = getNotUpdated();
            if (deletedSome = notUpdated.foundSome) {
                itemCountAfterUpdate -= notUpdated.items.length;
            }
        }
        else { deletedSome = false; }
        var madeChanges = addedSome || updatedSome || deletedSome;
        if (madeChanges) {
            aggregateNotify({
                added: addedSome,
                addedItems: addedItems,
                addedKeys: addedKeys,
                updated: updatedSome,
                updatedItems: updatedItems,
                updatedKeys: updatedKeys,
                deleted: deletedSome,
                deletedItems: notUpdated.items,
                deletedKeys: notUpdated.keys
            });
        }
        if (addedSome) { notifyListItemAdd(addedItems, addedKeys, true); }
        if (updatedSome) { notifyListItemUpdate(updatedItems, updatedKeys, true); }
        if (deletedSome) { removeItems(notUpdated.items, notUpdated.keys, true); }
        return madeChanges;
    }
    function getNullKey() { return null; }
    function setKeyFromDataCallBack() {
        getKeyFromDataFunction = undefined;
        isListOfLists = false;
        settingsGetKeyFromData = settings.getKeyFromItemData;
        if (!!settingsGetKeyFromData) {
            if (typeof settingsGetKeyFromData === "function") {
                getKeyFromDataFunction = tf.js.GetFunctionOrNull(settingsGetKeyFromData);
            }
            else if (tf.js.GetIsNonEmptyArray(settingsGetKeyFromData)) {
                getKeyFromDataFunction = tf.js.GetFunctionOrNull(settingsGetKeyFromData[0]);
                settingsGetKeyFromData = settingsGetKeyFromData.slice(1);
                if (!(isListOfLists = settingsGetKeyFromData.length > 0)) {
                    settingsGetKeyFromData = null;
                }
            }
        }
        
        if (!getKeyFromDataFunction) { getKeyFromDataFunction = getNullKey; }
    }
    function aggregateNotify(notifySettings) {
        if (tf.js.GetIsValidObject(notifySettings)) {
            var defaultSettings = { added: false, updated: false, deleted: false };
            aggregateDispatcher.Notify(tf.js.ShallowMerge(defaultSettings, notifySettings, { sender: theThis }));
        }
    }
    function initialize() {
        aggregateDispatcher = new tf.events.EventNotifier({ eventName: "agg" });
        allEventDispatchers = new tf.events.MultiEventNotifier({ eventNames: tf.consts.allKeyedListEventNames });
        makePrivateKey = tf.js.MakeObjectKey;
        list = {}; keyList = {}; itemCount = itemCountAfterUpdate = 0;
        settings = tf.js.GetValidObjectFrom(settings);
        name = settings.name;
        needsUpdateItemData = tf.js.GetFunctionOrNull(settings.needsUpdateItemData);
        keepNotUpdated = tf.js.GetBoolFromValue(settings.keepNotUpdated, false);
        filterAddItemCallBack = tf.js.GetFunctionOrNull(settings.filterAddItem);
        key = settings.key;
        setKeyFromDataCallBack();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * A callback function that must be provided in the creation of [Keyed Lists Periodic Refresh]{@link tf.js.KeyedListsPeriodicRefresh} instances to 
 * preprocess the data returned by the remote service into an {@link enumerable} used to update the [Keyed List]{@link tf.js.KeyedList} instances 
 * managed by the Periodic Refresh via their [UpdateFromNewData]{@link tf.js.KeyedList#UpdateFromNewData} functions.
 * @public
 * @callback tf.types.PreProcessServiceData
 * @param {object} data - an object returned from the remote service
 * @returns {enumerable<object>} - | {@link enumerable}<{@link object}> the parameter to be passed to [UpdateFromNewData]{@link tf.js.KeyedList#UpdateFromNewData}
 */
/**
 * Notifications sent by [Keyed Lists Periodic Refresh]{@link tf.js.KeyedListsPeriodicRefresh} instances. Properties are available in notifications that require them
 * @public
 * @typedef {object} tf.types.KeyedListsPeriodicRefreshNotification
 * @property {tf.js.KeyedListsPeriodicRefresh} sender - the instance sending the notification
*/
/**
 * A callback function that receives notifications from a [Keyed Lists Periodic Refresh]{@link tf.js.KeyedListsPeriodicRefresh} instance
 * @public
 * @callback tf.types.KeyedListsPeriodicRefreshCallBack
 * @param {tf.types.KeyedListsPeriodicRefreshNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * Settings used in the creation of [Keyed Lists Periodic Refresh]{@link tf.js.KeyedListsPeriodicRefresh} instances
 * @public
 * @typedef {object} tf.types.KeyedListsPeriodicRefreshSettings
 * @property {enumerable<tf.js.KeyedList | tf.types.KeyedListSettings>} keyedLists - a non-empty enumerable whose elements can be a mix of pre-existing [Keyed Lists]{@link tf.js.KeyedList} 
 * instances or settings used in the creation of new lists
 * @property {tf.types.PreProcessServiceData} preProcessServiceData - a mandatory callback that transforms raw data returned from a service into data digestible by [Keyed List]{@link tf.js.KeyedList} instances
 * @property {string | tf.types.GetUrlFunction} serviceURL - a mandatory url to access, either the url string itself or a function that returns an url string
 * @property {number} refreshMillis - The desired number of milliseconds between periodic refreshes
 * @property {boolean} useRedirect - if set to <b>true</b> requests are sent using a redirect proxy, to avoid cross domain violations
 * @property {boolean} refreshOnCreate - if set to <b>true</b> the first request is sent immediately upon creation of this instance
 * @property {tf.types.KeyedListsPeriodicRefreshCallBack} onCreated - a callback notified upon completion of the first refresh operation 
 * @property {tf.types.KeyedListsPeriodicRefreshCallBack} refreshCallback - a callback notified upon completion of the each refresh operation
 * @property {boolean} retryOnFail - if set to <b>true</b> requests are re-sent immediately upon failure, defaults to {@link void}
*/
/**
 * @public
 * @class
 * @summary Instances of Keyed Lists Periodic Refresh retrieve data from remote services to update one or more [Keyed List]{@link tf.js.KeyedList} instances, using 
 * their respective [UpdateFromNewData]{@link tf.js.KeyedList#UpdateFromNewData} functions. Instances can work with pre-existing Keyed Lists or create new ones
 * @param {tf.types.KeyedListsPeriodicRefreshSettings} settings - Keyed Lists Periodic Refresh creation settings
*/
tf.js.KeyedListsPeriodicRefresh = function (settings) {
    var defaultRefreshTimeOutMillis = 1000 * 60 * 10;
    var theThis, periodicJSONGet, keyedListsByName, keyedLists, refreshMillis, newData;
    var refreshCallback, onCreatedCallback, refreshListeners, refreshCount, isDeleted;
    /**
     * @public
     * @function
     * @summary - Retrieves by name one of the [Keyed Lists]{@link tf.js.KeyedList} associated with this instance
     * @param {string} listName - the name of the list
     * @returns {tf.js.KeyedList} - | {@link tf.js.KeyedList} the list, if a list named <b>listName</b> is found
    */
    this.GetKeyedList = function (listName) { return getKeyedList(listName); }
    /**
     * @public
     * @function
     * @summary - Triggers an immediate refresh
     * @returns {void} - | {@link void} no return value
    */
    this.RefreshNow = function () { return refreshNow(); }
    /**
     * @public
     * @function
     * @summary - Retrieves the number of refresh operations performed by this instance
     * @returns {number} - | {@link number} the number of refreshes
    */
    this.GetRefreshCount = function () { return refreshCount; }
    /**
     * @public
     * @function
     * @summary - Checks if a refresh operation is in progress (a request was sent, but a response has not been received)
     * @returns {boolean} - | {@link boolean } <b>true</b> if a refresh is in progress, <b>false</b> otherwise
    */
    this.GetIsRefreshing = function () { return periodicJSONGet.GetIsRefreshing(); }
    /**
     * @public
     * @function
     * @summary - Adds a listener for list refresh events
     * @param {tf.types.KeyedListsPeriodicRefreshCallBack} callBack - the callback for event notifications
     * @returns {tf.events.EventListener} - | {@link tf.events.EventListener} the event listener
    */
    this.AddOnRefreshListener = function (callBack) { return addListener(refreshListeners, callBack); }
    /**
     * @private
     * @function
     * @summary - Marks this instance for deletion
     * @returns {void} - | {@link void} no return value
    */
    this.OnDelete = function () { return onDelete(); }
    function getKeyedList(listName) { return keyedListsByName[listName]; }
    function onDelete() {
        isDeleted = true;
        if (periodicJSONGet) { periodicJSONGet.OnDelete(); periodicJSONGet = null; }
        refreshListeners = deleteListener(refreshListeners);
        for (var i in keyedLists) { keyedLists[i].OnDelete(); } keyedLists = null; keyedListsByName = {};
    }
    function deleteListener(theListener) { if (!!theListener) { theListener.OnDelete(); } return null; }
    function refreshNow() { if (periodicJSONGet) { periodicJSONGet.RefreshNow(); } }
    function onNotifyRefresh() { return refreshListeners.Notify({ sender: theThis }); }
    function updateFromNewData(data) {
        ++refreshCount;
        if (!refreshMillis) { periodicJSONGet.Cancel(); }
        var notify = true;
        if (!data) {
            if (settings.retryOnFail) {
                notify = false;
                tf.GetDebug().LogIfTest("KeyedListsPeriodicRefresh: retrying JSON download");
                setTimeout(refreshNow, 1000);
                //refreshNow();
            }
        }
        if (notify) {
            var newData = settings.preProcessServiceData(data);
            for (var i in keyedLists) { keyedLists[i].UpdateFromNewData(newData); }
        }
    }
    function notifyRefresh() { if (!!refreshCallback) { refreshCallback({ sender: theThis }); } onNotifyRefresh(); }
    function onListLoaded(notification) { if (!isDeleted) { updateFromNewData(notification.data); notifyRefresh(); } }
    function onListLoadedFirstTime(notification) {
        if (!isDeleted) {
            periodicJSONGet.ChangeCallBack(onListLoaded);
            updateFromNewData(notification.data);
            if (!!onCreatedCallback) { var occb = onCreatedCallback; onCreatedCallback = null; occb({ sender: theThis }); }
            notifyRefresh();
        }
    }
    function createPeriodicRefresh() {
        var autoRefresh = ((refreshMillis = tf.js.GetNonNegativeIntFrom(settings.refreshMillis)) > 0);
        periodicJSONGet = new tf.ajax.PeriodicJSONGet({
            url: settings.serviceURL,
            refreshMillis: refreshMillis ? refreshMillis : defaultRefreshTimeOutMillis,
            autoRefresh: autoRefresh,
            onRefresh: onListLoadedFirstTime,
            optionalScope: theThis,
            useRedirect: settings.useRedirect,
            JSONDecode: settings.JSONDecode,
            postParams: settings.postParams,
            requestHeaders: settings.requestHeaders
        });
        if (tf.js.GetBoolFromValue(settings.refreshOnCreate, true)) { periodicJSONGet.RefreshNow(); }
    }
    function initialize() {
        keyedLists = [];
        keyedListsByName = {};
        if (!!settings && typeof settings === "object" && !!settings.keyedLists && tf.js.GetIsArray(settings.keyedLists)) {
            isDeleted = false;
            refreshListeners = new tf.events.EventNotifier();
            refreshCallback = tf.js.GetFunctionOrNull(settings.refreshCallback);
            onCreatedCallback = tf.js.GetFunctionOrNull(settings.onCreated);
            for (var i in settings.keyedLists) {
                var keyedList = settings.keyedLists[i];
                if (!!keyedList) {
                    if (!(keyedList instanceof tf.js.KeyedList)) { keyedList = tf.js.GetIsValidObject(keyedList) ? new tf.js.KeyedList(keyedList) : null; }
                    if (!!keyedList) { keyedLists.push(keyedList); keyedListsByName[keyedList.GetName()] = keyedList; }
                }
            }
            if (keyedLists.length) { createPeriodicRefresh(); }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: listeners.js
// tf.events
/**
 * @public
 * @function
 * @summary - Stops propagation of the given {@link DOMEvent}
 * @param {DOMEvent} event - the event
 * @returns {void} - | {@link void} no return value
*/
tf.events.StopDOMEvent = function (event) {
    //tf.GetDebug().LogIfTest('.');
    if (!event) { if (window.event) { event = window.event; } }
    if (!!event && typeof event === "object") {
        //if (event.stopPropagation) { event.stopPropagation(); }
        if (event.cancelBubble !== undefined) { event.cancelBubble = true; }
        if (event.returnValue != null) { event.returnValue = false; }
        if (event.preventDefault) { event.preventDefault(); }
        if (event.cancel != null) { event.cancel = true; }
    }
    return false;
};
/**
 * @public
 * @class
 * @summary Delayed Call Back instances receive an arbitrary number notifications during a maximum given period of time, before delivering only the last one of these notifications to the given callback.
 * Use Delayed Call Back to avoid reacting immediately to each instance of an event that may fire in rapid succession during a short period of time
 * @param {number} callBackDelay - the number of milliseconds during which notifications are delayed
 * @param {function} callBack - the callback
 * @param {object} optionalScope - optional scope used with <b>callBack</b>
 */
tf.events.DelayedCallBack = function (callBackDelay, callBack, optionalScope) {
    var theThis, theDelay, theCallBack, theThisForCallBack, lastNotificationTime, waitingForTimeOut, theNotification;
    /**
     * @public
     * @function
     * @summary - Use this function with an event listener to delay event notifications
     * @returns {void} - | {@link void} no return value
    */
    this.DelayCallBack = function () {
        lastNotificationTime = +new Date(); theNotification = arguments;
        if (waitingForTimeOut == undefined) { waitingForTimeOut = setTimeout(delayCallBack, theDelay); }
    }
    /**
     * @public
     * @function
     * @summary - Use this function to cancel a pending delayed callback
     * @returns {void} - | {@link void} no return value
    */
    this.CancelCallBack = function () {
        if (waitingForTimeOut != undefined) { clearTimeout(waitingForTimeOut); waitingForTimeOut = undefined; }
    }
    /**
     * @public
     * @function
     * @summary - Use this function to execute a pending callback immediatelly
     * @returns {void} - | {@link void} no return value
    */
    this.CallBackNow = function () { theThis.CancelCallBack(); doCallBack(); }
    /**
     * @public
     * @function
     * @summary - Determines if a there is a pending callback request
     * @returns {bool} - | {@link bool} <b>true</b> if a callback request is pending, <b>false</b> otherwise
    */
    this.GetHasPendingCallBack = function () { return waitingForTimeOut != undefined; }
    this.ChangeDelay = function (newCallBackDelay) { theDelay = newCallBackDelay; }
    function doCallBack() { theCallBack.apply(theThisForCallBack, theNotification); }
    function delayCallBack() { if (+new Date() - lastNotificationTime < theDelay) { waitingForTimeOut = setTimeout(delayCallBack, theDelay); } else { waitingForTimeOut = undefined; doCallBack(); } }
    function initialize() {
        theDelay = callBackDelay;
        theCallBack = callBack;
        theThisForCallBack = optionalScope;
        lastNotificationTime = +new Date(1, 1, 2000, 12, 0, 0);
        waitingForTimeOut = undefined;
        theNotification = null;
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Settings used in the creation of [Dom Event Listener]{@link tf.events.DOMEventListener} instances
 * @public
 * @typedef {object} tf.types.DOMEventListenerSettings
 * @property {HTMLElementLike} target - the element whose events will be notified
 * @property {tf.types.DOMEventName} eventName - the name of the event to listen for
 * @property {tf.types.DOMEventListenerCallBack} callBack - to receive event notifications
*/
/**
 * @public
 * @class
 * @summary DOM Event Listener instances are created by calling the API function [AddDomEventListener]{@link tf.events.AddDOMEventListener}
 * @param {DOMEventListenerSettings} settings - creation settings
 */
tf.events.DOMEventListener = function (settings) {
    var theThis, target, eventName, callBack;
    /**
     * @public
     * @function
     * @summary - Use this function to delete the event listener and stop receiving notifications
     * @returns {void} - | {@link void} no return value
    */
    this.OnDelete = function () { if (!!callBack) { tf.events.DelDOMEventListener(target, eventName, callBack); callBack = null; } }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (!!(callBack = tf.js.GetFunctionOrNull(settings.callBack)) &&
            !!tf.dom.GetDOMEventListenerFrom(settings.target) &&
            !!tf.js.GetIsNonEmptyString(settings.eventName)) {
            eventName = settings.eventName;
            target = settings.target;
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Notifications sent by [Multi Dom Event Listener]{@link tf.events.MultiDOMEventListener} instances
 * @public
 * @typedef {object} tf.types.MultiDOMEventListenerNotification
 * @property {tf.events.MultiDOMEventListener} sender - the instance sending the notification
 * @property {DOMEvent} event - the event being notified
 * @property {tf.types.DOMEventName} eventName - the name of the event being notified
 * @property {HTMLElementLike} target - the element whose event is being notified
 * @property {object} callBackSettings - application defined properties, provided in the creation of the {@link tf.events.MultiDOMEventListener} instance
*/
/**
 * A callback function that can be used in the creation of [AddDOMEventListener]{@link tf.events.MultiDOMEventListener} instances
 * @public
 * @callback tf.types.MultiDOMEventListenerCallBack
 * @param {tf.types.MultiDOMEventListenerNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * Settings used in the creation of [Multi Dom Event Listener]{@link tf.events.MultiDOMEventListener} instances
 * @public
 * @typedef {object} tf.types.MultiDOMEventListenerSettings
 * @property {HTMLElementLike} target - the element whose events will be notified
 * @property {enumerable<tf.types.DOMEventName>} eventNames - the names of the events to listen for
 * @property {tf.types.MultiDOMEventListenerCallBack} callBack - to receive event notifications
 * @property {object} optionalScope - optional scope used with <b>callBack</b>
 * @property {object} callBackSettings - application defined properties, provided in the creation of the {@link tf.events.MultiDOMEventListener} instance
 * @property {function} onPreNotify - optional callback that receives, and may alter, each notification object before it is sent to listeners
 * @property {object} preNotifyScope - optional scope used with <b>onPreNotify</b>
*/
/**
 * @public
 * @class
 * @summary Multi DOM Event Listener instances notify one or more [DOMEvents]{@link DOMEvent} to a single callback
 * @param {MultiDOMEventListenerSettings} settings - creation settings
 */
tf.events.MultiDOMEventListener = function (settings) {
    var theThis, domObj, target, DOMListeners, callBack, optionalScope, callBackSettings, preNotify, preNotifyScope, lastEvent, lastEventName;
    this.GetDomObj = function () { return domObj; }
    /**
     * @public
     * @function
     * @summary - Retrieves the element whose events are being monitored
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the element
    */
    this.GetTarget = function () { return target; }
    /**
     * @public
     * @function
     * @summary - Retrieves the last event received and notified
     * @returns {DOMEvent} - | {@link DOMEvent} the element
    */
    this.GetLastEvent = function () { return lastEvent; }
    /**
     * @public
     * @function
     * @summary - Retrieves the name last event received and notified
     * @returns {tf.types.DOMEventName} - | {@link tf.types.DOMEventName} the name of the last event
    */
    this.GetLastEventName = function () { return lastEventName; }
    /**
     * @public
     * @function
     * @summary - Use this function to delete the event listeners associated with this instance and stop receiving notifications
     * @returns {void} - | {@link void} no return value
    */
    this.OnDelete = function () { if (!!DOMListeners) { for (var i in DOMListeners) { DOMListeners[i].OnDelete(); } DOMListeners = null; } }
    this.ChangeCallBackSettings = function (newCallBackSettings) { callBackSettings = newCallBackSettings; }
    function notifyEvent(eventNotification) {
        var retVal = callBack.call(optionalScope, eventNotification);
        return retVal != undefined ? retVal : true;
    }
    function onReceivedEvent(event, eventName) {
        if (!event) { if (window.event) { event = window.event; } }
        switch (eventName) {
            case tf.consts.DOMEventNamesClick:
                //tf.events.StopDOMEvent(event);
                break;
            default:
                break;
        }
        lastEventName = eventName;
        lastEvent = event;
        var eventNotification = { sender: theThis, callBackSettings: callBackSettings, event: event, eventName: eventName, target: target, domObj: domObj };
        if (!!preNotify) { preNotify.call(preNotifyScope, eventNotification); }
        return notifyEvent(eventNotification);
    }
    function makeEventNotificationCallBack(eventName) { return function (event) { return onReceivedEvent(event, eventName) }; }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (!!tf.dom.GetDOMEventListenerFrom(settings.target) &&
            !!tf.js.GetIsValidObject(settings.eventNames) &&
            !!(callBack = tf.js.GetFunctionOrNull(settings.callBack))) {
            optionalScope = settings.optionalScope;
            domObj = settings.domObj;
            target = settings.target;
            callBackSettings = settings.callBackSettings;
            preNotify = tf.js.GetFunctionOrNull(settings.onPreNotify);
            preNotifyScope = settings.preNotifyScope;
            DOMListeners = [];
            for (var i in settings.eventNames) {
                var eventName = settings.eventNames[i];
                if (tf.js.GetIsNonEmptyString(eventName)) {
                    DOMListeners.push(tf.events.AddDOMEventListener(target, eventName, makeEventNotificationCallBack(eventName)));
                }
            }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Notifications sent by {@link tf.events.DOMFullScreenChangeListener} instances
 * @public
 * @typedef {object} tf.types.DOMFullScreenChangeListenerNotification
 * @property {tf.events.DOMFullScreenChangeListener} sender - the instance sending the notification
 * @property {DOMEvent} event - the event being notified
 * @property {object} callBackSettings - application defined properties, provided in the creation of the {@link tf.events.DOMFullScreenChangeListener} instance
*/
/**
 * A callback function that can be used in the creation of instances of [DOM Full Screen Change Listener]{@link tf.events.DOMFullScreenChangeListener}
 * @public
 * @callback tf.types.DOMFullScreenChangeListenerCallBack
 * @param {tf.types.DOMFullScreenChangeListenerNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * Settings used in the creation of [DOM Full Screen Change Listener]{@link tf.events.DOMFullScreenChangeListener} instances
 * @public
 * @typedef {object} tf.types.DOMFullScreenChangeListenerSettings
 * @property {tf.types.DOMFullScreenChangeListenerCallBack} callBack - to receive event notifications
 * @property {object} optionalScope - optional scope used with <b>callBack</b>
 * @property {object} callBackSettings - application defined properties, to be passed to <b>callBack</b> during notifications
*/
/**
 * @public
 * @class
 * @summary DOM Full Screen Change Listener instances report to a given callback when the Browser enters or leaves full screen mode
 * @param {tf.types.DOMFullScreenChangeListenerSettings} settings - creation settings
 */
tf.events.DOMFullScreenChangeListener = function (settings) {
    var theThis, onDelayFullScreen, optionalScope, callBack, callBackSettings, DOMListeners;
    /**
     * @public
     * @function
     * @summary - Checks if fullscreen mode is currently on
     * @returns {bool} - | {@link bool} <b>true</b> if in fullscreen mode, <b>false</b> otherwise
    */
    this.GetIsFullScreen = function () { return tf.browser.GetIsFullScreen(); }
    /**
     * @public
     * @function
     * @summary - Use this function to delete the event listener and stop receiving notifications
     * @returns {void} - | {@link void} no return value
    */
    this.OnDelete = function () { if (!!DOMListeners) { for (var i in DOMListeners) { DOMListeners[i].OnDelete(); } DOMListeners = null; } }
    function onFullScreenChange(evt) {
        callBack.call(optionalScope, { sender: theThis, callBackSettings: callBackSettings, event: evt });
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (!!tf.js.GetFunctionOrNull(settings.callBack)) {
            optionalScope = settings.optionalScope;
            callBack = settings.callBack;
            callBackSettings = settings.callBackSettings;
            onDelayFullScreen = new tf.events.DelayedCallBack(50, onFullScreenChange, theThis);
            DOMListeners = [];
            for (var i in tf.consts.allFullScreenEventNames) {
                DOMListeners.push(tf.events.AddDOMEventListener(document, tf.consts.allFullScreenEventNames[i], onDelayFullScreen.DelayCallBack));
            }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Settings used in the creation of [DOM Click Listener]{@link tf.events.DOMClickListener} instances
 * @public
 * @typedef {object} tf.types.DOMClickListenerSettings
 * @property {HTMLElementLike} target - the element whose click events will be monitored
 * @property {tf.types.MultiDOMEventListenerCallBack} callBack - to receive event notifications
 * @property {object} optionalScope - optional scope used with <b>callBack</b>
 * @property {object} callBackSettings - application defined properties, to be passed to <b>callBack</b> during notifications
*/
/**
 * @public
 * @class
 * @summary DOM Click Listener instances report [click]{@link tf.consts.DOMEventNamesClick} [DOM Events]{@link DOMEvent} to a given callback
 * @param {tf.types.DOMClickListenerSettings} settings - creation settings
 * @extends {tf.events.MultiDOMEventListener}
 */
tf.events.DOMClickListener = function (settings) {
    var theThis;
    function onPreNotify(notification) {
        switch (notification.eventName) {
            case tf.consts.DOMEventNamesClick:
                //tf.events.StopDOMEvent(notification.event);
                break;
            default:
                break;
        }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        var eventNames = [tf.consts.DOMEventNamesClick];
        var settingsUse = tf.js.ShallowMerge(settings, { eventNames: eventNames, onPreNotify: onPreNotify, preNotifyScope: theThis });
        tf.events.MultiDOMEventListener.call(theThis, settingsUse);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.events.DOMClickListener, tf.events.MultiDOMEventListener);
/**
 * Settings used in the creation of [DOM Click Listener]{@link tf.events.DOMClickListener} instances
 * @public
 * @typedef {object} tf.types.DOMClickListenerSettings
 * @property {HTMLElementLike} target - the element whose click events will be monitored
 * @property {tf.types.MultiDOMEventListenerCallBack} callBack - to receive event notifications
 * @property {object} optionalScope - optional scope used with <b>callBack</b>
 * @property {object} callBackSettings - application defined properties, to be passed to <b>callBack</b> during notifications
*/
/**
 * @public
 * @class
 * @summary DOM Click Listener instances report [click]{@link tf.consts.DOMEventNamesClick} [DOM Events]{@link DOMEvent} to a given callback
 * @param {tf.types.DOMClickListenerSettings} settings - creation settings
 * @extends {tf.events.MultiDOMEventListener}
 */
tf.events.DOMWheelListener = function (settings) {
    var theThis, isFireFox;
    function onPreNotify(notification) {
        var isUp = false;
        var event = notification.event;
        switch (notification.eventName) {
            case tf.consts.DOMEventNamesDOMMouseScroll:
                isUp = event.detail < 0;
                break;
            case tf.consts.DOMEventNamesMouseWheel:
                isUp = event.wheelDelta > 0;
                break;
            default:
                break;
        }
        notification.isUp = isUp;
        if (tf.js.GetFunctionOrNull(event.preventDefault)) { event.preventDefault(); }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        isFireFox = tf.browser.GetBrowserType().isFireFox;
        var eventNames = isFireFox ? [tf.consts.DOMEventNamesDOMMouseScroll] : [tf.consts.DOMEventNamesMouseWheel];
        var settingsUse = tf.js.ShallowMerge(settings, { eventNames: eventNames, onPreNotify: onPreNotify, preNotifyScope: theThis });
        tf.events.MultiDOMEventListener.call(theThis, settingsUse);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.events.DOMWheelListener, tf.events.MultiDOMEventListener);
/**
 * Notifications sent by {@link tf.events.DOMHoverListener} instances contain the properties of {@link tf.types.MultiDOMEventListenerNotification} plus:
 * @public
 * @typedef {object} tf.types.DOMHoverListenerNotification
 * @property {boolean} isInHover - <b>true</b> in [MouseOver]{@link tf.consts.DOMEventNamesMouseOver} events, <b>false</b> in [MouseOut]{@link tf.consts.DOMEventNamesMouseOut} events
 * @property {tf.types.pixelCoordinates} mouseCoords - the mouse pointer coordinates associated with the event
*/
/**
 * A callback function that can be used in the creation of instances of [DOM Hover Listener]{@link tf.events.DOMHoverListener}
 * @public
 * @callback tf.types.DOMHoverListenerCallBack
 * @param {tf.types.DOMHoverListenerNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * Settings used in the creation of [DOM Hover Listener]{@link tf.events.DOMHoverListener} instances
 * @public
 * @typedef {object} tf.types.DOMHoverListenerSettings
 * @property {HTMLElementLike} target - the element whose hover events will be monitored
 * @property {tf.types.DOMHoverListenerCallBack} callBack - to receive event notifications
 * @property {object} optionalScope - optional scope used with <b>callBack</b>
 * @property {object} callBackSettings - application defined properties, to be passed to <b>callBack</b> during notifications
*/
/**
 * @public
 * @class
 * @summary DOM Hover Listener instances report [MouseOver]{@link tf.consts.DOMEventNamesMouseOver} and [MouseOut]{@link tf.consts.DOMEventNamesMouseOut} 
 * [DOM Events]{@link DOMEvent} to a given callback
 * @param {tf.types.DOMHoverListenerSettings} settings - creation settings
 * @extends {tf.events.MultiDOMEventListener}
 */
tf.events.DOMHoverListener = function (settings) {
    var theThis, isInHover, lastPos;
    /**
     * @public
     * @function
     * @summary - Checks if the last event received was a [MouseOver]{@link tf.consts.DOMEventNamesMouseOver} event
     * @returns {boolean} - | {@link boolean} <b>true</b> if the last event was a MouseOver event, <b>false</b> otherwise
    */
    this.GetIsInHover = function () { return isInHover; }
    /**
     * @public
     * @function
     * @summary - Retrieves the mouse pointer position in the last event received and notified
     * @returns {tf.types.pixelCoordinates} - | {@link tf.types.pixelCoordinates} the last position
    */
    this.GetLastPos = function () { return lastPos; }
    function onPreNotify(notification) {
        lastPos = notification.mouseCoords = tf.events.GetMouseEventCoords(notification.event);
        switch (notification.eventName) {
            case tf.consts.DOMEventNamesMouseOver:
                isInHover = notification.isInHover = true;
                break;
            case tf.consts.DOMEventNamesMouseOut:
                isInHover = notification.isInHover = false;
                break;
        }
    }
    function initialize() {
        isInHover = false;
        var eventNames = [tf.consts.DOMEventNamesMouseOver, tf.consts.DOMEventNamesMouseOut];
        var settingsUse = tf.js.ShallowMerge(settings, { eventNames: eventNames, onPreNotify: onPreNotify, preNotifyScope: theThis });
        tf.events.MultiDOMEventListener.call(theThis, settingsUse);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.events.DOMHoverListener, tf.events.MultiDOMEventListener);
/**
 * @public
 * @class
 * @summary DOM MouseEnterLeave Listener instances report [MouseEnter]{@link tf.consts.DOMEventNamesMouseEnter} and [MouseLeave]{@link tf.consts.DOMEventNamesMouseLeave} 
 * [DOM Events]{@link DOMEvent} to a given callback
 * @param {tf.types.DOMHoverListenerSettings} settings - creation settings
 * @extends {tf.events.MultiDOMEventListener}
 */
tf.events.DOMMouseEnterLeaveListener = function (settings) {
    var theThis, isInHover, lastPos;
    /**
     * @public
     * @function
     * @summary - Checks if the last event received was a [MouseEnter]{@link tf.consts.DOMEventNamesMouseEnter} event
     * @returns {boolean} - | {@link boolean} <b>true</b> if the last event was a MouseEnter event, <b>false</b> otherwise
    */
    this.GetIsInHover = function () { return isInHover; }
    /**
     * @public
     * @function
     * @summary - Retrieves the mouse pointer position in the last event received and notified
     * @returns {tf.types.pixelCoordinates} - | {@link tf.types.pixelCoordinates} the last position
    */
    this.GetLastPos = function () { return lastPos; }
    function onPreNotify(notification) {
        lastPos = notification.mouseCoords = tf.events.GetMouseEventCoords(notification.event);
        switch (notification.eventName) {
            case tf.consts.DOMEventNamesMouseEnter:
                isInHover = notification.isInHover = true;
                break;
            case tf.consts.DOMEventNamesMouseLeave:
                isInHover = notification.isInHover = false;
                break;
        }
    }
    function initialize() {
        isInHover = false;
        var eventNames = [tf.consts.DOMEventNamesMouseEnter, tf.consts.DOMEventNamesMouseLeave];
        var settingsUse = tf.js.ShallowMerge(settings, { eventNames: eventNames, onPreNotify: onPreNotify, preNotifyScope: theThis });
        tf.events.MultiDOMEventListener.call(theThis, settingsUse);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.events.DOMMouseEnterLeaveListener, tf.events.MultiDOMEventListener);
/**
 * @public
 * @class
 * @summary DOM MouseEnterLeave Listener instances report [MouseEnter]{@link tf.consts.DOMEventNamesMouseEnter} and [MouseLeave]{@link tf.consts.DOMEventNamesMouseLeave} 
 * [DOM Events]{@link DOMEvent} to a given callback
 * @param {tf.types.DOMHoverListenerSettings} settings - creation settings
 * @extends {tf.events.MultiDOMEventListener}
 */
tf.events.DOMFocusBlurListener = function (settings) {
    var theThis, hasFocus;
    /**
     * @public
     * @function
     * @summary - Checks if the last event received was a [Focus]{@link tf.consts.DOMEventNamesFocus} event
     * @returns {boolean} - | {@link boolean} <b>true</b> if the last event was a Focus event, <b>false</b> otherwise
    */
    this.GetHasFocus = function () { return hasFocus; }
    function onPreNotify(notification) {
        //if (notification.event.target == theThis.GetTarget()) {
            switch (notification.eventName) {
                case tf.consts.DOMEventNamesFocus:
                    hasFocus = notification.hasFocus = true;
                    break;
                case tf.consts.DOMEventNamesBlur:
                    hasFocus = notification.hasFocus = false;
                    break;
            }
        //}
    }
    function initialize() {
        hasFocus = false;
        var eventNames = [tf.consts.DOMEventNamesFocus, tf.consts.DOMEventNamesBlur];
        var settingsUse = tf.js.ShallowMerge(settings, { eventNames: eventNames, onPreNotify: onPreNotify, preNotifyScope: theThis });
        tf.events.MultiDOMEventListener.call(theThis, settingsUse);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.events.DOMFocusBlurListener, tf.events.MultiDOMEventListener);
/**
 * Notifications sent by {@link tf.events.DOMMouseListener} contain the properties of {@link tf.types.MultiDOMEventListenerNotification} plus:
 * @public
 * @typedef {object} tf.types.DOMMouseListenerNotification
 * @property {boolean} isInHover - <b>true</b> if the mouse pointer is currently hovering <b>target</b>, <b>false</b> otherwise
 * @property {boolean} isInDrag - <b>true</b> if the mouse pointer is currently down, <b>false</b> otherwise
 * @property {tf.types.pixelCoordinates} mouseCoords - the mouse pointer coordinates associated with the event
*/
/**
 * A callback function that can be used in the creation of instances of [DOM Mouse Listener]{@link tf.events.DOMMouseListener}
 * @public
 * @callback tf.types.DOMMouseListenerCallBack
 * @param {tf.types.DOMMouseListenerNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * Settings used in the creation of [DOM Mouse Listener]{@link tf.events.DOMMouseListener} instances
 * @public
 * @typedef {object} tf.types.DOMMouseListenerSettings
 * @property {HTMLElementLike} target - the element whose hover events will be monitored
 * @property {tf.types.DOMMouseListenerCallBack} callBack - to receive event notifications
 * @property {object} optionalScope - optional scope used with <b>callBack</b>
 * @property {object} callBackSettings - application defined properties, to be passed to <b>callBack</b> during notifications
*/
/**
 * @public
 * @class
 * @summary DOM Mouse Listener instances report [mouse pointer related events]{@link tf.types.DOMMouseEventName} to a given callback
 * @param {tf.types.DOMMouseListenerSettings} settings - creation settings
 * @extends {tf.events.MultiDOMEventListener}
 */
tf.events.DOMMouseListener = function (settings) {
    var theThis, isInHover, isInDrag, lastPos;
    /**
     * @public
     * @function
     * @summary - Checks if the mouse pointer is currently hovering <b>target</b>
     * @returns {bool} - | {@link bool} <b>true</b> if yes, <b>false</b> otherwise
    */
    this.GetIsInHover = function () { return isInHover; }
    /**
     * @public
     * @function
     * @summary - Checks if the mouse pointer is being dragged<b>target</b>
     * @returns {bool} - | {@link bool} <b>true</b> if yes, <b>false</b> otherwise
    */
    this.GetIsInDrag = function () { return isInDrag; }
    /**
     * @public
     * @function
     * @summary - Retrieves the mouse pointer position in the last event received and notified
     * @returns {tf.types.pixelCoordinates} - | {@link tf.types.pixelCoordinates} the last position
    */
    this.GetLastPos = function () { return lastPos; }
    function onPreNotify(notification) {
        lastPos = notification.mouseCoords = tf.events.GetMouseEventCoords(notification.event);
        switch (notification.eventName) {
            case tf.consts.DOMEventNamesMouseOver:
                isInHover = notification.isInHover = true;
                break;
            case tf.consts.DOMEventNamesMouseOut:
                isInHover = notification.isInHover = false;
                break;
            case tf.consts.DOMEventNamesMouseDown:
                isInDrag = notification.isInDrag = true;
                break;
            case tf.consts.DOMEventNamesMouseUp:
                isInDrag = notification.isInDrag = false;
                break;
        }
    }
    function initialize() {
        isInDrag = isInHover = false;
        lastPos = [0, 0];
        var settingsUse = tf.js.ShallowMerge(settings, { eventNames: tf.consts.allMouseEventNames, onPreNotify: onPreNotify, preNotifyScope: theThis });
        tf.events.MultiDOMEventListener.call(theThis, settingsUse);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.events.DOMMouseListener, tf.events.MultiDOMEventListener);
/**
 * @public
 * @class 
 * @summary The {@link singleton} instance of this class, obtainable by calling {@link tf.GetDocMouseListener},
 * sends notifications of [mouse related events]{@link tf.types.DOMMouseEventName} targetted to the HTML document.
*/
tf.events.DocMouseListener = function () {
    var theThis, mouseListener, callBack, optionalScope, callBackSettings;
    /**
     * @public
     * @function
     * @summary - Starts sending notifications to the given callback, using the optional scope and callback settings 
     * @param {tf.types.MultiDOMEventListenerCallBack} callBack - to receive event notifications
     * @param {object} optionalScope - optional scope used with <b>callBack</b>
     * @param {object} callBackSettings - optional application defined properties passed to <b>callBack</b> on notifications
     * @returns {void} - | {@link void} no return value
    */
    this.SetCapture = function (callBack, optionalScope, callBackSettings) { return setCapture(callBack, optionalScope, callBackSettings); }
    /**
     * @public
     * @function
     * @summary - Stops sending notifications to the callback previously set with the [SetCapture]{@link tf.events.DocMouseListener#SetCapture} function
     * @returns {void} - | {@link void} no return value
    */
    this.ReleaseCapture = function () { return releaseCapture(); }
    /**
     * @public
     * @function
     * @summary - Checks if notifications are currently being sent to a callback
     * @returns {bool} - | {@link bool} <b>true</b> if yes, <b>false</b> otherwise
    */
    this.GetIsCaptured = function () { return !!callBack; }
    function setCapture(callBackSet, optionalScopeSet, callBackSettingsSet) {
        releaseCapture();
        //tf.GetDebug().LogIfTest("docMouse: set capture");
        if (!!(callBack = tf.js.GetFunctionOrNull(callBackSet))) {
            mouseListener = new tf.events.DOMMouseListener({ target: document, callBack: onMouse, optionalScope: theThis, callBackSettings: undefined });
            optionalScope = optionalScopeSet;
            callBackSettings = callBackSettingsSet;
        }
    }
    function releaseCapture() {
        if (!!callBack) {
            //tf.GetDebug().LogIfTest("docMouse: release capture");
            callBack = optionalScope = callBackSettings = undefined;
            mouseListener.OnDelete();
        }
    }
    function onMouse(notification) {
        var retVal = true;
        if (!!callBack) {
            if ((retVal = callBack.call(optionalScope, notification)) === undefined) { retVal = true; }
            else if (retVal) { tf.events.StopDOMEvent(notification.event); }
        }
        return retVal;
    }
    function initialize() {
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * @public
 * @function
 * @summary - Retrieves the target of the DOM Event
 * @param {DOMEvent} ev - the event
 * @returns {HTMLElement} - | {@link HTMLElement} the event target
*/
tf.events.GetEventTarget = function (ev) { if (!!ev) { if (ev.srcElement) { return ev.srcElement; } else if (ev.originalTarget) { return ev.originalTarget; } } return null; }
/**
 * @public
 * @function
 * @summary - Retrieves the Pixel Coordinates associated with the mouse DOM Event
 * @param {DOMEvent} ev - the event
 * @returns {tf.types.pixelCoordinates} - | {@link tf.types.pixelCoordinates} the event's pixel coordinates
*/
tf.events.GetMouseEventCoords = function (ev) {
    if (tf.js.GetIsValidObject(ev)) {
        if (ev.offsetX !== undefined) { return [ev.offsetX, ev.offsetY] }
        else if (ev.layerX != undefined) { return [ev.layerX, ev.layerY]; }
    }
    return [0, 0];
}
/**
 * Notifications sent to DOM Event Listeners
 * @public
 * @typedef {object} tf.types.DOMEventListenerNotification
 * @property {DOMEvent} event - the event being notified
*/
/**
 * A callback function that can be used with the function [AddDOMEventListener]{@link tf.events.AddDOMEventListener}
 * @public
 * @callback tf.types.DOMEventListenerCallBack
 * @param {tf.types.DOMEventListenerNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * @public
 * @function
 * @summary - Directs notifications of the given event name on the given target to the given callback, 
 * returns a [Dom Event Listener]{@link tf.events.DOMEventListener} instance
 * @param {HTMLElementLike} target - the element whose events will be notified
 * @param {tf.types.DOMEventName} eventName - the name of the event to listen for
 * @param {tf.types.DOMEventListenerCallBack} callBack - to receive event notifications
 * @returns {tf.events.DOMEventListener} - | {@link tf.events.DOMEventListener} the listener
*/
tf.events.AddDOMEventListener = function (target, eventName, callBack) {
    var listener = null;
    if (tf.js.GetFunctionOrNull(callBack)) {
        if (target = tf.dom.GetDOMEventListenerFrom(target)) {
            if (tf.js.GetIsNonEmptyString(eventName)) {
                if (target.addEventListener) { target.addEventListener(eventName, callBack, true); }
                else if (target.attachEvent) { target.attachEvent("on" + eventName, callBack); }
                else { target["on" + eventName] = callBack; }
                listener = new tf.events.DOMEventListener({ target: target, eventName: eventName, callBack: callBack });
            }
        }
    }
    return listener;
}
/**
 * @public
 * @function
 * @summary - Stops directing notifications of the given event name on the given target to the given callback
 * @property {HTMLElementLike} target - the element whose events are being notified
 * @property {tf.types.DOMEventName} eventName - the name of the event that is being listen for
 * @property {tf.types.DOMEventListenerCallBack} callBack - to stop receiving event notifications
 * @returns {void} - | {@link void} no return value
*/
tf.events.DelDOMEventListener = function (target, eventName, callBack) {
    if (tf.js.GetFunctionOrNull(callBack)) {
        if (target = tf.dom.GetDOMEventListenerFrom(target)) {
            if (tf.js.GetIsNonEmptyString(eventName)) {
                if (target.removeEventListener) { target.removeEventListener(eventName, callBack, true); }
                else if (target.detachEvent) { target.detachEvent("on" + eventName, callBack); }
                else { target["on" + eventName] = undefined; }
            }
        }
    }
}
/**
 * Settings used in the creation of [EventListener]{@link tf.events.EventListener} instances
 * @private
 * @typedef {object} tf.types.EventListenerSettings
 * @property {string} key - unique identifier
 * @property {function} deleteCallBack - a callback used by the listener to delete itself
*/
/**
 * @public
 * @class
 * @summary Applications do not create instances of this class directly. They are obtained from TerraFly API classes that include <b>AddListener</b> functions
 * @param {tf.types.EventListenerSettings} settings - event listener creation settings
 */
tf.events.EventListener = function (settings) {
    var theThis, onDeleteCallBack, key;
    /**
     * @public
     * @function
     * @summary - Removes this event listener
     * @returns {void} - | {@link void} no return value
    */
    this.OnDelete = function () { if (!!onDeleteCallBack) { var localRef = onDeleteCallBack; onDeleteCallBack = null; localRef(theThis); } }
    /**
     * @private
     * @function
     * @summary - Retrieves the listener's unique identifier
     * @returns {string} - | {@link string} the listener's unique identifier
    */
    this.GetKey = function () { return key; }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        key = settings.key;
        onDeleteCallBack = tf.js.GetFunctionOrNull(settings.deleteCallBack);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Settings used in the creation of [Event Notifier]{@link tf.events.EventNotifier} instances
 * @public
 * @typedef {object} tf.types.EventNotifierSettings
 * @property {string} eventName - the application defined name of the event
*/
/**
 * @public
 * @class
 * @summary Event Notifier instances implement event notifications for a single application defined event name, provided on creation.
 * During their lifetime, Event Notifiers create [Event Listeners]{@link tf.event.EventListener} for given callback functions, 
 * and relay notifications to these callbacks upon request
 * @param {tf.types.EventNotifierSettings} settings - creation settings
 */
tf.events.EventNotifier = function (settings) {
    var theThis, eventName, listeners, keyCount, count;
    /**
     * @public
     * @function
     * @summary - Retrieves the name of the event provided in the creation of this Notifier instance
     * @returns {string} - | {@link string} the name
    */
    this.GetEventName = function () { return eventName; }
    /**
     * @public
     * @function
     * @summary - Adds the given callback to the list of notification recipients
     * @param {function} callBack - a function capable of receiving notifications sent by this Notifier instance
     * @returns {tf.events.EventListener} - | {@link tf.events.EventListener} an Event Listener
    */
    this.Add = function (callBack) { return add(callBack); }
    /**
     * @public
     * @function
     * @summary - Notifies [Event Listeners]{@link tf.event.EventListener} previously added to an event
     * @param {...*} notificationArgument - any number of arguments to be used in the notifications sent to listeners
     * @returns {void} - | {@link void} no return value
    */
    this.Notify = function () {
        for (var i in listeners) {
            try { listeners[i].callBackFunction.apply(undefined, arguments); }
            catch (e) { console.log('exception during EventNotifier notification'); }
        }
    }
    /**
     * @public
     * @function
     * @summary - Removes all [Event Listeners]{@link tf.event.EventListener}
     * @returns {void} - | {@link void} no return value
    */
    this.OnDelete = function () { return onDelete(); }
    this.GetListenerCount = function () { return count; }
    function onDelete() { for (var i in listeners) { listeners[i].listener.OnDelete(); } listeners = []; }
    function isListener(theListener) { return !!theListener && theListener instanceof tf.events.EventListener; }
    function deleteCallBack(theListener) {
        if (isListener(theListener)) { var key = tf.js.MakeObjectKey(theListener.GetKey()); if (!!listeners[key]) { delete listeners[key]; } --count; }
    }
    function add(callbackFunction) {
        var listener = null;
        if (!!tf.js.GetFunctionOrNull(callbackFunction)) {
            ++count;
            ++keyCount;
            listeners[tf.js.MakeObjectKey(keyCount)] = { listener: listener = new tf.events.EventListener({ key: keyCount, deleteCallBack: deleteCallBack }), callBackFunction: callbackFunction };
        }
        return listener;
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        eventName = tf.js.GetNonEmptyString(settings.eventName, "");
        listeners = {};
        count = keyCount = 0;
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Settings used in the creation of [Multi Event Notifier]{@link tf.events.MultiEventNotifier} instances
 * @public
 * @typedef {object} tf.types.MultiEventNotifierSettings
 * @property {enumerable<string>} eventNames - application defined event names for each of which an [Event Notifier]{@link tf.events.EventNotifier} instance is created
*/
/**
 * @public
 * @class
 * @summary Multi Event Notifier instances manage a variable number of [Event Notifiers]{@link tf.event.EventNotifier} 
 * automating listening and notification functionality for an arbitrary number of application defined event names, which may be specified
 * on creation and/or dynamically added and removed.
 * Instances of this class are used throughout the API (by [Maps]{@link tf.map.Map}, [Keyed Feature Lists]{@link tf.map.KeyedFeatureList}, [Keyed Lists]{@link tf.js.KeyedList}, etc.)
 * to implement listening and notification of their respective event names
 * @param {tf.types.MultiEventNotifierSettings} settings - creation settings
 */
tf.events.MultiEventNotifier = function (settings) {
    var theThis, notifiers;
    /**
     * @public
     * @function
     * @summary - Adds the given callback to the [Event Notifier]{@link tf.events.EventNotifier} associated with the given event name
     * @param {string} eventName - one of the event names associated with this Multi Event Notifier instance
     * @param {function} callBack - a function capable of receiving notifications sent by the Event Notifier associated with <b>eventName</b>
     * @returns {tf.events.EventListener} - | {@link tf.events.EventListener} an Event Listener, or {@link void} if <b>eventName</b> is not associated with this instance
    */
    this.AddListener = function (eventName, callBack) { return addListener(eventName, callBack); }
    /**
     * @public
     * @function
     * @summary - Adds one or more listeners for the given event names
     * @param {tf.types.EventNamesAndCallBacks} eventNamesAndCallBacks - the event names and callbacks
     * @returns {tf.types.EventNamesAndListeners} - | {@link tf.types.EventNamesAndListeners} the event names and listeners
    */
    this.AddListeners = function (eventNamesAndCallBacks) { return addListeners(eventNamesAndCallBacks); }
    /**
     * @public
     * @function
     * @summary - Notifies [Event Listeners]{@link tf.event.EventListener} previously added to the given event name
     * @param {string} eventName - one of the event names associated with this Multi Event Notifier instance
     * @param {...*} notificationArgument - any number of arguments to be used in the notifications sent to listeners
     * @returns {void} - | {@link void} no return value
    */
    this.Notify = function (eventName) {
        if (!!eventName && notifiers[eventName]) { notifiers[eventName].Notify.apply(null, Array.prototype.slice.call(arguments, 1)); }
    }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Event Notifier]{@link tf.event.EventNotifier} instance associated with the given event name, if any
     * @param {string} eventName - one of the event names associated with this Multi Event Notifier instance
     * @returns {tf.events.EventNofifier} - | {@link tf.events.EventNofifier} the Event Notifier, or {@link void} if <b>eventName</b> is not associated with this instance
    */
    this.GetNotifier = function (eventName) { return getNotifier(eventName); }
    /**
     * @public
     * @function
     * @summary - Adds an [Event Notifier]{@link tf.event.EventNotifier} instance associated with the given event name
     * @param {string} eventName - an application defined event name
     * @returns {tf.events.EventNofifier} - | {@link tf.events.EventNofifier} the Event Notifier
    */
    this.AddNotifier = function (eventName) { return addNotifier(eventName); }
    /**
     * @public
     * @function
     * @summary - Deletes the [Event Notifier]{@link tf.event.EventNotifier} instance associated with the given event name, if any
     * @param {string} eventName - an application defined event name
     * @returns {void} - | {@link void} no return value
    */
    this.DelNotifier = function (eventName) { return delNotifier(eventName); }
    /**
     * @public
     * @function
     * @summary - Removes all [Event Notifiers]{@link tf.event.EventNotifier}
     * @returns {void} - | {@link void} no return value
    */
    this.OnDelete = function () { return onDelete(); }
    function getNotifier(eventName) { return !!eventName ? notifiers[eventName] : null; }
    function addListener(eventName, callBackFunction) {
        var listener = null;
        if (!!eventName && !!callBackFunction) { if (!!notifiers[eventName]) { listener = notifiers[eventName].Add(callBackFunction); } }
        return listener;
    }
    function addListeners(eventNamesAndCallBacks) {
        var listeners = {};
        if (tf.js.GetIsValidObject(eventNamesAndCallBacks)) {
            for (var thisEventName in eventNamesAndCallBacks) {
                var listenerSet = getNotifier(thisEventName);
                if (!!listenerSet) {
                    var thisCallBack = tf.js.GetFunctionOrNull(eventNamesAndCallBacks[thisEventName]);
                    if (!!thisCallBack) { listeners[thisEventName] = listenerSet.Add(thisCallBack); }
                }
            }
        }
        return listeners;
    }
    function delNotifier(eventName) {
        if (!!eventName && !!notifiers[eventName]) { notifiers[eventName].OnDelete(); delete notifiers[eventName]; }
    }
    function addNotifier(eventName) {
        if (!!eventName) {
            if (!!notifiers[eventName]) {
                tf.GetDebug().LogIfTest('tf.events.MultiEventNotifier: adding duplicate listener for event name: ' + eventName);
            }
            else { notifiers[eventName] = new tf.events.EventNotifier({ eventName: eventName }); }
        }
    }
    function onDelete() { for (var i in notifiers) { delNotifier(i); } }
    function createListenerSets(eventNames) {
        notifiers = {}; if (!!eventNames && typeof eventNames === "object") { for (var i in eventNames) { addNotifier(eventNames[i]); } }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        createListenerSets(settings.eventNames);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * @public
 * @function
 * @summary - Deletes one or more listeners for the given event names
 * @param {tf.types.EventNamesAndListeners} eventNamesAndListeners - the event names and listeners
 * @returns {void} - | {@link void} no return value
*/
tf.events.DeleteListeners = function (eventNamesAndListeners) {
    if (tf.js.GetIsValidObject(eventNamesAndListeners)) {
        for (var i in eventNamesAndListeners) {
            var listener = eventNamesAndListeners[i];
            if (tf.js.GetIsInstanceOf(listener, tf.events.EventListener)) {
                listener.OnDelete();
                delete eventNamesAndListeners[i];
            }
        }
    }
}
/**
 * A JavaScript {@link object} whose single property name is an API event name and its value is a callBack function to receive notifications of that event
 * @public
 * @typedef {tf.types.EventNameAndCallBack} tf.types.EventNameAndCallBack
 * @property {string} callBack - an event name and callBack pair, the event name is the property name
 * @example
 * // Declares an association between the onMapMoveEnd callBack and the name of the tf.consts.mapMoveEndEvent event
 * var eventNameAndCallBack = {} ; eventNameAndCallBack[tf.consts.mapMoveEndEvent] = onMapMoveEnd;
 * @see {@link tf.types.EventNamesAndCallBacks}
 */
/**
 * An {@link enumerable} of {@link tf.types.EventNameAndCallBack} items that can be created as a group
 * @public
 * @typedef {tf.types.EventNamesAndCallBacks} tf.types.EventNamesAndCallBacks
 * @example
 * // Add listeners to 3 map events
 * var eventNamesAndCallBacks = {} ;
 * eventNamesAndCallBacks[tf.consts.mapMoveEndEvent] = onMapMoveEnd;
 * eventNamesAndCallBacks[tf.consts.mapMouseMoveEvent] = onMapMouseMoveOrClick;
 * eventNamesAndCallBacks[tf.consts.mapClickEvent] = onMapMouseMoveOrClick;
 * var eventNamesAndListeners = [map]{@link tf.map.Map}.[AddListeners]{@link tf.map.Map#AddListeners}(eventNamesAndCallBacks);
 * // When the listeners are no longer needed, dispose of them as a group
 * [tf.events.DeleteListeners]{@link tf.events.DeleteListeners}(eventNamesAndListeners);
 * @see [map]{@link tf.map.Map}[AddListeners]{@link tf.map.Map#AddListeners}
 * @see [DeleteListeners]{@link tf.events.DeleteListeners}
 */
/**
 * A JavaScript {@link object} whose single property name is an API event name and its value is an instance of [EventListener]{@link tf.events.EventListener}. 
 * Applications do not create these objects direction, they are obtained by calling API functions that create and return them.
 * @public
 * @typedef {tf.types.EventNameAndListener} tf.types.EventNameAndListener
 * @property {string} theEventListener - an event name and listener par
 * @see {@link tf.types.EventNamesAndCallBacks}
 */
/**
 * An {@link enumerable} of {@link tf.types.EventNameAndListener} items that can be disposed of as a group
 * @public
 * @typedef {tf.types.EventNamesAndListeners} tf.types.EventNamesAndListeners
 * @see [map]{@link tf.map.Map}[AddListeners]{@link tf.map.Map#AddListeners}
 * @see [DeleteListeners]{@link tf.events.DeleteListeners}
 */

// SOURCE FILE: canvas.js
/**
 * @public
 * @function
 * @summary - Traces a circle on the given context, at the given center, and with the given diameter, using {@link tf.canvas.ellipse}
 * @param {canvasContext} ctx - context on which to draw the circle
 * @param {number} aX - horizontal center coordinate
 * @param {number} aY - vertical center coordinate
 * @param {number} aDiameter - diameter
 * @returns {void} - | {@link void} no return value
*/
tf.canvas.circle = function (ctx, aX, aY, aDiameter) { tf.canvas.ellipse(ctx, aX, aY, aDiameter, aDiameter); }
/**
 * @public
 * @function
 * @summary - Traces an axis-aligned ellipse on the given context, at the given center, and with the given diameters, using <b>bezierCurveTo</b>, does
 * not fill or stroke the traced geometry
 * @param {canvasContext} ctx - context on which to draw the ellipse
 * @param {number} aX - horizontal center coordinate
 * @param {number} aY - vertical center coordinate
 * @param {number} aWidth - horizontal diameter
 * @param {number} aHeight - vertical diameter
 * @returns {void} - | {@link void} no return value
*/
tf.canvas.ellipse = function (ctx, aX, aY, aWidth, aHeight) {
    var hB = (aWidth / 2) * .5522848, vB = (aHeight / 2) * .5522848,
        eX = aX + aWidth, eY = aY + aHeight, mX = aX + aWidth / 2, mY = aY + aHeight / 2;
    ctx.moveTo(aX, mY);
    ctx.bezierCurveTo(aX, mY - vB, mX - hB, aY, mX, aY);
    ctx.bezierCurveTo(mX + hB, aY, eX, mY - vB, eX, mY);
    ctx.bezierCurveTo(eX, mY + vB, mX + hB, eY, mX, eY);
    ctx.bezierCurveTo(mX - hB, eY, aX, mY + vB, aX, mY);
}
/**
 * @public
 * @function
 * @summary - Strokes and fills a rectangle with rounded corners on the given context
 * @param {canvasContext} ctx - context on which to draw the rectangle
 * @param {number} x - the rectangle's leftmost coordinate
 * @param {number} y - the rectangle's topmost coordinate
 * @param {number} width - the width of the rectangle
 * @param {number} height - the height of the rectangle
 * @param {number} radius - the radius of the rectangle's rounded corners
 * @param {boolean} fill - if <b>true</b> the rectangle is filled with the current fill color, defaults to {@link void}
 * @param {boolean} stroke - if <b>true</b> the rectangle is stroked with the current stroke color and width, defaults to {@link void}
 * @returns {void} - | {@link void} no return value
*/
tf.canvas.StrokeFillRoundRect = function (ctx, x, y, width, height, radius, fill, stroke, dontTranslate) {
    stroke = tf.js.GetBoolFromValue(stroke, false);
    fill = tf.js.GetBoolFromValue(fill, false);
    if (fill || stroke) {
        if (!dontTranslate) { ctx.translate(0.5, 0.5); }
        var minDim = width < height ? width : height;
        radius = tf.js.GetFloatNumberInRange(radius, 0, minDim / 2);
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        if (stroke) { ctx.stroke(); }
        if (fill) { ctx.fill(); }
    }
}
/**
 * @public
 * @function
 * @summary - Strokes and fills a bubble on the given HTML5 canvas context, with an arrow callout going up from its left top corner
 * @param {canvasContext} ctx - the canvas context to draw on
 * @param {tf.types.pixelCoordinates} leftTop - left and top coordinates
 * @param {tf.types.pixelCoordinates} widthHeight - width and height dimensions 
 * @param {number} arrowHeight - in pixels, determines how far from the bubble the callout arrow ends
 * @param {number} radius - in pixels, used for rounding corners and determining the width of the callout arrow
*/
tf.canvas.StrokeFillBubbleLT = function (ctx, x, y, w, h, arrowHeight, radius) {
    var r = x + w;
    var b = y + h;
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x, y - arrowHeight);
    ctx.lineTo(x + radius * 2, y);
    ctx.lineTo(r - radius, y);
    ctx.quadraticCurveTo(r, y, r, y + radius);
    ctx.lineTo(r, y + h - radius);
    ctx.quadraticCurveTo(r, b, r - radius, b);
    ctx.lineTo(x + radius, b);
    ctx.quadraticCurveTo(x, b, x, b - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
}
/**
 * @public
 * @function
 * @summary - Strokes and fills a bubble on the given HTML5 canvas context, with an arrow callout going down from its left bottom corner
 * @param {canvasContext} ctx - the canvas context to draw on
 * @param {tf.types.pixelCoordinates} leftTop - left and top coordinates
 * @param {tf.types.pixelCoordinates} widthHeight - width and height dimensions 
 * @param {number} arrowHeight - in pixels, determines how far from the bubble the callout arrow ends
 * @param {number} radius - in pixels, used for rounding corners and determining the width of the callout arrow
*/
tf.canvas.StrokeFillBubbleLB = function (ctx, x, y, w, h, arrowHeight, radius) {
    var r = x + w;
    var b = y + h;
    ctx.moveTo(x + radius, y);
    ctx.lineTo(r - radius, y);
    ctx.quadraticCurveTo(r, y, r, y + radius);
    ctx.lineTo(r, y + h - radius);
    ctx.quadraticCurveTo(r, b, r - radius, b);
    ctx.lineTo(x + radius * 2, b);
    ctx.lineTo(x, b + arrowHeight);
    ctx.lineTo(x + radius, b);
    ctx.quadraticCurveTo(x, b, x, b - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
}
/**
 * @public
 * @function
 * @summary - Strokes and fills a bubble on the given HTML5 canvas context, with an arrow callout going up from its right top corner
 * @param {canvasContext} ctx - the canvas context to draw on
 * @param {tf.types.pixelCoordinates} leftTop - left and top coordinates
 * @param {tf.types.pixelCoordinates} widthHeight - width and height dimensions 
 * @param {number} arrowHeight - in pixels, determines how far from the bubble the callout arrow ends
 * @param {number} radius - in pixels, used for rounding corners and determining the width of the callout arrow
*/
tf.canvas.StrokeFillBubbleRT = function (ctx, x, y, w, h, arrowHeight, radius) {
    var r = x + w;
    var b = y + h;
    ctx.moveTo(x + radius, y);
    ctx.lineTo(r - radius * 2, y);
    ctx.lineTo(r, y - arrowHeight);
    ctx.lineTo(r - radius, y);
    ctx.quadraticCurveTo(r, y, r, y + radius);
    ctx.lineTo(r, y + h - radius);
    ctx.quadraticCurveTo(r, b, r - radius, b);
    ctx.lineTo(x + radius, b);
    ctx.quadraticCurveTo(x, b, x, b - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
}
/**
 * @public
 * @function
 * @summary - Strokes and fills a bubble on the given HTML5 canvas context, with an arrow callout going down from its right bottom corner
 * @param {canvasContext} ctx - the canvas context to draw on
 * @param {tf.types.pixelCoordinates} leftTop - left and top coordinates
 * @param {tf.types.pixelCoordinates} widthHeight - width and height dimensions 
 * @param {number} arrowHeight - in pixels, determines how far from the bubble the callout arrow ends
 * @param {number} radius - in pixels, used for rounding corners and determining the width of the callout arrow
*/
tf.canvas.StrokeFillBubbleRB = function (ctx, x, y, w, h, arrowHeight, radius) {
    var r = x + w;
    var b = y + h;
    ctx.moveTo(x + radius, y);
    ctx.lineTo(r - radius, y);
    ctx.quadraticCurveTo(r, y, r, y + radius);
    ctx.lineTo(r, y + h - radius);
    ctx.quadraticCurveTo(r, b, r - radius, b);
    ctx.lineTo(r - radius, b);
    ctx.lineTo(r, b + arrowHeight);
    ctx.lineTo(r - 2 * radius, b);
    ctx.lineTo(x + radius, b);
    ctx.quadraticCurveTo(x, b, x, b - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
}
/**
 * @public
 * @function
 * @summary - Strokes and fills a bubble on the given HTML5 canvas context, with an arrow callout going up from its the middle of its top edge
 * @param {canvasContext} ctx - the canvas context to draw on
 * @param {tf.types.pixelCoordinates} leftTop - left and top coordinates
 * @param {tf.types.pixelCoordinates} widthHeight - width and height dimensions 
 * @param {number} arrowHeight - in pixels, determines how far from the bubble the callout arrow ends
 * @param {number} radius - in pixels, used for rounding corners and determining the width of the callout arrow
*/
tf.canvas.StrokeFillBubbleMidT = function (ctx, x, y, w, h, arrowHeight, radius) {
    var r = x + w;
    var b = y + h;
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + w / 2 - radius / 2, y);
    ctx.lineTo(x + w / 2, y - arrowHeight);
    ctx.lineTo(x + w / 2 + radius / 2, y);
    ctx.lineTo(x + radius * 2, y);
    ctx.lineTo(r - radius, y);
    ctx.quadraticCurveTo(r, y, r, y + radius);
    ctx.lineTo(r, y + h - radius);
    ctx.quadraticCurveTo(r, b, r - radius, b);
    ctx.lineTo(x + radius, b);
    ctx.quadraticCurveTo(x, b, x, b - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
}
/**
 * @public
 * @function
 * @summary - Strokes and fills a bubble on the given HTML5 canvas context, with an arrow callout going down from its the middle of its bottom edge
 * @param {canvasContext} ctx - the canvas context to draw on
 * @param {tf.types.pixelCoordinates} leftTop - left and top coordinates
 * @param {tf.types.pixelCoordinates} widthHeight - width and height dimensions 
 * @param {number} arrowHeight - in pixels, determines how far from the bubble the callout arrow ends
 * @param {number} radius - in pixels, used for rounding corners and determining the width of the callout arrow
*/
tf.canvas.StrokeFillBubbleMidB = function (ctx, x, y, w, h, arrowHeight, radius) {
    var r = x + w;
    var b = y + h;
    ctx.moveTo(x + radius, y);
    ctx.lineTo(r - radius, y);
    ctx.quadraticCurveTo(r, y, r, y + radius);
    ctx.lineTo(r, y + h - radius);
    ctx.quadraticCurveTo(r, b, r - radius, b);
    ctx.lineTo(x + w / 2 + radius / 2, b);
    ctx.lineTo(x + w / 2, b + arrowHeight);
    ctx.lineTo(x + w / 2 - radius / 2, b);
    ctx.lineTo(x + radius, b);
    ctx.quadraticCurveTo(x, b, x, b - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
}
/**
 * @public
 * @function
 * @summary - Strokes and fills a bubble on the given HTML5 canvas context, with an arrow callout going up from its the middle of its right edge
 * @param {canvasContext} ctx - the canvas context to draw on
 * @param {tf.types.pixelCoordinates} leftTop - left and top coordinates
 * @param {tf.types.pixelCoordinates} widthHeight - width and height dimensions 
 * @param {number} arrowHeight - in pixels, determines how far from the bubble the callout arrow ends
 * @param {number} radius - in pixels, used for rounding corners and determining the width of the callout arrow
*/
tf.canvas.StrokeFillBubbleMidR = function (ctx, x, y, w, h, arrowHeight, radius) {
    var r = x + w;
    var b = y + h;
    ctx.moveTo(x + radius, y);
    ctx.lineTo(r - radius, y);
    ctx.quadraticCurveTo(r, y, r, y + radius);
    ctx.lineTo(r + arrowHeight, y + h / 2);
    ctx.lineTo(r, b - radius);
    ctx.quadraticCurveTo(r, b, r - radius, b);
    ctx.lineTo(x + radius, b);
    ctx.quadraticCurveTo(x, b, x, b - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
}
/**
 * @public
 * @function
 * @summary - Strokes and fills a bubble on the given HTML5 canvas context, with an arrow callout going down from its the middle of its left edge
 * @param {canvasContext} ctx - the canvas context to draw on
 * @param {tf.types.pixelCoordinates} leftTop - left and top coordinates
 * @param {tf.types.pixelCoordinates} widthHeight - width and height dimensions 
 * @param {number} arrowHeight - in pixels, determines how far from the bubble the callout arrow ends
 * @param {number} radius - in pixels, used for rounding corners and determining the width of the callout arrow
*/
tf.canvas.StrokeFillBubbleMidL = function (ctx, x, y, w, h, arrowHeight, radius) {
    var r = x + w;
    var b = y + h;
    ctx.moveTo(x + radius, y);
    ctx.lineTo(r - radius, y);
    ctx.quadraticCurveTo(r, y, r, y + radius);
    ctx.lineTo(r, y + h - radius);
    ctx.quadraticCurveTo(r, b, r - radius, b);
    ctx.lineTo(x + radius, b);
    ctx.quadraticCurveTo(x, b, x, b - radius);
    ctx.lineTo(x - arrowHeight, y + h / 2);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
}
/**
 * @public
 * @function
 * @summary - Draws a rectangle with rounded corners from the left top coordinates of given context to the given dimensions.
 * Can be used with {@link tf.canvas.CreateMemoryImage}
 * @param {canvasContext} ctx - context on which to draw the rectangle
 * @param {object} settings - drawing settings
 * @param {number} settings.width - rectangle width in pixels
 * @param {number} settings.height - rectangle height in pixels
 * @param {number} settings.radius - rounded corners radius in pixels
 * @param {boolean} settings.fill - if <b>true</b> the rectangle is filled, defaults to <b>false</b>
 * @param {colorWithOptionalAlpha} settings.fill_color - fill color
 * @param {boolean} settings.line - if <b>true</b> the rectangle is stroked, defaults to <b>false</b>
 * @param {colorWithOptionalAlpha} settings.line_color - stroke color
 * @param {number} settings.line_width - stroke width in pixels
 * @returns {tf.types.iconAnchor} - | {@link tf.types.iconAnchor} the rectangle's anchor
*/
tf.canvas.DrawRoundRect = function (ctx, settings) {
    var defaultSettings = { width: 10, height: 10, radius: 2, fill: false, fill_color: "#fff", line: false, line_color: "#000", line_width: 1 };
    var settings = tf.js.ShallowMerge(defaultSettings, settings);
    var width = settings.width, height = settings.height, radius = settings.radius, fill = !!settings.fill, stroke = !!settings.line, strokeW = 0;
    if (!settings.dontTranslate) { ctx.translate(0.5, 0.5); }
    ctx.canvas.width = width;
    ctx.canvas.height = height;
    ctx.beginPath();
    ctx.clearRect(0, 0, width, height);
    //ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    if (stroke) { ctx.strokeStyle = settings.line_color; ctx.lineWidth = strokeW = settings.line_width; }
    if (fill) { ctx.fillStyle = settings.fill_color; }
    if (settings.line_dash !== undefined) {
        ctx.setLineDash(settings.line_dash);
    }
    tf.canvas.StrokeFillRoundRect(ctx, strokeW / 2, strokeW / 2, width - strokeW, height - strokeW, radius, fill, stroke, settings.dontTranslate);
    ctx.closePath();
    return [0.5, 0.5];
}
/**
 * @public
 * @function
 * @summary - Draws a bubble around given text with an optional callout arrow. Used to implement the <b>marker</b> style in [Map Feature Sub Style]{@link tf.map.FeatureSubStyle}
 * instances. Can be used with {@link tf.canvas.CreateMemoryImage}
 * @param {canvasContext} ctx - context on which to draw the rectangle
 * @param {object} settings - marker settings
 * @param {string} settings.label - the text
 * @param {number} settings.font - the text font, without size
 * @param {hexColor} settings.font_color - text font color
 * @param {number} settings.font_height - the text height, in pixels
 * @param {tf.types.opacity0100} settings.font_opacity - text font opacity
 * @param {hexColor} settings.line_color - text stroke color
 * @param {tf.types.opacity0100} settings.line_opacity - text stroke opacity
 * @param {number} settings.border_line_color - border stroke color
 * @param {tf.types.opacity0100} settings.border_line_opacity - border stroke opacity
 * @param {number} settings.border_line_width - border stroke width in pixels
 * @param {number} settings.fill_color - bubble fill color
 * @param {tf.types.opacity0100} settings.fill_opacity - bubble fill opacity
 * @param {number} settings.arrowHeight - in pixels, determines how far from the bubble the callout arrow ends
 * @param {number} settings.radius - in pixels, used for rounding corners and determining the width of the callout arrow
 * @param {tf.types.horizontalPositioning} settings.horPos - horizontal positioning of the bubble
 * @param {tf.types.verticalPositioning} settings.verPos - vertical positioning of the bubble
 * @returns {tf.types.iconAnchor} - | {@link tf.types.iconAnchor} the marker's anchor
*/
tf.canvas.DrawTextMarkerImage = function (ctx, settings) {
    settings = tf.js.GetValidObjectFrom(settings);
    //var horPos = tf.js.GetNonEmptyString(settings.horpos, tf.consts.positioningLeft);
    var horPos = tf.js.GetNonEmptyString(settings.horpos, tf.consts.positioningCenter);
    //var horPos = tf.js.GetNonEmptyString(settings.horpos, tf.consts.positioningRight);
    var verPos = tf.js.GetNonEmptyString(settings.verpos, tf.consts.positioningTop);
    //var verPos = tf.js.GetNonEmptyString(settings.verpos, tf.consts.positioningCenter);
    //var verPos = tf.js.GetNonEmptyString(settings.verpos, tf.consts.positioningBottom);
    var isLeft, isCenterHor, isTop, isCenterVer;
    var strokeFunction, iconAnchor = [0.5, 0.5];
    switch (horPos.toLowerCase()) {
        default:
        case tf.consts.positioningCenter: isCenterHor = true; isLeft = false; iconAnchor[0] = 0.5; break;
        case tf.consts.positioningLeft: isCenterHor = false; isLeft = true; iconAnchor[0] = 1; break;
        case tf.consts.positioningRight: isCenterHor = false; isLeft = false; iconAnchor[0] = 0; break;
    }
    switch (verPos.toLowerCase()) {
        case tf.consts.positioningCenter: isCenterVer = true; isTop = false; iconAnchor[1] = 0.5; break;
        case tf.consts.positioningTop: isCenterVer = false; isTop = true; iconAnchor[1] = 1; break;
        case tf.consts.positioningBottom: isCenterVer = false; isTop = false; iconAnchor[1] = 0; break;
    }
    var label = tf.js.GetNonEmptyString(settings.label, '');
    var textStrokeColor = settings.line_color != null ? settings.line_color : "0xFFFFFF";
    var textStrokeOpac = settings.line_opacity != null ? settings.line_opacity : 0.2;
    var textStrokeWidth = settings.line_width != null ? settings.line_width : 0;
    var textFillColor = settings.font_color != null ? settings.font_color : "0x000000";
    var textFillOpac = settings.font_opacity != null ? settings.font_opacity : 1.0;
    var olTextStrokeColor = tf.js.GetRGBAColor(textStrokeColor, textStrokeColor, textStrokeOpac);
    var olTextFillColor = tf.js.GetRGBAColor(textFillColor, textFillColor, textFillOpac);
    var bgStrokeColor = settings.border_line_color != null ? settings.border_line_color : "0x000000";
    var bgStrokeOpac = settings.border_line_opacity != null ? settings.border_line_opacity : 1.0;
    var bgStrokeWidth = settings.border_line_width != null ? settings.border_line_width : 2;
    var bgFillColor = settings.fill_color != null ? settings.fill_color : "0xffb27f";
    var bgFillOpac = settings.fill_opacity != null ? settings.fill_opacity : 1.0;
    var olBGStrokeColor = tf.js.GetRGBAColor(bgStrokeColor, bgStrokeColor, bgStrokeOpac);
    var olBGFillColor = tf.js.GetRGBAColor(bgFillColor, bgFillColor, bgFillOpac);
    var styles = tf.GetStyles(), subStyles = styles.GetSubStyles();
    var defaultFontHeighPX = subStyles.markerFontSizePXNumber;
    var aFontHeightPX = settings.font_height != null ? tf.js.GetIntNumberInRange(settings.font_height, 8, 20, defaultFontHeighPX) : defaultFontHeighPX;
    var defaultFontName = subStyles.markerFontFamily;
    var aFontName = typeof settings.font === "string" && settings.font.length ? settings.font : defaultFontName;
    var aFont = aFontHeightPX + "px " + aFontName;
    var arrow_length = settings.arrow_length ? settings.arrow_length : 12;
    var marginPix = 2;
    var marginL = marginPix, marginR = marginPix, marginT = marginPix + 1, marginB = marginPix - 1, marginX = marginL + marginR, marginY = marginT + marginB;
    ctx.font = aFont;
    ctx.strokeStyle = olTextStrokeColor;
    ctx.lineWidth = textStrokeWidth;
    ctx.fillStyle = olTextFillColor;
    if (!settings.dontTranslate) { ctx.translate(0.5, 0.5); }
    var wText = ctx.measureText(label).width;
    var hText = aFontHeightPX /*+ textStrokeWidth*/;
    //var textL = marginL + textStrokeWidth / 2;
    var textL = marginL + textStrokeWidth / 2 - 1;
    //var textT = marginT /*+ textStrokeWidth / 2*/;
    var textT = marginT - 1;
    var textBubbleW = wText + marginX + textStrokeWidth;
    //var textBubbleH = hText + marginY + textStrokeWidth;
    var textBubbleH = hText + marginY + textStrokeWidth + 1;
    textL += bgStrokeWidth / 2;
    textT += bgStrokeWidth / 2;
    textBubbleW += 2 * bgStrokeWidth;
    textBubbleH += 2 * bgStrokeWidth;
    var canvasW = textBubbleW - bgStrokeWidth + 1;
    var canvasH = textBubbleH + arrow_length - bgStrokeWidth;
    var xStrokeCoord = bgStrokeWidth / 2;
    var yStrokeCoord = bgStrokeWidth / 2;
    if (isLeft) {
        if (isTop) {
            strokeFunction = tf.canvas.StrokeFillBubbleRB;
        }
        else if (isCenterVer) {
            strokeFunction = tf.canvas.StrokeFillBubbleMidR;
            canvasW += arrow_length;
            canvasH -= arrow_length;
        }
        else {
            strokeFunction = tf.canvas.StrokeFillBubbleRT;
            yStrokeCoord += arrow_length;
            textT += arrow_length;
        }
    }
    else if (isCenterHor) {
        if (isTop) {
            strokeFunction = tf.canvas.StrokeFillBubbleMidB;
        }
        else if (isCenterVer) {
            strokeFunction = tf.canvas.StrokeFillRoundRect;
            canvasH -= arrow_length;
        }
        else {
            strokeFunction = tf.canvas.StrokeFillBubbleMidT;
            yStrokeCoord += arrow_length;
            textT += arrow_length;
        }
    }
    else {
        if (isTop) {
            strokeFunction = tf.canvas.StrokeFillBubbleLB;
        }
        else if (isCenterVer) {
            strokeFunction = tf.canvas.StrokeFillBubbleMidL;
            canvasW += arrow_length;
            canvasH -= arrow_length;
            xStrokeCoord += arrow_length;
            textL += arrow_length;
        }
        else {
            strokeFunction = tf.canvas.StrokeFillBubbleLT;
            yStrokeCoord += arrow_length;
            textT += arrow_length;
        }
    }
    var radius = tf.js.NumberClip((hText + marginY) * 0.35, 1, 10000);
    ctx.canvas.width = canvasW;
    ctx.canvas.height = canvasH;
    ctx.font = aFont;
    ctx.lineCap = "square";
    ctx.lineJoin = "round";
    //ctx.beginPath();
    ctx.clearRect(0, 0, canvasW, canvasH);
    //ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.strokeStyle = olBGStrokeColor;
    ctx.lineWidth = bgStrokeWidth;
    ctx.fillStyle = olBGFillColor;
    if (isCenterHor && isCenterVer) { tf.canvas.StrokeFillRoundRect(ctx, xStrokeCoord, yStrokeCoord, textBubbleW - 2 * bgStrokeWidth, textBubbleH - 2 * bgStrokeWidth, radius, true, true, settings.dontTranslate); }
    else {
        ctx.beginPath();
        strokeFunction(ctx, xStrokeCoord, yStrokeCoord, textBubbleW - 2 * bgStrokeWidth, textBubbleH - 2 * bgStrokeWidth, arrow_length, radius, settings.dontTranslate);
        ctx.closePath();
        ctx.stroke();
        ctx.fill();
    }
    //ctx.closePath();
    ctx.strokeStyle = olTextStrokeColor;
    ctx.lineWidth = textStrokeWidth;
    ctx.textBaseline = 'top';
    if (tf.browser.GetBrowserType().isFireFox) { textT += 2; }
    if (textStrokeWidth > 0) {
        //ctx.fillStyle = olTextStrokeColor;
        //ctx.fillText(label, textL + textStrokeWidth, textT + textStrokeWidth);
        ctx.strokeText(label, textL, textT);
    }
    ctx.fillStyle = olTextFillColor;
    ctx.fillText(label, textL, textT);
    return iconAnchor;
}
/**
 * A callback that can be used with the function [CreateMemoryImage]{@link tf.canvas.CreateMemoryImage}
 * @public
 * @callback tf.types.CreateMemoryImageDrawFunction
 * @param {canvasContext} ctx - context to draw on
 * @param {object} settings - draw settings whose contents vary depending on the callback
 * @returns {tf.types.iconAnchor} - | {@link tf.types.iconAnchor} the drawing's anchor
*/
/**
 * Object returned by the function [CreateMemoryImage]{@link tf.canvas.CreateMemoryImage}
 * @public
 * @typedef tf.types.CreateMemoryImageResult
 * @property {string} image - an HTML string that can be used in places where an <b>img</b> can be used
 * @property {tf.types.iconAnchor} anchor - the image's anchor
*/
/**
 * @public
 * @function
 * @summary - Uses the given callback to draw arbitrary content on the returned memory image, created with <b>toDataURL</b>
 * @param {object} settings - image creation settings
 * @param {tf.types.CreateMemoryImageDrawFunction} settings.drawFunction - the callback to draw content
 * @param {object} settings.drawSettings - object passed to <b>drawFunction</b>
 * @returns {tf.types.CreateMemoryImageResult} - | {@link tf.types.CreateMemoryImageResult} the image and it's anchor
*/
tf.canvas.CreateMemoryImage = function (settings) {
    settings = tf.js.GetValidObjectFrom(settings);
    var drawFunction = tf.js.GetFunctionOrNull(settings.drawFunction);
    var image, anchor;
    if (!!drawFunction) {
        //var useCanvas = !!settings.canvas ? settings.canvas : tf.GetStyles().GetHiddenCanvas();
        var useCanvas = document.createElement('canvas');
        var ctx = useCanvas.getContext("2d");
        //ctx.save();
        anchor = drawFunction(ctx, settings.drawSettings);
        //image = useCanvas.toDataURL("image/png");
        //image = ctx;
        //ctx.restore();
    }
    return { image: useCanvas, anchor: anchor };//{ image: image, anchor: anchor };
}
/**
 * method tf.canvas.PaintSlider - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} canvasElem - parameter description?
 * @param {?} width - parameter description?
 * @param {?} height - parameter description?
 * @param {?} thumbConstDim - parameter description?
 * @param {?} roundRectRadius - parameter description?
 * @param {?} backFillColor - parameter description?
 * @param {?} backStrokeColor - parameter description?
 * @param {?} thumbStrokeColor - parameter description?
 * @param {?} thumbFillColor - parameter description?
 * @param {?} thumbStrokeColorNoHover - parameter description?
 * @param {?} thumbFillColorNoHover - parameter description?
 * @param {?} mouseFillColor - parameter description?
 * @param {?} pos01 - parameter description?
 * @param {?} isInHover - parameter description?
 * @param {?} mouse01 - parameter description?
*/
tf.canvas.PaintSlider = function (
    canvasElem,
    width,
    height,
    thumbConstDim,
    roundRectRadius,
    backFillColor,
    backStrokeColor,
    thumbStrokeColor,
    thumbFillColor,
    thumbStrokeColorNoHover,
    thumbFillColorNoHover,
    mouseFillColor,
    pos01,
    isInHover,
    mouse01) {
    var fill = true;
    var stroke = true;
    canvasElem.width = width;
    canvasElem.height = height;
    var ctx = canvasElem.getContext("2d");
    ctx.save();
    ctx.translate(0.5, 0.5);
    ctx.canvas.width = width;
    ctx.canvas.height = height;
    ctx.beginPath();
    ctx.clearRect(0, 0, width, height);
    ctx.closePath();
    ctx.beginPath();
    ctx.fillStyle = backFillColor;
    ctx.strokeStyle = backStrokeColor;
    ctx.lineWidth = 2;
    tf.canvas.StrokeFillRoundRect(ctx, roundRectRadius / 2, roundRectRadius / 2, width - roundRectRadius, height - roundRectRadius, roundRectRadius, fill, stroke);
    ctx.closePath();
    var mid = Math.round(width * pos01);
    ctx.beginPath();
    if (isInHover) {
        var midMouse = Math.round(width * mouse01);
        ctx.lineWidth = 1;
        ctx.strokeStyle = "#fff";
        ctx.fillStyle = mouseFillColor;
        ctx.fillRect(midMouse - thumbConstDim + 1, 1, thumbConstDim + 1, height - 2);
        //ctx.strokeRect(midMouse - thumbConstDim, 1, thumbConstDim + 1, height - 2);
    }
    else {
        ctx.fillStyle = thumbStrokeColorNoHover;
        ctx.fillStyle = thumbFillColorNoHover;
        ctx.fillRect(2, 2, mid, height - 4);
    }
    ctx.closePath();
    ctx.lineWidth = 2;
    mid = Math.round(width * pos01);
    ctx.beginPath();
    ctx.strokeStyle = thumbStrokeColor;
    ctx.fillStyle = thumbFillColor;
    ctx.fillRect(mid - thumbConstDim + 1, 0, thumbConstDim + 1, height);
    //ctx.strokeRect(mid - thumbConstDim, 0, thumbConstDim + 1, height);
    ctx.closePath();
    ctx.restore();
};
/**
 * class tf.dom.Canvas - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
*/
tf.dom.Canvas = function () {
    var theThis = null, canvasElem = null, canvasCtx = null, repaintCallBack = null, repaintCallBackThis = null;
/**
 * method tf.dom.Canvas.Repaint - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.Repaint = function () { return paintCanvas(); }
/**
 * method tf.dom.Canvas.SetRepaint - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} repaintCallBackSet - parameter description?
 * @param {?} repaintCallBackThisSet - parameter description?
*/
    this.SetRepaint = function (repaintCallBackSet, repaintCallBackThisSet) {
        repaintCallBack = tf.js.GetFunctionOrNull(repaintCallBackSet);
        repaintCallBackThis = repaintCallBackThisSet;
    }
    function paintCanvas() {
        if (!!repaintCallBack) {
            var pixWidth = canvasElem.clientWidth; var pixHeight = canvasElem.clientHeight; canvasElem.width = pixWidth; canvasElem.height = pixHeight;
            canvasCtx.save(); repaintCallBack.call(repaintCallBackThis, theThis, canvasCtx, pixWidth, pixHeight); canvasCtx.restore();
        }
    }
    function initialize() {
        var divObj = new tf.dom.Div({ cssClass: tf.GetStyles().GetUnPaddedDivClassNames(false, true) });
        canvasElem = document.createElement('canvas');
        canvasElem.style.width = '100%';
        canvasElem.style.height = '100%';
        canvasCtx = canvasElem.getContext("2d");
        divObj.AddContent(canvasElem);
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: divObj.GetHTMLElement() });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
}
tf.js.InheritFrom(tf.dom.Canvas, tf.dom.Insertable);
/**
 * class tf.ui.CanvasSlider - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} initPos01 - parameter description?
 * @param {?} controlHeight - parameter description?
 * @param {?} hoverDrawBool - parameter description?
*/
tf.ui.CanvasSlider = function (initPos01, controlHeight, hoverDrawBool) {
    var theThis, docMouseListener, styles;
    var paintSlider, slideConstDim, thumbConstDim;
    var divObj, divElem, canvasElem, pos01, hover01, mouse01;
    var thumbFillColorHover, thumbStrokeColorHover, backFillColorHover, backStrokeColorHover;
    var thumbFillColorNoHover, thumbStrokeColorNoHover, backFillColorNoHover, backStrokeColorNoHover;
    var thumbFillColor, thumbStrokeColor, backFillColor, backStrokeColor;
    var mouseFillColor;
    var mouseMoveCallBack, thisMouseMoveCallBack;
    var clickCallBack, thisClickCallBack;
    var hoverCallBack, thisHoverCallBack;
    var hoverListener;
    var isInHover;
    var isInDrag;
/**
 * method tf.ui.CanvasSlider.GetIsInDrag - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetIsInDrag = function () { return isInDrag; }
/**
 * method tf.ui.CanvasSlider.GetIsInHover - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetIsInHover = function () { return isInHover; }
/**
 * method tf.ui.CanvasSlider.GetHover01 - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetHover01 = function () { return hover01; }
/**
 * method tf.ui.CanvasSlider.GetMouse01 - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetMouse01 = function () { return mouse01; }
/**
 * method tf.ui.CanvasSlider.SetOnClickListener - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} theCallBack - parameter description?
 * @param {?} theThisForCallBack - parameter description?
*/
    this.SetOnClickListener = function (theCallBack, theThisForCallBack) {
        clickCallBack = typeof theCallBack === "function" ? theCallBack : null;
        thisClickCallBack = theThisForCallBack;
    }
/**
 * method tf.ui.CanvasSlider.SetOnHoverListener - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} theCallBack - parameter description?
 * @param {?} theThisForCallBack - parameter description?
*/
    this.SetOnHoverListener = function (theCallBack, theThisForCallBack) {
        hoverCallBack = typeof theCallBack === "function" ? theCallBack : null;
        thisHoverCallBack = theThisForCallBack;
    }
/**
 * method tf.ui.CanvasSlider.SetOnMouseMoveListener - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} theCallBack - parameter description?
 * @param {?} theThisForCallBack - parameter description?
*/
    this.SetOnMouseMoveListener = function (theCallBack, theThisForCallBack) {
        mouseMoveCallBack = typeof theCallBack === "function" ? theCallBack : null;
        thisMouseMoveCallBack = theThisForCallBack;
    }
/**
 * method tf.ui.CanvasSlider.Repaint - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.Repaint = function () { paintCanvas(); }
/**
 * method tf.ui.CanvasSlider.SetPos01 - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} pos01Set - parameter description?
*/
    this.SetPos01 = function (pos01Set) { return setPos01(pos01Set, true); }
/**
 * method tf.ui.CanvasSlider.GetPos01 - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetPos01 = function () { return pos01; }
/**
 * method tf.ui.CanvasSlider.SetColors - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} thumbFillColorSet - parameter description?
 * @param {?} thumbStrokeColorSet - parameter description?
 * @param {?} backFillColorSet - parameter description?
 * @param {?} backStrokeColorSet - parameter description?
*/
    this.SetColors = function (thumbFillColorSet, thumbStrokeColorSet, backFillColorSet, backStrokeColorSet) { return setColors(thumbFillColorSet, thumbStrokeColorSet, backFillColorSet, backStrokeColorSet); }
/**
 * method tf.ui.CanvasSlider.SetMouseFillColor - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} mouseFillColorSet - parameter description?
*/
    this.SetMouseFillColor = function (mouseFillColorSet) { mouseFillColor = mouseFillColorSet; paintCanvas(); }
    function setColors(thumbFillColorSet, thumbStrokeColorSet, backFillColorSet, backStrokeColorSet) {
        thumbFillColor = thumbFillColorSet;
        thumbStrokeColor = thumbStrokeColorSet;
        backFillColor = backFillColorSet;
        backStrokeColor = backStrokeColorSet;
    }
    function setPos01(pos01Set, doRepaint) {
        pos01 = tf.js.GetFloatNumberInRange(pos01Set, 0, 1, 0.5);
        if (doRepaint) { paintCanvas(); }
    }
    function setPosSlideColors(hoverColorsBool) {
        if (!!hoverColorsBool && hoverDrawBool) {
            setColors(thumbFillColorHover, thumbStrokeColorHover, backFillColorHover, backStrokeColorHover);
        }
        else {
            setColors(thumbFillColorNoHover, thumbStrokeColorNoHover, backFillColorNoHover, backStrokeColorNoHover);
        }
    }
    function paintCanvas() {
        var roundRectRadius = 2;
        paintSlider(canvasElem, divElem.clientWidth, divElem.clientHeight, thumbConstDim, roundRectRadius,
            backFillColor, backStrokeColor, thumbStrokeColor, thumbFillColor, thumbStrokeColorNoHover, thumbFillColorNoHover, mouseFillColor,
            pos01, isInHover && !isInDrag && hoverDrawBool, mouse01);
    }
    function notifyPos01Change() { if (clickCallBack) { clickCallBack.call(thisClickCallBack, theThis, pos01); } }
    function onMouseEvent(ev) {
        var mousePosXY = !!ev.mouseCoords ? ev.mouseCoords : tf.events.GetMouseEventCoords(ev);
        var width = divElem ? divElem.offsetWidth : 0;
        var click01 = width ? mousePosXY[0] / width : 0;
        if (isInDrag) {
            if (click01 != pos01) {
                setPos01(click01, true);
                if (click01 <= 0) {
                    console.log('here');
                }
                notifyPos01Change();
            }
        }
        else if (click01 != mouse01) { mouse01 = click01; }
        if (mouseMoveCallBack) {
            mouseMoveCallBack.call(thisClickCallBack, theThis, mouse01);
        }
    }
    function onMouseDnSlide(ev) { isInDrag = true; /*docMouseListener.SetCapture(onMouseEvent, theThis, null);*/ onMouseEvent(ev); }
    function onMouseUpSlide(ev) { isInDrag = false; /*docMouseListener.ReleaseCapture();*/ onMouseEvent(ev); }
    function onMouseMoveSlide(ev) { onMouseEvent(ev); }
    var wasInHover = false;
    function onHover() {
        if (isInHover = hoverListener.GetIsInHover()) {
            isInDrag = false;
        }
        setPosSlideColors(isInHover);
        if (wasInHover != isInHover) {
            wasInHover = isInHover;
            paintCanvas();
        }
        var mousePosXY = tf.events.GetMouseEventCoords(hoverListener.GetLastEvent());
        var width = divElem ? divElem.offsetWidth : 0;
        var click01 = width ? mousePosXY[0] / width : 0;
        if (click01 != hover01) {
            hover01 = click01;
            if (hoverCallBack) { hoverCallBack.call(thisHoverCallBack, theThis, hover01); }
        }
    }
    function initialize() {
        styles = tf.GetStyles();
        paintSlider = tf.canvas.PaintSlider;
        slideConstDim = controlHeight ? controlHeight : "0.8em";
        thumbConstDim = 4;
        mouseFillColor = styles.GetSubStyles().disabledTextColor;
        thumbFillColorHover = "#FFF"; thumbStrokeColorHover = styles.GetButtonBGColor(true); backFillColorHover = styles.GetButtonBGColor(true); backStrokeColorHover = "#333";
        thumbFillColorNoHover = styles.GetButtonBGColor(true); thumbStrokeColorNoHover = styles.GetButtonBGColor(true); backFillColorNoHover = "#fff"; backStrokeColorNoHover = "#bfbfbf";
        thumbFillColor = thumbFillColorNoHover;
        thumbStrokeColor = thumbStrokeColorNoHover;
        backFillColor = backFillColorHover;
        backStrokeColor = backStrokeColorHover;
        isInHover = isInDrag = false;
        docMouseListener = tf.GetDocMouseListener();
        hoverDrawBool = !!hoverDrawBool;
        divObj = new tf.dom.Div({ cssClass: styles.unPaddedBlockDivClass });
        divElem = divObj.GetHTMLElement();
        canvasElem = document.createElement('canvas');
        canvasElem.style.width = '100%';
        canvasElem.style.height = '100%';
        divElem.style.height = slideConstDim;
        divElem.style.width = "1px";
        var listeners = {
            "mousemove": onMouseMoveSlide,
            "mouseup": onMouseUpSlide,
            "mousedown": onMouseDnSlide
        };
        for (var i in listeners) { tf.events.AddDOMEventListener(divElem, i, listeners[i]); }
        hoverListener = new tf.events.DOMHoverListener({ target: divElem, callBack: onHover, optionalScope: theThis, callBackSettings: null });
        setPos01(initPos01, false);
        setPosSlideColors(false);
        divObj.AddContent(canvasElem);
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: divObj });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.ui.CanvasSlider, tf.dom.Insertable);

// SOURCE FILE: urlparams.js
/**
 * A callback function to receive the notification that the function [CreateURLAPIMaps]{@link tf.urlapi.CreateURLAPIMaps} has finished the process of creating all maps
 * @public
 * @callback tf.types.CreateURLAPIMapsCallBack
 * @param {object} notification - the notification
 * @param {tf.types.URLParametersObject} notification.parameters - url parameters in {@link object} format
 * @param {enumerable<tf.map.Map>} notification.maps - an enumerable containing the maps created
 * @param {enumerable<tf.urlapi.DLayerList>} notification.dLayers - an enumerable containing the [DLayer Lists]{@link tf.urlapi.DLayerList} created
 * @returns {void} - | {@link void} no return value
 */
/**
 * @public
 * @function
 * @summary - creates and configures one or more [Map]{@link tf.map.Map} instances based on the given settings, including url parameters, and adds them to the given containers.
 * Notifies a callback when all maps are created
 * @param {object} settings - creation settings
 * @param {tf.types.CreateURLAPIMapsCallBack} settings.onCreated - a mandatory callback to receive a notification when all maps are created
 * @param {object} settings.optionalScope - optional scope used with <b>onCreated</b>
 * @param {enumerable<HTMLElementLike>} settings.mapContainers - a mandatory enumerable of the containers to which map instances are added
 * @param {boolean} settings.allowDLayers - set to <b>false</b> to prevent the creation of a [DLayer List]{@link tf.urlapi.DLayerList} specified by [URL Parameters]{@link tf.types.URLParameters}, defaults to <b>true</b>
 * @param {function} settings.dLayersPreProcessDataItem - passed to [DLayer List]{@link tf.urlapi.DLayerList}, defaults to {@link void} 
 * @param {tf.types.URLParameters} settings.parameters - optional parameters to initialize the maps, dlayers
 * @returns {void} - | {@link void} no return value
*/
tf.urlapi.CreateURLAPIMaps = function (settings) {
    if (tf.js.GetIsValidObject(settings) && tf.js.GetIsValidObject(settings.mapContainers)) {
        var onCreatedCallBack = tf.js.GetFunctionOrNull(settings.onCreated);
        if (!!onCreatedCallBack) {
            var parameters = settings.parameters;
            if (!tf.js.GetIsValidObject(parameters)) {
                if (tf.js.GetIsString(parameters)) {
                    parameters = tf.urlapi.ParseURLAPIParameters(parameters);
                }
                else { parameters = {}; }
            }
            var dLayersAllowed = tf.js.GetBoolFromValue(settings.allowDLayers, true);
            var nDLayerExtent = tf.js.GetIntNumberInRange(parameters[tf.consts.paramNameDLExtent], 0, 999, 0);
            //nDLayerExtent = true;
            var viewCenterLat = tf.js.GetLatitudeFrom(parameters[tf.consts.paramNameLat]);
            var viewCenterLon = tf.js.GetLongitudeFrom(parameters[tf.consts.paramNameLon]);
            if (!parameters[tf.consts.paramNamePanels]) { parameters[tf.consts.paramNamePanels] = tf.consts.defaultPanels; }
            if (parameters[tf.consts.paramNameTFLogo] === tf.consts.tfLogoOffStr) { parameters[tf.consts.paramNameTFLogo] = false; } else { parameters[tf.consts.paramNameTFLogo] = true; }
            var panelParams = tf.js.GetNonEmptyString(parameters[tf.consts.paramNamePanels], '');
            var mapEngine = tf.map.GetMapEngineFrom(parameters[tf.consts.paramNameFMap]);
            if (parameters[tf.consts.paramNameTFLogo]) { panelParams += tf.consts.charSplitStrings + tf.consts.paramNameTFLogo; }
            var useMapNik2 = mapEngine == tf.consts.mapnik2Engine;
            if (useMapNik2) { delete parameters[tf.consts.paramNameLegend]; } else { delete parameters[tf.consts.paramNameLegendH]; }
            var linkTargetStr = parameters[tf.consts.paramLinkTargetStr];
            tf.urlapi.LoadRemoteParameters(parameters, createMaps);
        }
    }
    function createMaps() {
        function updateToggleButtonTexts(toggleButton, bool) {
            var text = bool ? "2D view" : "3D view";
            var toolTip = bool ? "Switch to 2D view" : "Switch to 3D view";
            toggleButton.SetText(text); toggleButton.ChangeToolTip(toolTip);
        }
        var mapLegendStr = useMapNik2 ? tf.urlapi.RemovePlugInPhotoFromLegend(parameters[tf.consts.paramNameLegendM]).legendStr : null;
        var hybridLegendStr = useMapNik2 ? parameters[tf.consts.paramNameLegendH] : parameters[tf.consts.paramNameLegend];
        var legendAndPlugInPhoto = tf.urlapi.RemovePlugInPhotoFromLegend(hybridLegendStr);
        hybridLegendStr = legendAndPlugInPhoto.legendStr;
        var messageTimeout = tf.js.GetFloatNumberInRange(parameters[tf.consts.paramNameMessageTimeout], tf.consts.minMessageTimeout, tf.consts.maxMessageTimeout, tf.consts.defaultMessageTimeout);
        //var dLayercenter = { Latitude: viewCenterLat, Longitude: viewCenterLon };
        var mapSettings = {
            fullScreenContainer: settings.fullScreenContainer,
            center: [viewCenterLon, viewCenterLat],
            mapType: parameters[tf.consts.paramNameType],
            mapAerialSource: parameters[tf.consts.paramNameSource],
            mapLayerSourceURL: parameters[tf.consts.mapLayerSourceName],
            mapEngine: mapEngine,
            panels: panelParams,
            addressBarText: parameters[tf.consts.paramNameAddress],
            addressBarHelp: parameters[tf.consts.paramNameHelp],
            panOnClick: true,
            goDBOnDoubleClick: true,
            legendH: hybridLegendStr,
            legendM: mapLegendStr,
            messageTimeout: messageTimeout,
            vidParam: parameters[tf.consts.paramNameVid],
            passThroughString: parameters[tf.consts.paramNamePassThrough],
            level: parameters[tf.consts.paramNameLevel],
            resolution: parameters[tf.consts.paramNameRes],
            linkTargetStr: linkTargetStr
        };
        var allMaps = [], allDLayers = [], allPerspectiveMaps = [], allPerspectiveDLayers = [], perspectiveMapToggleButtons = [];
        var dLayersInfo = dLayersAllowed ? tf.urlapi.GetDLayersInfoFromURLParameters(parameters) : [];
        var hasDLayers = dLayersAllowed ? tf.js.GetIsNonEmptyArray(dLayersInfo) : false;
        var usePerspectiveMap = parameters[tf.consts.paramNamePerspectiveMap], perspectiveMapIsInitiallyVisible;
        var actualDLayersPreProcessServiceData = tf.js.GetFunctionOrNull(settings.dLayersPreProcessServiceData);
        var styles;
        if (usePerspectiveMap != undefined && tf.js.GetIsValidObject(tf.webgl) && tf.webgl.PerspectiveMap !== undefined) {
            if (tf.webgl.GetWebGL().GetHasWebGL()) {
                perspectiveMapIsInitiallyVisible = tf.js.GetBoolFromValue(usePerspectiveMap);
                usePerspectiveMap = true;
                styles = tf.GetStyles();
            }
            else {
                usePerspectiveMap = perspectiveMapIsInitiallyVisible = false;
            }
        }
        var toggleButtonSpecs = { position: 'absolute', bottom: '0.5em', marginLeft: '50%', transform: "translate(-50%, 0)", zIndex: 2 };
        for (var i in settings.mapContainers) {
            var thisContainer = settings.mapContainers[i];
            if (tf.dom.GetHTMLElementFrom(thisContainer)) {
                mapSettings.container = thisContainer;
                var map = new tf.map.Map(mapSettings);
                var perspectiveMap, perspectiveDLayer;
                var dLayersPreProcessServiceData = !!usePerspectiveMap ?
                    function (index) {
                        return function (data, dLayer) {
                            var mapDLayers = allPerspectiveDLayers[index];
                            if (!!mapDLayers) { mapDLayers.PreProcessServiceData(data, dLayer); }
                            if (!!actualDLayersPreProcessServiceData) { actualDLayersPreProcessServiceData(data, dLayer); }
                        }
                    }(allPerspectiveDLayers.length) :
                    actualDLayersPreProcessServiceData;
                var dLayers = hasDLayers ? new tf.urlapi.DLayerList({
                    dLayersInfo: dLayersInfo, map: map, preProcessDataItem: settings.dLayersPreProcessDataItem, preProcessServiceData: dLayersPreProcessServiceData,
                    nDLayerExtent: nDLayerExtent,
                    linkTargetStr: linkTargetStr
                }) : undefined;
                allMaps.push(map);
                if (!!usePerspectiveMap) {
                    perspectiveMap = new tf.webgl.PerspectiveMap({ map: map, isVisible: perspectiveMapIsInitiallyVisible });
                    allPerspectiveMaps.push(perspectiveMap);
                    var toggleButton = new tf.ui.TextBtn({ style: styles.mapTextBtnClass, label: "", /*onClick: onToggleClick,*/ tooltip: "", dim: 20 });
                    var onToggleClick = function (perspectiveMap, toggleButton) {
                        return function () {
                            var bool = !perspectiveMap.GetIsVisible();
                            perspectiveMap.SetIsVisible(bool);
                            updateToggleButtonTexts(toggleButton, bool);
                        }
                    }(perspectiveMap, toggleButton);
                    var onPerspectiveMapVisibilityChange = function (perspectiveMap, toggleButton) {
                        return function (notification) {
                            var bool = perspectiveMap.GetIsVisible();
                            updateToggleButtonTexts(toggleButton, bool);
                        }
                    }(perspectiveMap, toggleButton);
                    perspectiveMap.AddListener(tf.consts.perspectiveMapVisibilityChangeEvent, onPerspectiveMapVisibilityChange);
                    toggleButton.SetOnClick(onToggleClick);
                    updateToggleButtonTexts(toggleButton, perspectiveMapIsInitiallyVisible);
                    styles.ApplyStyleProperties(toggleButton, toggleButtonSpecs);
                    toggleButton.AppendTo(map.GetMapMapContainer());
                    perspectiveMapToggleButtons.push(toggleButton);
                }
                if (!!dLayers) {
                    allDLayers.push(dLayers);
                    if (!!usePerspectiveMap) {
                        var perspectiveDLayer = new tf.webgl.PerspectiveDLayers({ perspectiveMap: perspectiveMap });
                        allPerspectiveDLayers.push(perspectiveDLayer);
                    }
                }
            }
        }
        var notification = {
            parameters: parameters, maps: allMaps, dLayers: allDLayers,
            perspectiveMaps: allPerspectiveMaps, perspectiveDLayers: allPerspectiveDLayers,
            perspectiveToggleButtons: perspectiveMapToggleButtons
        };
        setTimeout(function () { onCreatedCallBack.call(settings.optionalScope, notification); }, 10);
    }
};
/**
 * Object returned by the function [RemovePlugInPhotoFromLegend]{@link tf.urlapi.RemovePlugInPhotoFromLegend}
 * @public
 * @typedef {object} tf.types.RemovePlugInPhotoFromLegendResult
 * @property {boolean} bla.requestedPlugInPhoto - set to <b>true</b> if the flag was found and removed, <b>false</b> otherwise
 * @property {tf.types.legendString} bla.legendStr - the legend string, either unchanged or without the flag
*/
/**
 * @public
 * @function
 * @summary - Checks for the presence and removes a flag requesting the creation of obsolete Geoimages layer from the given legend string
 * @param {tf.types.legendString} legendStr - the given legend string
 * @returns {tf.types.RemovePlugInPhotoFromLegendResult} - | {@link tf.types.RemovePlugInPhotoFromLegendResult} the flag and legend
*/
tf.urlapi.RemovePlugInPhotoFromLegend = function (legendStr) {
    var requestedPlugInPhoto = false;
    var legendStrUse = tf.js.GetNonEmptyString(legendStr, "");
    if (!!legendStr) {
        var unescapedLegend = unescape(legendStr);
        var legendArray = unescapedLegend.split(';');
        legendStrUse = "";
        for (var i = 0; i < legendArray.length; i++) {
            //tf.GetDebug().LogIfTest(legendArray[i]);
            if (legendArray[i].indexOf("plugin_photo") != -1) { requestedPlugInPhoto = true; }
            else { legendStrUse += legendArray[i] + ";"; }
        }
        legendStrUse = tf.js.ClipEndingChar(legendStrUse, ';');
    }
    return { requestedPlugInPhoto: requestedPlugInPhoto, legendStr: legendStrUse };
}
/**
 * Object returned by the function [BreakUrlParamString]{@link tf.urlapi.BreakUrlParamString}
 * @public
 * @typedef {object} tf.types.BreakUrlParamStringResult
 * @property {string} tag - either <b>'#'</b> or <b>'?'</b>
 * @property {string} urlPart - the portion of the string before <b>tag</b>
 * @property {string} paramsPart - the portion of the string after <b>tag</b>
*/
/**
 * @public
 * @function
 * @summary - Breaks a full url string into two parts separated by either a <b>'#'</b> or <b>'?'</b>
 * @param {string} strFullUrl - the given full url
 * @returns {tf.types.BreakUrlParamStringResult} - | {@link tf.types.BreakUrlParamStringResult} the broken parts
*/
tf.urlapi.BreakUrlParamString = function (strFullUrl) {
    var strFullUrlUse = tf.js.GetNonEmptyString(strFullUrl);
    var tag, urlPart, paramsPart;
    function splitStrInTwo (fullStr, splitChar) {
        var splitStr = fullStr.split(splitChar), leftSideStr = '', rightSideStr = '', didSplit;
        if (didSplit = (splitStr.length == 2)) { leftSideStr = splitStr[0]; rightSideStr = splitStr[1]; } else { leftSideStr = fullStr; rightSideStr = ''; }
        return { leftSideStr: leftSideStr, rightSideStr: rightSideStr, didSplit: didSplit };
    }
    if (!!strFullUrlUse) {
        var charsSplit = ['#', '?'];
        var split;
        for (var c in charsSplit) {
            var splitChar = charsSplit[c];
            if ((split = splitStrInTwo(strFullUrlUse, splitChar)).didSplit) {
                tag = splitChar;
                urlPart = split.leftSideStr;
                paramsPart = split.rightSideStr;
                break;
            }
        }
        if (!split.didSplit) {
            tag = '?';
            urlPart = strFullUrlUse;
            paramsPart = '';
        }
    }
    else { tag = '?'; urlPart = ''; paramsPart = ''; }
    return { tag: tag, urlPart: urlPart, paramsPart: paramsPart };
}
/**
 * @public
 * @function
 * @summary - Modifies a full url string by breaking it with {@link tf.urlapi.BreakUrlParamString} and then
 * concatenating the url part, the tag, the given defaults string, the original params part, and the given overrides string, in that order
 * @param {string} strOriginalURL - the given full url
 * @param {string} strDefaults - the given default parameters
 * @param {string} strOverrides - the given override parameters
 * @returns {string} - | {@link string} the modified url
*/
tf.urlapi.ModifyURLParamString = function (strOriginalURL, strDefaults, strOverrides) {
    var strOriginalURLUse = tf.js.GetNonEmptyString(strOriginalURL);
    var strDefaultsUse = tf.js.GetNonEmptyString(strDefaults);
    var strOverridesUse = tf.js.GetNonEmptyString(strOverrides);
    var urlBroken = tf.urlapi.BreakUrlParamString(strOriginalURLUse);
    var paramsPart = urlBroken.paramsPart;
    if (!!strDefaultsUse) {
        if (paramsPart.length > 0 && paramsPart.charAt(0) != '&') { paramsPart = '&' + paramsPart; }
        paramsPart = strDefaultsUse + paramsPart;
    }
    if (!!strOverridesUse) { paramsPart += strOverridesUse; }
    return urlBroken.urlPart + urlBroken.tag + paramsPart;
}
/**
 * @public
 * @function
 * @summary - Parses the given full url string for parameters to be merged with the given defaults, unescapes parameter values, converts property names to lowercase
 * @param {string} fullURL - the given full url
 * @param {object} defaultParameters - the given default parameters
 * @returns {object} - | {@link object} the <b>fullURL</b> parameters combined with the <b>defaultParameters</b> in object format
*/
tf.urlapi.ParseURLParameters = function (fullURL, defaultParameters) {
    var parameters = tf.js.GetIsValidObject(defaultParameters) ? defaultParameters : {};
    if (tf.js.GetIsNonEmptyString(fullURL)) {
        var urlBroken = tf.urlapi.BreakUrlParamString(fullURL);
        var paramsPart = urlBroken.paramsPart;
        var paramStringArray = paramsPart.split("&");
        var paramStringArrayLen = paramStringArray.length;
        if (paramStringArrayLen) {
            for (var i = 0; i < paramStringArrayLen; ++i) {
                var equalIndex = paramStringArray[i].indexOf("=");
                if (equalIndex != -1) {
                    var key = paramStringArray[i].substring(0, equalIndex).toLowerCase();
                    var value = paramStringArray[i].substring(equalIndex + 1, paramStringArray[i].length);
                    parameters[key] = unescape(value);
                }
            }
        }
    }
    else if (tf.js.GetIsValidObject(fullURL)) { parameters = tf.js.ShallowMerge(parameters, fullURL); }
    return parameters;
}
/**
 * @public
 * @function
 * @summary - Parses the given full url string for parameters to be merged with the default values of TerraFly {@link tf.types.URLParameters}
 * @param {string} fullURL - the given full url
 * @param {object} overrideDefaults - optional object containing default values, defaults to {@link void}
 * @returns {object} - | {@link object} the <b>fullURL</b> parameters combined with the defaults
*/
tf.urlapi.ParseURLAPIParameters = function (fullURL, overrideDefaults) {
    var defaultParameters = {};
    defaultParameters[tf.consts.paramNameLat] = tf.consts.defaultLatitude;
    defaultParameters[tf.consts.paramNameLon] = tf.consts.defaultLongitude;
    defaultParameters[tf.consts.paramNameRes] = undefined; //tf.consts.defaultRes;
    defaultParameters[tf.consts.paramNameLevel] = tf.consts.defaultLevel;
    defaultParameters[tf.consts.paramNamePanels] = tf.consts.defaultPanels;
    defaultParameters[tf.consts.paramNameLegend] = tf.consts.defaultLegend;
    defaultParameters[tf.consts.paramNameLegendH] = tf.consts.defaultLegendH;
    defaultParameters[tf.consts.paramNameLegendM] = tf.consts.defaultLegendM;
    defaultParameters[tf.consts.paramNameAddress] = tf.consts.defaultAddress;
    defaultParameters[tf.consts.paramNameVid] = tf.consts.defaultVid;
    defaultParameters[tf.consts.paramNamePassThrough] = tf.consts.defaultTFPassThrough;
    defaultParameters[tf.consts.paramNameTFLogo] = tf.consts.defaultTFLogoOn ? tf.consts.tfLogoOnStr : tf.consts.tfLogoOffStr;
    defaultParameters[tf.consts.paramNameType] = tf.consts.typeNameHybrid;
    defaultParameters[tf.consts.paramNameFMap] = tf.consts.defaultFMap;
    defaultParameters[tf.consts.paramNameSource] = tf.consts.defaultSourceName;
    defaultParameters[tf.consts.paramNameMessageTimeout] = tf.consts.defaultMessageTimeout;
    defaultParameters[tf.consts.paramNameHelp] = tf.consts.defaultHelp;
    defaultParameters[tf.consts.paramNameApps] = tf.consts.defaultApps;
    defaultParameters[tf.consts.paramLinkTargetStr] = '_top';
    if (tf.js.GetIsValidObject(overrideDefaults)) { defaultParameters = tf.js.ShallowMerge(defaultParameters, overrideDefaults); }
    var parameters = tf.urlapi.ParseURLParameters(fullURL, defaultParameters);
    var addressStr = parameters[tf.consts.paramNameAddress];
    addressStr = typeof addressStr === "string" ? addressStr.replace(/\+/g, " ") : "";
    parameters[tf.consts.paramNameAddress] = addressStr;
    return parameters;
}
/**
 * @public
 * @function
 * @summary - Retrieves the actual value of some url parameters from remote files or services
 * @param {tf.types.URLParametersObject} parameters - the given parameters, in {@link object} format
 * @param {function} callBack - a function called (without parameters) after all remote url parameters are retrieved
 * @returns {void} - | {@link void} no return value
*/
tf.urlapi.LoadRemoteParameters = function (parameters, callBack) {
    var nParamsToProcess = 0;
    function setTimeoutCallBack() { if (!!callBackUse) { setTimeout(function () { callBackUse() }, 10); } }
    function onLoadedParam(paramName, param) { parameters[paramName] = param; if (nParamsToProcess > 1) { --nParamsToProcess } else { setTimeoutCallBack(); } }
    if (tf.js.GetIsValidObject(parameters)) {
        var callBackUse = tf.js.GetFunctionOrNull(callBack);
        var paramsWithDDURLDD = [ tf.consts.paramNameLegend, tf.consts.paramNameLegendH, tf.consts.paramNameLegendM ];
        var paramsWithDDURLDDCount = paramsWithDDURLDD.length;
        if (!!paramsWithDDURLDDCount) {
            for (var i in paramsWithDDURLDD) { if (parameters[paramsWithDDURLDD[i]]) { ++nParamsToProcess; } }
            if (!!nParamsToProcess) {
                for (var i = 0 ; i < paramsWithDDURLDDCount ; i++) {
                    var thisParamName = paramsWithDDURLDD[i];
                    var thisParam = parameters[thisParamName];
                    if (thisParam) { new tf.urlapi.URLPartsLoader(thisParamName, thisParam, onLoadedParam); }
                }
            }
            else { setTimeoutCallBack(); }
        }
        else { setTimeoutCallBack(); }
    }
}
/**
 * @private
 * @class
 * @summary - Retrieves one remote url parameter and notifies a callback. Used internally by the API
 * @param {string} paramName - the name of the parameter, in {@link object} format
 * @param {string} initialParam - the initial parameter value, containing a remote reference enclosed with '$$' strings (prefix and suffix)
 * @param {function} onLoadedParamParts - called when all parts of this parameter have been loaded, receiving the loaded parameter name and its value, in that order
 * @returns {void} - | {@link void} no return value
*/
tf.urlapi.URLPartsLoader = function (paramName, initialParam, onLoadedParamParts) {
    var theThis, paramParts, paramPartsCounter;
    /**
     * @public
     * @function
     * @summary - Retrieves initial parameter value, containing a remote reference enclosed with '$$' strings (prefix and suffix)
     * @returns {string} - | {@link string} the parameter value
    */
    this.GetInitialParam = function () { return initialParam; }
    function loadParamParts(param) {
        if (param.indexOf(tf.consts.urlPartsSeparatorStr) != -1) {
            paramParts = param.split(tf.consts.urlPartsSeparatorStr);
            paramPartsCounter = 0;
            for (var i = 1; i < paramParts.length; i += 2) {
                paramPartsCounter++;
                new tf.ajax.GetRequest({ url: paramParts[i], onDataLoaded: onURLPartLoaded, requestProps: i, autoSend: true, overrideMimeType: 'text/plain', useRedirect: false });
            }
        }
        else { onLoadedParamParts.call(undefined, paramName, param); }
    }
    function onURLPartLoaded(notification) {
        if (notification.httpRequest.status == 200) {
            var content = unescape(notification.httpRequest.responseText);
            paramParts[notification.requestProps] = content.replace(/[\r\n]/g, "");
            if (! --paramPartsCounter) { combineParameters(); }
        }
    }
    function combineParameters() {
        var result = ""; for (var i = 0; i < paramParts.length; i++) { result += paramParts[i]; } loadParamParts(result);
    }
    function initialize() { loadParamParts(initialParam); }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Settings extracted by the function [GetDLayersInfoFromURLParameters]{@link tf.urlapi.GetDLayersInfoFromURLParameters} to be used in the creation of [DLayer]{@link tf.urlapi.DLayer} instances
 * @public
 * @typedef {object} tf.types.URLDLayerSettings
 * @property {string} - dLayerLegend - the name of the DLayer
 * @property {string} - dLayerData - the remote service associated with the DLayer
 * @property {string} - dLayerField - the name of the field to display as a [Map Feature]{@link tf.map.Feature}
 * @property {boolean} - dLayerSelect - the initial map visibility of the DLayer, <b>true</b> if visible, <b>false</b> otherwise
 * @property {string} - dLayerColor - the color with which to display text markers belonging to the DLayer
*/
/**
 * @public
 * @function
 * @summary - Extracts settings used to create a [DLayer List]{@link tf.urlapi.DLayerList} from the given url parameters 
 * @param {tf.types.URLParametersObject} parameters - the given parameters, in {@link object} format
 * @returns {enumerable<tf.types.URLDLayerSettings>} - | {@link enumerable} <{@link tf.types.URLDLayerSettings}> the retrieved settings
*/
tf.urlapi.GetDLayersInfoFromURLParameters = function (parameters) {
    var dLayers = [];
    if (tf.js.GetIsValidObject(parameters)) {
        var index = 0;
        if (getDLayerFromURL("", index)) { ++index; } if (getDLayerFromURL("0", index)) { ++index; } for (var iDLayer = 1 ; getDLayerFromURL(iDLayer, index) ; ++iDLayer) { ++index; }
    }
    function getDLayerFromURL(withSuffix, dLayerIndex) {
        var dLayerLegend;
        if (dLayerLegend = parameters[tf.consts.paramNameDLLegend + withSuffix]) {
            var dLayerData = parameters[tf.consts.paramNameDLData + withSuffix];
            var dLayerField = parameters[tf.consts.paramNameDLField + withSuffix];
            var dLayerSelect = tf.js.GetBoolFromValue(parameters[tf.consts.paramNameDLSelect + withSuffix], true);
            var dLayerColors = parameters[tf.consts.paramNameDLColor + withSuffix];
            if (!dLayerColors) { dLayerColors = ","; }
            var dLayerMarkerStyle = parameters["dLayerMarkerStyle" + withSuffix]
            var dLayerMarkerHoverStyle = parameters["dLayerMarkerHoverStyle" + withSuffix]
            if (!tf.js.GetIsValidObject(dLayerMarkerHoverStyle)) {
                dLayerMarkerHoverStyle = dLayerMarkerStyle;
            }
            dLayers.push({
                markerStyle: dLayerMarkerStyle,
                markerHoverStyle: dLayerMarkerHoverStyle,
                dLayerLegend: dLayerLegend, dLayerData: dLayerData, dLayerField: dLayerField, dLayerSelect: dLayerSelect, dLayerColors: dLayerColors, dLayerIndex: dLayerIndex
            });
            return true;
        }
        return false;
    }
    return dLayers;
};
tf.urlapi.ParseSplitStringWithSeparators = function (str) {
    return tf.js.ParseSplitStringWithSeparators(str, tf.consts.charSplitStrings);
};
tf.urlapi.AddStringWithSeparators = function (strBeingAddedTo, strToBeAdded) {
    return tf.js.AddStringWithSeparators(strBeingAddedTo, strToBeAdded, tf.consts.charSplitStrings);
};
tf.urlapi.AddStringsWithSeparatorsIfAbsent = function (strBeingAddedTo, strsToBeAdded) {
    return tf.js.AddStringsWithSeparatorsIfAbsent(strBeingAddedTo, strsToBeAdded, tf.consts.charSplitStrings);
};

// SOURCE FILE: listcontent.js
/**
 * Settings used in the creation of [Table Row]{@link tf.ui.TableRow} instances
 * @public
 * @typedef {object} tf.types.TableRowSettings
 * @property {tf.js.KeyedItem} keyedItem - an optional [Keyed Item]{@link tf.js.KeyedItem} instance to be associated with the Table Row
 * @property {tf.types.CSSStyleSpecs} style - Style assumed by the Table Row when unselected
 * @property {tf.types.CSSStyleSpecs} selectedStyle - Style assumed by the Table Row when selected
*/
/**
 * @public
 * @class
 * @summary A Table Row instance belongs to a single [Table]{@link tf.ui.Table} instance and displays application defined {@link HTMLContent}.
 * Applications create Table Rows and then add them to a [Table]{@link tf.ui.Table} using one of its functions [AppendRow]{@link tf.ui.Table#AppendRow}, 
 * [InsertRowAfter]{@link tf.ui.Table#InsertRowAfter}, and [InsertRowBefore]{@link tf.ui.Table#InsertRowBefore}
 * @param {tf.types.TableRowSettings} settings - creation settings
 */
tf.ui.TableRow = function (settings) {
    var theThis, savedDisplay, isShowing, styles, keyedItem;
    var domObj, domElement, container, hoverListener, isSelected, clickListener, style, selectedStyle;
    var colorSelected, colorUnSelected;
    /**
     * @public
     * @function
     * @summary - Retrieves the [Keyed Item]{@link tf.js.KeyedItem} instance associated with this Table Row instance, if one was associated during creation
     * @returns {tf.js.KeyedItem} - | {@link tf.js.KeyedItem} the associated item instance, or {@link void} if no instance was associated
    */
    this.GetKeyedItem = function () { return keyedItem; }
    /**
     * @public
     * @function
     * @summary - Shows or hides this instance
     * @param {boolean} bool - <b>true</b> to show, <b>false</b> to hide
     * @returns {void} - | {@link void} no return value
    */
    this.ShowOrHide = function (bool) { return showOrHide(bool); }
    /**
     * @public
     * @function
     * @summary - Checks if this instance is visible
     * @returns {boolean} - | {@link boolean} <b>true</b> if visible, <b>false</b> otherwise
    */
    this.IsShowing = function () { return isShowing; }
    /**
     * @public
     * @function
     * @summary - Retrieves the {@link tf.ui.Table} instance associated with this Table Row instance
     * @returns {tf.ui.Table} - | {@link tf.ui.Table} the table
    */
    this.GetTable = function () { return container; }
    /**
     * @public
     * @function
     * @summary - Removes any content that was previously added to this Table Row instance
     * @returns {void} - | {@link void} no return value
    */
    this.ClearContent = function () { domObj.ClearContent(); };
    /**
     * @public
     * @function
     * @summary - Replaces any content that was previously added to this Table Row instance with the given new content
     * @param {HTMLElementLike} elem - the new content
     * @returns {void} - | {@link void} no return value
    */
    this.ReplaceContent = function (elem) { this.ClearContent(); this.AppendRow(elem); }
    /**
     * @public
     * @function
     * @summary - Adds the given new content to contents that were previously added to this Table Row instance
     * @param {HTMLElementLike} elem - the new content
     * @returns {void} - | {@link void} no return value
    */
    this.AddContent = function (elem) {
        if (tf.js.GetIsNonEmptyString(elem)) { domElement.innerHTML = elem; }
        else { tf.dom.AddContent(elem, domElement); }
    }
    /**
     * @public
     * @function
     * @summary - If necessary, scrolls the associated [Table]{@link tf.ui.Table} to ensure that this Table Row instance is visible
     * @returns {void} - | {@link void} no return value
    */
    this.EnsureVisible = function () { if (!!container) { return container.EnsureVisible(theThis); } }
    /**
     * @public
     * @function
     * @summary - Selects this Table Row among all other rows in its associated [Table]{@link tf.ui.Table} instance
     * @param {boolean} ensureVisibleBool - set to <b>true</b> to scroll the table, if necessary, to make this instance visible
     * @param {boolean} bypassNotification - set to <b>true</b> to prevent the table from notifying a change in selection
     * @returns {void} - | {@link void} no return value
    */
    this.Select = function (ensureVisibleBool, bypassNotification) { return select(ensureVisibleBool, bypassNotification); }
    /**
     * @public
     * @function
     * @summary - Checks if this Table Row instance is the currently selected row in its associated [Table]{@link tf.ui.Table} instance.
     * @returns {boolean} - | {@link boolean} <b>true</b> if this row is selected, <b>false</b> otherwise
    */
    this.GetIsSelected = function () { return isSelected; }
    /**
     * @private
     * @function
     * @summary - Retrieves the {@link HTMLElementLike} used by this instance. Used internally by the API
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the element
    */
    this.privateGetHTMLElement = function () { return domElement; }
    /**
     * @private
     * @function
     * @summary - Changes this Table Row instance's style to reflect the given selected status. Used internally by the API
     * @param {boolean} bool - <b>true</b> if selected, <b>false</b> otherwise
     * @returns {void} - | {@link void} no return value
    */
    this.SetSelectedStyle = function (bool) { return setSelectedStyle(bool); }
    /**
     * @private
     * @function
     * @summary - Changes this Table Row instance's style to reflect the given selected status. Used internally by the API
     * @param {tf.ui.Table} containerSet
     * @returns {void} - | {@link void} no return value
    */
    this.OnAddToContainer = function (containerSet) { if (containerSet instanceof tf.ui.Table) { container = containerSet; } }
    /**
     * @private
     * @function
     * @summary - Removes this Table Row instance from its associated [Table]{@link tf.ui.Table} instance. Used internally by the API
     * @returns {void} - | {@link void} no return value
    */
    this.OnRemoveFromContainer = function () { container = null; }
    function setSelectedStyle(isSelectedSet) {
        var styleUse;
        if (isSelected = !!isSelectedSet) { styleUse = selectedStyle; } else { styleUse = style; }
        if (!!styleUse) { styles.ApplyStyleProperties(domElement, styleUse); }
        else { domElement.style.backgroundColor = isSelected ? colorSelected : colorUnSelected; }
    }
    function showOrHide(showBool) { if (isShowing != !!showBool) { isShowing = !!showBool; domElement.style.display = isShowing ? savedDisplay : 'none'; } }
    function select(ensureVisibleBool, bypassNotification) { if (!!container) { container.SelectRow(theThis, ensureVisibleBool, bypassNotification); } }
    function onHover(notification) {
        var content = notification.target, retVal = false;
        if (content) {
            if (notification.isInHover) {
                if (!!container) { retVal = container.OnHoverIntoContent(theThis); }
            }
        }
        return retVal;
    }
    function onClick(notification) {
        var retVal = false;
        if (!!container) { retVal = container.OnClickContent(theThis); }
        return retVal;
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        styles = tf.GetStyles();
        keyedItem = settings.keyedItem;
        var subStyles = styles.GetSubStyles();
        colorSelected = subStyles.containerDarkSelBackgroundColor;
        colorUnSelected = subStyles.containerDarkBackgroundColor;
        style = settings.style;
        selectedStyle = settings.selectedStyle;
        domObj = new tf.dom.Div({ cssClass: styles.listContentClass });
        domElement = domObj.GetHTMLElement();
        savedDisplay = 'block';
        hoverListener = new tf.events.DOMHoverListener({ target: domObj, callBack: onHover, optionalScope: theThis, callBackSettings: null });
        clickListener = new tf.events.DOMClickListener({ target: domObj, callBack: onClick, optionalScope: theThis, callBackSettings: null });
        isShowing = true;
        isSelected = false;
        setSelectedStyle(false);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Row selection notifications sent by {@link tf.ui.Table} instances
 * @public
 * @typedef {object} TableRowSelectNotification
 * @property {tf.ui.Table} sender - the instance sending the notification
 * @property {tf.ui.TableRow} selected - the [Table Row]{@link tf.ui.TableRow} instance that has been selected
 * @property {tf.ui.TableRow} prevSelected - the pleviously selected [Table Row]{@link tf.ui.TableRow} instance, or {@link void}
 * @property {boolean} isClick - <b>true</b> only if a mouse click event initiated the selection
 * @property {tf.ui.KeyedTable} keyedTable - the [Keyed Table]{@link tf.ui.KeyedTable} instance associated with the Table, if one was provided when the Table's was created
*/
/**
 * A callback function that can be used in the creation of instances of [Table]{@link tf.ui.Table}
 * @public
 * @callback tf.types.TableRowSelectCallBack
 * @param {tf.types.TableRowSelectNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * Settings used in the creation of [Table]{@link tf.ui.Table} instances
 * @public
 * @typedef {object} tf.types.TableSettings
 * @property {tf.ui.KeyedTable} keyedTable - an optional [Keyed Table]{@link tf.ui.KeyedTable} instance to be associated with the Table
 * @property {tf.types.TableRowSelectCallBack} onSelect - an optional callback to be notified of [Table Row]{@link tf.ui.TableRow} selection changes
 * @property {object} optionalScope - optional scope used with <b>onSelect</b>
 * @property {boolean} selectOnHover - Allows or prevents the Table from selecting a [Table Row]{@link tf.ui.TableRow} instance when the mouse pointer hovers over it
 * @property {tf.types.CSSStyleSpecs} style - Style assumed by the Table
*/
/**
 * @public
 * @class
 * @summary A Table instance is an [Insertable]{@link tf.dom.Insertable} implementing a standard vertical table with scrolling and contains zero or more 
 * [Table Row]{@link tf.ui.TableRow} instances, one of which can be marker as "Selected", either by calling the
 * function [SelectRow]{@link tf.ui.Table#SelectRow} of this Table, or when a mouse pointer click (and optionally hover)
 * event occurs on a row.
 * @param {tf.types.TableSettings} settings - creation settings
 * @extends {tf.dom.Insertable}
 */
tf.ui.Table = function (settings) {
    var theThis, containerObj, containerElem, optionalScope, onSelectCallBack, contents, nContents, selectedContent, selectOnHoverBool, keyedTable;
    /**
     * @public
     * @function
     * @summary - Retrieves the [Keyed Table]{@link tf.ui.KeyedTable} instance associated with this table instance, if one was associated during creation
     * @returns {tf.ui.KeyedTable} - | {@link tf.ui.KeyedTable} the associated instance, or {@link void} if no instance was associated
    */
    this.GetKeyedTable = function () { return keyedTable; }
    /**
     * @public
     * @function
     * @summary - Checks if this Table Instance automatically selects a [Table Row]{@link tf.ui.TableRow} instance when the mouse pointer hovers over it.
     * Selection of a row always occurs on mouse click events
     * @returns {boolean} - | {@link boolean} <b>true</b> if selection on hover is allowed, <b>false</b> otherwise
    */
    this.GetSelectOnHover = function () { return selectOnHoverBool; }
    /**
     * @public
     * @function
     * @summary - Allows or prevents this Table Instance to/from automatically selecting a [Table Row]{@link tf.ui.TableRow} instance when the mouse pointer hovers over it.
     * Selection of a row always occurs on mouse click events
     * @param {boolean} bool - <b>true</b> to allow select on hover, <b>false</b> to prevent it
     * @returns {void} - | {@link void} no return value
    */
    this.SetSelectOnHover = function (bool) { selectOnHoverBool = !!bool; }
    /**
     * @public
     * @function
     * @summary - Adds the given [Table Row]{@link tf.ui.TableRow] instance to the end of this Table instance
     * @param {tf.ui.TableRow} tableRow - the table row
     * @returns {void} - | {@link void} no return value
    */
    this.AppendRow = function (tableRow) {
        if (!!tableRow && tableRow instanceof tf.ui.TableRow) {
            tableRow.OnAddToContainer(theThis);
            containerObj.AddContent(tableRow.privateGetHTMLElement());
            contents.push(tableRow);
            ++nContents;
        }
    }
    
    /**
     * @public
     * @function
     * @summary - Inserts the the given [Table Row]{@link tf.ui.TableRow] instance before an existing row instance
     * @param {tf.ui.TableRow} tableRow - the table row to insert
     * @param {tf.ui.TableRow} existingTableRow - the existing table row, before which <b>tableRow</b> will be inserted
     * @returns {void} - | {@link void} no return value
    */
    this.InsertRowBefore = function (tableRow, existingTableRow) {
        if (
            (!!tableRow && tableRow instanceof tf.ui.TableRow) &&
            (!!existingTableRow && existingTableRow instanceof tf.ui.TableRow) &&
            existingTableRow.GetTable() == theThis) {
            tableRow.OnAddToContainer(theThis);
            containerObj.InsertContentBefore(tableRow.privateGetHTMLElement(), existingTableRow);
            contents.push(tableRow);
            ++nContents;
        }
    }
    /**
     * @public
     * @function
     * @summary - Inserts the the given [Table Row]{@link tf.ui.TableRow] instance after an existing row instance
     * @param {tf.ui.TableRow} tableRow - the table row to insert
     * @param {tf.ui.TableRow} existingTableRow - the existing table row, after which <b>tableRow</b> will be inserted
     * @returns {void} - | {@link void} no return value
    */
    this.InsertRowAfter = function (tableRow, existingTableRow) {
        if (
            (!!tableRow && tableRow instanceof tf.ui.TableRow) &&
            (!!existingTableRow && existingTableRow instanceof tf.ui.TableRow) &&
            existingTableRow.GetTable() == theThis) {
            tableRow.OnAddToContainer(theThis);
            containerObj.InsertContentAfter(tableRow.privateGetHTMLElement(), existingTableRow);
            contents.push(tableRow);
            ++nContents;
        }
    }
    /**
     * @public
     * @function
     * @summary - Removes the given [Table Row]{@link tf.ui.TableRow] instance from this Table instance
     * @param {tf.ui.TableRow} tableRow - the table row to remove
     * @returns {void} - | {@link void} no return value
    */
    this.DelRow = function (tableRow) {
        if (!!tableRow && tableRow instanceof tf.ui.TableRow && tableRow.GetTable() == theThis) {
            var index = contents.indexOf(tableRow);
            containerElem.removeChild(tableRow.privateGetHTMLElement());
            tableRow.OnRemoveFromContainer();
            if (index != -1) { contents.splice(index, 1); }
            --nContents;
            if (tableRow == selectContent) {
                var nextSelIndex = (index != -1 && nContents > 0) ? (index < nContents ? index : index - 1) : -1;
                if (nextSelIndex == -1) {
                    unselectContent();
                    notifySelect(tableRow, false);
                }
                else { selectContent(contents[nextSelIndex], true, false, false); }
            }
        }
    }
    /**
     * @public
     * @function
     * @summary - Removes all [Table Row]{@link tf.ui.TableRow] instances from this Table instance
     * @returns {void} - | {@link void} no return value
    */
    this.Clear = function () {
        nContents = contents.length;
        for (var i = 0 ; i < nContents ; ++i) { contents[i].OnRemoveFromContainer(); }
        contents = [];
        containerObj.ClearContent();
        selectedContent = null;
        nContents = 0;
    }
    this.GetRow = function (rowIndex) { return !!contents && nContents > 0 ? contents[rowIndex] : undefined; }
    /**
     * @public
     * @function
     * @summary - Retrieves the number of [Table Row]{@link tf.ui.TableRow] instances currently in this Table instance
     * @returns {number} - | {@link number} the number of table row instances
    */
    this.GetRowCount = function () { return nContents; }
    /**
     * @public
     * @function
     * @summary - Selects a [Table Row]{@link tf.ui.TableRow} instance among all other rows
     * @param {tf.ui.TableRow} tableRow - the table row to select
     * @param {boolean} ensureVisibleBool - set to <b>true</b> to scroll the table, if necessary, to make this instance visible
     * @param {boolean} bypassNotification - set to <b>true</b> to prevent the table from notifying a change in selection
     * @returns {void} - | {@link void} no return value
    */
    this.SelectRow = function (tableRow, ensureVisibleBool, bypassNotification) { return selectContent(tableRow, ensureVisibleBool, bypassNotification); }
    /**
     * @public
     * @function
     * @summary - Retrieves the currently selected [Table Row]{@link tf.ui.TableRow} instance
     * @returns {tf.ui.TableRow} - | {@link tf.ui.TableRow} the selected row, or {@link void} if no row is selected
    */
    this.GetSelectedRow = function () { return selectedContent; }
    this.UnselectRow = function () { return unselectContent(); }
    /**
     * @public
     * @function
     * @summary - If necessary, scrolls this Table instance to ensure that the given [Table Row]{@link tf.ui.TableRow} instance is visible
     * @param {tf.ui.TableRow} tableRow - the table row to select
     * @returns {void} - | {@link void} no return value
    */
    this.EnsureVisible = function (tableRow) { return ensureVisible(tableRow); }
    /**
     * @public
     * @function
     * @summary - If necessary, scrolls this Table instance to ensure that the currently selected [Table Row]{@link tf.ui.TableRow} instance is visible
     * @returns {void} - | {@link void} no return value
    */
    this.EnsureSelectedContentVisible = function () { return this.EnsureVisible(this.GetSelectedRow()); }
    /**
     * @private
     * @function
     * @summary - Used internally by the API
     * @param {tf.ui.TableRow} theContent - the table row
     * @returns {void} - | {@link void} no return value
    */
    this.OnHoverIntoContent = function (theContent) { return onHoverIntoContent(theContent); }
    /**
     * @private
     * @function
     * @summary - Used internally by the API
     * @param {tf.ui.TableRow} theContent - the table row
     * @returns {void} - | {@link void} no return value
    */
    this.OnClickContent = function (theContent) { return onClickContent(theContent); }
    /**
     * @private
     * @function
     * @summary - Retrieves the number of [Table Row]{@link tf.ui.TableRow] instances currently in this Table instance
     * @returns {number} - | {@link number} the number of table row instances
     * @deprecated
    */
    //this.GetContents = function () { return contents; }
    this.Sort = function (sortFnc) {
        if (!sortAndCheckIfChanged(sortFnc)) {
            reFill();
            //console.log('sort and refill');
        } //else { console.log('sort refill skip'); }
    }
    function reFill() {
        if (!!containerElem) {
            var outerContainer = containerElem.parentNode;
            var sp = !!outerContainer ? outerContainer.scrollTop : 0;
            containerObj.ClearContent();
            for (var i in contents) {
                var content = contents[i];
                containerObj.AddContent(content.privateGetHTMLElement());
            }
            if (!!outerContainer) { outerContainer.scrollTop = sp; }
        }
    }
    function sortAndCheckIfChanged(sortFnc) {
        var isSorted = true;
        if (tf.js.GetFunctionOrNull(sortFnc)) {
            var nContents = contents.length;
            if (nContents > 0) {
                var contentsCopy = contents.slice(0);
                contents.sort(sortFnc);
                for (var i = 0 ; (i < nContents) && isSorted ; ++i) {
                    isSorted = contentsCopy[i] == contents[i];
                }
            }
        }
        return isSorted;
    }
    function onClickContent(theContent) { selectContent(theContent, false, false, true); return true;}
    function onHoverIntoContent(theContent) { if (selectOnHoverBool) { selectContent(theContent, false, false, false); } }
    function ensureVisible(content) {
        if (!!content && content instanceof tf.ui.TableRow && content.GetTable() == theThis) {
            if (content = content.privateGetHTMLElement()) {
                var outerContainer = containerElem.parentNode;
                if (!!outerContainer) {
                    outerContainer.scrollTop = content.offsetTop - outerContainer.offsetTop;
                }
            }
        }
    }
    function unselectContent() {
        if (!!selectedContent) {
            selectedContent.SetSelectedStyle(false);
            selectedContent = null;
        }
    }
    function notifySelect(prevSel, isClick) {
        if (!!onSelectCallBack) { onSelectCallBack.call(optionalScope, { sender: theThis, selected: selectedContent, prevSelected: prevSel, isClick: !!isClick, keyedTable: keyedTable }); }
    }
    function selectContent(content, ensureVisibleBool, bypassNotification, isClick) {
        if (!!content && content instanceof tf.ui.TableRow) {
            if (content.GetTable() == theThis) {
                var prevSel = selectedContent;
                var alreadySelected = content == prevSel;
                if (!alreadySelected) {
                    unselectContent();
                    selectedContent = content;
                    selectedContent.SetSelectedStyle(true);
                }
                if (!!ensureVisibleBool) { ensureVisible(content); }
                if (!bypassNotification) { notifySelect(prevSel, isClick); }
            }
        }
    }
    function initialize() {
        var styles = tf.GetStyles();
        contents = [];
        nContents = 0;
        selectedContent = null;
        onSelectCallBack = tf.js.GetFunctionOrNull(settings.onSelect);
        optionalScope = settings.optionalScope;
        selectOnHoverBool = !!settings.selectOnHover;
        containerObj = new tf.dom.Div({ cssClass: tf.GetStyles().unPaddedBlockDivClass });
        containerElem = containerObj.GetHTMLElement();
        keyedTable = settings.keyedTable;
        if (tf.js.GetIsValidObject(settings.style)) { styles.ApplyStyleProperties(containerElem, settings.style); }
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: containerElem });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.ui.Table, tf.dom.Insertable);
/**
 * Content requests sent by {@link tf.ui.KeyedTable} instances
 * @public
 * @typedef {object} tf.types.KeyedRowTableRowContentRequest
 * @property {tf.ui.Table} sender - the instance sending the notification
 * @property {tf.js.KeyedItem} keyedItem - the [Keyed Item]{@link tf.js.KeyedItem} instance for which content is being requested
 * @property {object} properties - application defined properties provided in the creation of the [Keyed Table]{@link tf.ui.KeyedTable} instance
*/
/**
 * A callback function that provides content for [Table Row]{@link tf.ui.TableRow} instances in [Keyed Tables]{@link tf.ui.KeyedTable}
 * @public
 * @callback tf.types.KeyedRowTableGetContent
 * @param {tf.types.KeyedRowTableRowContentRequest} request - the request
 * @returns {HTMLElementLike} - | {@link HTMLElementLike} the requested content
 */
/**
 * Notifications sent by {@link tf.ui.KeyedTable} instances
 * @public
 * @typedef {object} tf.types.KeyedTableNotification
 * @property {tf.ui.Table} sender - the instance sending the notification
 * @property {tf.types.keyedFeatureListEventName} eventName - the name of the event
 * @property {object} properties - application defined properties provided in the creation of the [Keyed Table]{@link tf.ui.KeyedTable} instance
 * @property {tf.types.KeyedListEventNotification} keyedListNotification - the associated [Keyed List]{@link tf.js.KeyedList} notification
*/
/**
 * A callback function that receives change notifications from instances of [Keyed Table]{@link tf.ui.KeyedTable}
 * @public
 * @callback tf.types.KeyedTableCallBack
 * @param {tf.types.KeyedTableNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * Settings used in the creation of [Keyed Table]{@link tf.ui.KeyedTable} instances
 * @public
 * @typedef {object} tf.types.KeyedTableSettings
 * @property {tf.js.KeyedList} keyedList - the associated [Keyed List]{@link tf.js.KeyedList} instance
 * @property {tf.types.PropertyName} propertyName - the name of the [Keyed Item]{@link tf.js.KeyedItem} property to be associated with [Table Rows]{@link tf.ui.TableRow} in this table.
 * @property {object} optionalScope - optional JavaScript scope used in callBacks and notifications
 * @property {tf.types.KeyedTableCallBack} onContentChange - a callback to receive notifications from this table
 * @property {tf.types.KeyedRowTableGetContent} getRowContent - a callback to provide content for [Table Row]{@link tf.ui.TableRow} instances in this table
 * @property {object} properties - application defined properties, passed to notifications and callbacks
 * @property {tf.types.TableSettings} tableSettings - used in the creation of the associated [Table]{@link tf.ui.Table} instance, whose <b>keyedTable</b> property will be automatically defined by the Keyed Table
 * @property {tf.types.TableRowSettings} rowSettings - used in the creation of [Table Row]{@link tf.ui.TableRow} instances, whose <b>keyedItem</b> property will be automatically defined by the Keyed Table
*/
/**
 * @public
 * @class
 * @summary A Keyed Table creates and manages a [Table]{@link tf.ui.Table} instance to which [Table Rows]{@link tf.ui.TableRow} are automatically added, updated, and deleted 
 * based in the [Keyed Items]{@link tf.js.KeyedItem} and [events]{@link tf.types.keyedListEventName} of a given [Keyed List]{@link tf.js.KeyedList} instance. 
 * Keyed Tables obtain row content from a callback, and notify table change events to a single listener, both of which are specified on creation
 * @param {tf.types.KeyedTableSettings} settings - creation settings
 */
tf.ui.KeyedTable = function (settings) {
    var theThis, table, keyedList, onChangeCallBack, listMonitor, getRowContentCallBack, optionalScope, propertyName, properties, sortFnc, onPreSortCB, onSortedCB;
    this.SetSort = function (sortFnc) { return setSort(sortFnc); }
    this.GetTable = function () { return table; }
    /**
     * @public
     * @function
     * @summary - Retrievs the application defined properties provided in the creation of this Keyed Table instance
     * @returns {object} - | {@link object} the properties
    */
    this.GetProperties = function () { return properties; }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Keyed List]{@link tf.js.KeyedList} instance associated with this Keyed Table instance
     * @returns {tf.js.KeyedList} - | {@link tf.js.KeyedList} the keyed list instance
    */
    this.GetKeyedList = function () { return keyedList; }
    /**
     * @public
     * @function
     * @summary - Retrieves the name of the [Keyed Item]{@link tf.js.KeyedItem} property that is associated with with [Table Rows]{@link tf.ui.TableRow} in this Keyed Table instance
     * @returns {tf.types.PropertyName} - | {@link tf.types.PropertyName} the name
    */
    this.GetPropertyName = function () { return propertyName; }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Table Row]{@link tf.ui.TableRow} associated with the given [Keyed Item]{@link tf.js.KeyedItem}, if one exists
     * @param {tf.js.KeyedItem} keyedItem - the keyed item
     * @returns {tf.ui.TableRow} - | {@link tf.ui.TableRow} the Table Row instance or {@link void}
    */
    this.GetRowFromKeyedItem = function (keyedItem) { return getTableRowFromItem(keyedItem); }
    this.ScrollTo = function (keyedItem) { var row = theThis.GetRowFromKeyedItem(keyedItem) ; if (!!row) { row.Select(true, true); } }
    this.SetKeyedList = function (keyedListSet) { return setKeyedList(keyedListSet); }
    function setSort(sortFncSet) {
        if (sortFnc != sortFncSet) { if (sortFnc = tf.js.GetFunctionOrNull(sortFncSet)) { doSort(); } }
    }
    function doSort() {
        if (sortFnc != undefined) {
            if (!!onPreSortCB) { onPreSortCB({ sender: theThis }); }
            table.Sort(sortFnc);
            if (!!onSortedCB) { onSortedCB({ sender: theThis }); }
        }
    }
    function onListItemsAddedOrUpdated(notification) {
        var items = notification.items;
        for (var i in items) {
            var thisItem = items[i];
            var row = getTableRowFromItem(thisItem);
            var isNewItem = !row;
            var content;
            if (isNewItem) { setTableRowToItem(thisItem, row = new tf.ui.TableRow(tf.js.ShallowMerge(settings.rowSettings, { keyedItem: thisItem}))); } else { row.ClearContent(); }
            if (!!getRowContentCallBack) {
                var data = getRowContentCallBack.call(optionalScope, { sender: theThis, keyedItem: thisItem, properties: properties });
                if (tf.js.GetIsValidObject(data)) { content = data.content; }
            }
            if (!!content) { row.AddContent(content); } else { row.privateGetHTMLElement().innerHTML = thisItem.GetKey(); }
        }
        doSort();
    }
    function notifyChange(keyedListNotification, type) {
        if (!!onChangeCallBack) {
            onChangeCallBack.call(optionalScope, { sender: theThis, eventName: type, properties: properties, keyedListNotification: keyedListNotification });
        }
    }
    function onListItemsAdded(notification) {
        onListItemsAddedOrUpdated(notification);
        notifyChange(notification, tf.consts.keyedTableRowsAddedEvent);
    }
    function onListItemsUpdated(notification) {
        onListItemsAddedOrUpdated(notification);
        notifyChange(notification, tf.consts.keyedTableRowsUpdatedEvent);
    }
    function onListItemsDeleted(notification) {
        var items = notification.items;
        for (var i in items) {
            var thisItem = items[i], tableRow = getTableRowFromItem(thisItem);
            if (!!tableRow) { table.DelRow(tableRow); setTableRowToItem(thisItem, null); }
        }
        notifyChange(notification, tf.consts.keyedTableRowsDeletedEvent);
    }
    function getTableRowFromItem(keyedItem) { return tf.js.GetObjProperty(keyedItem, propertyName); }
    function setTableRowToItem(keyedItem, row) { tf.js.SetObjProperty(keyedItem, propertyName, row); if (!!row) { table.AppendRow(row); } }
    function deleteTableRowFromItem(keyedItem) { var row = getTableRowFromItem(keyedItem); if (!!row) { setTableRowToItem(keyedItem, null); row.OnDelete(); } }
    function setKeyedList(keyedListSet) {
        if (tf.js.GetIsInstanceOf(keyedListSet, tf.js.KeyedList)) {
            table.Clear();
            keyedList = keyedListSet;
            var listeners = {};
            listeners[tf.consts.keyedListDeleteEvent] = onListItemsDeleted;
            listeners[tf.consts.keyedListAddedItemsEvent] = onListItemsAdded;
            listeners[tf.consts.keyedListUpdatedItemsEvent] = onListItemsUpdated;
            listeners[tf.consts.keyedListDeletedItemsEvent] = onListItemsDeleted;
            listMonitor = keyedList.AddListeners(listeners);
            keyedList.NotifyItemsAdded(onListItemsAddedOrUpdated);
        }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        table = new tf.ui.Table(tf.js.ShallowMerge(settings.tableSettings, { keyedTable: theThis }));
        getRowContentCallBack = tf.js.GetFunctionOrNull(settings.getRowContent);
        onPreSortCB = tf.js.GetFunctionOrNull(settings.onPreSort);
        onSortedCB = tf.js.GetFunctionOrNull(settings.onSorted);
        optionalScope = settings.optionalScope;
        onChangeCallBack = tf.js.GetFunctionOrNull(settings.onContentChange);
        propertyName = tf.js.GetNonEmptyString(settings.propertyName, tf.consts.TableRowProperty);
        properties = tf.js.GetIsValidObject(settings.properties) ? settings.properties : {};
        setKeyedList(settings.keyedList)
        tf.dom.Insertable.call(theThis, { domObj: theThis, domElement: table });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.ui.KeyedTable, tf.dom.Insertable);

// SOURCE FILE: map.js
/**
 * Specifications for the next animation set, returned by [Map Animation Callbacks]{@link tf.types.MapAnimationCallBack}, passed to
 * the function {@link tf.map.Map#StartAnimation}, upon receiving an [Animation Request]{@link tf.types.MapAnimationRequest} 
 * sent by a {@link tf.map.Map} instance
 * @public
 * @typedef {object} tf.types.MapAnimationStep
 * @property {tf.types.mapCoordinates} center - the new map center, if defined
 * @property {tf.types.mapResolution} resolution - the new map resolution, if defined
 * @property {number} rotation - the new map rotation, in radians, if defined
 * @property {number} duration - the duration of the animation step, in milliseconds
 * @property {boolean} notifyListeners - if set to <b>true</b> event notifications are sent to listeners during the animation, 
 * @property {tf.types.EasingFunction} easing - if not defined defaults to {@link tf.units.EaseInAndOut}
 * otherwise notifications are sent only when the animation ends, defaults to {@link void}
*/
/**
 * A request for the next animation step sent by {@link tf.map.Map} instances to callBacks passed to the function {@link tf.map.Map#StartAnimation}
 * @public
 * @typedef {object} tf.types.MapAnimationRequest
 * @property {tf.map.Map} sender - the instance sending the notification
 * @property {number} step - the current animation step, starts at 0 and is incremented at each call. 
 * Used by the callBack to determine which data to return for the next setp of the animation, and
 * when to stop the animation. 
 * An ongoing animation may be prematurely stoped by calls made to {@link tf.map.Map#StartAnimation} 
 * or {@link tf.map.Map#EndAnimation}, in which case this property is set to <b>-1</b>
*/
/**
 * A callback function that can be passed to the function {@link tf.map.Map#StartAnimation} to start an ongoing map animation
 * @public
 * @callback tf.types.MapAnimationCallBack
 * @param {tf.types.MapAnimationRequest} request - a request for the next animation step
 * @returns {tf.types.MapAnimationStep} - | {@link tf.types.MapAnimationStep} the requested next step, or {@link void} to end the animation
 */
/**
 * Map UTM coordinates use the array format <b>[ x, y, zone  ]</b>
 * @public
 * @typedef {array} tf.types.mapUTMCoordinates
 */
/**
 * Map coordinates use the GeoJSON array format <b>[ {@link tf.types.longitude}, {@link tf.types.latitude} ]</b>
 * @public
 * @typedef {array} tf.types.mapCoordinates
 */
/**
 * Map extents delimit a rectangular map area and are defined by a 4-position coordinate array in the order: <b>[ minLon, minLat, maxLon, maxLat ]</b>, where min/maxLon coordinates 
 * are {@link tf.types.longitude} and min/maxLat coordinates are {@link tf.types.latitude}
 * @public
 * @typedef {array} tf.types.mapExtent
 */
/**
 * An instance of a map layer class, currently only {@link tf.map.FeatureLayer}
 * @public
 * @typedef {tf.types.mapLayer} tf.types.mapLayer
 */
/**
 * A callback function that can be passed to the function [Add Listener]{@link tf.map.Map#AddListener} of a [Map]{@link tf.map.Map} instance to start receiving event notifications from it
 * @public
 * @callback tf.types.MapEventCallBack
 * @param {tf.types.MapEventNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * A callback, provided by map ({@link tf.map.Map}) instances during {@link tf.consts.mapPreComposeEvent} and {@link tf.consts.mapPostComposeEvent} notifications, 
 * to start a new rendering cycle after the current one completes
 * @public
 * @callback tf.types.MapContinueAnimation
 * @returns {void} - | {@link void} no return value
 * @see {@link tf.types.MapShowFeatureImmediately}
 */
/**
 * A callback, provided by map ({@link tf.map.Map}) instances during {@link tf.consts.mapPreComposeEvent} and {@link tf.consts.mapPostComposeEvent} notifications, to display instances of {@link tf.map.Feature} 
 * during the post compose phase of the map rendering cycle. This can be used to achieve animation effects, and to display transient map features that are not associated with a persistent data set
 * @public
 * @callback tf.types.MapShowFeatureImmediately
 * @param {tf.map.Feature} mapFeature - the map feature to show
 * @returns {void} - | {@link void} no return value
 * @see {@link tf.types.MapContinueAnimation}
 */
/**
 * Elements in the <b>featureCluster</b> property included in some notifications sent by {@link tf.map.Map} instances.
 * @public
 * @typedef {object} tf.types.MapFeatureClusterElement
 * @property {tf.map.Feature} mapFeature - a map feature in the cluster
 * @property {tf.map.KeyedFeature} keyedFeature - the keyed feature associated with the <b>mapFeature</b>, if any
 * @property {string} styleName - the name of the style of the <b>mapFeature</b>, if any
 */
/**
 * Notifications sent by {@link tf.map.Map} instances. Properties are included in the event notifications that require them, and undefined otherwise
 * @public
 * @typedef {object} tf.types.MapEventNotification
 * @property {tf.map.Map} sender - the instance sending the notification
 * @property {tf.types.mapEventName} eventName - the name of the event
 * @property {tf.types.mapCoordinates} eventCoords - the map coordinates associated with the event, if any
 * @property {tf.types.mapResolution} resolution - the map resolution in {@link tf.consts.mapResolutionChangeEvent} notifications
 * @property {tf.types.mapLevel} level - the map level in {@link tf.consts.mapLevelChangeEvent} notifications
 * @property {tf.map.KeyedFeature} keyedFeature - the keyed feature associated with the event, if any
 * @property {tf.map.Feature} mapFeature - the map feature associated with the event, if any
 * @property {string} styleName - the name of the style of the map feature associated with the event, if any
 * @property {boolean} isInHover - <b>true</b> if for "hover in" events, <b>false</b> for "hover out" events
 * @property {tf.map.KeyedFeature} nextKeyedFeature - the next keyed feature being "hovered in" in "hover out" event notifications
 * @property {tf.map.Feature} nextFeature - the next map feature being "hovered in" in "hover out" event notifications
 * @property {tf.map.KeyedFeature} prevKeyedFeature - the previous keyed feature being "hovered out" in "hover in" event notifications
 * @property {tf.map.Feature} prevFeature - the previous map feature being "hovered out" in "hover in" event notifications
 * @property {tf.map.Feature} prevFeature - the previous map feature being "hovered out" in "hover in" event notifications
 * @property {tf.types.MapShowFeatureImmediately} showFeatureImmediately - a function that displays an instance of {@link tf.map.Feature} during the post compose phase of the map rendering cycle
 * @property {tf.types.MapContinueAnimation} continueAnimation - a function that instructs the {@link tf.map.Map} instance to start a new rendering cycle after the current one completes
 * @property {tf.types.mapType} oldType - the map type being replaced in {@link tf.consts.mapTypeChangeEvent} notifications
 * @property {tf.types.mapType} newType - the new map type in {@link tf.consts.mapTypeChangeEvent} notifications
 * @property {array<tf.types.MapFeatureClusterElement>} featureCluster - an array containing information about map features in the same cluster as the map feature 
 * for which the event was triggered. This property is <b>undefined</b> in
 * non-cluster related event notifications
*/
/**
 * Settings used by the [map]{@link tf.map.Map} function [AddFeatureLayer]{@link tf.map.Map#AddFeatureLayer}
 * @public
 * @typedef {object} tf.types.AddFeatureLayerSettings
 * @property {string} name - the layer name, displayed in the Map Layers popup
 * @property {string} description - the layer description
 * @property {boolean} isVisible - if <b>false</b> the layer is created invisible, defaults to <b>true</b>
 * @property {boolean} isHidden - if <b>false</b> the layer is not listed in the Map Layers popup, defaults to <b>true</b>
 * @property {number} zIndex - the layer zIndex, defaults to 0
 * @property {tf.types.opacity01} opacity - the layer opacity, defaults to 1
 * @property {tf.types.MinMaxLevels} minMaxLevels - if defined, constrains the layer's visibility to the given range, defaults to {@link void}
 * @property {boolean} useClusters - if <b>true</b> the layer can only display [Features]{@link tf.map.Feature] with [point geometries]{@link tf.types.GeoJSONGeometryType} 
 * and displays clusters of features into a single feature. Defaults to <b>void</b>
 * @property {number} clusterFeatureDistance - the distance in pixels under which [Map Features]{@link tf.map.Feature] are clustered together
 * @property {tf.types.MapFeatureStyleLike} clusterStyle - style used to display a cluster of [Map Features]{@link tf.map.Feature]
 * @property {tf.types.MapFeatureStyleSettings} clusterLabelStyle - style used to display the number of [Map Features]{@link tf.map.Feature] in a cluster
*/
/**
 * View settings used in the creation of [Map]{@link tf.map.Map} instances
 * @public
 * @typedef {object} tf.types.MapViewSettings
 * @property {tf.types.mapExtent} extent - optional allowed map extent (to restrict map navigation)
 * @property {tf.types.mapLevel} minLevel - optional minimum level allowed
 * @property {tf.types.mapLevel} maxLevel - optional maximum level allowed
*/
/**
 * A string containing the url to a Map Tile Server
 * @public
 * @typedef {string} tf.types.mapTileServerUrl
 */
/**
 * Settings used in the creation of [Map]{@link tf.map.Map} instances
 * @public
 * @typedef {object} tf.types.MapSettings
 * @property {HTMLElementLike} container - the container where the map is created, this is a mandatory property
 * @property {HTMLElementLike} fullScreenContainer - defines the container to be displayed in fullscreen, if not defined, <b>document.body</b> is displayed in fullscreen
 * @property {tf.types.mapCoordinates} center - optional map center, defaults to [ {@link tf.consts.defaultLongitude}, {@link tf.consts.defaultLatitude}]
 * @property {tf.types.mapLevel} level - optional map level, defaults to {@link tf.consts.defaultLevel}
 * @property {tf.types.mapResolution} resolution - optional map resolution, defaults to {@link void}, if defined takes precedence over <b>level</b>
 * @property {tf.types.mapEngine} mapEngine - optional map engine, defaults to {@link tf.consts.mapnik2Engine}
 * @property {tf.types.mapType} mapType - optional map type, defaults to {@link tf.consts.typeNameHybrid}
 * @property {tf.types.mapAerialSource} mapAerialSource - the source of Aerial map tiles, defaults to {@link tf.consts.sourceName_best_available}
 * @property {tf.types.MapViewSettings} viewSettings - optional view settings
 * @property {tf.types.mapTileServerUrl} mapLayerSourceURL - optional alternative map engine, defaults to {@link void}, if defined replaces <b>mapEngine</b>
 * @property {tf.types.opacity01} mapLayerSourceHybridModeOpacity - optional opacity used with <b>mapLayerSourceURL</b> when the map type is set to {@link tf.consts.typeNameHybrid}, defaults to 1
 * @property {tf.types.mapPanelNamesString} panels - if present sets the visibility status of map panels
 * @property {boolean} showMapCenter - if set to <b>false</b> prevents the map center image from being overlayed on map, otherwise the map center is displayed
 * @property {boolean} panOnClick - if set to <b>false</b> prevents the map from panning to the map location clicked by the user
 * @property {boolean} goDBOnDoubleClick - if set to <b>false</b> prevents the map from displaying the TerraFly geoquery page corresponding to the map location double clicked by the user
 * @property {string} addressBarHelp - if present sets the text that is displayed when the user clicks the '?' button in the map's Address Bar
 * @property {string} passThroughString - if present sets the value of a string used by the map when interacting with some TerraFly services
 * @property {string} vidParam - if present sets the value of a string used by the map when interacting with some TerraFly services
 * @property {number} messageTimeout - if present sets the time after which the Message Popup automatically hides itself, defaults to {@link tf.consts.defaultMessageTimeout}
 * @property {tf.types.legendString} legendH - if present sets the value of the {@link tf.consts.typeNameHybrid} legend, defaults to {@link tf.consts.defaultLegendH}
 * @property {tf.types.legendString} legendM - if present sets the value of the {@link tf.consts.typeNameMap} legend, defaults to {@link tf.consts.defaultLegendM}
*/
/**
 * @public
 * @class
 * @summary Create instances of this class to display the TerraFly HTerraMap
 * @param {tf.types.MapSettings} settings - map creation settings
 */
tf.map.Map = function (settings) {
    var styles, subStyles;
    var mapPrivateLayerZIndex = 10000;
    var id = null;
    var mapCanvas = null;
    var linkTargetStr;
    var layersByName;
    var mapURLIPs = ["184", "186", "188", "190"];
    //var mapURLIPs = ["184", "186", "190"];
    //var mapURLIPs = ["184", "186", "188"];
    var allEventDispatchers = null;
    var actualToVirtualTranslateCallBack, virtualToActualTranslateCallBack, getDisplayPixelSizeCB;
    var animationCallBack, animationOptionalScope, animationStep, isAnimating, animationSpecs;
    var originalViewConstrainResolution;
    function fractionalConstrainZoom(resolution, delta, direction) { return delta ? originalViewConstrainResolution.call(olView, resolution, delta, direction) : resolution; }
    this.ActualToVirtualPixelCoords = function (pixelCoords) { return actualToVirtualPixelCoords(pixelCoords); }
    function actualToVirtualPixelCoords(pixelCoords) {
        var coords;
        if (!!pixelCoords) { if (!(coords = (!!actualToVirtualTranslateCallBack ? actualToVirtualTranslateCallBack(pixelCoords) : pixelCoords.slice(0)))) { coords = pixelCoords; } }
        else { coords = [0, 0]; }
        return coords;
    }
    this.VirtualToActualPixelCoords = function (pixelCoords) { return virtualToActualPixelCoords(pixelCoords); }
    function virtualToActualPixelCoords(pixelCoords) {
        var coords;
        if (!!pixelCoords) { if (!(coords = (!!virtualToActualTranslateCallBack ? virtualToActualTranslateCallBack(pixelCoords) : pixelCoords.slice(0)))) { coords = pixelCoords; } }
        else { coords = [0, 0]; }
        return coords;
    }
    this.SetDecodedLegends = function (decodedLegendH, decodedLegendM) { return setDecodedLegends(decodedLegendH, decodedLegendM, undefined); }
    this.SetIsUSScaleUnits = function (bool) { if (isUsScaleUnits != !!bool) { toggleScaleUnits(); } }
    this.GetIsUSScaleUnits = function () { return isUsScaleUnits; }
    this.SetFractionalZoomInteraction = function (setBool) {
        olView.constrainResolution = !!setBool ? fractionalConstrainZoom: originalViewConstrainResolution;
    }
    this.RemoveDragPan = function () { return removeDragPan(); }
    this.AddDragPan = function () { return addDragPan(); }
    this.GetCanvas = function () { return mapCanvas; }
    this.GetPixelSize = function () {
        var dps = !!getDisplayPixelSizeCB ? getDisplayPixelSizeCB() : undefined;
        return !!dps ? dps : theThis.GetActualPixelSize();
    }
    this.SetActualToVirtualPixelTranslateCallBacks = function (actualToVirtualCallBack, virtualToActualCallBack, displayPixelSizeCallBack) {
        actualToVirtualTranslateCallBack = tf.js.GetFunctionOrNull(actualToVirtualCallBack);
        if (!(virtualToActualTranslateCallBack = tf.js.GetFunctionOrNull(virtualToActualCallBack))) {
            virtualToActualTranslateCallBack = actualToVirtualCallBack;
        }
        getDisplayPixelSizeCB = tf.js.GetFunctionOrNull(displayPixelSizeCallBack);
    }
    this.SetTarget = function (newTarget) { olMap.setTarget(newTarget); }
    this.RestoreTarget = function () { olMap.setTarget(mapContainer); }
    this.getAPIMap = function () { return olMap; }
    this.getAPIView = function () { return olView; }
    this.GetControlContainer = function () { return mapControlContainerHTML; }
    this.CreateMapWithSameLayers = function (container) {
        var map;
        if (tf.dom.GetHTMLElementFrom(container)) {
            var mapSettings = {
                container: container,
                center: getCenter(),
                panels: "noaddress+nomaplocation+nouserlocation+nomapscale",
                panOnClick: false,
                goDBOnDoubleClick: false,
                resolution: getResolution()
            };
            map = new tf.map.Map(mapSettings);
            map.SetHasInteractions(false);
            map.ShowMapCenter(false);
            map.getAPIMap().setLayerGroup(olMap.getLayerGroup());
        }
        return map;
    }
    /*this.ShareLayersWith = function (map) {
        if (!!(map = tf.js.GetMapFrom(map))) {
            map.getAPIMap().setLayerGroup(olMap.getLayerGroup());
        }
    }*/
    /**
     * @public
     * @function
     * @summary - Returns the map instance's unique identifier
     * @returns {number} - | {@link number} the map instance's unique identifier
    */
    this.GetID = function () { return id; }
    /**
     * @public
     * @function
     * @summary - Returns the map container that was passed in the creation of the map instance
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the map container
    */
    this.GetMapContainer = function () { return containerAll; }
    /**
     * @private
     * @function
     * @summary - Returns the top map container
     * @returns {HTMLElementLike} - | {@link HTMLElementLike} the top map container
    */
    this.GetMapMapContainer = function () { return mapContainerAllObj; }
    this.GetMapControlContainer = function () { return mapControlContainerObj; }
    /**
     * @public
     * @function
     * @summary - Returns the map engine that was passed in the creation of the map instance
     * @returns {tf.types.mapEngine} - | {@link tf.types.mapEngine} the map engine
    */
    this.GetMapEngine = function () { return mapEngine; }
    /**
     * @public
     * @function
     * @summary - Uses the browser's geolocation service to create or update (and display) a map feature at the estimated user location
     * @returns {void} - | {@link void} no return value
    */
    this.ShowUserLocation = function () { return updateUserLocation(); }
    /**
     * @public
     * @function
     * @summary - Hides the map feature positioned at the estimated user location, if it has been created
     * @returns {void} - | {@link void} no return value
    */
    this.HideUserLocation = function () { return hideUserLocation(); }
    /**
     * @public
     * @function
     * @summary - CenterUses the browser's geolocation service to center the map to the estimated user location
     * @returns {void} - | {@link void} no return value
    */
    this.CenterToUserLocation = function () { return requestCenterToUserLocation(); }
    /**
     * @public
     * @function
     * @summary - Requests the map to initiate a render cycle. Should not be called from within a render cycle (e.g. during a map {@link tf.consts.mapPostComposeEvent} event)
     * @returns {void} - | {@link void} no return value
    */
    this.Render = function () { return render(); }
    /**
     * @public
     * @function
     * @summary - Sets the value of a string used by the map when interacting with some TerraFly services
     * @param {string} tfPassThroughString - the string value
     * @returns {void} - | {@link void} no return value
    */
    this.SetTFPassThroughString = function (passTroughString) { setTFPassThroughString(passTroughString); }
    /**
     * @public
     * @function
     * @summary - Returns the value of a string used by the map when interacting with some TerraFly services
     * @returns {string} - | {@link string} the string value
    */
    this.GetTFPassThroughString = function () { return getTFPassTroughString(); }
    /**
     * @public
     * @function
     * @summary - Sets the value of a string used by the map when interacting with some TerraFly services
     * @param {string} vidParamStr - the string value
     * @returns {void} - | {@link void} no return value
    */
    this.SetVIDParamStr = function (vidParamStr) { setVIDParamStr(vidParamStr); }
    /**
     * @public
     * @function
     * @summary - Returns the value of a string used by the map when interacting with some TerraFly services
     * @returns {string} - | {@link string} the string value
    */
    this.GetVIDParamStr = function () { return getVIDParamStr(); }
    /**
     * @public
     * @function
     * @summary - Sets the text that is displayed in the map's Address Bar
     * @param {string} addressBarText - the text
     * @returns {void} - | {@link void} no return value
    */
    this.SetAddressBarText = function (addressBarText) { return setAddressBarText(addressBarText); }
    /**
     * @public
     * @function
     * @summary - Returns the text displayed in the map's Address Bar
     * @returns {string} - | {@link string} the text
    */
    this.GetAddressBarText = function () { return getAddressBarText(); }
    /**
     * @public
     * @function
     * @summary - Sets the text that is displayed when the user clicks the '?' button in the map's Address Bar
     * @param {string} addressBarHelpStr - the text
     * @returns {void} - | {@link void} no return value
    */
    this.SetAddressBarHelp = function (addressBarHelpStr) { return setAddressBarHelp(addressBarHelpStr); }
    /**
     * @public
     * @function
     * @summary - Opens a GeoQuery page for the given address
     * @param {string} addressStr - the address
     * @returns {void} - | {@link void} no return value
    */
    this.GoDBByAddress = function (addressStr) { goDBByAddress(addressStr); }
    /**
     * @public
     * @function
     * @summary - Opens a GeoQuery page for the given coordinates
     * @param {tf.types.mapCoordinates} pointCoords - the coordinates
     * @returns {void} - | {@link void} no return value
    */
    this.GoDBByCoords = function (pointCoords) { goDBByCoords(pointCoords); }
    /**
     * @public
     * @function
     * @summary - Opens a GeoQuery page for the coordinates at the center of the map
     * @returns {void} - | {@link void} no return value
    */
    this.GoDBByCenterCoords = function () { goDBByCenterCoords(); }
    /**
     * @public
     * @function
     * @summary - Allows or prevents the map from opening a GeoQuery page corresponding to the map coordinates double clicked by the user
     * @param {boolean} bool - Set to <b>true</b> to allow, <b>false</b> to prevent
     * @returns {void} - | {@link void} no return value
    */
    this.SetGoDBOnDoubleClick = function (bool) { setGoDBOnDoubleClick(bool); }
    /**
     * @public
     * @function
     * @summary - Determines if the map is allowed to open a GeoQuery page corresponding to the map coordinates double clicked by the user
     * @returns {boolean} - | {@link boolean} <b>true</b> if it is allowed, <b>false</b> otherwise
    */
    this.GetGoDBOnDoubleClick = function () { return getGoDBOnDoubleClick(); }
    /**
     * @public
     * @function
     * @summary - Allows or prevents automatic re-centering to the coordinates clicked by the user
     * @param {boolean} bool - Set to <b>true</b> to allow, <b>false</b> to prevent
     * @returns {void} - | {@link void} no return value
    */
    this.SetUsePanOnClick = function (bool) { setUsePanOnClick(bool); }
    /**
     * @public
     * @function
     * @summary - Determines if the map is allowed to automatically re-center to the coordinates clicked by the user
     * @returns {boolean} - | {@link boolean} <b>true</b> if it is allowed, <b>false</b> otherwise
    */
    this.IsUsingPanOnClick = function () { return isUsingPanOnClick(); }
    this.AnimatedSetRotation = function (newRotationRad, animationTime) { return animatedSetRotation(newRotationRad, animationTime); }
    this.AnimatedResetRotation = function () { return animatedResetRotation(); }
    /**
     * @public
     * @function
     * @summary - Rotates the map clockwise to the given angle
     * @param {number} rotationDeg - The angle in degrees
     * @returns {void} - | {@link void} no return value
    */
    this.SetRotationDeg = function (rotationDeg) { return setRotationDeg(rotationDeg); }
    /**
     * @public
     * @function
     * @summary - Obtains the clockwise map rotation angle
     * @returns {number} - | {@link number} the angle in degrees
    */
    this.GetRotationDeg = function (rotationDeg) { return getRotationDeg(); }
    /**
     * @public
     * @function
     * @summary - Rotates the map clockwise to the given angle
     * @param {number} rotationRad - The angle in radians
     * @returns {void} - | {@link void} no return value
    */
    this.SetRotationRad = function (rotationRad) { return setRotationRad(rotationRad); }
    /**
     * @public
     * @function
     * @summary - Obtains the clockwise map rotation angle
     * @returns {number} - | {@link number} the angle in radians
    */
    this.GetRotationRad = function (rotationRad) { return getRotationRad(); }
    /**
     * @public
     * @function
     * @summary - Translates the given pixel coordinates into map coordinates
     * @param {tf.types.pixelCoordinates} pixelCoords - the pixel coordinates
     * @returns {tf.types.mapCoordinates} - | {@link tf.types.mapCoordinates} the map coordinates
    */
    this.PixelToMapCoords = function (pixelCoords) { return pixelToMapCoords(pixelCoords); }
    this.ActualPixelToMapCoords = function (pointCoords) { return actualPixelToMapCoords(pointCoords); }
    /**
     * @public
     * @function
     * @summary - Translates the given map coordinates into pixel coordinates
     * @param {tf.types.mapCoordinates} pointCoords - the map coordinates
     * @returns {tf.types.pixelCoordinates} - | {@link tf.types.pixelCoordinates} the pixel coordinates
    */
    this.MapToPixelCoords = function (pointCoords) { return mapToPixelCoords(pointCoords); }
    this.ActualMapToPixelCoords = function (pointCoords) { return actualMapToPixelCoords(pointCoords); }
    /**
     * @public
     * @function
     * @summary - Obtains the distance in pixels between two map given coordinates
     * @param {tf.types.mapCoordinates} pointCoords1 - the first map coordinates
     * @param {tf.types.mapCoordinates} pointCoords2 - the second map coordinates
     * @returns {number} - | {@link number} the distance between the map coordinates in pixels
    */
    this.GetPixelDistance = function (pointCoords1, pointCoords2) { return getPixelDistance(pointCoords1, pointCoords2); }
    /**
     * @public
     * @function
     * @summary - Obtains the distance in pixels between the center of the map and the given map coordinates
     * @param {tf.types.mapCoordinates} pointCoords - the given map coordinates
     * @returns {number} - | {@link number} the distance between the map center and the map coordinates in pixels
    */
    this.GetPixelDistanceFromCenter = function (pointCoords) { return getPixelDistanceFromCenter(pointCoords); }
    /**
     * @public
     * @function
     * @summary - Checks if the given map coordinates are displayed at the same pixel coordinates as the map center
     * @param {tf.types.mapCoordinates} pointCoords - the given map coordinates
     * @returns {boolean} - | {@link boolean} <b>true</b> if the pixel coordinates of the center coincide with the pixel coordinates of the given the map coordinates, <b>false</b> otherwise
    */
    this.IsSamePixelAsCenter = function (pointCoords) { return isSamePixelAsCenter(pointCoords); }
    /**
     * @public
     * @function
     * @summary - Checks if the given map coordinates are within the current map viewing area
     * @param {tf.types.mapCoordinates} pointCoords - the given map coordinates
     * @returns {boolean} - | {@link boolean} <b>true</b> if the pixel coordinates of given coordinates are visible, <b>false</b> otherwise
    */
    this.GetAreMapCoordsVisible = function (pointCoords) { return getAreMapCoordsVisible(pointCoords); }
    /**
     * @public
     * @function
     * @summary - Recenters the map to the given coordinates
     * @param {tf.types.mapCoordinates} pointCoords - the new map center coordinates
     * @returns {void} - | {@link void} no return value
    */
    this.SetCenter = function (pointCoords) { setCenter(pointCoords); }
    /**
     * @public
     * @function
     * @summary - Recenters the map to the given coordinates and changes the map level to the given level
     * @param {tf.types.mapCoordinates} pointCoords - the new map center coordinates
     * @param {tf.types.mapLevel} level - the new map level
     * @returns {void} - | {@link void} no return value
    */
    this.SetCenterAndLevel = function (pointCoords, level) { setCenterAndLevel(pointCoords, level); }
    /**
     * @public
     * @function
     * @summary - Retrieves the current map center coordinates
     * @returns {tf.types.mapCoordinates} - | {@link tf.types.mapCoordinates} the map center coordinates
    */
    this.GetCenter = function () { return getCenter(); }
    /**
     * @public
     * @function
     * @summary - Sets the map level
     * @param {tf.types.mapLevel} level - the desired map level
     * @returns {void} - | {@link void} no return value
    */
    this.SetLevel = function (level) { setLevel(level); }
    /**
     * @public
     * @function
     * @summary - Gets the current map level
     * @returns {tf.types.mapLevel} - | {@link tf.types.mapLevel} the current map level
    */
    this.GetLevel = function () { return getLevel(); }
    /**
     * @public
     * @function
     * @summary - Sets the map resolution
     * @param {tf.types.mapResolution} resolution - the desired map resolution
     * @returns {void} - | {@link void} no return value
    */
    this.SetResolution = function (resolution) { setResolution(resolution); }
    /**
     * @public
     * @function
     * @summary - Gets the current map resolution
     * @returns {tf.types.mapResolution} - | {@link tf.types.mapResolution} the current map resolution
    */
    this.GetResolution = function () { return getResolution() }
    /**
     * @public
     * @function
     * @summary - Incrementally changes the map level to the given level if it differs from the current map level. If the given level matches the current
     * map level no animation is performed and the optional callback is immediatelly notified
     * @param {tf.types.mapLevel} newLevel - the desired new level
     * @param {tf.types.MapEventCallBack} callBack - if defined, receives a notification when the animation ends
     * @param {number} duration - the duration of the animation per level changed, in milliseconds, defaults to {@link tf.consts.defaultMapAnimatedDurationPerLevelMillis}
     * @param {boolean} notifyListeners - Set to <b>true</b> to send event notifications during the animation, defaults to {@link void}
     * @param {tf.types.EasingFunction} easing - if not defined defaults to {@link tf.units.EaseInAndOut}
     * @returns {void} - | {@link void} no return value
    */
    this.AnimatedSetLevel = function (newLevel, callBack, durationPerLevel, notifyListeners, easing) { return animatedSetLevel(newLevel, callBack, durationPerLevel, notifyListeners, easing); }
    /**
     * @public
     * @function
     * @summary - Incrementally recenters the map to the given map coordinates if their corresponding pixel coordinates differ from those of the center of the map, 
     * otherwise [SetCenter]{@link tf.map.Map#SetCenter} is performed instead of an animation, and the optional calback is notified immediately
     * @param {tf.types.mapCoordinates} pointCoords - the new map center coordinates
     * @param {tf.types.MapEventCallBack} callBack - if defined, receives a notification when the animation ends
     * @param {number} duration - the duration of the animation, in milliseconds, defaults to {@link tf.consts.defaultMapAnimatedCenterDurationMillis}
     * @param {boolean} notifyListeners - Set to <b>true</b> to send event notifications during the animation, defaults to {@link void}
     * @param {tf.types.EasingFunction} easing - if not defined defaults to {@link tf.units.EaseInAndOut}
     * @returns {void} - | {@link void} no return value
    */
    this.AnimatedSetCenter = function (pointCoords, callBack, duration, notifyListeners, easing) { animatedSetCenter(pointCoords, callBack, duration, notifyListeners, easing); }
    /**
     * @public
     * @function
     * @summary - Recenters the map to the given coordinates, uses incremental animation if the new center coordinates are visible
     * @param {tf.types.mapCoordinates} pointCoords - the new map center coordinates
     * @param {number} duration - the duration of the animation, in milliseconds, defaults to {@link tf.consts.defaultMapAnimatedCenterDurationMillis}
     * @returns {void} - | {@link void} no return value
    */
    this.AnimatedSetCenterIfDestVisible = function (pointCoords, duration) { animatedSetCenterIfDestVisible(pointCoords, duration); }
    /**
     * @public
     * @function
     * @summary - Checks if the map is performing an animation
     * @returns {boolean} - | {@link boolean} <b>true</b> if an animation is in progress, <b>false</b> otherwise
    */
    this.GetIsAnimating = function () { return isAnimating; }
    /**
     * @public
     * @function
     * @summary - Starts a map animation
     * @param {tf.types.MapAnimationCallBack} callBack - the animation callback
     * @param {object} optionalScope - optional JavaScript scope used with <b>callBack</b>
     * @returns {void} - | {@link void} no return value
    */
    this.StartAnimation = function (callBack, optionalScope) { return startAnimation(callBack, optionalScope); }
    /**
     * @public
     * @function
     * @summary - Stops an ongoing map animation
     * @returns {void} - | {@link void} no return value
    */
    this.EndAnimation = function () { return endAnimation(); }
    /**
     * @public
     * @function
     * @summary - Calls a TerraFly service to determine the map coordinates corresponding to the given address and performs a "fly" animation to re-center the map to those coordinates
     * @param {string} addressStr - the address
     * @returns {void} - | {@link void} no return value
    */
    this.FlyToAddress = function (addressStr) { return flyToAddress(addressStr); }
    /**
     * @public
     * @function
     * @summary - Retrieves the visible map extent
     * @returns {tf.types.mapExtent} - | {@link tf.types.mapExtent} the map extent
    */
    this.GetVisibleExtent = function () { return getVisibleExtent(); }
    /**
     * @public
     * @function
     * @summary - Sets the visible map extent
     * @param {tf.types.mapExtent} extent - the new map extent
     * @returns {void} - | {@link void} no return value
    */
    this.SetVisibleExtent = function (extent) { return setVisibleExtent(extent); }
    /**
     * @public
     * @function
     * @summary - Removes the given layer instance from the map
     * @param {tf.types.mapLayer} layerInstance - the layer instance
     * @returns {void} - | {@link void} no return value
    */
    this.RemoveLayer = function (layerInstance) { removeLayer(layerInstance); }
    /**
     * @public
     * @function
     * @summary - Adds a [Feature Layer]{@link tf.map.FeatureLayer} to the map
     * @param {tf.types.AddFeatureLayerSettings} layerSettings - layer instance creation settings
     * @returns {tf.map.FeatureLayer} - | {@link tf.map.FeatureLayer} the added feature layer
    */
    this.AddFeatureLayer = function (layerSettings) { return addFeatureLayer(layerSettings); }
    /**
     * @public
     * @function
     * @summary - Notifies the map that its container may have been resized
     * @returns {void} - | {@link void} no return value
    */
    this.OnResize = function () { return onResize(); }
    /**
     * @public
     * @function
     * @summary - Obtains the size of the map in pixels
     * @returns {tf.types.pixelCoordinates} - | {@link tf.types.pixelCoordinates} the size of the map in pixels
    */
    this.GetActualPixelSize = function () { return getActualPixelSize(); }
    /**
     * @public
     * @function
     * @summary - Moves the map center by a pixel offset
     * @param {tf.types.pixelCoordinates} pixelOffset - the offset
     * @returns {void} - | {@link void} no return value
    */
    this.PanByPixelOffset = function (pixelOffset) { panByPixelOffset(pixelOffset); }
    /**
     * @public
     * @function
     * @summary - Adds a listener for the given map event name
     * @param {tf.types.mapEventName} eventName - the name of the map event
     * @param {tf.types.MapEventCallBack} callBack - the callback for event notifications
     * @returns {tf.events.EventListener} - | {@link tf.events.EventListener} the event listener
    */
    this.AddListener = function (eventName, callBack) { return allEventDispatchers.AddListener(eventName, callBack); }
    /**
     * @public
     * @function
     * @summary - Adds one or more listeners for the given map event names
     * @param {tf.types.EventNamesAndCallBacks} eventNamesAndCallBacks - the event names and callbacks
     * @returns {tf.types.EventNamesAndListeners} - | {@link tf.types.EventNamesAndListeners} the event names and listeners
    */
    this.AddListeners = function (eventNamesAndCallBacks) { return allEventDispatchers.AddListeners(eventNamesAndCallBacks); }
    /**
     * @public
     * @function
     * @summary - Shows or hides the map center image overlay
     * @param {boolean} bool - set to <b>true</b> to dislay the center image, <b>false</b> to hide it
     * @returns {void} - | {@link void} no return value
    */
    this.ShowMapCenter = function (bool) { return showMapCenter(bool); }
    this.GetMapCenterElem = function () { return mapCenterButton; }
    /**
     * @public
     * @function
     * @summary - Checks if the map center image overlay is visible
     * @returns {boolean} - | {@link boolean} <b>true</b> if visible, <b>false</b> otherwise
    */
    this.IsShowingMapCenter = function () { return isShowingMapCenter; }
    this.GetLayersPopup = function () { return layersPopup; }
    this.ShowLayerList = function (bool) {
        var isShowingNow = isShowingMapLayers();
        if (isShowingNow != (bool = !!bool)) { toggleMapLayers(); }
    }
    this.GetIsShowingLayerList = function () { return isShowingMapLayers(); }
    /**
     * @public
     * @function
     * @summary - Shows or hides map panels
     * @param {tf.types.mapPanelNamesString} strPanels - a string containing the names of panels to be shown, panels not listed are hidden
     * @returns {void} - | {@link void} no return value
    */
    this.ShowPanels = function (strPanels) { return showPanels(strPanels); }
    /**
     * @public
     * @function
     * @summary - Shows or hides a map panel
     * @param {tf.types.mapPanelName} strPanel - the map panel
     * @param {boolean} showBool - <b>true</b> to show the panel, <b>false</b> to hide it
     * @returns {void} - | {@link void} no return value
    */
    this.ShowPanel = function (strPanel, showBool) { return showPanel(strPanel, showBool); }
    this.GetPanelElement = function (strPanel) { return getPanelElement(strPanel); }
    /**
     * @public
     * @function
     * @summary - Retrieves the current visibility state of a map panel
     * @param {tf.types.mapPanelName} strPanel - the map panel
     * @returns {boolean} - | {@link boolean} <b>true</b> if the panel is visible, <b>false</b> otherwise
    */
    this.IsPanelShowing = function (strPanel) { return isPanelShowing(strPanel); }
    /**
     * @public
     * @function
     * @summary - Shows or hides the full screen button
     * @param {boolean} bool - <b>true</b> to show, <b>false</b> to hide
     * @returns {void} - | {@link void} no return value
    */
    this.SetFullScreenButtonVisibility = function (bool) { showPanel(tf.consts.panelNameFullscreen, bool); }
    /**
     * @public
     * @function
     * @summary - Shows or hides the TerraFly Map Logo
     * @param {boolean} bool - <b>true</b> to show, <b>false</b> to hide
     * @returns {void} - | {@link void} no return value
    */
    this.SetLogoVisibility = function (visible) { return setLogoVisibility(visible); }
    /**
     * @public
     * @function
     * @summary - Shows the map full screen mode
     * @returns {void} - | {@link void} no return value
    */
    this.FullScreen = function () { return onFullScreen(); }
    /**
     * @public
     * @function
     * @summary - Toggles the map between full screen and normal modes
     * @returns {void} - | {@link void} no return value
    */
    this.ToggleMapFullScreen = function () { return toggleMapFullScreen(); }
    /**
     * @public
     * @function
     * @summary - Sets the map type 
     * @param {tf.types.mapType} type - the map type
     * @returns {void} - | {@link void} no return value
    */
    this.SetMapType = function (type) { setMapType(type, true); }
    /**
     * @public
     * @function
     * @summary - Gets the map type 
     * @returns {tf.types.mapType} - | {@link tf.types.mapType} the map type
    */
    this.GetMapType = function () { return currentMode; }
    /**
     * @public
     * @function
     * @summary - Sets the source of Aerial map tiles
     * @param {tf.types.mapAerialSource} source - the source
     * @returns {void} - | {@link void} no return value
    */
    this.SetSource = function (source) { setSource(source, true); }
    /**
     * @public
     * @function
     * @summary - Gets the source of Aerial map tiles
     * @returns {tf.types.mapAerialSource} - | {@link tf.types.mapAerialSource} the source
    */
    this.GetSource = function () { return currentSource; }
    /**
     * @public
     * @function
     * @summary - Sets the values of the [Hybrid]{@link tf.consts.typeNameHybrid} and [Map]{@link tf.consts.typeNameMap} [Legend Strings]{@link tf.types.legendString}
     * @param {tf.types.legendString} legendStrHybrid - used with [Hybrid]{@link tf.consts.typeNameHybrid} type
     * @param {tf.types.legendString} legendStrMap - used with [Map]{@link tf.consts.typeNameMap} type
     * @returns {void} - | {@link void} no return value
    */
    this.SetLegend = function (legendStrHybrid, legendStrMap) { setLegend(legendStrHybrid, legendStrMap); }
    /**
     * @public
     * @function
     * @summary - Checks if map interactions (pan, zoom, etc.) are allowed
     * @returns {boolean} - | {@link boolean} <b>true</b> if interactions are allowed, <b>false</b> otherwise
    */
    this.GetHasInteractions = function () { return getHasInteractions(); }
    /**
     * @public
     * @function
     * @summary - Allows or prevents map interactions (pan, zoom, etc.)
     * @param {boolean} bool - set to <b>true</b> to allow interactions, <b>false</b> to prevent interactions
     * @returns {void} - | {@link void} no return value
    */
    this.SetHasInteractions = function (bool) { setHasInteractions(bool); }
    /**
     * @public
     * @function
     * @summary - Shows the Address Bar
     * @returns {void} - | {@link void} no return value
    */
    this.ShowAddressBar = function () { showAddressBar(); }
    /**
     * @public
     * @function
     * @summary - Hides the Address Bar
     * @returns {void} - | {@link void} no return value
    */
    this.HideAddressBar = function () { hideAddressBar(); }
    /**
     * @public
     * @function
     * @summary - Toggles the Address Bar visibility state
     * @returns {void} - | {@link void} no return value
    */
    this.ToggleAddressBar = function () { toggleAddressBar(); }
    /**
     * @public
     * @function
     * @summary - Checks if the Address Bar is visible
     * @returns {boolean} - | {@link boolean} <b>true</b> if the bar is visible, <b>false</b> otherwise
    */
    this.IsShowingAddressBar = function () { return isShowingAddressBar(); }
    /**
     * @public
     * @function
     * @summary - Shows the Message Popup
     * @param {HTMLElementLike} contents - the contents to be displayed
     * @returns {void} - | {@link void} no return value
    */
    this.ShowMessage = function (contents) { showMessage(contents); }
    /**
     * @public
     * @function
     * @summary - Hides the Message Popup
     * @returns {void} - | {@link void} no return value
    */
    this.HideMessage = function () { hideMessage(); }
    /**
     * @public
     * @function
     * @summary - Toggles the Message Popup visibility state
     * @returns {void} - | {@link void} no return value
    */
    this.ToggleMessage = function () { toggleMessage(); }
    /**
     * @public
     * @function
     * @summary - Checks if the Message Popup is visible
     * @returns {boolean} - | {@link boolean} <b>true</b> if the popup is visible, <b>false</b> otherwise
    */
    this.IsShowingMessage = function () { return isShowingMessage(); }
    /**
     * @public
     * @function
     * @summary - Sets the time after which the Message Popup automatically hides itself
     * @param {number} timeoutSecs - the time in seconds
     * @returns {void} - | {@link void} no return value
    */
    this.SetMessageTimeout = function (timeoutSecs) { setMessageTimeout(timeoutSecs); }
    /**
     * @public
     * @function
     * @summary - Hides any visible control popups (layers, types, sources, etc.)
     * @returns {void} - | {@link void} no return value
    */
    this.HideOpenControlPopups = function () { hideOpenControlPopups(); }
    /**
     * @public
     * @function
     * @summary - Hides any visible popups (information, location, message)
     * @returns {void} - | {@link void} no return value
    */
    this.HideOpenPopups = function () { hideOpenPopups(); }
    /**
     * @public
     * @function
     * @summary - Checks if the Information Popup is visible
     * @returns {boolean} - | {@link boolean} <b>true</b> if the popup is visible, <b>false</b> otherwise
    */
    this.IsShowingInfoPopup = function () { return isShowingInfoWindow(); }
    /**
     * @public
     * @function
     * @summary - Toggles the visibility state of the Information Popup
     * @returns {void} - | {@link void} no return value
    */
    this.ToggleInfoPopup = function () { toggleInfoWindow(); }
    /**
     * @public
     * @function
     * @summary - Hides the Information Popup
     * @returns {void} - | {@link void} no return value
    */
    this.HideInfoPopup = function () { hideInfoWindow(); }
    /**
     * @public
     * @function
     * @summary - Shows the Information Popup
     * @param {string} title - title of the popup
     * @param {HTMLElementLike} content - content of the popup
     * @param {tf.types.mapCoordinates} pointCoords - map coordinates associated with the popup
     * @returns {void} - | {@link void} no return value
    */
    this.ShowInfoPopup = function (title, content, pointCoords) { showInfoWindow(title, content, pointCoords); }
    /**
     * @public
     * @function
     * @summary - Checks if the Information Popup is pinned
     * @returns {boolean} - | {@link boolean} <b>true</b> if the popup is pinned, <b>false</b> otherwise
    */
    this.IsInfoPopupPinned = function () { return infoWindowPinned; }
    /**
     * @public
     * @function
     * @summary - Toggles the pinned state of the Information Popup
     * @returns {void} - | {@link void} no return value
    */
    this.ToggleInfoPopupPin = function () { toggleInfoWindowPin(); }
    /**
     * @public
     * @function
     * @summary - Allows the user to interactivelly define a rectangular map area for information download from a TerraFly service
     * @returns {void} - | {@link void} no return value
    */
    this.StartDownloadInteraction = function () { return startDownloadInteraction(); }
    /**
     * @public
     * @function
     * @summary - Cancels an ongoing Download interaction
     * @returns {void} - | {@link void} no return value
    */
    this.CancelDownloadInteraction = function () { return cancelDownloadInteraction(); }
    /**
     * @public
     * @function
     * @summary - Allows the user to interactivelly measure distances and areas
     * @returns {void} - | {@link void} no return value
    */
    this.StartMeasureInteraction = function () { return startMeasureInteraction(); }
    /**
     * @public
     * @function
     * @summary - Cancels an ongoing Measure interaction
     * @returns {void} - | {@link void} no return value
    */
    this.CancelMeasureInteraction = function () { return cancelMeasureInteraction(); }
    /**
     * @public
     * @function
     * @summary - Collapses or expands the Overview Map according to the given parameter
     * @param {boolean} bool - set to <b>true</b> to collapse the Overview Map, <b>false</b> to expand it
     * @returns {void} - | {@link void} no return value
    */
    this.SetOverviewMapCollapsed = function (bool) {
        if (!!mapControls[tf.consts.panelNameOverview] && mapControls[tf.consts.panelNameOverview].isOn) { mapControls[tf.consts.panelNameOverview].control.setCollapsed(!!bool); }
    }
    /**
     * @public
     * @function
     * @summary - Checks if the Overview Map is collapsed
     * @returns {boolean} - | {@link boolean} <b>true</b> if the Overview Map is collapsed, <b>false</b> otherwise
    */
    this.IsOverviewMapCollapsed = function () { return !!mapControls[tf.consts.panelNameOverview] && mapControls[tf.consts.panelNameOverview].isOn && mapControls[tf.consts.panelNameOverview].control.getCollapsed(); }
    /**
     * @public
     * @function
     * @summary - Sets map view options
     * @param {tf.types.MapViewSettings} viewSettings - view options
     * @returns {void} - | {@link void} no return value
    */
    this.SetView = function (viewSettings) { return setView(viewSettings); }
    /**
     * @public
     * @function
     * @summary - Sets a custom Map Tile layer source along with its {@link tf.consts.typeNameHybrid} opacity
     * @param {tf.types.mapTileServerUrl} mapLayerSourceURLSet - alternative map engine
     * @param {tf.types.opacity01} mapLayerSourceHybridModeOpacitySet - opacity used when the map type is set to {@link tf.consts.typeNameHybrid}
     * @returns {void} - | {@link void} no return value
    */
    this.SetMapLayerSource = function (mapLayerSourceURLSet, mapLayerSourceHybridModeOpacitySet) {
        return setMapLayerSource(mapLayerSourceURLSet, mapLayerSourceHybridModeOpacitySet);
    }
    /**
     * @public
     * @function
     * @summary - Shows or hides all keyed features in the given list
     * @param {tf.map.KeyedFeatureList} keyedFeatureList - the list
     * @param {boolean} showOrHideBool - <b>true</b> to show the features, <b>false</b> to hide them
     * @param {string} styleName - optional feature style name
     * @returns {void} - | {@link void} no return value
    */
    this.ShowAllKeyedFeatures = function (keyedFeatureList, showOrHideBool, styleName) { return showAllKeyedFeatures(keyedFeatureList, showOrHideBool, styleName); }
    /**
     * @public
     * @function
     * @summary - Shows or hides the keyed features in the given list whose keys are included in the given list of keys
     * @param {tf.map.KeyedFeatureList} keyedFeatureList - the list
     * @param {enumerable} keyList - an enumerable containing the keys of the features to be shown or hidden
     * @param {boolean} showOrHideBool - <b>true</b> to show the features, <b>false</b> to hide them
     * @param {string} styleName - optional feature style name
     * @returns {void} - | {@link void} no return value
    */
    this.ShowSomeKeyedFeatures = function (keyedFeatureList, keyList, showOrHideBool, styleName) { return showSomeKeyedFeatures(keyedFeatureList, keyList, showOrHideBool, styleName); }
    /**
     * @public
     * @function
     * @summary - Shows or hides one keyed feature
     * @param {tf.map.KeyedFeature} keyedFeature - the feature
     * @param {boolean} showOrHideBool - <b>true</b> to show the features, <b>false</b> to hide them
     * @param {string} styleName - optional feature style name
     * @returns {void} - | {@link void} no return value
    */
    this.ShowKeyedFeature = function (keyedFeature, showOrHideBool, styleName) { return showKeyedFeature(feature, showOrHideBool, styleName); }
    /**
     * @public
     * @function
     * @summary - Checks if a given keyed feature is being shown
     * @param {tf.map.KeyedFeature} keyedFeature - the feature
     * @returns {boolean} - | {@link boolean} <b>true</b> if the feature is being shown, <b>false</b> otherwise
    */
    this.GetIsShowingKeyedFeature = function (keyedFeature) { return getIsShowingKeyedFeature(keyedFeature); }
    /**
     * @public
     * @function
     * @summary - Obtains the map feature layer for showing a given keyed feature, if one exists
     * @param {tf.map.KeyedFeature} keyedFeature - the feature
     * @returns {tf.map.FeatureLayer} - | {@link tf.map.FeatureLayer} the feature layer, or null if none exists
    */
    this.GetLayerForKeyedFeature = function (keyedFeature) { return getLayerForKeyedFeature(keyedFeature); }
    /**
     * @public
     * @function
     * @summary - Obtains the map feature layer for showing a given keyed feature list, if one exists
     * @param {tf.map.KeyedFeatureList} keyedFeatureList - the feature list
     * @returns {tf.map.FeatureLayer} - | {@link tf.map.FeatureLayer} the feature layer, or null if none exists
    */
    this.GetLayerForKeyedFeatureList = function (keyedFeatureList) { return getLayerForKeyedFeatureList(keyedFeatureList); }
    /**
     * @public
     * @function
     * @summary - Obtains a map feature layer given its name, if one exists
     * @param {string} name - the feature layer name
     * @returns {tf.map.FeatureLayer} - | {@link tf.map.FeatureLayer} the feature layer, or null if none exists
    */
    this.GetLayerByName = function (name) { return getLayerByName(name); }
    /**
     * @private
     * @function
     * @summary - adds a deprecated {@link TLayer} instance to the map
     * @param {tf.types.FeatureLayerSettings} layerSettings - layer creation settings
     * @returns {TLayer} - the deprecated TLayer instance
     * @deprecated This function will soon be removed
    */
    this.deprecatedAddLegacyLayer = function (layerSettings) { return addLegacyLayer(layerSettings); }
    /**
     * @private
     * @function
     * @summary - Requests the map to immediately initiate a render cycle. Should not be called from within a render cycle (e.g. during a map {@link tf.consts.mapPostComposeEvent} event)
     * @returns {void} - | {@link void} no return value
    */
    this.renderNow = function () { return renderNow(); }
    /**
     * @private
     * @function
     * @summary - Adds an HTML overlay to the map
     * @param {tf.map.HTMLOverlay} mapHTMLOverlay - the overlay instance
     * @returns {void} - | {@link void} no return value
    */
    this.addHTMLOverlay = function (mapHTMLOverlay) { if (!!mapHTMLOverlay && mapHTMLOverlay instanceof tf.map.HTMLOverlay) { olMap.addOverlay(mapHTMLOverlay.getAPIOverlay()); } }
    /**
     * @private
     * @function
     * @summary - Removes an HTML overlay from the map
     * @param {tf.map.HTMLOverlay} mapHTMLOverlay - the overlay instance
     * @returns {void} - | {@link void} no return value
    */
    this.removeHTMLOverlay = function (mapHTMLOverlay) { if (!!mapHTMLOverlay && mapHTMLOverlay instanceof tf.map.HTMLOverlay) { olMap.removeOverlay(mapHTMLOverlay.getAPIOverlay()); } }
    /**
     * @private
     * @function
     * @summary - Adds an HTML control to the map
     * @param {tf.map.HTMLControl} mapHTMLControl - the control instance
     * @returns {void} - | {@link void} no return value
    */
    this.addHTMLControl = function (mapHTMLControl) { if (!!mapHTMLControl && mapHTMLControl instanceof tf.map.HTMLControl) { olMap.addControl(mapHTMLControl.getAPIControl()); } }
    /**
     * @private
     * @function
     * @summary - Removes an HTML control from the map
     * @param {tf.map.HTMLControl} mapHTMLControl - the control instance
     * @returns {void} - | {@link void} no return value
    */
    this.removeHTMLControl = function (mapHTMLControl) { if (!!mapHTMLControl && mapHTMLControl instanceof tf.map.HTMLControl) { olMap.removeControl(mapHTMLControl.getAPIControl()); } }
    function showAllKeyedFeatures(keyedFeatureList, showOrHideBool, styleNameForShow) {
        if (keyedFeatureList instanceof tf.map.KeyedFeatureList) {
            var featureLayer = getLayerForKeyedFeatureList(keyedFeatureList);
            if (!!featureLayer) {
                if (!!showOrHideBool) {
                    var keyedList = keyedFeatureList.GetKeyedList();
                    var keyedItemList = keyedList.GetKeyedItemList();
                    for (var i in keyedItemList) { featureLayer.AddKeyedFeature(keyedFeatureList.GetFeature(keyedItemList[i].GetKey()), styleNameForShow, true); }
                    featureLayer.AddWithheldFeatures();
                } else { featureLayer.RemoveAllFeatures(); }
            }
        }
    }
    function showSomeKeyedFeatures(keyedFeatureList, keyList, showOrHideBool, styleNameForShow) {
        if (keyedFeatureList instanceof tf.map.KeyedFeatureList && typeof keyList === "object") {
            var featureLayer = getLayerForKeyedFeatureList(keyedFeatureList);
            if (!!featureLayer) {
                var keyedList = keyedFeatureList.GetKeyedList();
                showOrHideBool = !!showOrHideBool;
                for (var i in keyList) {
                    var keyedItem = keyedList.GetItem(keyList[i]);
                    if (!!keyedItem) {
                        var keyedFeature = keyedFeatureList.GetFeature(keyedItem.GetKey());
                        if (showOrHideBool) { featureLayer.AddKeyedFeature(keyedFeature, styleNameForShow, true); } else { featureLayer.DelKeyedFeature(keyedFeature, true); }
                    }
                }
                if (showOrHideBool) { featureLayer.AddWithheldFeatures(); } else { featureLayer.DelWithheldFeatures(); }
            }
        }
    }
    function showFeature(keyedFeature, showOrHideBool, styleNameForShow) {
        var featureLayer = getLayerForKeyedFeature(keyedFeature);
        if (!!featureLayer) { if (!!showOrHideBool) { featureLayer.AddKeyedFeature(keyedFeature, styleNameForShow, false); } else { featureLayer.DelKeyedFeature(keyedFeature, false); } }
    }
    function getIsShowingKeyedFeature(keyedFeature) {
        var featureLayer = getLayerForKeyedFeature(keyedFeature);
        return !!featureLayer ? featureLayer.ContainsKeyedFeature(keyedFeature) : false;
    }
    function getLayerForKeyedFeature(keyedFeature) { return tf.js.GetIsInstanceOf(keyedFeature, tf.map.KeyedFeature) ? getLayerByName(keyedFeature.GetLayerName()) : null; }
    function getLayerForKeyedFeatureList(keyedFeatureList) { return tf.js.GetIsInstanceOf(keyedFeatureList, tf.map.KeyedFeatureList) ? getLayerByName(keyedFeatureList.GetLayerName()) : null; }
    function getLayerByName(name) { return layersByName[name]; }
    var mapLayerSourceURL = null;
    var mapLayerSourceHybridModeOpacity = 1;
    var mapLayerSourceURLWasSet = false;
    function setMapLayerSource(mapLayerSourceURLSet, mapLayerSourceHybridModeOpacitySet) {
        mapLayerSourceURL = !!mapLayerSourceURLSet && typeof mapLayerSourceURLSet == "string" && mapLayerSourceURLSet.length > 0 ? mapLayerSourceURLSet : null;
        mapLayerSourceHybridModeOpacity = tf.js.GetFloatNumberInRange(mapLayerSourceHybridModeOpacitySet, 0.0, 1.0, 1.0);
        mapLayerSourceURLWasSet = false;
        setVectorLayerParams();
    }
    var useMapNik2 = null;
    var firstFeatureOnly = true;
    var infoFeatureName = "Info";
    var theThis = null;
    var mapButtonDimEmStr;
    var baseLayersPopup = null;
    var layersPopup = null;
    var typesPopup = null;
    var sourcesPopup = null;
    var infoWindowPopup = null;
    var locInfoWindowPopup = null;
    var messagePopup = null;
    var addressPopup = null;
    var downloadPopup = null;
    var measurePopup = null;
    var zIndexPopups = [];
    var baseNotification;
    function addToZIndexPopups(popup, theThis) {
        if (popup) {
            zIndexPopups.push(popup);
            popup.SetZIndex(minZIndexPopup++);
            popup.SetOnClickTitle(function () { return onClickMessagePopup(popup); }, theThis);
        }
    }
    function promoteToTopZIndex(popup) {
        if (popup) {
            var currentZIndex = popup.GetZIndex();
            if (currentZIndex < minZIndexPopup - 1) {
                var nZIndexPopups = zIndexPopups.length;
                var topZIndex = nZIndexPopups + minZIndexPopup;
                popup.SetZIndex(topZIndex);
                minZIndexPopup = topZIndex + 1;
                if (topZIndex > maxZIndex + nZIndexPopups) {
                    for (var i = 0 ; i < nZIndexPopups ; i++) {
                        var adjustedZIndex = zIndexPopups[i].GetZIndex() - startMinZIndexPopup;
                        zIndexPopups[i].SetZIndex(adjustedZIndex);
                    }
                    minZIndexPopup = startMinZIndexPopup + nZIndexPopups;
                }
            }
        }
    }
    var olMap = null;
    var olView = null;
    var rasterLayer = null;
    var vectorLayer = null;
    var vectorLayerSource = null, rasterLayerSource = null;
    var mapEngine = null, currentMode = null, currentSource = null;
    var mapFeatureLayers = [];
    var hiddenMapFeatureLayers = [];
    var invalidLatLon = -999;
    var invalidZoom = -1;
    var invalidRes = 0;
    var currentRes = invalidRes;
    var currentLevel = invalidZoom;
    var currentLat = invalidLatLon;
    var currentLon = invalidLatLon;
    var styles = tf.GetStyles();
    var containerAll = null, mapContainerAllObj = null, mapContainerObj = null, mapContainerAll = null, mapContainer = null;
    var mapControlContainerObj, mapControlContainerHTML;
    var maxZIndex = 500;
    var initialZIndex = 1;
    var zIndex = initialZIndex;
    var isShowingMapCenter = true;
    var mapCenterButton = null;
    var minZIndexPopup = 0;
    var startMinZIndexPopup = 0;
    var hoverListener;
    function createDivs(containerAllSet) {
        containerAll = tf.dom.GetHTMLElementFrom(containerAllSet);
        mapContainerAllObj = new tf.dom.Div({ cssClass: styles.mapContainerClass });
        mapContainerObj = new tf.dom.Div({ cssClass: styles.mapSubContainerClass });
        //mapControlContainerObj = new tf.dom.Div({ cssClass: styles.mapContainerClass });
        mapControlContainerObj = new tf.dom.Div({ cssClass: styles.GetUnPaddedDivClassNames(false, false) });
        mapControlContainerHTML = mapControlContainerObj.GetHTMLElement();
        mapControlContainerHTML.style.backgroundColor = "rgba(255, 0, 0, 0.6)";
        //mapControlContainerHTML.title = "hello, world.";
        mapContainerAll = mapContainerAllObj.GetHTMLElement();
        mapContainer = mapContainerObj.GetHTMLElement();
        hoverListener = new tf.events.DOMMouseEnterLeaveListener({
            target: containerAll, callBack: function (notification) {
                var target = notification.event.target;
                if (containerAll == target) {
                    if (!notification.isInHover) {
                        if (!containerAll.contains(document.activeElement)) {
                            hoverOutOfPossibleHoveredFeature();
                            //console.log('hovered out');
                        }
                    }
                }
                return true;
            }, optionalScope: theThis, callBackSettings: null
        });
        mapContainerObj.AppendTo(mapContainerAll);
        mapControlContainerObj.AppendTo(mapContainerAll);
        /*mapContainer.style.zIndex = zIndex++;
        mapContainer.style.height = "200%";
        mapContainer.style.width = "200%";
        mapContainer.style.transform = "translate(-50%, -50%)";*/
        minZIndexPopup = zIndex + 200;
        startMinZIndexPopup = minZIndexPopup;
        if (!settings.noNativeControls) {
            //var dim = subStyles.mapButtonDimEmNumber;
            var dim = (subStyles.locationPopupContentFontSizeEmNumber * 2);
            htmlFeedDiv = new tf.dom.Div({ cssClass: styles.dLayerInfoClass });
            var htmlFeedDivStyle = htmlFeedDiv.GetHTMLElement().style;
            htmlFeedDivStyle.textAlign = 'center';
            htmlFeedDivStyle.display = 'inline';
            var toggleBtn = styles.AddButtonDivRightMargin(new tf.ui.SvgGlyphBtn({
                style: styles.mapSvgGlyphInPopupClass, glyph: tf.styles.SvgGlyphCloseXName,
                onClick: toggleLocInfoWindow, tooltip: tf.consts.mapLocationPopupHideTip, dim: dim + "em"
            }));
            toggleBtn.GetHTMLElement().style.display = 'inline-block';
            infoPopupDiv = new tf.dom.Div({ cssClass: styles.unPaddedInlineBlockDivClass });
            infoPopupDiv.AddContent(toggleBtn);
            infoPopupDiv.AddContent(htmlFeedDiv);
        }
        if (!!containerAll) { mapContainerAllObj.AppendTo(containerAll); }
    }
    var olSourceVector = null;
    var olLayer = null;
    var privateTLayer = null;
    var userPosFeature = null;
    var userPosLocationFeature = null;
    var olInfoFeature = null;
    var olLocFeature = null;
    function privateNotifyTLayerVisibilityChange(tLayer) { if (layersPopup) { layersPopup.UpdateLayerVisibilityFromMap(); } }
    function privateSetDeleteCmdCallBack(tLayer, deleteCmdCallBack) { if (tLayer) { tLayer.exportSetDeleteCmdCallBack = deleteCmdCallBack; } }
    function removeLayer(layerObj) {
        if (tf.js.GetIsMapFeatureLayer(layerObj)) {
            var isHidden = layerObj.GetIsHidden();
            var layerArray = isHidden ? hiddenMapFeatureLayers : mapFeatureLayers;
            var index = layerArray.indexOf(layerObj);
            if (index != -1) {
                var layerName = layerObj.GetName();
                if (tf.js.GetIsNonEmptyString(layerName)) { delete layersByName[layerName]; }
                layerObj.RemoveAllFeatures();
                layerObj.exportSetDeleteCmdCallBack.call(layerObj);
                layerArray.splice(index, 1);
                if (!isHidden) { refreshLayersPopup(); }
            }
        }
    }
    function addLegacyLayer(layerSettings) { return doAddFeatureLayer(layerSettings, true); }
    function addFeatureLayer(layerSettings) { return doAddFeatureLayer(layerSettings, false); }
    function doAddFeatureLayer(layerSettings, isLegacy) {
        var featureLayer = null;
        var settingsUse = tf.js.ShallowMerge(layerSettings);
        var canAddLayer = true;
        var layerName = null;
        if (tf.js.GetIsNonEmptyString(settingsUse.name)) {
            if (!(canAddLayer = !getLayerByName(layerName = settingsUse.name))) {
                tf.GetDebug().LogIfTest("tf.map.Map: adding layer with duplicate name: " + layerName);
            }
        }
        if (canAddLayer) {
            settingsUse = tf.js.ShallowMerge(settingsUse, {
                map: theThis,
                olMap: olMap,
                notifyDelFeatures: privateNotifyDelFeatures,
                notifyVisibilityChange: privateNotifyTLayerVisibilityChange,
                setDeleteCmdCallBack: privateSetDeleteCmdCallBack
            });
            featureLayer = !!isLegacy ? new TLayer(settingsUse) : (settingsUse.overrideClass == undefined ? new tf.map.FeatureLayer(settingsUse) : new settingsUse.overrideClass(settingsUse)) ;
            if (!!layerName) { layersByName[layerName] = featureLayer; }
            if (!!featureLayer.GetIsHidden()) { hiddenMapFeatureLayers.push(featureLayer); } else { mapFeatureLayers.push(featureLayer); refreshLayersPopup(); }
        }
        return featureLayer;
    }
    function panByPixelOffset(pixelOffset) {
        if (tf.js.GetIsArrayWithMinLength(pixelOffset, 2)) {
            var x = tf.js.GetFloatNumber(pixelOffset[0], 0);
            var y = tf.js.GetFloatNumber(pixelOffset[1], 0);
            if (x != 0 || y != 0) {
                var center = getCenter();
                var sCenter = mapToPixelCoords(center);
                sCenter.X += x; sCenter.Y += y;
                var newCenter = pixelToMapCoords([sCenter.X, sCenter.Y]);
                setCenter(newCenter);
            }
        }
    }
    function getOLViewCenter() { return olView.getCenter(); }
    function getCenterCoords() { return tf.units.OL2TM(getOLViewCenter()); }
    function getCenter() {
        var center = getCenterCoords();
        center.Longitude = center[0];
        center.Latitude = center[1];
        return center;
    }
    function getPixelDistance(pointCoords1, pointCoords2) {
        var P1 = mapToPixelCoords(pointCoords1);
        var P2 = mapToPixelCoords(pointCoords2);
        var distanceX = P1[0] - P2[0];
        var distanceY = P1[1] - P2[1];
        var distanceSQ = (distanceX * distanceX) + (distanceY * distanceY);
        return Math.sqrt(distanceSQ);
    }
    function isSamePixelAs(pointCoords1, pointCoords2) { return getPixelDistance(pointCoords1, pointCoords2) == 0; };
    function getPixelDistanceFromCenter(pointCoords) {
        return getPixelDistance(/*[currentLon, currentLat]*/getCenter(), pointCoords);
    }
    function isSamePixelAsCenter(pointCoords) { return getPixelDistanceFromCenter(pointCoords) == 0; }
    function actualPixelToMapCoords(pointCoords) {
        var mapCoords = olMap.getCoordinateFromPixel(pointCoords);
        if (!tf.js.GetIsArrayWithMinLength(mapCoords, 2)) { mapCoords = [0, 0]; }
        else { mapCoords = tf.units.OL2TM(mapCoords); }
        return mapCoords;
    }
    function pixelToMapCoords(pointCoords) { return actualPixelToMapCoords(actualToVirtualPixelCoords(pointCoords)); }
    function actualMapToPixelCoords(pointCoords) {
        var pixelCoords = olMap.getPixelFromCoordinate(tf.units.TM2OL(pointCoords));
        if (!tf.js.GetIsArrayWithMinLength(pixelCoords, 2)) { pixelCoords = [0, 0]; }
        return pixelCoords;
    }
    function mapToPixelCoords(pointCoords) { return virtualToActualPixelCoords(actualMapToPixelCoords(pointCoords)); }
    var lastContainerAllClientW, lastContainerAllClientH;
    function onResize() {
        var newWidth = mapContainerAll.clientWidth;
        var newHeight = mapContainerAll.clientHeight;
        //console.log('attempt resize: ' + newWidth + ' x ' + newHeight);
        if (lastContainerAllClientW != newWidth || lastContainerAllClientH != newHeight) {
            //console.log('resize: ' + newWidth + ' x ' + newHeight);
            olMap.setSize([lastContainerAllClientW = newWidth, lastContainerAllClientH = newHeight]);
            olMap.updateSize();
            //theThis.Render();
        }
    }
    function getActualPixelSize() {
        if (olMap) { return olMap.getSize(); }
        else if (mapContainerAll) { return [mapContainerAll.clientWidth, mapContainerAll.clientHeight]; }
        return [0, 0];
    }
    function setLogoVisibility(visible) { return showPanel(tf.consts.panelNameTFLogo, !!visible); }
    var addressBarIsShowing = undefined;
    //var locInfoWindowIsShowing = undefined;
    var locInfoWindowIsShowing = false;
    //var locInfoWindowIsShowing = true;
    function getPanelElement(strPanel) {
        var elem;
        if (tf.js.GetIsNonEmptyString(strPanel)) {
            var strPanelLower = strPanel.toLowerCase();
            var panelControl = mapControls[strPanelLower];
            elem = !!panelControl ? panelControl.control : undefined;
        }
        return elem;
    }
    function showPanel(strPanel, showBool) {
        if (tf.js.GetIsNonEmptyString(strPanel)) {
            var strPanelLower = strPanel.toLowerCase();
            var panelControl = mapControls[strPanelLower];
            if (!panelControl) { checkCreateControl(strPanelLower); }
            if (!!panelControl) {
                if ((showBool = !!showBool) != panelControl.isOn) {
                    if (panelControl.isOn = !panelControl.isOn) {
                        if (panelControl.control) {
                            olMap.addControl(panelControl.control);
                            switch (strPanelLower) {
                                case tf.consts.panelNameOverview:
                                    if (!overviewMapClickHooked) {
                                        tryHookCount = 0;
                                        hookOverviewMapClick();
                                    }
                                    break;
                                case tf.consts.panelNameAddress:
                                    if (addressBarIsShowing === undefined || addressBarIsShowing == true) { showAddressBar(); }
                                    break;
                                case tf.consts.panelNameMapLocation:
                                    setUseRevGeocoderOnMoveEnd(showLocInfoWindowOnMoveEnd);
                                    if (locInfoWindowIsShowing === undefined || locInfoWindowIsShowing == true) { showLocInfoWindow(); }
                                    break;
                            }
                        }
                    }
                    else {
                        olMap.removeControl(panelControl.control);
                        switch (strPanelLower) {
                            case tf.consts.panelNameAddress:
                                addressBarIsShowing = isShowingAddressBar();
                                hideAddressBar();
                                break;
                            case tf.consts.panelNameMapLocation:
                                locInfoWindowIsShowing = isShowingLocInfoWindow();
                                hideLocInfoWindow();
                                setUseRevGeocoderOnMoveEnd(false);
                                break;
                        }
                    }
                }
            }
        }
    }
    function isPanelShowing(strPanel) {
        var isVisible = false;
        if (tf.js.GetIsNonEmptyString(strPanel)) {
            var panelControl = mapControls[strPanel.toLowerCase()];
            if (!!panelControl) { isVisible = panelControl.isOn; }
        }
        return isVisible;
    }
    function showPanels(strPanels) {
        if (tf.js.GetIsNonEmptyString(strPanels)) {
            strPanels = strPanels.split(tf.consts.charSplitStrings);
            var nParams = strPanels.length;
            var paramShown = [];
            var allstrPanels = tf.consts.allPanelNames;
            var allstrPanelsLen = allstrPanels.length;
            var showAddress = true;
            var showMapLocation = true;
            var showMapScale = true;
            var showMapRotate = true;
            var showUserLocation = true;
            for (var i = 0 ; i < nParams ; ++i) {
                var paramName = strPanels[i].toLowerCase();
                if (paramName == tf.consts.panelNameNoAddress) { showAddress = false; }
                else if (paramName == tf.consts.panelNameNoMapLocation) { showMapLocation = false; }
                else if (paramName == tf.consts.panelNameNoMapRotate) { showMapRotate = false; }
                else if (paramName == tf.consts.panelNameNoMapScale) { showMapScale = false; }
                else if (paramName == tf.consts.panelNameNoUserLocation) { showUserLocation = false; }
                else {
                    for (var j = 0 ; j < allstrPanelsLen ; ++j) {
                        var thisPanelParam = allstrPanels[j];
                        if (thisPanelParam == paramName) {
                            paramShown[j] = true;
                            showPanel(paramName, true);
                            break;
                        }
                    }
                }
            }
            for (var j = 0 ; j < allstrPanelsLen ; ++j) { var thisPanelShown = paramShown[j]; if (!thisPanelShown) { showPanel(allstrPanels[j], false); } }
            showPanel(tf.consts.panelNameAddress, showAddress);
            showPanel(tf.consts.panelNameMapLocation, showMapLocation);
            showPanel(tf.consts.panelNameMapRotate, showMapRotate);
            showPanel(tf.consts.panelNameMapScale, showMapScale);
            showPanel(tf.consts.panelNameUserLocation, showUserLocation);
        }
    }
    function setLegend(legendStrHybrid, legendStrMap) {
        //tf.GetDebug().LogIfTest("setting legend");
        var legendStrHybridUse = tf.js.GetNonEmptyString(legendStrHybrid, "");
        var legendStrMapUse = tf.js.GetNonEmptyString(legendStrMap, "");
        var decodedHybridLegend = new tf.map.aux.LegendDecoder(legendStrHybridUse);
        var decodedMapLayers = useMapNik2 ? new tf.map.aux.LegendDecoder(legendStrMapUse) : null;
        if (!!baseLayersPopup) {
            baseLayersPopup.SetLegend(decodedHybridLegend, decodedMapLayers);
            refreshLayersPopup();
        }
    }
    function isShowingPopup(popup) { return !!popup && popup.IsShowing(); }
    function showInfoPopup(popup) { if (!!popup) { hideOpenControlPopups(); popup.Show(true); } }
    function showControlPopup(popup) { if (!!popup) { hideOpenControlPopups(); showInfoPopup(popup); } }
    function hidePopup(popup) { !!popup && popup.Show(false); }
    function togglePopup(popup) { if (isShowingPopup(popup)) { hidePopup(popup); } else { showPopup(popup); } }
    function toggleControlPopup(popup) { if (isShowingPopup(popup)) { hidePopup(popup); } else { showControlPopup(popup); } }
    function isShowingMapType() { return isShowingPopup(typesPopup); }
    function showMapType() { showControlPopup(typesPopup); }
    function hideMapType() { hidePopup(typesPopup); }
    function toggleMapType() { toggleControlPopup(typesPopup); }
    function isShowingAddressBar() { return isShowingPopup(addressPopup); }
    function toggleAddressBar() { toggleControlPopup(addressPopup); }
    function hideAddressBar() { hidePopup(addressPopup); }
    function showAddressBar() { showControlPopup(addressPopup); }
    function isShowingMapLayers() { return isShowingPopup(layersPopup); }
    function showMapLayers() {
        if (mapFeatureLayers.length > 0) {
            showControlPopup(layersPopup);
        }
        else {
            showMapBaseLayers();
        }
    }
    function hideMapLayers() { hidePopup(layersPopup); }
    function toggleMapLayers() {
        if (isShowingMapLayers()) {
            hideMapLayers();
        }
        else {
            showMapLayers();
        }
    }
    function isShowingMapSource() { return isShowingPopup(sourcesPopup); }
    function showMapSource() { showControlPopup(sourcesPopup); }
    function hideMapSource() { hidePopup(sourcesPopup); }
    function toggleMapSource() { toggleControlPopup(sourcesPopup); }
    function isShowingMapBaseLayers() { return isShowingPopup(baseLayersPopup); }
    function showMapBaseLayers() { if (baseLayersPopup && baseLayersPopup.GetHasLegend()) { showControlPopup(baseLayersPopup); } }
    function hideMapBaseLayers() { hidePopup(baseLayersPopup); }
    function toggleMapBaseLayers() { toggleControlPopup(baseLayersPopup); }
    function hideOpenControlPopups() {
        //hideAddressBar();
        hideMapType();
        hideMapLayers();
        hideMapSource();
        hideMapBaseLayers();
    }
    function hideOpenPopups() {
        hideInfoWindow();
        hideLocInfoWindow();
        hideMessage();
        hideOpenControlPopups();
    }
    var mapControls = [];
    function privateSetSource(source) { setSource(source, false); }
    function privateSetMode(mode) { setMapType(mode, false); }
    function privateInfoOnClose() { hideInfoWindow(); }
    function privateLocInfoOnClose() {
        //hideLocInfoWindow();
    }
    function privateMessageOnClose() { hideMessage(); }
    function privateHasLegendCallBack() { return baseLayersPopup ? baseLayersPopup.GetHasLegend() : false; }
    function refreshLayersPopup() { if (layersPopup) { layersPopup.RefreshContent(); } }
    function onClickMessagePopup(thePopup) {
        if (thePopup.IsShowing()) {
            var promote = true;
            if (thePopup == messagePopup) {
                if (isShowingMessage()) {
                    if (messageHideInterval) {
                        clearMessageInterval();
                        thePopup.ShowTitleColorInfo(true);
                    }
                    else { hideMessage(); }
                }
            }
            else if (thePopup == infoWindowPopup) { toggleInfoWindowPin(); }
            else if (thePopup == locInfoWindowPopup) { promote = false; }
            if (promote && thePopup.IsShowing()) { promoteToTopZIndex(thePopup); }
        }
    }
    var currentHString = "";
    var currentMString = "";
    var curMapServerIndex = 0, curRasterServerIndex;
    var defaultMapnikStringH = "osm_water,osm_buildings,osm_roads,osm_road_names,osm_place_names";
    var defaultMapnikStringM = "osm_land,osm_landuse,osm_water,osm_buildings,osm_roads,osm_road_names,osm_place_names";
    var currentMapnikStringH = defaultMapnikStringH;
    var currentMapnikStringM = defaultMapnikStringM;
    var getVectorTileFunction = null;
    function getMapLayerSourceURL(tileCoordZXY) {
        var thisURL = mapLayerSourceURL;
        thisURL = thisURL.replace("\{x\}", tileCoordZXY[1].toString());
        thisURL = thisURL.replace("\{y\}", (-tileCoordZXY[2] - 1).toString());
        //thisURL = thisURL.replace("\{y\}", tileCoordZXY[2].toString());
        thisURL = thisURL.replace("\{z\}", tileCoordZXY[0].toString());
        return thisURL;
    }
    function isHybridMode() { return currentMode == tf.consts.typeNameHybrid; }
    function getMapnik1VectorTile(tileCoordZXY, pixelRatio, projection) {
        var thisURL = undefined;
        if (!!mapLayerSourceURL) { thisURL = getMapLayerSourceURL(tileCoordZXY); }
        else {
            var usingHybrid = isHybridMode();
            var mapURLPrefix = "http://terranode-";
            var mapURLs = ["163", "167", "170", "246"];
            var nURLs = mapURLs.length;
            var mapPrefixStr = ".cs.fiu.edu/cache_mapnik/Default.aspx?TargetImageType=png&style=BT&Composite=";
            var mapType = usingHybrid ? "HYBRID" : "MAP";
            var strUse = usingHybrid ? currentHString : currentMString;
            var mapSuffixStr = "&projType=merc&type=" + mapType + "&x=" + tileCoordZXY[1] + "&y=" + (-tileCoordZXY[2] - 1) + "&z=" + tileCoordZXY[0];
            var mapFullStr = mapPrefixStr + strUse + mapSuffixStr;
            if (curMapServerIndex == nURLs) { curMapServerIndex = 0; }
            thisURL = mapURLPrefix + mapURLs[curMapServerIndex++] + mapFullStr;
        }
        return thisURL;
    }
    function getMapnik2VectorTile(tileCoordZXY, pixelRatio, projection) {
        var thisURL = undefined;
        if (!!mapLayerSourceURL) { thisURL = getMapLayerSourceURL(tileCoordZXY); }
        else {
            var usingHybrid = isHybridMode();
            var mapURLPrefix = "http://131.94.133.";
            var nMapURLIPs = mapURLIPs.length;
            var service = usingHybrid ? "vmix" : "vector";
            var mapURLMiddle = "/TileService/" + service + ".aspx?projection=bing&styleset=";
            var mapStyle = usingHybrid ? "hybrid" : "map";
            var layersStr = usingHybrid ? currentMapnikStringH : currentMapnikStringM;
            var basicLayersStr = "&layers=" + layersStr;//"osm_land,osm_landuse,osm_water,osm_buildings,osm_roads,osm_road_names,osm_place_names";
            var mapURLSuffix = "&x=" + tileCoordZXY[1] + "&y=" + (-tileCoordZXY[2] - 1) + "&z=" + tileCoordZXY[0];
            if (curMapServerIndex >= nMapURLIPs) { curMapServerIndex = 0; }
            thisURL = mapURLPrefix + mapURLIPs[curMapServerIndex++] + mapURLMiddle + mapStyle + basicLayersStr + mapURLSuffix;
        }
        return thisURL;
    }
    function setVectorLayerParams() {
        if (vectorLayerSource) {
            var usingHybrid = isHybridMode();
            if (!!mapLayerSourceURL) {
                vectorLayer.setOpacity(usingHybrid ? mapLayerSourceHybridModeOpacity : 1);
                rasterLayer.setOpacity(usingHybrid ? 1.0 - mapLayerSourceHybridModeOpacity : 1);
            }
        }
    }
    function refreshVectorLayer() {
        if (!!vectorLayer) {
            vectorLayerSource = new ol.source.XYZ({ tileUrlFunction: getVectorTileFunction, crossOrigin: 'anonymous' }); vectorLayer.setSource(vectorLayerSource);
        }
    }
    function refreshRasterLayer() {
        if (!!rasterLayer) {
            rasterLayerSource = new ol.source.XYZ({ tileUrlFunction: getRasterTileFunction, crossOrigin: 'anonymous' }); rasterLayer.setSource(rasterLayerSource);
        }
    }
    function privateNotifyLegendOptionChange() { if (!mapLayerSourceURL) { refreshVectorLayer(); } }
    function privateNotifyLegendStringChange(currentHStringSet, currentMStringSet) {
        if (useMapNik2) {
            currentMapnikStringH = baseLayersPopup.GetHasLegendH() ? currentHStringSet : tf.js.GetNonEmptyString(currentHStringSet, defaultMapnikStringH);
            currentMapnikStringM = baseLayersPopup.GetHasLegendM() ? currentMStringSet : tf.js.GetNonEmptyString(currentMStringSet, defaultMapnikStringM);
        }
        else { currentHString = currentHStringSet; currentMString = currentMStringSet; }
        setVectorLayerParams();
    }
    var singleAttribution = null;
    var olOverviewMapControl = null;
    var olScaleLineControl = null;
    var olRotateControl = null;
    var rotationDuration = 250;
    var isUsScaleUnits = false;
    function toggleScaleUnits() {
        isUsScaleUnits = !isUsScaleUnits;
        setScaleUnits();
        mergeWithBaseAndNotifyListeners(tf.consts.mapToggleScaleUnitEvent);
    }
    function setScaleUnits() {
        if (!!olScaleLineControl) {
            var unitsName = isUsScaleUnits ? "us" : "metric";
            olScaleLineControl.setUnits(unitsName);
        }
    }
    function createScaleLineControl() {
        var targetUse = tf.dom.GetHTMLElementFrom(settings.scaleElemTarget);
        if (!targetUse) { targetUse = mapControlContainerHTML; }
        olScaleLineControl = new ol.control.ScaleLine({ target: targetUse });
        mapControls[tf.consts.panelNameMapScale] = { control: olScaleLineControl, isOn: false };
        olScaleLineControl.element.addEventListener("click", function () { toggleScaleUnits(); }); setScaleUnits();
    }
    function checkCreateControl(controlName) {
        var controlObj;
        switch (controlName) {
            case tf.consts.panelNameAddress:
                controlObj = new tf.map.ui.CustomControl(theThis, styles.mapAddressButtonClass, "A", showAddressBar, { tipLabel: tf.consts.addressBarName, imageLabel: getSearchButtonImg(), target: mapControlContainerHTML });
                break;
            case tf.consts.panelNameZoom:
                controlObj = new ol.control.Zoom({ zoomInLabel: tf.map.ui.CreateMapButtonTextSpan("+"), zoomOutLabel: tf.map.ui.CreateMapButtonTextSpan("-"), target: mapControlContainerHTML });
                break;
            case tf.consts.panelNameLayers:
                controlObj = new tf.map.ui.CustomControl(theThis, styles.mapLayersButtonClass, "L", showMapLayers, { tipLabel: tf.consts.mapLayersName, imageLabel: getLayersButtonImg(), target: mapControlContainerHTML });
                break;
            case tf.consts.panelNameType:
                controlObj = new tf.map.ui.CustomControl(theThis, styles.mapTypeButtonClass, "T", showMapType, { tipLabel: tf.consts.mapTypesName, imageLabel: getTypeButtonImg(), target: mapControlContainerHTML });
                break;
            case tf.consts.panelNameMeasure:
                controlObj = new tf.map.ui.CustomControl(theThis, styles.mapMeasureButtonClass, "M", startMeasureInteraction, { tipLabel: tf.consts.mapMeasureName, imageLabel: getMeasureButtonImg(), target: mapControlContainerHTML });
                break;
        }
        if (controlObj != undefined) { mapControls[controlName] = { control: controlObj, isOn: false }; }
    }
    function createMapControls(allControls, skipScaleLineControl) {
        if (allControls) {
            var controlNames = [tf.consts.panelNameAddress, tf.consts.panelNameZoom, tf.consts.panelNameLayers, tf.consts.panelNameType, tf.consts.panelNameMeasure];
            for (var i in controlNames) { checkCreateControl(controlNames[i]); }
            mapControls[tf.consts.panelNameDownload] = {
                control: new tf.map.ui.CustomControl(theThis, styles.mapDownloadButtonClass, "D", startDownloadInteraction, { tipLabel: tf.consts.mapDownloadName, imageLabel: getDownloadButtonImg(), target: mapControlContainerHTML }),
                isOn: false
            };
            mapControls[tf.consts.panelNameSource] = {
                control: new tf.map.ui.CustomControl(theThis, styles.mapSourceButtonClass, "S", showMapSource, { tipLabel: tf.consts.mapSourcesName, target: mapControlContainerHTML }),
                isOn: false
            };
            mapControls[tf.consts.panelNameFullscreen] = {
                control: new tf.map.ui.CustomControl(theThis, styles.mapFullScreenButtonClass, getFullScreenLabelNormal(), toggleMapFullScreen, { tipLabel: tf.consts.fullScreenToolTipNormal, target: mapControlContainerHTML }),
                isOn: false
            };
            mapControls[tf.consts.panelNameMapLocation] = {
                control: new tf.map.ui.CustomControl(theThis, styles.mapLocationButtonClass, "C", toggleLocInfoWindowShow, {
                    tipLabel: showLocInfoWindowOnMoveEnd ? tf.consts.mapLocationHideTip : tf.consts.mapLocationShowTip, imageLabel: getMapLocationButtonImg(), target: mapControlContainerHTML
                }),
                isOn: false
            };
            if (!!navigator.geolocation) {
                mapControls[tf.consts.panelNameUserLocation] = {
                    control: new tf.map.ui.CustomControl(theThis, styles.mapUserLocationButtonClass, "U", buttonRequestCenterToUserLocation, {
                        tipLabel: tf.consts.centerToUserLocationTip, imageLabel: getMapUserLocationButtonImg(), target: mapControlContainerHTML
                    }),
                    isOn: false
                };
            }
            var defaultMap2RasterImageUrls = [];
            var nURLIPs = mapURLIPs.length;
            for (var i = 0; i < nURLIPs; ++i) {
                var thisURL = 'http://131.94.133.' + mapURLIPs[i] + '/TileService/rmix.aspx?projection=bing&x={x}&y={y}&z={z}';
                defaultMap2RasterImageUrls.push(thisURL);
            }
            olOverviewMapControl = new ol.control.OverviewMap({
                layers: [new ol.layer.Tile({ source: new ol.source.XYZ({ urls: defaultMap2RasterImageUrls, crossOrigin: 'anonymous' }) })],
                className: 'ol-overviewmap',
                collapseLabel: tf.map.ui.CreateMapButtonTextSpan("\u00BB"),
                label: tf.map.ui.CreateMapButtonTextSpan("\u00AB"),
                collapsed: true, target: mapControlContainerHTML
            });
            mapControls[tf.consts.panelNameOverview] = {
                control: olOverviewMapControl,
                isOn: false
            };
            olRotateControl = new ol.control.Rotate({
                autoHide: false,
                label: tf.map.ui.CreateMapButtonTextSpan("\u21e7"),
                tipLabel: "Reset Map Rotation",
                resetNorth: function () {
                    var currentRotation = getRotationRad();
                    if (currentRotation == 0) {
                        showMessage(
                            "- Hold down SHIFT & ALT then Click & Drag to rotate<br/>" +
                            "- On touch screens, use two fingers to rotate "
                        );
                    }
                    else {
                        currentRotation = currentRotation % (2 * Math.PI);
                        if (currentRotation < -Math.PI) { currentRotation += 2 * Math.PI; }
                        if (currentRotation > Math.PI) { currentRotation -= 2 * Math.PI; }
                        animatedResetRotation();
                    }
                },
                target: mapControlContainerHTML
            });
            olRotateControl.element.style.zIndex = 1;
            mapControls[tf.consts.panelNameMapRotate] = { control: olRotateControl, isOn: false };
        }
        //poweredByTerraFlySVG = '<svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" enable-background="new 0 0 66 58" viewBox="0 0 66 58" height="100%" width="100%" y="0px" x="0px" version="1.1"><g><path d="M60.262,17.214c-3.436-2.931-9.344-2.097-15.352,1.575c4.221-1.991,8.189-2.166,10.611-0.042   c4.215,3.7,2.146,12.954-4.627,20.673C44.123,47.139,35.217,50.398,31,46.698c-2.393-2.1-2.758-5.987-1.392-10.369   c-3.021,6.815-3.053,13.151,0.52,16.2C35.365,57,46.357,52.715,54.68,42.963C62.998,33.211,65.5,21.683,60.262,17.214z" fill="#00519E" /><g ><g ><path d="M7.104,31.737H4.948V25.52H3v-1.763h6.046v1.763H7.104V31.737z" fill="#00519E" /><path d="M20.032,25.444c0.185,0,0.362,0.016,0.529,0.042l0.12,0.023l-0.19,2.014     c-0.175-0.044-0.416-0.065-0.726-0.065c-0.466,0-0.804,0.107-1.015,0.319c-0.211,0.211-0.317,0.519-0.317,0.919v3.041H16.3     v-6.185h1.588l0.332,0.988h0.104c0.178-0.327,0.426-0.592,0.745-0.795C19.387,25.544,19.708,25.444,20.032,25.444z" fill="#00519E" /><path d="M25.276,25.444c0.186,0,0.362,0.016,0.529,0.042l0.12,0.023l-0.19,2.014     c-0.175-0.044-0.417-0.065-0.726-0.065c-0.466,0-0.805,0.107-1.016,0.319c-0.21,0.211-0.316,0.519-0.316,0.919v3.041h-2.134     v-6.185h1.588l0.333,0.988h0.104c0.179-0.327,0.427-0.592,0.745-0.795C24.631,25.544,24.952,25.444,25.276,25.444z" fill="#00519E" /><path d="M30.821,31.737l-0.41-0.821h-0.042c-0.289,0.358-0.581,0.6-0.879,0.732     c-0.299,0.131-0.684,0.195-1.157,0.195c-0.582,0-1.041-0.173-1.375-0.522c-0.335-0.35-0.502-0.84-0.502-1.473     c0-0.659,0.229-1.15,0.688-1.471c0.458-0.323,1.123-0.504,1.991-0.544l1.031-0.033v-0.087c0-0.51-0.25-0.763-0.752-0.763     c-0.451,0-1.024,0.151-1.719,0.457L27.078,26c0.72-0.372,1.629-0.556,2.729-0.556c0.792,0,1.406,0.196,1.841,0.589     c0.435,0.393,0.652,0.942,0.652,1.648v4.056H30.821z M29.238,30.338c0.259,0,0.479-0.081,0.663-0.246     c0.184-0.162,0.276-0.375,0.276-0.638v-0.481l-0.492,0.024c-0.702,0.024-1.053,0.282-1.053,0.773     C28.633,30.149,28.835,30.338,29.238,30.338z" fill="#00519E" /><path d="M12.376,31.843c-1.03,0-1.829-0.272-2.398-0.82c-0.57-0.547-0.854-1.326-0.854-2.338     c0-1.044,0.264-1.846,0.792-2.404s1.28-0.837,2.259-0.837c0.932,0,1.651,0.241,2.158,0.728c0.508,0.486,0.762,1.186,0.762,2.099     v0.688c0,0,0.017,0.181-0.056,0.234c-0.059,0.045-0.27,0.028-0.27,0.028h-3.489c0.015,0.346,0.142,0.616,0.379,0.812     c0.239,0.195,0.563,0.296,0.975,0.296c0.375,0,0.72-0.038,1.034-0.107c0.279-0.062,0.577-0.165,0.898-0.308     c0.014-0.005,0.067-0.036,0.092-0.026c0.037,0.013,0.032,0.058,0.032,0.058v1.446c-0.335,0.172-0.68,0.289-1.037,0.355     C13.296,31.812,12.87,31.843,12.376,31.843z M12.25,26.895c-0.251,0-0.461,0.079-0.63,0.238     c-0.168,0.157-0.268,0.405-0.297,0.745h1.834c-0.008-0.298-0.093-0.538-0.255-0.717C12.741,26.984,12.523,26.895,12.25,26.895z" fill="#00519E" /></g><g ><path d="M33.332,35.92c-0.302,0-0.575-0.047-0.82-0.139v-0.924c0.28,0.096,0.524,0.145,0.734,0.145     c0.332,0,0.588-0.135,0.766-0.406c0.178-0.271,0.324-0.656,0.432-1.159l1.488-7.087h-1.264l0.084-0.439l1.35-0.433l0.148-0.654     c0.203-0.874,0.482-1.491,0.838-1.852c0.355-0.36,0.881-0.54,1.58-0.54c0.176,0,0.391,0.025,0.645,0.076     c0.252,0.05,0.447,0.106,0.59,0.167l-0.283,0.845c-0.332-0.126-0.631-0.19-0.898-0.19c-0.379,0-0.672,0.106-0.875,0.318     c-0.201,0.213-0.365,0.599-0.494,1.163l-0.162,0.708h1.559l-0.164,0.832h-1.553l-1.52,7.191c-0.17,0.826-0.43,1.428-0.785,1.809     C34.373,35.73,33.908,35.92,33.332,35.92z M39.697,32.698h-1.102l2.176-10.193h1.102L39.697,32.698z" fill="#00519E" /><path d="M42.285,25.518h1.102l0.482,3.57c0.045,0.301,0.086,0.744,0.129,1.332     c0.041,0.588,0.062,1.062,0.062,1.418H44.1c0.152-0.379,0.342-0.817,0.57-1.311c0.225-0.493,0.393-0.832,0.504-1.021l2.129-3.989     h1.166l-4.559,8.397c-0.406,0.752-0.807,1.272-1.207,1.565c-0.395,0.294-0.873,0.439-1.434,0.439     c-0.314,0-0.619-0.047-0.918-0.139v-0.886c0.275,0.081,0.561,0.119,0.859,0.119c0.357,0,0.666-0.109,0.92-0.331     c0.254-0.221,0.504-0.547,0.744-0.979l0.498-0.89L42.285,25.518z" fill="#00519E" /></g></g></g><text xml:space="preserve" style="font-style:normal;font-weight:normal;font-size:7.5px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#bfbfbf;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;" x="3.3413041" y="7.6913047" ><tspan x="3.3413041" y="7.6913047">powered by</tspan></text> <text y="7.1869569" x="3.0891302" style="font-style:normal;font-weight:normal;font-size:7.5px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" xml:space="preserve"><tspan y="7.1869569" x="3.0891302">powered by</tspan></text> </svg>';
        var logoOptions = { target: mapControlContainerHTML };
        var usingLogoSVG;
        if (usingLogoSVG = tf.js.GetIsNonEmptyString(settings.logoSVGHTML)) {
            logoOptions.innerHTML = settings.logoSVGHTML;
        }
        else { logoOptions.imageLabel = tf.platform.GetPoweredByTerraFlyLogo(); }
        mapControls[tf.consts.panelNameTFLogo] = { control: new tf.map.ui.CustomLogo(theThis, styles.mapTFLogoControlClass, logoOptions), isOn: false };
        if (usingLogoSVG) {
            mapControls[tf.consts.panelNameTFLogo].control.GetHTMLElement().style.padding = "4px";
        }
        if (!skipScaleLineControl) { createScaleLineControl(); }
    }
    var hasBeforeRender;
    function animatedSetRotation(newRotationRad, rotationDurationUse) {
        var currentRotation = getRotationRad();
        if (currentRotation != newRotationRad) {
            if (rotationDurationUse == undefined) { rotationDurationUse = rotationDuration; }
            if (hasBeforeRender) {
                olMap.beforeRender(ol.animation.rotate({
                    rotation: currentRotation,
                    duration: rotationDurationUse,
                    easing: ol.easing.easeOut
                }));
                setRotationRad(newRotationRad);
            }
            else {
                olView.animate({
                    rotation: newRotationRad,
                    duration: rotationDurationUse,
                    easing: ol.easing.easeOut
                }, function (animationConcludedOK) {
                    /*setTimeout(function () {
                        var normalizedAngle = tf.units.NormalizeAngle0To2PI(newRotationRad) - 2 * Math.PI;
                        console.log(normalizedAngle);
                        setRotationRad(normalizedAngle);
                    }, 10);*/
                    if (!animationConcludedOK) {
                        setRotationRad(newRotationRad);
                    }
                });
            }
        }
    }
    function animatedResetRotation() {
        var currentRotation = getRotationRad();
        if (currentRotation != 0) {
            animatedSetRotation(0);
        }
        /*var currentRotation = getRotationRad();
        if (currentRotation != 0) {
            if (hasBeforeRender) {
                currentRotation = currentRotation % (2 * Math.PI);
                if (currentRotation < -Math.PI) { currentRotation += 2 * Math.PI; }
                if (currentRotation > Math.PI) { currentRotation -= 2 * Math.PI; }
                olMap.beforeRender(ol.animation.rotate({
                    rotation: currentRotation,
                    duration: rotationDuration,
                    easing: ol.easing.easeOut
                }));
                setRotationRad(0);
            }
            else {
                olView.animate({
                    rotation: 0,
                    duration: rotationDuration,
                    easing: ol.easing.easeOut
                }, function (animationConcludedOK) {
                    if (!animationConcludedOK) {
                        setRotationRad(0);
                    }
                });
            }
        }*/
    }
    function getLayersForLayersPopup() { return mapFeatureLayers; }
    function createMapPopups() {
        var containerForAddressAndMessage = !!containerAll ? containerAll : mapContainerAll;
        baseLayersPopup =
            useMapNik2 ?
            new tf.map.ui.Mapnik2Popup(mapContainerAll, theThis, privateNotifyLegendStringChange, privateNotifyLegendOptionChange, mapControls[tf.consts.panelNameLayers].control, undefined) :
            new tf.map.ui.Mapnik1Popup(mapContainerAll, theThis, privateNotifyLegendStringChange, privateNotifyLegendOptionChange, mapControls[tf.consts.panelNameLayers].control, undefined);
        layersPopup = new tf.map.ui.LayersPopup(mapContainerAll, theThis, privateHasLegendCallBack, mapControls[tf.consts.panelNameLayers].control, showMapBaseLayers, getLayersForLayersPopup);
        addressPopup = new tf.map.ui.AddressBar(containerForAddressAndMessage, theThis, mapControls[tf.consts.panelNameAddress].control);
        typesPopup = new tf.map.ui.TypesPopup(mapContainerAll, theThis, privateSetMode, mapControls[tf.consts.panelNameType].control);
        sourcesPopup = new tf.map.ui.SourcesPopup(mapContainerAll, theThis, privateSetSource, mapControls[tf.consts.panelNameSource].control);
        locInfoWindowPopup = new tf.map.ui.LocationPopup(mapContainerAll);
        locInfoWindowPopup.SetOnClose(privateLocInfoOnClose, theThis);
        locInfoWindowPopup.SetZIndex(99);
        infoWindowPopup = new tf.map.ui.InfoPopup(mapContainerAll);
        infoWindowPopup.SetOnClose(privateInfoOnClose, theThis);
        addToZIndexPopups(infoWindowPopup, theThis);
        messagePopup = new tf.map.ui.MessagePopup(containerForAddressAndMessage);
        messagePopup.SetOnClose(privateMessageOnClose, theThis);
        //messagePopup.Show(false);
        addToZIndexPopups(messagePopup, theThis);
    }
    function setNewExtent(overviewDiv) {
        try {
            var offset = overviewDiv.helper.position();
            var divSize = [overviewDiv.helper.width(), overviewDiv.helper.height()];
            var mapSize = map.getPixelSize();
            var c = map.getView().getResolution();
            var xMove = offset.left * (Math.abs(mapSize[0] / divSize[0]));
            var yMove = offset.top * (Math.abs(mapSize[1] / divSize[1]));
            var bottomLeft = [0 + xMove, mapSize[1] + yMove];
            var topRight = [mapSize[0] + xMove, 0 + yMove];
            var left = map.getCoordinateFromPixel(bottomLeft);
            var top = map.getCoordinateFromPixel(topRight);
            var extent = [left[0], left[1], top[0], top[1]];
            map.getView().fit(extent, mapSize);
            map.getView().setResolution(c);
        }
        catch (exception) { }
    }
    var overviewMapElem = null, overviewBoxElem = null, overviewBoxParent = null;
    function onClickOverviewMap(notification) {
        var ovMap = olOverviewMapControl.getOverviewMap();
        var evTarget = tf.events.GetEventTarget(notification.event);
        var mouseOffset = tf.events.GetMouseEventCoords(notification.event);
        if (!evTarget || !mouseOffset) { return; }
        var clickX = mouseOffset[0];
        var clickY = mouseOffset[1];
        if (evTarget != overviewMapElem) {
            if (evTarget == overviewBoxElem) {
                clickX += overviewBoxParent.offsetLeft;
                clickY += overviewBoxParent.offsetTop;
            }
            else {
                clickX += evTarget.offsetLeft;
                clickY += evTarget.offsetTop;
            }
        }
        var coordinate = tf.units.OL2TM(ovMap.getCoordinateFromPixel([clickX, clickY]));
        setCenter(coordinate);
    }
    var tryHookCount = 0;
    var overviewMapClickHooked = false;
    function hookOverviewMapClick() {
        console.log('hookOverviewMapClick try');
        overviewMapElem = document.getElementsByClassName("ol-overviewmap-map");
        if (overviewMapElem.length > 0) {
            overviewMapClickHooked = true;
            overviewMapElem = overviewMapElem[0];
            overviewBoxElem = document.getElementsByClassName("ol-overviewmap-box");
            if (overviewBoxElem.length > 0) {
                overviewMapElem.style.cursor = 'pointer';
                overviewBoxElem = overviewBoxElem[0];
                overviewBoxParent = overviewBoxElem.parentNode;
                new tf.events.DOMClickListener({ target: overviewMapElem, callBack: onClickOverviewMap, optionalScope: theThis, callBackSettings: undefined });
            }
        }
        else {
            if (++tryHookCount < 10) {
                setTimeout(hookOverviewMapClick, 1000);
            }
            else {
                console.log('hookOverviewMapClick failed');
            }
        }
    }
    function createRasterAndVectorLayers() {
        vectorLayerSource = new ol.source.XYZ({ tileUrlFunction: getVectorTileFunction, crossOrigin: 'anonymous' });
        rasterLayerSource = new ol.source.XYZ({ tileUrlFunction: getRasterTileFunction, crossOrigin: 'anonymous' });
        rasterLayer = new ol.layer.Tile({ source: rasterLayerSource });
        vectorLayer = new ol.layer.Tile({ source: vectorLayerSource });
        olMap.addLayer(rasterLayer);
        olMap.addLayer(vectorLayer);
    }
    function setMapType(mode, updatePopup) {
        var modeSet = tf.js.GetNonEmptyString(mode, tf.consts.defaultSourceName);
        modeSet = modeSet.toLowerCase();
        var oldMode = currentMode;
        if (!currentMode || currentMode != modeSet) {
            var rasterVisible = false, vectorVisible = false;
            switch (modeSet) {
                default:
                case tf.consts.typeNameHybrid:
                    rasterVisible = vectorVisible = true;
                    currentMode = tf.consts.typeNameHybrid;
                    break;
                case tf.consts.typeNameMap:
                    vectorVisible = true;
                    currentMode = tf.consts.typeNameMap;
                    break;
                case tf.consts.typeNameAerial:
                    rasterVisible = true;
                    currentMode = tf.consts.typeNameAerial;
                    break;
            }
            rasterLayer.setVisible(rasterVisible);
            vectorLayer.setVisible(vectorVisible);
            if (updatePopup) { if (typesPopup) { typesPopup.UpdateModeFromMap(); } }
            refreshVectorLayer();
            setVectorLayerParams();
            mergeWithBaseAndNotifyListeners(tf.consts.mapTypeChangeEvent, { oldType: oldMode, newType: currentMode });
        }
    }
    function setSource(source, updatePopup) {
        var sourceSet = tf.js.GetNonEmptyString(source, tf.consts.defaultSourceName);
        if (!currentSource || currentSource != sourceSet) {
            currentSource = sourceSet;
            if (!!updatePopup) { if (sourcesPopup) { sourcesPopup.UpdateSourceFromMap(); } }
            refreshRasterLayer();
        }
    }
    function getRasterTileFunction(tileCoordZXY, pixelRatio, projection) {
        var thisURL = undefined;
        var mapURLPrefix = "http://131.94.133.";
        var nMapURLIPs = mapURLIPs.length;
        var mapURLMiddle = "/TileService/rmix.aspx?projection=bing&source=" + currentSource;
        var mapURLSuffix = "&x=" + tileCoordZXY[1] + "&y=" + (-tileCoordZXY[2] - 1) + "&z=" + tileCoordZXY[0];
        if (curMapServerIndex >= nMapURLIPs) { curMapServerIndex = 0; }
        thisURL = mapURLPrefix + mapURLIPs[curMapServerIndex++] + mapURLMiddle + mapURLSuffix;
        return thisURL;
    }
    function setCenter(pointCoords) {
        if (tf.js.GetIsArrayWithMinLength(pointCoords, 2)) {
            var center = tf.units.TM2OL(pointCoords);
            olView.setCenter(center);
        }
    }
    function setCenterAndLevel(pointCoords, level) { setCenter(pointCoords); setLevel(level); }
    function getResolution() { return olView.getResolution(); }
    function setResolution(resolution) {
        resolution = tf.js.GetFloatNumber(resolution, tf.units.GetResolutionByLevel(tf.consts.defaultLevel));
        if (resolution != currentRes) {
            olView.setResolution(resolution);
            currentRes = getResolution();
            resChanged = true;
            var level = tf.units.GetLevelByResolution(currentRes);
            if (!isAnimating) {
                onDelayResEnd.DelayCallBack();
            }
            if (level != currentLevel) {
                currentLevel = level;
                if (!isAnimating) {
                    onDelayZoomEnd.DelayCallBack();
                }
            }
        }
    }
    function getLevel() { return currentLevel; }
    function setLevel(level) {
        level = tf.js.GetLevelFrom(level);
        if (level != currentLevel) {
            currentLevel = level;
            olView.setZoom(level);
            currentRes = getResolution();
            resChanged = levelChanged = true;
            if (!isAnimating) {
                onDelayResEnd.DelayCallBack();
                onDelayZoomEnd.DelayCallBack();
            }
        }
    }
    function setView(viewSettings) {
        viewSettings = tf.js.GetValidObjectFrom(viewSettings);
        var extent = viewSettings.extent;
        var minLevel = tf.js.GetLevelFrom(viewSettings.minLevel);
        var maxLevel = tf.js.GetLevelFrom(viewSettings.maxLevel);
        if (minLevel > maxLevel) { var t = minLevel; minLevel = maxLevel; maxLevel = t; }
        var levelNow = getLevel();
        var center = olView.getCenter();
        if (levelNow < minLevel) { levelNow = minLevel; }
        if (levelNow > maxLevel) { levelNow = maxLevel; }
        var tmExtent;
        if (tf.js.GetIsArrayWithLength(extent, 4)) {
            tmExtent = extent.slice(0);
            extent = ol.extent.applyTransform(extent, ol.proj.getTransform(tf.consts.tmSystem, tf.consts.olSystem));
        }
        else {
            extent = undefined;
        }
        var enableRotation = viewSettings.enableRotation !== undefined ? !!viewSettings.enableRotation : true;
        var newSettings = {
            //constrainRotation: 4,
            enableRotation: enableRotation,
            maxZoom: maxLevel,
            minZoom: minLevel,
            center: center,
            zoom: levelNow,
            extent: extent
        };
        var newOLView = new ol.View(newSettings);
        olMap.setView(olView = newOLView);
        originalViewConstrainResolution = olView.constrainResolution;
        hookUpOLViewEvents();
        newSettings.extent = tmExtent;
        mergeWithBaseAndNotifyListeners(tf.consts.mapViewSettingsChangedEvent, newSettings);
    }
    function hookUpOLViewEvents() {
        olView.on('change:resolution', function (event) {
            var newLevel = tf.units.GetLevelByResolution(currentRes = getResolution());
            resChanged = true;
            levelChanged = newLevel != currentLevel;
            currentLevel = newLevel;
            if (!isAnimating) {
                onDelayResEnd.DelayCallBack();
                if (levelChanged) { onDelayZoomEnd.DelayCallBack(); }
            }
            //tf.GetDebug().LogIfTest('level: ' + currentLevel + ' res: ' + currentRes);
        }, theThis);
        olView.on('change:rotation', function (event) {
            if (!isAnimating) {
                onDelayRotEnd.DelayCallBack();
            }
            //tf.GetDebug().LogIfTest('level: ' + currentLevel + ' res: ' + currentRes);
        }, theThis);
    }
    var userPosLocationStyleSpecs = { marker: true, label: '.', zindex: 1, border_color: "#00f", border_width: 2, marker_color: "#000", font_color: "#fff", font_height: 16 };
    function buttonRequestCenterToUserLocation() { return requestCenterToUserLocation(true, true); }
    function updateUserLocation() { return requestCenterToUserLocation(false, false); }
    function requestCenterToUserLocation(showCoordinates, panToBool) {
        if (!!navigator.geolocation) { navigator.geolocation.getCurrentPosition(function (position) { centerToUserLocation(position, showCoordinates, panToBool); }, failedGeoLoc); }
    }
    function failedGeoLoc(err) { }
    var userPosFeatureAlreadyAdded = false;
    function centerToUserLocation(position, showCoordinates, panToBool) {
        var lat = position.coords.latitude;
        var lon = position.coords.longitude;
        if (panToBool) {
            //panTo(lat, lon);
            setCenter([lon, lat]);
        }
        userPosFeature.SetPointCoords([lon, lat]);
        userPosLocationFeature.SetPointCoords([lon, lat]);
        userPosLocationFeature.ChangeStyle(tf.js.ShallowMerge(userPosLocationStyleSpecs, { label: 'User at: ( ' + lat.toFixed(6) + ',' + lon.toFixed(6) + ' )' }));
        if (!userPosFeatureAlreadyAdded) {
            privateTLayer.AddMapFeature(userPosFeature);
            userPosFeatureAlreadyAdded = true;
        }
    }
    function hideUserLocation() {
        if (userPosFeatureAlreadyAdded) {
            privateTLayer.DelMapFeature(userPosFeature);
            userPosFeatureAlreadyAdded = false;
        }
    }
    var olInteractions, olInteractionsCopy, mapDrawInteraction, onDelayMoveEnd, onDelayZoomEnd, onDelayResEnd, onDelayRotEnd;
    
    function createOLInteractions(canRotate) {
        return new ol.interaction.defaults({
            altShiftDragRotate: canRotate,
            pinchRotate: canRotate,
            doubleClickZoom: false
        });
    }
    function createOLViewAndMap(canRotate) {
        olView = new ol.View({
            //enableRotation: false,
            maxZoom: tf.consts.maxLevel/*,
            minZoom: tf.consts.minLevel*/
        });
        var olControl = ol.control.defaults(
            //{ attribution: false, rotate: false, zoom: false }).extend([new ol.control.Rotate({ autoHide: /*false*/true })/*, new ol.control.ScaleLine()*/]
            { attribution: false, rotate: false, zoom: false }
        );
        olInteractions = createOLInteractions(canRotate);
        olInteractionsCopy = new ol.Collection();
        olInteractionsCopy.extend(olInteractions.getArray());
        olMap = new ol.Map({
            loadTilesWhileAnimating: true,
            loadTilesWhileInteracting: true,
            renderer: 'canvas',
            target: mapContainer,
            view: olView,
            controls: olControl,
            interactions: olInteractions
        });
        hasBeforeRender = !!tf.js.GetFunctionOrNull(olMap.beforeRender);
        originalViewConstrainResolution = olView.constrainResolution;
        createRasterAndVectorLayers();
        olSourceVector = new ol.source.Vector();
        olLayer = new ol.layer.Vector({ source: olSourceVector/*, visible: true*/, zIndex: mapPrivateLayerZIndex });
        olLayer.setVisible(true);
        olMap.addLayer(olLayer);
        privateTLayer = addFeatureLayer({ isVisible: true, isHidden: true, color: "#fff", zIndex: mapPrivateLayerZIndex - 1 });
        /*privateTLayer = new tf.map.FeatureLayer(theThis, olMap, "", "", true, true, "#fff", null, null,
            false, null, null, null, false, null, mapPrivateLayerZIndex - 1
            );*/
        //privateTLayer.AddMarker(tf.consts.defaultLatitude, tf.consts.defaultLongitude, "hello, world.");
        var snapToPixel = false;
        var circle_radius = 16;
        var userPosGeom = new tf.map.FeatureGeom({ type: "point", coordinates: [tf.consts.defaultLongitude, tf.consts.defaultLatitude] });
        var userPosStyleSpecs = [
            { circle: true, circle_radius: circle_radius + 2, fill: true, fill_color: "#ebebeb", fill_alpha: 60, zindex: 2, snaptopixel: snapToPixel },
            { circle: true, circle_radius: circle_radius - 2, fill: false, fill_color: "#abf", line: true, line_color: "#00a", line_width: 1, zindex: 3, snaptopixel: snapToPixel },
            { circle: true, circle_radius: circle_radius - 8, fill: true, fill_color: "#f84", line: true, line_color: "#00f", line_width: 1, zindex: 4, snaptopixel: snapToPixel }
        ];
        var userPosHoverStyleSpecs = [
            tf.js.ShallowMerge(userPosStyleSpecs[0], { fill_color: "#fbfbfb" }),
            tf.js.ShallowMerge(userPosStyleSpecs[1], { line_width: 2 }),
            { circle: true, circle_radius: circle_radius - 8, fill: true, fill_color: "#f84", line: true, line_color: "#00f", line_width: 1, zindex: 4, snaptopixel: snapToPixel }
        ];
        userPosFeature = new tf.map.Feature({ geom: userPosGeom, style: userPosStyleSpecs, hoverStyle: userPosHoverStyleSpecs });
        userPosLocationFeature = new tf.map.Feature({ geom: userPosGeom, style: userPosLocationStyleSpecs });
        userPosFeature.SetOnHoverInOutListener(onHoverInOutUserPosFeature);
    }
    function onHoverInOutUserPosFeature() {
        if (userPosFeature.GetIsInHover()) {
            privateTLayer.AddMapFeature(userPosLocationFeature);
        }
        else { privateTLayer.DelMapFeature(userPosLocationFeature); }
    }
    var levelChanged, resChanged, posChanged;
    function checkSizePopups() {
        if (addressPopup) { addressPopup.OnContainerResize(); }
        if (measurePopup) { measurePopup.OnContainerResize(); }
        if (baseLayersPopup) { baseLayersPopup.OnContainerResize(); }
        if (infoWindowPopup) { infoWindowPopup.OnContainerResize(); }
        if (layersPopup) { layersPopup.OnContainerResize(); }
        if (sourcesPopup) { sourcesPopup.OnContainerResize(); }
        if (typesPopup) { typesPopup.OnContainerResize(); }
        if (locInfoWindowPopup) { locInfoWindowPopup.OnContainerResize(); }
        if (messagePopup) { messagePopup.OnContainerResize(); }
    }
    function addPointMarker(pointCoords, style, name) {
        var lat = tf.js.GetLatitudeFrom(pointCoords[1]);
        var lon = tf.js.GetLongitudeFrom(pointCoords[0]);
        var markerPoint = new ol.geom.Point([lon, lat]).transform(tf.consts.tmSystem, tf.consts.olSystem);
        var olFeature = new ol.Feature({ geometry: markerPoint, markerName: name });
        olFeature.setStyle(style);
        olSourceVector.addFeature(olFeature);
        return olFeature;
    }
    function getFullScreenLabelNormal() { return styles.GetUnicodeDoubleHorArrow(); }
    function getFullScreenLabelFull() { return styles.GetUnicodeXClose(); }
    function getSearchButtonImg() { return new tf.ui.SvgGlyphBtn({ style: styles.mapSvgGlyphInButtonClass, glyph: tf.styles.SvgGlyphMagnifyingLensName, dim: mapButtonDimEmStr, noChangeOnHover: true }); }
    function getLayersButtonImg() { return new tf.ui.SvgGlyphBtn({ style: styles.mapSvgGlyphInButtonClass, glyph: tf.styles.SvgGlyphMapLayersName, dim: mapButtonDimEmStr, noChangeOnHover: true }); }
    function getMeasureButtonImg() { return new tf.ui.SvgGlyphBtn({ style: styles.mapSvgGlyphInButtonClass, glyph: tf.styles.SvgGlyphMeasuringTapeName, dim: mapButtonDimEmStr, noChangeOnHover: true }); }
    function getDownloadButtonImg() { return new tf.ui.SvgGlyphBtn({ style: styles.mapSvgGlyphInButtonClass, glyph: tf.styles.SvgGlyphDownloadName, dim: mapButtonDimEmStr, noChangeOnHover: true }); }
    function getTypeButtonImg() { return new tf.ui.SvgGlyphBtn({ style: styles.mapSvgGlyphInButtonClass, glyph: tf.styles.SvgGlyphEarthName, dim: mapButtonDimEmStr, noChangeOnHover: true }); }
    function getMapLocationButtonImg() { return new tf.ui.SvgGlyphBtn({ style: styles.mapSvgGlyphInButtonClass, glyph: tf.styles.SvgGlyphBullsEye2Name, dim: mapButtonDimEmStr, noChangeOnHover: true }); }
    function getMapUserLocationButtonImg() { return new tf.ui.SvgGlyphBtn({ style: styles.mapSvgGlyphInButtonClass, glyph: tf.styles.SvgGlyphUserLocationName, dim: mapButtonDimEmStr, noChangeOnHover: true }); }
    function getMapInfoPinImgSrc() { return tf.platform.MakePlatformPath("image/pin260pinned.png"); }
    function getMapInfoUnPinImgSrc() { return tf.platform.MakePlatformPath("image/pin260.png"); }
    var pinInfoMarkerSrc = getMapInfoPinImgSrc();
    var unPinInfoMarkerSrc = getMapInfoUnPinImgSrc();
    function makeMarkerStyle(pinFile, pinAnchor) {
        var markerStyle =
            [new ol.style.Style({
                image: new ol.style.Icon({
                    crossOrigin: "",
                    src: pinFile,
                    anchor: pinAnchor
                })
            })];
        return markerStyle;
    }
    function createInfoMarkerStyle(pinned) {
        var aPin = pinned ? pinInfoMarkerSrc : unPinInfoMarkerSrc;
        return makeMarkerStyle(aPin, [0.5, 0.05]);
    }
    var pinInfoMarker = createInfoMarkerStyle(true);
    var unPinInfoMarker = createInfoMarkerStyle(false);
    function showInfoMarker(pointCoords) {
        olInfoFeature = addPointMarker(pointCoords, unPinInfoMarker, infoFeatureName);
    }
    function hideInfoMarker() {
        if (olInfoFeature) {
            olSourceVector.removeFeature(olInfoFeature);
            olInfoFeature = null;
        }
    }
    var infoWindowPinned = false;
    function toggleInfoWindowPin() {
        if (olInfoFeature) {
            infoWindowPinned = !infoWindowPinned;
            var markerUse = infoWindowPinned ? pinInfoMarker : unPinInfoMarker;
            olInfoFeature.setStyle(markerUse);
            infoWindowPopup.ShowTitleColorInfo(infoWindowPinned);
        }
    }
    function isShowingInfoWindow() { return infoWindowPopup ? infoWindowPopup.IsShowing() : false; }
    function hideInfoWindow() {
        if (isShowingInfoWindow()) {
            hideInfoMarker();
            infoWindowPopup.ShowTitleColorInfo(false);
            infoWindowPopup.Show(false);
            infoWindowPinned = false;
        }
    }
    function toggleInfoWindow() {
        if (isShowingInfoWindow()) { hideInfoWindow(); } else { showInfoWindow(); }
    }
    function showInfoWindow(title, content, pointCoords) {
        if (infoWindowPopup) {
            if (!infoWindowPinned) {
                if (!!content) {
                    //hideOpenControlPopups();
                    hideInfoMarker();
                    showInfoMarker(pointCoords);
                    infoWindowPopup.SetTitle(title);
                    infoWindowPopup.SetContent(content);
                    promoteToTopZIndex(infoWindowPopup);
                    infoWindowPopup.Show(true);
                }
            }
        }
    }
    var showLocInfoWindowOnMoveEndByDefault;
    var showLocInfoWindowOnMoveEnd;
    function setLocInfoWindowShow() {
        setUseRevGeocoderOnMoveEnd(showLocInfoWindowOnMoveEnd);
        if (!showLocInfoWindowOnMoveEnd) {
            hideLocInfoWindow();
            mapControls[tf.consts.panelNameMapLocation].control.ChangeToolTip(tf.consts.mapLocationShowTip);
        }
        else {
            showLocInfoWindow();
            mapControls[tf.consts.panelNameMapLocation].control.ChangeToolTip(tf.consts.mapLocationHideTip);
        }
    }
    function toggleLocInfoWindowShow() {
        showLocInfoWindowOnMoveEnd = !showLocInfoWindowOnMoveEnd;
        setLocInfoWindowShow();
    }
    function toggleLocInfoWindow() { if (isShowingLocInfoWindow()) { hideLocInfoWindow(); } else { showLocInfoWindow(); } }
    function isShowingLocInfoWindow() { return locInfoWindowPopup ? locInfoWindowPopup.IsShowing() : false; }
    function hideLocInfoWindow() {
        if (isShowingLocInfoWindow()) {
            locInfoWindowPopup.Show(false);
        }
    }
    function showLocInfoWindow() {
        if (locInfoWindowPopup) {
            /*promoteToTopZIndex(locInfoWindowPopup);*/
            locInfoWindowPopup.Show(true);
        }
    }
    var infoPopupDiv = null;
    var htmlFeedDiv = null;
    function updateLocInfoWindow(myLabel, myContent, useUpdatedColor) {
        locInfoWindowPopup.ShowTitleColorInfo(!!useUpdatedColor);
        locInfoWindowPopup.SetTitle(typeof myLabel == "string" && myLabel.length > 0 ? myLabel : "Location");
        htmlFeedDiv.ClearContent();
        if (typeof myContent === "string") { htmlFeedDiv.GetHTMLElement().innerHTML = myContent; } else { htmlFeedDiv.AddContent(myContent); }
        locInfoWindowPopup.SetContent(infoPopupDiv);
        if (showLocInfoWindowOnMoveEnd) { if (!isShowingLocInfoWindow()) { showLocInfoWindow(); } }
    }
    var messagePinned = false;
    function setMessageTimeout(timeoutSecs) {
        messageTimeoutSecs = (typeof timeoutSecs == "number" && timeoutSecs >= 0) ? timeoutSecs : defaultmessageTimeoutSecs;
    }
    function isShowingMessage() { return isShowingPopup(messagePopup); }
    function showMessage(content) {
        if (messagePopup && !messagePinned) {
            clearMessageInterval();
            messagePopup.SetContent(content);
            messagePopup.ShowTitleColorInfo(false);
            promoteToTopZIndex(messagePopup);
            showInfoPopup(messagePopup);
            setMessageTimeoutObject();
        }
    }
    function toggleMessage() { if (isShowingMessage()) { hideMessage() } else { showMessage(); } }
    function hideMessage() {
        if (isShowingMessage()) {
            clearMessageInterval();
            hidePopup(messagePopup);
            messagePinned = false;
        }
    }
    var messageHideInterval = null;
    var defaultmessageTimeoutSecs = 5;
    var messageTimeoutSecs = defaultmessageTimeoutSecs;
    function clearMessageInterval() {
        if (messageHideInterval) {
            clearInterval(messageHideInterval);
            messageHideInterval = null;
        }
    }
    function setMessageTimeoutObject() {
        if (messageTimeoutSecs) {
            messageHideInterval = setTimeout(hideMessage, messageTimeoutSecs * 1000);
        }
    }
    function whenMapResolutionChanges(atGivenResolution) {
        if (decodedLegendH != undefined) {
            var res = atGivenResolution != undefined ? atGivenResolution : getResolution();
            if (useMapNik2) {
                currentMapnikStringH = tf.js.GetLegendCompositesStrs(decodedLegendH, res).m2;
                currentMapnikStringM = tf.js.GetLegendCompositesStrs(decodedLegendM, res).m2
            }
            else {
                currentHString = tf.js.GetLegendCompositesStrs(decodedLegendH, res).m1H;
                currentMString = tf.js.GetLegendCompositesStrs(decodedLegendH, res).m1M;
            }
            setVectorLayerParams();
            //privateNotifyLegendOptionChange();
        }
        else {
            if (!!baseLayersPopup) {
                if (resChanged) { baseLayersPopup.OnResolutionChange(currentRes); }
            }
        }
    }
    function onNotifyMoveEnd() {
        whenMapResolutionChanges();
        mergeWithBaseAndNotifyListeners(tf.consts.mapMoveEndEvent, makeCurrentLatLonNotification());
        levelChanged = false;
        posChanged = false;
    }
    function createLevelResolutionNotification() { return { level: currentLevel, resolution: currentRes }; }
    function createLevelRotationNotification() { return { rotation_rad: getRotationRad(), rotation_deg: getRotationDeg() }; }
    function onNotifyResolutionEnd() {
        whenMapResolutionChanges();
        mergeWithBaseAndNotifyListeners(tf.consts.mapResolutionChangeEvent, createLevelResolutionNotification());
        resChanged = false;
    }
    function onNotifyRotationEnd() {
        mergeWithBaseAndNotifyListeners(tf.consts.mapRotationChangeEvent, createLevelRotationNotification());
    }
    function onNotifyZoomEnd() {
        mergeWithBaseAndNotifyListeners(tf.consts.mapLevelChangeEvent, createLevelResolutionNotification());
        levelChanged = false;
    }
    var minAniSpeed = 100;
    var maxAniSpeed = 9999999999;
    function makeAnimatedCallBackNotification() {
        return mergeWithBaseNotification(tf.js.ShallowMerge(makeCurrentLatLonNotification(), createLevelResolutionNotification()));
    }
    function notifyAnimationEnd(callBack) {
        if (!!(callBack = tf.js.GetFunctionOrNull(callBack))) {
            var notification = makeAnimatedCallBackNotification();
            setTimeout(function () { callBack(notification); }, 1);
            //callBack(notification);
        }
    }
    function animatedSetLevel(newLevel, callBack, durationPerLevel, notifyListeners, easing) {
        newLevel = tf.js.GetLevelFrom(newLevel);
        var levelDiff = Math.abs(currentLevel - newLevel);
        if (levelDiff != 0) {
            durationPerLevel = tf.js.GetFloatNumberInRange(durationPerLevel, minAniSpeed, maxAniSpeed, tf.consts.defaultMapAnimatedDurationPerLevelMillis);
            var speed = levelDiff * durationPerLevel;
            if (speed <= 0) { speed = 10; }
            startAnimation(function (request) {
                var nextStep;
                if (request.step == 0) {
                    nextStep = {
                        duration: speed,
                        resolution: tf.units.GetResolutionByLevel(newLevel),
                        notifyListeners: !!notifyListeners
                    };
                    if (tf.js.GetFunctionOrNull(easing)) { nextStep.easing = easing; }
                }
                else {
                    notifyAnimationEnd(callBack); callBack = null;
                }
                return nextStep;
            }, theThis);
        }
        else { notifyAnimationEnd(callBack); }
    }
    function animatedSetCenter(pointCoords, callBack, duration, notifyListeners, easing) {
        //return setCenter(pointCoords);
        if (isSamePixelAsCenter(pointCoords)) {
            setCenter(pointCoords);
            notifyAnimationEnd(callBack);
        }
        else {
            var latitude = tf.js.GetLatitudeFrom(pointCoords[1]);
            var longitude = tf.js.GetLongitudeFrom(pointCoords[0]);
            duration = tf.js.GetFloatNumberInRange(duration, minAniSpeed, maxAniSpeed, tf.consts.defaultMapAnimatedCenterDurationMillis);
            var center = getCenter();
            startAnimation(function (request) {
                var nextStep;
                if (request.step == 0) {
                    nextStep = {
                        duration: duration,
                        center: [longitude, latitude],
                        notifyListeners: !!notifyListeners
                    };
                    if (tf.js.GetFunctionOrNull(easing)) { nextStep.easing = easing; }
                }
                else if (!!callBack) { notifyAnimationEnd(callBack); callBack = null; }
                return nextStep;
            }, theThis);
        }
    }
    function animatedSetCenterIfDestVisible(pointCoords, speed) {
        if (getAreMapCoordsVisible(pointCoords)) { animatedSetCenter(pointCoords, speed, null, false); } else { setCenter(pointCoords); }
    }
    var hasInteractions = true;
    var hadZoomControl = false;
    function getHasInteractions() { return hasInteractions; }
    function setHasInteractions(bool) {
        bool = !!bool;
        if (bool != hasInteractions) {
            if (bool) { addInteractions(); }
            else { removeInteractions(); }
        }
    }
    function removeInteractions() {
        if (hasInteractions) {
            olInteractions.clear();
            if (hadZoomControl = !!mapControls[tf.consts.panelNameZoom] && mapControls[tf.consts.panelNameZoom].isOn) { showPanel(tf.consts.panelNameZoom, false); }
            hasInteractions = false;
        }
    }
    function addInteractions() {
        if (!hasInteractions) {
            olInteractions.extend(olInteractionsCopy.getArray());
            if (hadZoomControl) { showPanel(tf.consts.panelNameZoom, true); }
            if (!!mapDrawInteraction) {
                mapDrawInteraction.Restore();
            }
            hadZoomControl = false;
            hasInteractions = true;
        }
    }
    var vidParamStr = null;
    function setVIDParamStr(vidParamStrSet) { vidParamStr = typeof vidParamStrSet === "string" && vidParamStrSet.length > 0 ? vidParamStrSet : null; }
    function getVIDParamStr() { return vidParamStr; }
    var passTroughString = null;
    function setTFPassThroughString(passThroughStringSet) {
        passTroughString = tf.js.GetNonEmptyString(passThroughStringSet, null);
        if (tf.js.GetIsNonEmptyString(passTroughString)) { if (passTroughString.charAt(0) != '&') { passTroughString = '&' + passTroughString; } }
    }
    function getTFPassTroughString() { return passTroughString; }
    var revGeocoder = null;
    function isUsingRevGeocoderOnMoveEnd() { return revGeocoder != null && revGeocoder.IsListeningToMoveEnd(); }
    function setUseRevGeocoderOnMoveEnd(bool) { if (revGeocoder) { revGeocoder.SetListenToMoveEnd(bool); } }
    var tDBPage = null;
    var geoCodeFlyer = null;
    function onEndGeoCodeFlyer(Lat, Lon, ErrorMsg, GeoCodeResult) {
        if (isUsingRevGeocoderOnMoveEnd()) {
            if (geoCodeFlyer == null || !geoCodeFlyer.DidMove()) { revGeocoder.TryShowGeocode(Lat, Lon, ErrorMsg, GeoCodeResult); }
            //revGeocoder.TryShowGeocode(Lat, Lon, ErrorMsg, GeoCodeResult);
        }
        else if (tf.js.GetIsNonEmptyString(ErrorMsg)) { showMessage(ErrorMsg); }
    }
    function flyToAddress(addressStr) {
        var tryToFly = true;
        if (geoCodeFlyer) {
            geoCodeFlyer.Cancel();
            if (tryToFly = geoCodeFlyer.WasCancelled() || geoCodeFlyer.HasCompleted()) { geoCodeFlyer = null; }
        }
        if (tryToFly) {
            if (tf.js.GetIsNonEmptyString(addressStr)) {
                geoCodeFlyer = new tf.map.aux.GeoCodeFlyer(theThis, onEndGeoCodeFlyer, addressStr);
                new tf.services.Geocoder({
                    address: addressStr, callBack: function (data) {
                        var pointCoords = !!data ? data.pointCoords : [0, 0];
                        geoCodeFlyer.DelayCallBack(pointCoords[1], pointCoords[0], data.errormsg, data.geocoderlevel);
                    }
                });
                //TGetLatLngByAddress(addressStr, geoCodeFlyer.DelayCallBack);
            }
        }
        return tryToFly;
    }
    function defaultMapOnClick(notification) { animatedSetCenter(notification.eventCoords); }
    var panOnClickListener = null;
    function AfterMapOnClickFlyEnds(lat, lon) { }
    function setUsePanOnClick(bool) {
        if ((bool = !!bool) != isUsingPanOnClick()) {
            if (bool) { panOnClickListener = allEventDispatchers.AddListener(tf.consts.mapClickEvent, defaultMapOnClick); }
            else { panOnClickListener.OnDelete(); panOnClickListener = null; }
        }
    }
    function isUsingPanOnClick() { return panOnClickListener != null; }
    function goDBByAddress(addressStr) { if (tDBPage) { tDBPage.GoDBByAddress(addressStr); } }
    function goDBByCoords(pointCoords) { if (tDBPage) { tDBPage.GoDBByCoords(pointCoords); } }
    function GoDBByCenterCoords() { if (tDBPage) { tDBPage.GoDBByCenterCoords(); } }
    var goDBOnDoubleClick = true;
    function setGoDBOnDoubleClick(bool) { goDBOnDoubleClick = !!bool; }
    function getGoDBOnDoubleClick() { return goDBOnDoubleClick; }
    function setAddressBarHelp(addressBarHelpStr) {
        if (addressPopup) {
            typeof addressBarHelpStr !== "string" && (addressBarHelpStr = "");
            addressPopup.SetAddressBarHelp(addressBarHelpStr);
        }
    }
    function setAddressBarText(addressBarText) {
        if (addressPopup) {
            typeof addressBarText !== "string" && (addressBarText = "");
            addressPopup.SetAddressBarText(addressBarText);
        }
    }
    function getAddressBarText() { return addressPopup ? addressPopup.GetAddressBarText() : ''; }
    function setRotationDeg(rotationDeg) { return setRotationRad(tf.units.DegreesToRadians(rotationDeg)); }
    function getRotationDeg() { return tf.units.RadiansToDegrees(getRotationRad()); }
    function setRotationRad(rotationRad) { olView.setRotation(tf.js.GetFloatNumber(rotationRad, 0)); }
    function getRotationRad() { return olView.getRotation(); }
    function doDownloadQuery(downloadExtent, utmExtent) {
        if (!!downloadExtent) {
            var passthroughParam = getTFPassTroughString();
            if (!passthroughParam) { passthroughParam = ''; }
            var strUrl =
                "http://vn4.cs.fiu.edu/cgi-bin/tfrectdisp.cgi?" +
                passthroughParam +
                "&dt=51306.25" +
                "&X1l=" + downloadExtent[0] +
                "&Y1l=" + downloadExtent[3] +
                "&X2l=" + downloadExtent[2] +
                "&Y2l=" + downloadExtent[1] +
                "&Source=best_available" +
                "&Res=" + getResolution() +
                "&Overlay=wcity";
            window.open(strUrl, "_blank");
        }
    }
    function onConfirmDownload() {
        var downloadExtent = mapDrawInteraction.GetMapExtent();
        var utmExtent = mapDrawInteraction.GetBoxExtent();
        if (downloadExtent) {
            doDownloadQuery(downloadExtent, utmExtent);
            cancelInteraction();
        }
        else {
            showMessage("<p/>First: Click/Touch to select a rectangular area.<p/>Then: Press the button to download.");
        }
    }
    function startInteraction(type, onEnd) { hideOpenControlPopups(); if (!!mapDrawInteraction) { mapDrawInteraction.Start(type, onEnd); } }
    function cancelInteraction() { if (!!mapDrawInteraction) { mapDrawInteraction.Cancel(); } }
    function cancelDownloadInteraction() { if (!!downloadPopup) { downloadPopup.Show(false); } }
    function startDownloadInteraction() {
        if (!downloadPopup) {
            downloadPopup = new tf.map.ui.DownloadBar(mapContainerAll, theThis,
                mapControls[tf.consts.panelNameDownload].control,
                cancelInteraction, onConfirmDownload, theThis);
        }
        downloadPopup.Show(true);
        startInteraction('box', cancelDownloadInteraction);
    }
    function cancelMeasureInteraction() { if (measurePopup) { measurePopup.Show(false); } }
    function privateOnChangeMeasureType() { cancelInteraction(); startMeasureInteraction(); }
    function startMeasureInteraction() {
        if (!measurePopup) {
            measurePopup = new tf.map.ui.MeasureBar(mapContainerAll, theThis,
                mapControls[tf.consts.panelNameMeasure].control,
                cancelInteraction, privateOnChangeMeasureType, theThis);
        }
        measurePopup.Show(true);
        startInteraction(measurePopup.GetIsMeasuringDistances() ? 'lines' : 'poly', cancelMeasureInteraction);
    }
    function createCenterMapButton(visibleBool) {
        var mapCenterButtonElem;
        var dimMapCenter = "16rem";
        if (tf.js.GetIsNonEmptyString(settings.mapCenterSVG)) {
            mapCenterButton = new tf.dom.Div({ cssClass: styles.GetUnPaddedDivClassNames(false, false) });
            mapCenterButtonElem = mapCenterButton.GetHTMLElement();
            mapCenterButtonElem.innerHTML = settings.mapCenterSVG;
            mapCenterButtonElem.style.width = mapCenterButtonElem.style.height = dimMapCenter;
            mapCenterButtonElem.style.fill = "white";
        }
        else {
            mapCenterButton = new tf.ui.SvgGlyphBtn({ style: true, glyph: tf.styles.SvgGlyphBullsEye2Name, dim: dimMapCenter, noChangeOnHover: true });
            mapCenterButtonElem = mapCenterButton.GetHTMLElement();
        }
        styles.ApplySnapToCenterStyle(mapCenterButtonElem);
        mapContainerAll.appendChild(mapCenterButtonElem);
        mapCenterButtonElem.style.display = visibleBool ? 'block' : 'none';
        mapCenterButtonElem.style.pointerEvents = 'none';
        mapCenterButtonElem.style.position = 'absolute';
        mapCenterButtonElem.style.opacity = "0.30";
        styles.AddHorShadowStyle(mapCenterButton);
        styles.AddDefaultOpacityTransitionStyle(mapCenterButton);
        mapCenterButtonElem.style.zIndex = zIndex + 5;
    }
    function onNotifyFullScreen() {
        var fullScreenPanel = mapControls[tf.consts.panelNameFullscreen];
        if (!!fullScreenPanel) {
            if (tf.browser.GetIsFullScreen()) {
                fullScreenPanel.control.ChangeTitle(getFullScreenLabelFull(), tf.consts.fullScreenToolTipFull);
            } else {
                fullScreenPanel.control.ChangeTitle(getFullScreenLabelNormal(), tf.consts.fullScreenToolTipNormal);
            }
        }
        mergeWithBaseAndNotifyListeners(tf.consts.mapFullScreenEvent);
        onResize();
    }
    function onFullScreen() {
        if (!!containerAll) {
            if (!tf.browser.GetIsFullScreen()) {
                if (tf.dom.GetHTMLElementFrom(settings.fullScreenContainer)) {
                    tf.browser.RequestFullScreen(settings.fullScreenContainer);
                }
                else {
                    tf.browser.RequestFullScreen(document.body);
                }
            }
        }
    }
    function toggleMapFullScreen() {
        if (tf.browser.GetIsFullScreen()) { tf.browser.ExitFullScreen(); } else { theThis.FullScreen(); }
    }
    function getVisibleExtent() {
        return ol.extent.applyTransform(olView.calculateExtent(olMap.getSize()), ol.proj.getTransform(tf.consts.olSystem, tf.consts.tmSystem));
    }
    function getDisplayVisibleExtent() {
        return ol.extent.applyTransform(olView.calculateExtent(olMap.getSize()), ol.proj.getTransform(tf.consts.olSystem, tf.consts.tmSystem));
    }
    function setVisibleExtent(extent) {
        extent = tf.js.GetMapExtentFrom(extent);
        if (extent[0] != extent[2] && extent[1] != extent[3]) {
            //var size = olMap.getSize();
            var size = theThis.GetPixelSize();
            var mapW = size[0], mapH = size[1];
            if (mapW > 0 && mapH > 0) {
                var extentMidLon = extent[0] + (extent[2] - extent[0]) / 2;
                var extentMidLat = extent[1] + (extent[3] - extent[1]) / 2;
                var extentFeature = new tf.map.FeatureGeom({ type: "linestring", coordinates: [[extent[0], extentMidLat], [extent[2], extentMidLat]] });
                var extentWM = extentFeature.GetLength();
                extentFeature = new tf.map.FeatureGeom({ type: "linestring", coordinates: [[extentMidLon, extent[1]], [extentMidLon, extent[3]]] });
                var extentHM = extentFeature.GetLength();
                var res1 = extentWM / mapW, res2 = extentHM / mapH;
                var res = res1 > res2 ? res1 : res2 ;
                setResolution(res);
                setCenter([extentMidLon, extentMidLat]);
            }
        }
    }
    function getAreMapCoordsInExtent(pointCoords, extent) {
        var lat = tf.js.GetLatitudeFrom(pointCoords[1]);
        var lon = tf.js.GetLongitudeFrom(pointCoords[0]);
        var isIn = extent[1] <= lat && extent[3] >= lat && extent[0] <= lon && extent[2] >= lon;
        return isIn;
    }
    function getAreMapCoordsVisible(pointCoords) { return getAreMapCoordsInExtent(pointCoords, getVisibleExtent()); }
    function getPixelCoordsAreVisible(xPixel, yPixel) {
        var pointCoords = pixelToMapCoords(xPixel, yPixel);
        return getAreMapCoordsVisible(pointCoords);
    }
    function render() { return !!olMap ? olMap.render() : false; }
    function renderNow() { return !!olMap ? olMap.renderSync() : false; }
    function eventIsOnMap(e) {
        //tf.GetDebug().LogIfTest(e.browserEvent.target.className);
        return e.originalEvent.target.className == "ol-unselectable"
    }
    var lastHoveredFeature = null;
    function hoverOutOfPossibleHoveredFeature() {
        var center = getCenter();
        hoverIntoFeature(null, center[0], center[1]);
    }
    function privateNotifyDelFeatures(arg) {
        if (!!arg) {
            if (arg instanceof ol.Feature) {
                var mapFeature = arg.getProperties().mapFeature;
                if (mapFeature === lastHoveredFeature) {
                    hoverOutOfPossibleHoveredFeature();
                }
            }
            else if (typeof arg === "object") {
                for (var i in arg) {
                    var thisArg = arg[i];
                    if (thisArg instanceof ol.Feature) {
                        var mapFeature = thisArg.getProperties().mapFeature;
                        if (mapFeature === lastHoveredFeature) {
                            hoverOutOfPossibleHoveredFeature();
                            break;
                        }
                    }
                }
            }
        }
    }
    function hoverOutOfLastHoveredFeature(nextHoverFeature, lat, lon) {
        if (!!lastHoveredFeature) {
            var notification = mergeWithBaseNotification(tf.js.ShallowMerge(makeKeyedFeatureLatLonNotification(lastHoveredFeature, lat, lon, undefined), {
                nextKeyedFeature: getKeyedFeatureFromMapFeature(nextHoverFeature), nextFeature: nextHoverFeature, isInHover: false
            }));
            lastHoveredFeature.onHoverInOut(notification);
            doNotifyListeners(tf.consts.mapFeatureHoverInOutEvent, notification);
            lastHoveredFeature = null;
        }
    }
    function makeFeatureClusterNotification(featureCluster) { return !!featureCluster ? { featureCluster: featureCluster } : undefined; }
    function hoverIntoFeature(mapFeature, lat, lon, featureCluster) {
        if (mapFeature != lastHoveredFeature) {
            hoverOutOfLastHoveredFeature(mapFeature, lat, lon);
            if (!!mapFeature) {
                var notification = mergeWithBaseNotification(tf.js.ShallowMerge(makeKeyedFeatureLatLonNotification(mapFeature, lat, lon, featureCluster), {
                    prevKeyedFeature: getKeyedFeatureFromMapFeature(lastHoveredFeature), prevFeature: lastHoveredFeature, isInHover: true
                }));
                mapFeature.onHoverInOut(notification);
                doNotifyListeners(tf.consts.mapFeatureHoverInOutEvent, notification);
            }
            lastHoveredFeature = mapFeature;
        }
    }
    function createFeatureCluster(clusterFeature, features) {
        var clusterGeom = clusterFeature.getGeometry();
        var clusterGeomExtent = clusterGeom.getExtent();
        var clusterCoords = tf.units.OL2TM([clusterGeomExtent[0], clusterGeomExtent[1]]);
        var clusterFeatures;
        if (!!features && features.length > 1) {
            clusterFeatures = [];
            for (var i = 0, len = features.length ; i < len ; ++i) {
                var feature = features[i], props = feature.getProperties(), mapFeature = props.mapFeature;
                if (mapFeature) { clusterFeatures.push(mapFeature); }
            }
        }
        return { clusterFeatures: clusterFeatures, clusterCoords: clusterCoords };
    }
    function onPointerDrag(e) {
        if (eventIsOnMap(e)) {
            var hitMapFeature = false;
            var mapFeatures = [];
            var pixelCoords = actualToVirtualPixelCoords(e.pixel);
            var featureCluster;
            isDragging = true;
            if (!isDraggingOnMap) {
                olMap.forEachFeatureAtPixel(pixelCoords, function (feature, layer) {
                    if (feature) {
                        var features = feature.get('features');
                        if (features) {
                            featureCluster = createFeatureCluster(feature, features);
                            feature = features[0];
                        }
                        if (feature) {
                            var props = feature.getProperties();
                            var mapFeature = props.mapFeature;
                            if (mapFeature) {
                                mapFeatures.push(mapFeature);
                                if (firstFeatureOnly) { return true; }
                            }
                            else if (props.markerName == infoFeatureName) {
                                hitMapFeature = true;
                                return true;
                            }
                        }
                    }
                });
            }
            if (!hitMapFeature) {
                var mapEventNotification = { mapEvent: e };
                var actualCoordinate = tf.units.OL2TM(e.coordinate);
                var coordinate = actualPixelToMapCoords(pixelCoords);
                var lat = coordinate[1], lon = coordinate[0];
                var needNotifyMap = isDraggingOnMap;
                if (!needNotifyMap) {
                    var nMapFeatures = mapFeatures.length;
                    for (var i = 0; i < nMapFeatures; ++i) {
                        var mapFeature = mapFeatures[i];
                        var notification = tf.js.ShallowMerge(mergeWithBaseNotification(makeKeyedFeatureLatLonNotification(mapFeature, lat, lon, featureCluster)), mapEventNotification);
                        doNotifyListeners(tf.consts.mapFeatureMouseDragEvent, notification);
                        if (firstFeatureOnly) { break; }
                    }
                    if (nMapFeatures == 0) { needNotifyMap = isDraggingOnMap = true; }
                }
                if (needNotifyMap) {
                    mergeWithBaseAndNotifyListeners(tf.consts.mapMouseDragEvent,
                        tf.js.ShallowMerge(tf.js.ShallowMerge(makeFeatureClusterNotification(featureCluster),
                            makePixelNotification(makeLatLonNotification(lat, lon, actualCoordinate), pixelCoords, e.pixel)), mapEventNotification));
                }
            }
        }
    }
    function onPointerMove(e) {
        if (eventIsOnMap(e)) {
            var hitMapFeature = false;
            var mapFeatures = [];
            var pixelCoords = actualToVirtualPixelCoords(e.pixel);
            var featureCluster;
            olMap.forEachFeatureAtPixel(pixelCoords, function (feature, layer) {
                if (feature) {
                    var features = feature.get('features');
                    if (features) {
                        featureCluster = createFeatureCluster(feature, features);
                        feature = features[0];
                    }
                    if (feature) {
                        var props = feature.getProperties();
                        var mapFeature = props.mapFeature;
                        if (mapFeature) {
                            mapFeatures.push(mapFeature);
                            if (firstFeatureOnly) { return true; }
                        }
                        else if (props.markerName == infoFeatureName) {
                            hitMapFeature = true;
                            return true;
                        }
                    }
                }
            });
            if (!hitMapFeature) {
                var mapEventNotification = { mapEvent: e };
                var nMapFeatures = mapFeatures.length;
                var actualCoordinate = tf.units.OL2TM(e.coordinate);
                var coordinate = actualPixelToMapCoords(pixelCoords);
                var lat = coordinate[1], lon = coordinate[0];
                var rollOverHandled = false;
                for (var i in mapFeatures) {
                    var mapFeature = mapFeatures[i];
                    var notification = tf.js.ShallowMerge(mergeWithBaseNotification(makeKeyedFeatureLatLonNotification(mapFeature, lat, lon, featureCluster)), mapEventNotification);
                    hoverIntoFeature(mapFeature, lat, lon, featureCluster);
                    rollOverHandled = mapFeature.onMouseMove(notification);
                    if (!rollOverHandled) { doNotifyListeners(tf.consts.mapFeatureMouseMoveEvent, notification); }
                    if (rollOverHandled || firstFeatureOnly) { break; }
                }
                if (nMapFeatures == 0) { hoverIntoFeature(null, lat, lon, featureCluster); }
                mapEventNotification.nMapFeatures = nMapFeatures;
                mergeWithBaseAndNotifyListeners(tf.consts.mapMouseMoveEvent,
                    tf.js.ShallowMerge(tf.js.ShallowMerge(makeFeatureClusterNotification(featureCluster),
                    makePixelNotification(makeLatLonNotification(lat, lon, actualCoordinate), pixelCoords, e.pixel)), mapEventNotification));
            }
        }
    }
    function onPointerInstantClick(e) {
        if (eventIsOnMap(e)) {
            if (!mapDrawInteraction || !mapDrawInteraction.GetIsInteracting()) {
                var pixelCoords = actualToVirtualPixelCoords(e.pixel);
                var actualCoordinate = tf.units.OL2TM(e.coordinate);
                var coordinate = actualPixelToMapCoords(pixelCoords);
                var lat = coordinate[1], lon = coordinate[0];
                var hitPrivateMapFeature = false;
                var mapFeatures = [];
                var featureCluster;
                olMap.forEachFeatureAtPixel(pixelCoords, function (feature, layer) {
                    var features = feature.get('features');
                    if (features) {
                        featureCluster = createFeatureCluster(feature, features);
                        feature = features[0];
                    }
                    if (feature) {
                        var props = feature.getProperties();
                        if (!!props) {
                            var mapFeature = props.mapFeature;
                            if (!!mapFeature) { mapFeatures.push(mapFeature); }
                            else { var name = props.markerName; if (name == infoFeatureName) { hitPrivateMapFeature = true; toggleInfoWindowPin(); return true; } }
                        }
                    }
                }, theThis);
                if (!hitPrivateMapFeature) {
                    var mapEventNotification = { mapEvent: e };
                    var nMapFeatures = mapFeatures.length;
                    var clickHandled = false;
                    var clusterNotification = makeFeatureClusterNotification(featureCluster);
                    for (var i in mapFeatures) {
                        var mapFeature = mapFeatures[i];
                        var notification = tf.js.ShallowMerge(mergeWithBaseNotification(makeKeyedFeatureLatLonNotification(mapFeature, lat, lon, featureCluster)), mapEventNotification);
                        clickHandled = mapFeature.onClick(notification);
                        if (!clickHandled) { doNotifyListeners(tf.consts.mapFeatureInstantClickEvent, notification); }
                        if (clickHandled || firstFeatureOnly) { break; }
                    }
                    if (nMapFeatures == 0) {
                        mergeWithBaseAndNotifyListeners(tf.consts.mapInstantClickEvent, tf.js.ShallowMerge(
                            tf.js.ShallowMerge(clusterNotification,
                                makePixelNotification(makeLatLonNotification(lat, lon, actualCoordinate), pixelCoords, e.pixel), mapEventNotification)));
                    }
                }
            }
        }
    }
    function onPointerClick(e) {
        if (eventIsOnMap(e)) {
            if (!mapDrawInteraction || !mapDrawInteraction.GetIsInteracting()) {
                var pixelCoords = actualToVirtualPixelCoords(e.pixel);
                var actualCoordinate = tf.units.OL2TM(e.coordinate);
                var coordinate = actualPixelToMapCoords(pixelCoords);
                var lat = coordinate[1], lon = coordinate[0];
                var hitPrivateMapFeature = false;
                var mapFeatures = [];
                var featureCluster;
                olMap.forEachFeatureAtPixel(pixelCoords, function (feature, layer) {
                    var features = feature.get('features');
                    if (features) {
                        featureCluster = createFeatureCluster(feature, features);
                        feature = features[0];
                    }
                    if (feature) {
                        var props = feature.getProperties();
                        if (!!props) {
                            var mapFeature = props.mapFeature;
                            if (!!mapFeature) { mapFeatures.push(mapFeature); }
                            else { var name = props.markerName; if (name == infoFeatureName) { hitPrivateMapFeature = true; toggleInfoWindowPin(); return true; } }
                        }
                    }
                }, theThis);
                if (!hitPrivateMapFeature) {
                    var mapEventNotification = { mapEvent: e };
                    var nMapFeatures = mapFeatures.length;
                    var clickHandled = false;
                    var clusterNotification = makeFeatureClusterNotification(featureCluster);
                    for (var i in mapFeatures) {
                        var mapFeature = mapFeatures[i];
                        var notification = tf.js.ShallowMerge(mergeWithBaseNotification(makeKeyedFeatureLatLonNotification(mapFeature, lat, lon, featureCluster)), mapEventNotification);
                        clickHandled = mapFeature.onClick(notification);
                        if (!clickHandled) { doNotifyListeners(tf.consts.mapFeatureClickEvent, notification); }
                        if (clickHandled || firstFeatureOnly) { break; }
                    }
                    if (nMapFeatures == 0) {
                        mergeWithBaseAndNotifyListeners(tf.consts.mapClickEvent, tf.js.ShallowMerge(
                            tf.js.ShallowMerge(clusterNotification,
                            makePixelNotification(makeLatLonNotification(lat, lon, actualCoordinate), pixelCoords, e.pixel), mapEventNotification)));
                    }
                }
            }
        }
    }
    function onPointerDoubleClick(e) {
        if (eventIsOnMap(e)) {
            if (!mapDrawInteraction || !mapDrawInteraction.GetIsInteracting()) {
                var pixelCoords = actualToVirtualPixelCoords(e.pixel);
                var actualCoordinate = tf.units.OL2TM(e.coordinate);
                var coordinate = actualPixelToMapCoords(pixelCoords);
                var lat = coordinate[1], lon = coordinate[0];
                var hitPrivateMapFeature = false;
                var mapFeatures = [];
                var featureCluster;
                olMap.forEachFeatureAtPixel(pixelCoords, function (feature, layer) {
                    var features = feature.get('features');
                    if (features) {
                        featureCluster = createFeatureCluster(feature, features);
                        feature = features[0];
                    }
                    if (feature) {
                        var props = feature.getProperties();
                        if (!!props) {
                            var mapFeature = props.mapFeature;
                            if (!!mapFeature) { mapFeatures.push(mapFeature); }
                            else { var name = props.markerName; if (name == infoFeatureName) { hitPrivateMapFeature = true; toggleInfoWindowPin(); return true; } }
                        }
                    }
                }, theThis);
                if (!hitPrivateMapFeature) {
                    var mapEventNotification = { mapEvent: e };
                    var nMapFeatures = mapFeatures.length;
                    var clickHandled = false;
                    for (var i in mapFeatures) {
                        var mapFeature = mapFeatures[i];
                        var notification = tf.js.ShallowMerge(mergeWithBaseNotification(makeKeyedFeatureLatLonNotification(mapFeature, lat, lon, featureCluster)), mapEventNotification);
                        clickHandled = mapFeature.onDoubleClick(notification);
                        if (!clickHandled) { doNotifyListeners(tf.consts.mapFeatureDblClickEvent, notification); }
                        if (clickHandled || firstFeatureOnly) { break; }
                    }
                    if (nMapFeatures == 0) {
                        if (goDBOnDoubleClick) { goDBByCoords(coordinate); } else {
                            mergeWithBaseAndNotifyListeners(tf.consts.mapDblClickEvent,
                                tf.js.ShallowMerge(tf.js.ShallowMerge(makeFeatureClusterNotification(featureCluster),
                                makePixelNotification(makeLatLonNotification(lat, lon, actualCoordinate), pixelCoords, e.pixel))), mapEventNotification);
                        }
                    }
                }
            }
        }
    }
    this.onMoveEnd = function (e) { return onMoveEnd(e); }
    function onMoveStart(e) {
        var center = getCenter();
        var lat = center.Latitude, lon = center.Longitude;
        if (currentLat != lat && currentLon != lon) {
            currentLat = lat; currentLon = lon;
        }
        if (!isAnimating) {
            mergeWithBaseAndNotifyListeners(tf.consts.mapMoveStartEvent, makeCurrentLatLonNotification());
        }
    }
    function onMoveEnd(e) {
        var center = getCenter();
        var lat = center.Latitude, lon = center.Longitude;
        //hideOpenControlPopups();
        if (currentLat != lat && currentLon != lon) {
            currentLat = lat; currentLon = lon;
        }
        if (!isAnimating) {
            var endRes = getResolution();
            if (currentRes != endRes) {
                currentRes = endRes;
                onDelayResEnd.DelayCallBack();
                //console.log('delayed res on moveend');
                var endLevel = getLevel();
                if (currentLevel != endLevel) {
                    currentLevel = endLevel;
                    onDelayZoomEnd.DelayCallBack();
                    //console.log('delayed level on moveend');
                }
            }
            onDelayMoveEnd.DelayCallBack();
        }
    }
    function setMapEngine(mapEngineSet) {
        mapEngine = tf.map.GetMapEngineFrom(mapEngineSet);
        getVectorTileFunction = (useMapNik2 = (mapEngine !== tf.consts.mapnikEngine)) ? getMapnik2VectorTile : getMapnik1VectorTile;
    }
    //function getMapPinImgSrc() { return tf.platform.MakePlatformPath("image/mappin.png"); }
    function getKeyedFeatureFromMapFeature(mapFeature) {
        return !!mapFeature && !!tf.js.GetFunctionOrNull(mapFeature.GetKeyedFeature) ? mapFeature.GetKeyedFeature() : null;
    }
    function getMapFeatureFromMapFeature(mapFeature) {
        return !!mapFeature && !!tf.js.GetFunctionOrNull(mapFeature.GetMapFeature) ? mapFeature.GetMapFeature() : null;
    }
    function mergeWithBaseNotification(notification) { return tf.js.ShallowMerge(notification, baseNotification); }
    function doNotifyListeners(eventName, notification) {
        if (notification.sender !== theThis) {
            tf.GetDebug().LogIfTest("map: notify without sender");
        }
        allEventDispatchers.Notify(eventName, tf.js.ShallowMerge(/*mergeWithBaseNotification(*/notification/*)*/, { eventName: eventName }));
    }
    function mergeWithBaseAndNotifyListeners(eventName, notification) { return doNotifyListeners(eventName, mergeWithBaseNotification(notification)); }
    function makeLatLonNotification(lat, lon, actualCoords) {
        var eventCoords = [lon, lat]; if (actualCoords == undefined) { actualCoords = eventCoords; }
        return { eventCoords: eventCoords, actualEventCoords: actualCoords };
    }
    function makeCurrentLatLonNotification() { return makeLatLonNotification(currentLat, currentLon); }
    function makePixelNotification(notification, pixel, actualPixel) { return tf.js.ShallowMerge(notification, { pixelCoords: pixel, actualPixelCoords: actualPixel }); }
    function makeKeyedFeatureNotification(mapFeature) {
        var mapFeatureUse = getMapFeatureFromMapFeature(mapFeature);
        if (!mapFeatureUse) { mapFeatureUse = mapFeature; }
        return { keyedFeature: getKeyedFeatureFromMapFeature(mapFeatureUse), mapFeature: mapFeatureUse, styleName: mapFeatureUse.getStyleName() };
    }
    function makeKeyedFeatureLatLonNotification(mapFeature, lat, lon, featureCluster) {
        return tf.js.ShallowMerge(makeKeyedFeatureNotification(mapFeature), makeLatLonNotification(lat, lon), makeFeatureClusterNotification(featureCluster));
    }
    function addFeatureLayers(multiLayerSettings) {
        var layers = {};
        if (tf.js.GetIsValidObject(multiLayerSettings)) {
            for (var i in multiLayerSettings) {
                var thisLayerSettings = multiLayerSettings[i];
                if (tf.js.GetIsValidObject(thisLayerSettings)) {
                    var thisLayer = addFeatureLayer(thisLayerSettings);
                    if (!!thisLayer) { layers[thisLayer.GetName()] = thisLayer; }
                }
            }
        }
        return layers;
    }
    function showMapCenter(show) {
        if (!!mapCenterButton) {
            if (isShowingMapCenter != (show = !!show)) {
                //styles.ChangeOpacityVisibilityClass(mapCenterButton, isShowingMapCenter = show);
                tf.dom.GetHTMLElementFrom(mapCenterButton).style.display = !!(isShowingMapCenter = show) ? 'block' : 'none';
            }
        }
    }
    function checkNotifyListeners() {
        if (levelChanged) { onNotifyZoomEnd(); }
        if (resChanged) { onNotifyResolutionEnd(); }
        if (posChanged) { onNotifyMoveEnd(); }
    }
    function preRender(map, frameState) {
        if (isAnimating) {
            if (frameState.time <= animationSpecs.start + animationSpecs.duration) {
                if (frameState.time >= animationSpecs.start) {
                    //var easing = ol.easing.inAndOut;
                    //var easing = ol.easing.linear;
                    var easing = animationSpecs.easing;
                    var delta = 1 - easing((frameState.time - animationSpecs.start) / animationSpecs.duration);
                    if (animationSpecs.sourceCenter) {
                        var deltaX = animationSpecs.sourceCenter[0] - animationSpecs.endCenter[0];
                        var deltaY = animationSpecs.sourceCenter[1] - animationSpecs.endCenter[1];
                        frameState.viewState.center[0] = animationSpecs.endCenter[0] + delta * deltaX;
                        frameState.viewState.center[1] = animationSpecs.endCenter[1] + delta * deltaY;
                        var center = tf.units.OL2TM(frameState.viewState.center);
                        var newLon = center[0], newLat = center[1];
                        posChanged = newLon != currentLon || newLat != currentLat;
                        currentLat = newLat;
                        currentLon = newLon;
                    }
                    if (animationSpecs.sourceRes !== undefined) {
                        var deltaResolution = animationSpecs.sourceRes - animationSpecs.endRes;
                        var newRes;
                        var newLevel = tf.units.GetLevelByResolution(frameState.viewState.resolution = newRes = animationSpecs.endRes + delta * deltaResolution)
                        resChanged = newRes != currentRes;
                        levelChanged = newLevel != currentLevel;
                        currentLevel = newLevel;
                        currentRes = newRes;
                    }
                    if (animationSpecs.sourceRotation !== undefined) {
                        var deltaRotation = tf.units.GetShortestArcBetweenAngles(animationSpecs.endRotation, animationSpecs.sourceRotation)
                        frameState.viewState.rotation = animationSpecs.endRotation + delta * deltaRotation;
                    }
                    if (animationSpecs.notifyListeners) { checkNotifyListeners(); }
                    else { if (resChanged || levelChanged) { whenMapResolutionChanges(); } }
                }
            }
            else { getNextAnimationStep(); }
            if (isAnimating) {
                render();
            }
            else { checkNotifyListeners(); }
            return isAnimating;
        }
        else {
            var center = tf.units.OL2TM(frameState.viewState.center);
            currentLat = center[1];
            currentLon = center[0];
            currentRes = frameState.viewState.resolution;
        }
        return isAnimating;
    }
    this.GetInstantCenter = function () { return [currentLon, currentLat]; }
    //this.GetInstantRotationRad = function () { }
    this.GetInstantResolution = function () { return currentRes; }
    function callAnimationCallBack() {
        return !!animationCallBack ? animationCallBack.call(animationOptionalScope, { sender: theThis, step: animationStep++ }) : null;
    }
    function endAnimation() {
        if (isAnimating) {
            if (!!animationCallBack) { animationStep = -1; callAnimationCallBack(); animationCallBack = null; }
            isAnimating = false;
            render();
        }
    }
    function getNextAnimationStep() {
        if (isAnimating) {
            var nextStep = callAnimationCallBack();
            if (tf.js.GetIsValidObject(nextStep)) {
                var nextCenter = nextStep.center !== undefined ? tf.js.GetMapCoordsFrom(nextStep.center) : undefined;
                var nextRes = nextStep.resolution !== undefined ? nextStep.resolution : undefined;
                var nextRotation = nextStep.rotation !== undefined ? nextStep.rotation : undefined;
                var duration = nextStep.duration !== undefined ? nextStep.duration : 1000;
                var notifyListeners = nextStep.notifyListeners !== undefined ? !!nextStep.notifyListeners : false;
                var easing = tf.js.GetFunctionOrNull(nextStep.easing) ? nextStep.easing : tf.units.EaseInAndOut;
                var olEndCenter = nextCenter !== undefined ? tf.units.TM2OL(nextCenter) : undefined;
                animationSpecs = {
                    notifyListeners: notifyListeners,
                    sourceRes: nextRes !== undefined ? getResolution() : undefined,
                    sourceCenter: nextCenter !== undefined ? getOLViewCenter() : undefined,
                    sourceRotation: nextRotation !== undefined ? getRotationRad() : undefined,
                    endRes: nextRes,
                    endCenter: olEndCenter,
                    endRotation: nextRotation !== undefined ? nextRotation : undefined,
                    duration: duration,
                    easing: easing,
                    start: Date.now()
                };
                if (hasBeforeRender) {
                    if (nextCenter != undefined) { setCenter(nextCenter); }
                    if (nextRes !== undefined) { setResolution(nextRes); }
                    if (nextRotation !== undefined) { setRotationRad(nextRotation); }
                }
                else {
                    olView.animate({
                        rotation: nextRotation,
                        center: olEndCenter,
                        resolution: nextRes,
                        duration: duration,
                        easing: easing//ol.easing.easeOut
                    }, function (animationConcludedOK) {
                        if (!animationConcludedOK) {
                            if (nextCenter != undefined) { setCenter(nextCenter); }
                            if (nextRes !== undefined) { setResolution(nextRes); }
                            if (nextRotation !== undefined) { setRotationRad(nextRotation); }
                        }
                        endAnimation();
                    });
                }
            }
            else { endAnimation(); }
        }
    }
    function startAnimation(animationCallBackSet, animationOptionalScopeSet) {
        var wasAnimating = isAnimating;
        endAnimation();
        if (!!(animationCallBack = tf.js.GetFunctionOrNull(animationCallBackSet))) {
            if (hasBeforeRender) { if (!wasAnimating) { olMap.beforeRender(preRender); } }
            animationStep = 0;
            animationOptionalScope = animationOptionalScopeSet;
            isAnimating = true;
            getNextAnimationStep();
        }
    }
    var vectorContext, clientWantsToContinueAnimation, lastComposeEventName;
    function continueAnimation() { clientWantsToContinueAnimation = true; }
    function showFeatureImmediately(mapFeature) {
        if (mapFeature instanceof tf.map.Feature) {
            if (!!vectorContext) {
                var APIStyle = mapFeature.getAPIStyle();
                for (var i in APIStyle) { vectorContext.drawFeature(mapFeature.getAPIFeature(), APIStyle[i]); }
            }
        }
    }
    this.onComposeEvent = function (eventName, event, otherOLMap) { return onComposeEvent(eventName, event, false, otherOLMap); }
    function onComposeEvent(eventName, event, isSelfEvent, otherOLMap) {
        lastComposeEventName = eventName;
        vectorContext = event.vectorContext;
        clientWantsToContinueAnimation = false;
        mergeWithBaseAndNotifyListeners(eventName, { showFeatureImmediately: showFeatureImmediately, continueAnimation: continueAnimation, canvas: event.context.canvas });
        if (eventName == tf.consts.mapPostComposeEvent) {
            mergeWithBaseAndNotifyListeners(tf.consts.mapPostPostComposeEvent, { showFeatureImmediately: showFeatureImmediately, continueAnimation: continueAnimation, canvas: event.context.canvas });
        }
        vectorContext = undefined;
        if (clientWantsToContinueAnimation) { if (!!otherOLMap) { otherOLMap.render(); } else { render(); } }
        clientWantsToContinueAnimation = false;
    }
    var decodedLegendH, decodedLegendM;
    function setDecodedLegends(decodedLegendHSet, decodedLegendMSet, atResolution) {
        decodedLegendH = decodedLegendHSet;
        decodedLegendM = decodedLegendMSet;
        privateNotifyLegendOptionChange();
        whenMapResolutionChanges(atResolution);
    }
    function initialize() {
        styles = tf.GetStyles();
        subStyles = styles.GetSubStyles();
        showLocInfoWindowOnMoveEndByDefault = true; 
        showLocInfoWindowOnMoveEnd = false;
        isAnimating = false;
        currentSource = "best_available";
        if (settings.messageTimeout !== undefined) { setMessageTimeout(settings.messageTimeout); }
        if (tf.js.GetIsNonEmptyString(settings.vidParam)) { setVIDParamStr(settings.vidParam); }
        if (tf.js.GetIsNonEmptyString(settings.passThroughString)) { setTFPassThroughString(settings.passThroughString); }
        levelChanged = resChanged = posChanged = false;
        mapButtonDimEmStr = subStyles.mapButtonDimEmNumber + "em";
        baseNotification = { sender: theThis };
        layersByName = {};
        settings = tf.js.GetValidObjectFrom(settings);
        linkTargetStr = tf.js.GetIsNonEmptyString(settings.linkTargetStr) ? settings.linkTargetStr : '_top';
        id = tf.GetGlobalCounter().GetNext() + '';
        allEventDispatchers = new tf.events.MultiEventNotifier({ eventNames: tf.consts.allMapEventNames });
        setMapEngine(settings.mapEngine);
        if (tf.js.GetIsNonEmptyString(settings.mapLayerSourceURL)) { setMapLayerSource(settings.mapLayerSourceURL, settings.mapLayerSourceHybridModeOpacity); }
        createDivs(settings.container);
        var bkImgDataImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wAAAIDen//TAAAAfUlEQVRYhe2UsQ3AIAwETcYJ+w9BRQNZhI7mU0VCiBYuhV1Z/gKJO31IucjM7I7RVvPUajvza3k9Oa1LrUspF3376rYrt9MPzntoXRp/ZDfzOf+PAxQCXMLgPUAjwCX0HsAR4BJ6D+AIcAm9B3AEuITeAzgCXELvARwBLuELoBEJ6ZpdtuYAAAAASUVORK5CYII=";
        mapContainerAll.style.backgroundImage = "url('" + bkImgDataImage + "')";
        //var bkImgStr = tf.platform.MakePlatformPath("image/mapBack.png");
        //mapContainerAll.style.backgroundImage = "url('" + bkImgStr + "')";
        var delayCallBack = 300;
        onDelayMoveEnd = new tf.events.DelayedCallBack(delayCallBack, onNotifyMoveEnd, theThis);
        onDelayZoomEnd = new tf.events.DelayedCallBack(delayCallBack, onNotifyZoomEnd, theThis);
        onDelayResEnd = new tf.events.DelayedCallBack(delayCallBack, onNotifyResolutionEnd, theThis);
        onDelayRotEnd = new tf.events.DelayedCallBack(100, onNotifyRotationEnd, theThis);
        new tf.events.DOMFullScreenChangeListener({ callBack: onNotifyFullScreen, optionalScope: theThis });
        setSource(settings.mapAerialSource);
        var canRotate = settings.canRotate != undefined ? !!settings.canRotate : true;
        var receivedMapLegends = false;
        var initialRes, initialLevel;
        if (settings.resolution !== undefined) {
            initialRes = tf.js.GetFloatNumber(settings.resolution, tf.units.GetResolutionByLevel(tf.consts.defaultLevel));
        }
        else {
            initialLevel = tf.js.GetLevelFrom(settings.level);
            initialRes = tf.units.GetResolutionByLevel(initialLevel);
        }
        if (receivedMapLegends = settings.decodedLegendH != undefined) {
            setDecodedLegends(settings.decodedLegendH, settings.decodedLegendM, initialRes);
        }
        createOLViewAndMap(canRotate);
        setMapType(settings.mapType);
        createMapControls(!settings.noNativeControls, settings.noScaleLine);
        if (!settings.noNativePopups) { createMapPopups(); }
        var center = tf.js.GetMapCoordsFrom(settings.center);
        var lon = tf.js.GetLongitudeFrom(center[0]);
        var lat = tf.js.GetLatitudeFrom(center[1]);
        if (initialLevel != undefined) {
            setCenterAndLevel([lon, lat], initialLevel);
        }
        else {
            setCenter([lon, lat]);
            setResolution(initialRes);
        }
        createCenterMapButton(tf.js.GetBoolFromValue(settings.showMapCenter, true));
        if (!settings.noNativeControls) {
            mapDrawInteraction = new tf.map.aux.MapDrawInteraction(theThis, olMap, olSourceVector);
        }
        olMap.on("click", onPointerInstantClick, theThis);
        olMap.on("moveend", onMoveEnd, theThis);
        olMap.on("movestart", onMoveStart, theThis);
        olMap.on("pointermove", onPointerMove, theThis);
        olMap.on("pointerdrag", onPointerDrag, theThis);
        olMap.on("singleclick", onPointerClick, theThis);
        olMap.on("dblclick", onPointerDoubleClick, theThis);
        olMap.on('change:size', function (event) { checkSizePopups(); mergeWithBaseAndNotifyListeners(tf.consts.mapResizedEvent); }, theThis);
        olMap.on('precompose', function (event) { mapCanvas = event.context.canvas; onComposeEvent(tf.consts.mapPreComposeEvent, event, true); }, theThis);
        olMap.on('postcompose', function (event) { mapCanvas = event.context.canvas; onComposeEvent(tf.consts.mapPostComposeEvent, event, true); }, theThis);
        olMap.on('postrender', function (event) { mergeWithBaseAndNotifyListeners(tf.consts.mapPostRenderEvent, { event: event, canvas: mapCanvas }); }, theThis);
        if (tf.js.GetIsValidObject(settings.viewSettings)) { setView(settings.viewSettings); } else { hookUpOLViewEvents(); }
        if (!settings.noNativeControls) {
            tDBPage = new tf.map.aux.GoDBPage({ map: theThis, linkTargetStr: linkTargetStr });
        }
        if (!!mapControls[tf.consts.panelNameOverview] && mapControls[tf.consts.panelNameOverview].isOn) { setTimeout(hookOverviewMapClick, 500); }
        if (tf.js.GetIsNonEmptyString(settings.addressBarText)) { setAddressBarText(settings.addressBarText); }
        if (tf.js.GetIsNonEmptyString(settings.addressBarHelp)) { setAddressBarHelp(settings.addressBarHelp); }
        if (tf.js.GetIsNonEmptyString(settings.panels)) { showPanels(settings.panels); }
        else {
            if (!settings.noNativeControls) {
                showPanel(tf.consts.panelNameMapRotate, true);
            }
            showPanel(tf.consts.panelNameMapScale, true);
        }
        if (!settings.noNativeControls) {
            revGeocoder = new tf.map.aux.RevGeocoder(theThis, updateLocInfoWindow, locInfoWindowPopup);
            if (showLocInfoWindowOnMoveEndByDefault && isPanelShowing(tf.consts.panelNameMapLocation)) {
                showLocInfoWindowOnMoveEnd = true;
            }
            setLocInfoWindowShow();
        }
        if (tf.js.GetIsBoolean(settings.panOnClick)) { setUsePanOnClick(settings.panOnClick); }
        if (tf.js.GetIsBoolean(settings.goDBOnDoubleClick)) { setGoDBOnDoubleClick(settings.goDBOnDoubleClick); }
        if (!receivedMapLegends) {
            if (tf.js.GetIsNonEmptyString(settings.legendH)) { setTimeout(function () { setLegend(settings.legendH, settings.legendM); }, 500); }
            //if (tf.js.GetIsNonEmptyString(settings.legendH)) { setLegend(settings.legendH, settings.legendM); }
        }
        isDraggingOnMap = isDragging = false;
        documentClickListener = new tf.events.DOMClickListener({ target: document, callBack: onEndDragByDoc, optionalScope: theThis, callBackSettings: null });
        documentTouchUpListener = tf.events.AddDOMEventListener(document, tf.consts.DOMEventNamesTouchEnd, onEndDragByDoc);
    }
    var documentClickListener, documentTouchUpListener;
    var isDraggingOnMap, isDragging;
    function onEndDragByDoc() {
        if (isDraggingOnMap || isDragging) {
            isDraggingOnMap = isDragging = false;
            //console.log('notified end drag');
            mergeWithBaseAndNotifyListeners(tf.consts.mapEndDragEvent);
        }
    }
    function getDragPan() {
        var dragPan;
        olMap.getInteractions().forEach(function (interaction) { if (interaction instanceof ol.interaction.DragPan) { dragPan = interaction; } }, this);
        return dragPan;
    }
    function removeDragPan() {
        var dragPan = getDragPan();
        if (!!dragPan) {
            dragPan.setActive(false);
            olView.cancelAnimations();
            if (!!olView.setHint) {
                olView.setHint(ol.ViewHint.INTERACTING, -1);
            }
            else if (tf.js.GetIsArrayWithMinLength(olView.o, 2) && olView.o[1] > 0) {
                --olView.o[1];
            }
            olMap.getInteractions().remove(dragPan);
        }
    }
    function addDragPan() {
        var dragPan = getDragPan();
        if (!!dragPan) {
            dragPan.setActive(true);
        }
        if (!dragPan) {
            olMap.addInteraction(new ol.interaction.DragPan({ kinetic: new ol.Kinetic(-0.005, 0.05, 100), map: olMap }));
            olView.cancelAnimations();
            //olMap.on("moveend", onMoveEnd, theThis);
        }
    }
    (function actualConstructor(theMapThis) { theThis = theMapThis; initialize(); })(this);
};

// SOURCE FILE: polycode.js
tf.map.PolyCode = function () {
    var theThis, defaultPrecision = 5;
    this.ClipPrecision = function (precision) { return tf.js.GetIntNumberInRange(precision, 0, 7, 5); }
    this.Flipped = function (coordinates) { return !!coordinates && coordinates.length != undefined ? flipped(coordinates) : undefined; }
    this.DecodeValues = function(encodedValuesStr, precision) {
        var values = [], len = encodedValuesStr.length;
        if (len > 0) {
            var factor = Math.pow(10, theThis.ClipPrecision(precision)), index = 0, value = 0;
            while (index < len) {
                var newValIndex = trans(encodedValuesStr, index);
                value += newValIndex.value_change;
                index = newValIndex.index;
                var actualValue = (factor != 1) ? value / factor : value;
                values.push(actualValue);
            }
        }
        return values;
    }
    function trans(encodedStr, index) {
        var byteVal = undefined, result = 0, shift = 0, comp = false;
        while (byteVal == undefined || byteVal >= 0x20) {
            byteVal = encodedStr.charCodeAt(index) - 63;
            ++index;
            result |= (byteVal & 0x1f) << shift
            shift += 5
            comp = result & 1
        }
        var value_change = !!comp ? ~(result >>> 1) : (result >>> 1);
        return { index: index, value_change: value_change };
    }
    this.DecodeLevels = function(encodedLevelsString) {
        var decodedLevels = [];
        if (tf.js.GetIsNonEmptyString(encodedLevelsString)) {
            for (var i = 0; i < encodedLevelsString.length; ++i) {
                decodedLevels.push(encodedLevelsString.charCodeAt(i) - 63);
            }
        }
        return decodedLevels;
    }
    this.FromGeoJSONLineString = function (geometry, precision) {
        return (geometry && !!geometry.type && !!geometry.type.length && geometry.type.toLowerCase() == 'linestring') ?
            theThis.EncodeLineString(flipped(geometry.coordinates), precision) : undefined;
    }
    this.EncodeLineString = function (coordinates, precision) {
        if (!coordinates.length) { return ''; }
        var factor = Math.pow(10, theThis.ClipPrecision(precision)),
            output = encode(coordinates[0][0], 0, factor) + encode(coordinates[0][1], 0, factor);
        for (var i = 1; i < coordinates.length; i++) {
            var a = coordinates[i], b = coordinates[i - 1];
            output += encode(a[0], b[0], factor);
            output += encode(a[1], b[1], factor);
        }
        return output;
    }
    this.ToGeoJSONLineString = function (str, precision) {
        var coords = theThis.DecodeLineString(str, precision);
        return { type: 'LineString', coordinates: flipped(coords) };
    }
    this.DecodeLineString = function (str, precision) {
        var index = 0, lat = 0, lng = 0, coordinates = [], shift = 0, result = 0;
        var oneByte = null, latitude_change, longitude_change, factor = Math.pow(10, theThis.ClipPrecision(precision));
        // one coordinate decode per loop iteration
        while (index < str.length) {
            oneByte = null; shift = result = 0;
            do { oneByte = str.charCodeAt(index++) - 63; result |= (oneByte & 0x1f) << shift; shift += 5; } while (oneByte >= 0x20);
            latitude_change = ((result & 1) ? ~(result >>> 1) : (result >>> 1));
            shift = result = 0;
            do { oneByte = str.charCodeAt(index++) - 63; result |= (oneByte & 0x1f) << shift; shift += 5; } while (oneByte >= 0x20);
            longitude_change = ((result & 1) ? ~(result >>> 1) : (result >>> 1));
            lat += latitude_change;
            lng += longitude_change;
            coordinates.push([lat / factor, lng / factor]);
        }
        return coordinates;
    }
    this.FromGeoJSONMultiLineString = function (geometry, precision) {
        return (geometry && !!geometry.type && !!geometry.type.length && geometry.type.toLowerCase() == 'multilinestring') ?
            theThis.EncodeMultiLineString(flipped(geometry.coordinates), precision) : undefined;
    }
    this.EncodeMultiLineString = function (coordinates, precision) {
        //var nstrings = !!coordinates ? coordinates.length : 0;
        var strings = [];
        for (var i in coordinates) {
            var coords = coordinates[i].slice();
            strings.push(theThis.EncodeLineString(flipped(coords), precision));
        }
        return strings;
    }
    this.ToGeoJSONMultiLineString = function (strArray, precision) {
        var coords = theThis.DecodeMultiLineString(strArray, precision);
        return { type: 'MultiLineString', coordinates: coords };
    }
    this.DecodeMultiLineString = function (strArray, precision) {
        var coords = [];
        for (var i in strArray) { coords.push(flipped(theThis.DecodeLineString(strArray[i], precision))); }
        return coords;
    }
    function py2_round(value) {
        // Google's polyline algorithm uses the same rounding strategy as Python 2, which is different from JS for negative values
        return Math.floor(Math.abs(value) + 0.5) * Math.sign(value);
    }
    function encode(current, previous, factor) {
        current = py2_round(current * factor);
        previous = py2_round(previous * factor);
        var coordinate = current - previous;
        coordinate <<= 1;
        if (current - previous < 0) { coordinate = ~coordinate; }
        var output = '';
        while (coordinate >= 0x20) {
            output += String.fromCharCode((0x20 | (coordinate & 0x1f)) + 63);
            coordinate >>>= 5;
        }
        output += String.fromCharCode(coordinate + 63);
        return output;
    }
    function flipped(coords) {
        var flipped = [];
        for (var i = 0; i < coords.length; i++) { flipped.push(coords[i].slice().reverse()); }
        return flipped;
    }
    function initialize() { }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/*
function createEncodings(coords) {
    var i = 0;
    var plat = 0;
    var plng = 0;
    var encoded_points = "";
    for (i = 0; i < coords.length; ++i) {
        var lat = coords[i][0];
        var lng = coords[i][1];
        encoded_points += encodePoint(plat, plng, lat, lng);
        plat = lat;
        plng = lng;
    }
    // close polyline
    //encoded_points += encodePoint(plat, plng, coords[0][0], coords[0][1]);
    return encoded_points;
}
function encodePoint(plat, plng, lat, lng) {
    var late5 = Math.round(lat * 1e5);
    var plate5 = Math.round(plat * 1e5)
    var lnge5 = Math.round(lng * 1e5);
    var plnge5 = Math.round(plng * 1e5)
    var dlng = lnge5 - plnge5;
    var dlat = late5 - plate5;
    return encodeSignedNumber(dlat) + encodeSignedNumber(dlng);
}
function encodeSignedNumber(num) {
    var sgn_num = num << 1;
    if (num < 0) {
        sgn_num = ~(sgn_num);
    }
    return (encodeNumber(sgn_num));
}
function encodeNumber(num) {
    var encodeString = "";
    while (num >= 0x20) {
        encodeString += (String.fromCharCode((0x20 | (num & 0x1f)) + 63));
        num >>>= 5;
    }
    encodeString += (String.fromCharCode(num + 63));
    return encodeString;
}
*/

// SOURCE FILE: customcontrol.js
/**
 * method tf.map.ui.CreateMapButtonTextSpan - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} innerHTML - parameter description?
*/
tf.map.ui.CreateMapButtonTextSpan = function (innerHTML) {
    var span = document.createElement('span'); span.className = "ol-button-text-span";
    span.innerHTML = tf.js.GetNonEmptyString(innerHTML) ? innerHTML : "";
    return span;
}
/**
 * class tf.map.ui.CustomControl - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} tMap - parameter description?
 * @param {?} className - parameter description?
 * @param {?} innerHTML - parameter description?
 * @param {?} callBack - parameter description?
 * @param {?} opt_options - parameter description?
*/
tf.map.ui.CustomControl = function (tMap, className, innerHTML, callBack, opt_options) {
/**
 * method tf.map.ui.CustomControl.GetHTMLElement - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetHTMLElement = function () { return divElement; }
/**
 * method tf.map.ui.CustomControl.GetButton - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetButton = function () { return button; }
/**
 * method tf.map.ui.CustomControl.ChangeTitle - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} str - parameter description?
 * @param {?} tooltipStr - parameter description?
*/
    this.ChangeTitle = function (str, tooltipStr) { if (button) { button.innerHTML = str; button.title = tooltipStr; } }
/**
 * method tf.map.ui.CustomControl.ChangeToolTip - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} tooltipStr - parameter description?
*/
    this.ChangeToolTip = function (tooltipStr) { if (button) { button.title = tooltipStr; } }
    var options = tf.js.GetValidObjectFrom(opt_options);
    var tipLabel = options.tipLabel ? options.tipLabel : '';
    var imageLabel = options.imageLabel ? options.imageLabel : null;
    var button = document.createElement('button');
    var divElement = document.createElement('div');
    var onClick = null;
    button.title = tipLabel;
    if (imageLabel) { imageLabel.AppendTo(button); }
    else { button.appendChild(tf.map.ui.CreateMapButtonTextSpan(innerHTML)); }
    if (callBack) {
        new tf.events.DOMClickListener({ target: button, callBack: callBack, optionalScope: undefined, callBackSettings: undefined });
    }
    typeof className !== "string" && (className = '');
    divElement.style.zIndex = 1;
    divElement.className = className + " ol-unselectable ol-control";
    divElement.appendChild(button);
    ol.control.Control.call(this, {
        target: opt_options.target,
        hover: false, highlightOnly: false, element: divElement
    });
};
tf.js.InheritFrom(tf.map.ui.CustomControl, ol.control.Control);
/**
 * class tf.map.ui.CustomLogo - class description?
 * @private
 * @class
 * @summary - class summary?
 * @description - class description?
 * @param {?} tMap - parameter description?
 * @param {?} className - parameter description?
 * @param {?} opt_options - parameter description?
*/
tf.map.ui.CustomLogo = function (tMap, className, opt_options) {
/**
 * method tf.map.ui.CustomLogo.GetHTMLElement - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    this.GetHTMLElement = function () { return divElement; }
    var options = tf.js.GetValidObjectFrom(opt_options);
    var imageLabel = options.imageLabel ? options.imageLabel : null;
    var divElement = document.createElement('div');
    var innerHTML = options.innerHTML;
    typeof className !== "string" && (className = '') ;
    divElement.className = className + " ol-unselectable";
    if (imageLabel) { imageLabel.AppendTo(divElement); }
    if (innerHTML != undefined) {
        divElement.innerHTML = innerHTML;
    }
    ol.control.Control.call(this, { hover: false, highlightOnly: false, element: divElement });
};
tf.js.InheritFrom(tf.map.ui.CustomLogo, ol.control.Control);

// SOURCE FILE: featurelayer.js
/**
 * Map level ranges used by {@link tf.types.mapLayer} instances to constrain layer visibility to the given range
 * @public
 * @typedef {object} tf.types.MinMaxLevels
 * @property {tf.types.mapLevel} minLevel the minimum level at which the layer instance is displayed
 * @property {tf.types.mapLevel} maxLevel the maximum level at which the layer instance is displayed
*/
/**
 * Settings used in the creation of [Feature Layer]{@link tf.map.FeatureLayer} instances
 * @private
 * @typedef {object} tf.types.FeatureLayerSettings
 * @property {string} name - the layer name, displayed in the Map Layers popup
 * @property {string} description - the layer description
 * @property {boolean} isVisible - if <b>false</b> the layer is created invisible, defaults to <b>true</b>
 * @property {boolean} isHidden - if <b>false</b> the layer is not listed in the Map Layers popup, defaults to <b>true</b>
 * @property {number} zIndex - the layer zIndex, defaults to 0
 * @property {tf.types.opacity01} opacity - the layer opacity, defaults to 1
 * @property {tf.types.MinMaxLevels} minMaxLevels - if defined, constrains the layer's visibility to the given range, defaults to {@link void}
 * @property {boolean} useClusters - if <b>true</b> the layer can only display [Features]{@link tf.map.Feature] with [point geometries]{@link tf.types.GeoJSONGeometryType} 
 * and displays clusters of features into a single feature. Defaults to <b>void</b>
 * @property {number} clusterFeatureDistance - the distance in pixels under which [Map Features]{@link tf.map.Feature] are clustered together
 * @property {tf.types.MapFeatureStyleLike} clusterStyle - style used to display a cluster of [Map Features]{@link tf.map.Feature]
 * @property {tf.types.MapFeatureStyleSettings} clusterLabelStyle - style used to display the number of [Map Features]{@link tf.map.Feature] in a cluster
*/
/**
 * Notifications sent by {@link tf.map.FeatureLayer} instances. Properties are available in notifications that require them
 * @public
 * @typedef {object} tf.types.MapFeatureLayerEventNotification
 * @property {tf.map.FeatureLayer} sender - the instance sending the notification
 * @property {tf.types.mapFeatureLayerEventName} eventName - the name of the event
*/
/**
 * A callback function that can be passed to the function [Add Listener]{@link tf.map.FeatureLayer#AddListener} of a [Feature Layer]{@link tf.map.FeatureLayer} instance to start receiving event notifications from it
 * @public
 * @callback tf.types.MapFeatureLayerEventCallBack
 * @param {tf.types.MapFeatureLayerEventNotification} notification - the notification
 * @returns {void} - | {@link void} no return value
 */
/**
 * @public
 * @class
 * @summary Feature Layers group map features for display on the [TerraFly HTerraMap]{@link tf.map.Map}. 
 * Instances of this class are created by calling the function [AddFeatureLayer]{@link tf.map.Map#AddFeatureLayer} of a [Map]{@link tf.map.Map} instance
 * @param {tf.types.FeatureLayerSettings} settings - feature layer creation settings
 */
tf.map.FeatureLayer = function (settings)
{
    var debug;
    var theThis, tMap, olMap, strLayerName, strLayerDesc, notifyVisibilityChange, notifyDelFeatures, isVisible, isHidden, isForcedInvisible;
    var zIndex, opacity, olSourceVector, olClusterSource, olLayerVector;
    var featuresAddWithheld, featuresDelWithheld, styleCache, textFont, keyedFeatureList;
    var useClusters, clusterFeatureDistance, clusterStyle, clusterLabelStyle;
    var clustersIconFileName, clustersIconAnchor, clustersIconScale, showClusterCount;
    var allEventDispatchers;
    this.GetUsesClusters = function () { return useClusters; }
    this.SetUseClusters = function (bool) {
        if (useClusters != (bool = !!bool)) {
            useClusters = bool;
            var features = olSourceVector.getFeatures();
            createSourceVector();
            olSourceVector.addFeatures(features);
        }
    }
    /**
     * @public
     * @function
     * @summary - Adds a listener for the given map feature layer event name
     * @param {tf.types.mapFeatureLayerEventName} eventName - the name of the event
     * @param {tf.types.MapFeatureLayerEventCallBack} callBack - the callback for event notifications
     * @returns {tf.events.EventListener} - | {@link tf.events.EventListener} the event listener
    */
    this.AddListener = function (eventName, callBack) { return allEventDispatchers.AddListener(eventName, callBack); }
    /**
     * @public
     * @function
     * @summary - Retrieves the associated [Map]{@link tf.map.Map} instance
     * @returns {tf.map.Map} - | {@link tf.map.Map} the map instance
    */
    this.GetMap = function () { return tMap; }
    /**
     * @public
     * @function
     * @summary - Retrieves layer's name
     * @returns {string} - | {@link string} the name
    */
    this.GetName = function () { return strLayerName; }
    /**
     * @public
     * @function
     * @summary - Retrieves layer's description
     * @returns {string} - | {@link string} the description
    */
    this.GetDesc = function () { return strLayerDesc; }
    /**
     * @public
     * @function
     * @summary - Changes the layer's description
     * @param {string} newDescStr - the new description
     * @returns {void} - | {@link void} no return value
    */
    this.ChangeDescription = function (newDescStr) {
        if (tf.js.GetIsString(newDescStr)) { if (newDescStr != strLayerDesc) { strLayerDesc = newDescStr; doNotifyVisibilityChange(); } }
    }
    /**
     * @public
     * @function
     * @summary - Checks if the layer is hidden from the Layers Popup
     * @returns {boolean} - | {@link boolean} <b>true</b> if hidden, <b>false</b> otherwise
    */
    this.GetIsHidden = function () { return isHidden; }
    /**
     * @public
     * @function
     * @summary - Changes the layer's opacity
     * @param {tf.types.opacity01} opacity - the new opacity
     * @returns {void} - | {@link void} no return value
    */
    this.SetOpacity = function (opacity) { return setOpacity(opacity); }
    /**
     * @public
     * @function
     * @summary - Retrieves the layer's opacity
     * @returns {tf.types.opacity01} - | {@link tf.types.opacity01} the opacity
    */
    this.GetOpacity = function () { return getOpacity(); }
    /**
     * @public
     * @function
     * @summary - Changes the layer's zIndex
     * @param {number} zindex - the new zIndex
     * @returns {void} - | {@link void} no return value
    */
    this.SetZIndex = function (zindex) { return setZIndex(zindex); }
    /**
     * @public
     * @function
     * @summary - Retrieves the layer's zIndex
     * @returns {number} - | {@link number} the zIndex
    */
    this.GetZIndex = function () { return getZIndex(); }
    /**
     * @private
     * @function
     * @summary - Sets the minumum and maximum map levels at which this layer instance is displayed
     * @param {tf.types.mapLevel} minLevel the minimum level
     * @param {tf.types.mapLevel} maxLevel the maximum level
     * @returns {void} - | {@link void} no return value
    */
    this.SetMinMaxLevels = function (minLevel, maxLevel) { return setMinMaxLevels(minLevel, maxLevel); }
    this.SetIsForcedInvisible = function (bool) {
        if (isForcedInvisible != (bool = tf.js.GetBoolFromValue(bool))) {
            isForcedInvisible = bool;
            updateLayerVisibility();
        }
    }
    this.GetIsForcedInvisible = function () { return isForcedInvisible; }
    /**
     * @public
     * @function
     * @summary - Shows or hides the layer
     * @param {boolean} bool - <b>true</b> to show, <b>false</b> to hide
     * @returns {void} - | {@link void} no return value
    */
    this.SetVisible = function (bool) {
        if (isVisible != (bool = tf.js.GetBoolFromValue(bool))) {
            isVisible = bool;
            updateLayerVisibility();
            doNotifyVisibilityChange();
        }
    }
    /**
     * @public
     * @function
     * @summary - Checks if the layer is visible
     * @returns {boolean} - | {@link boolean} <b>true</b> if visible, <b>false</b> otherwise
    */
    this.GetIsVisible = function () { return /*olLayerVector.getVisible();*/ isVisible; }
    /**
     * @public
     * @function
     * @summary - Toggles layers's visibility state
     * @returns {void} - | {@link void} no return value
    */
    this.ToggleIsVisible = function () { return theThis.SetVisible(!isVisible); }
    /**
     * @public
     * @function
     * @summary - Adds all features that were withheld for group / bulk addition
     * @returns {void} - | {@link void} no return value
    */
    this.AddWithheldFeatures = function () {
        if (featuresAddWithheld.length) { olSourceVector.addFeatures(featuresAddWithheld); }
        featuresAddWithheld = [];
    }
    /**
     * @public
     * @function
     * @summary - Removes all features that were withheld for group / bulk removal
     * @returns {void} - | {@link void} no return value
    */
    this.DelWithheldFeatures = function () {
        if (featuresDelWithheld.length) {
            if (!!notifyDelFeatures) { notifyDelFeatures(featuresDelWithheld); }
            for (var i in featuresDelWithheld) {
                olSourceVector.removeFeature(featuresDelWithheld[i]);
            }
        }
        featuresDelWithheld = [];
    }
    /**
     * @public
     * @function
     * @summary - Adds one keyed feature to the layer
     * @param {tf.map.KeyedFeature} keyedFeature - the feature
     * @param {string} styleName - optional feature style name
     * @param {boolean} withHoldAddFeature - if <b>true</b> the feature is effectively added only when the function [AddWithheldFeatures]{@link tf.map.FeatureLayer#AddWithheldFeatures} 
     * is called, to improve performance when adding a large number of features in sequence. if <b>false</b> the feature is immediately added
     * @returns {void} - | {@link void} no return value
    */
    this.AddKeyedFeature = function (keyedFeature, styleName, withHoldAddFeature) { return addKeyedFeature(keyedFeature, styleName, withHoldAddFeature); }
    /**
     * @public
     * @function
     * @summary - Checks if the layer contains the given keyed feature
     * @param {tf.map.KeyedFeature} keyedFeature - the keyed feature
     * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
    */
    this.ContainsKeyedFeature = function (keyedFeature) { return containsKeyedFeature(keyedFeature); }
    /**
     * @public
     * @function
     * @summary - Removes one keyed feature from the layer
     * @param {tf.map.KeyedFeature} keyedFeature - the feature
     * @param {boolean} withHoldDelFeature - if <b>true</b> the feature is effectively deleted only when the function [DelWithheldFeatures]{@link tf.map.FeatureLayer#DelWithheldFeatures} 
     * is called, to improve performance when removing a large number of features in sequence. if <b>false</b> the feature is immediately removed
     * @returns {void} - | {@link void} no return value
    */
    this.DelKeyedFeature = function (keyedFeature, withHoldDelFeature) { return delKeyedFeature(keyedFeature, withHoldDelFeature); }
    /**
     * @public
     * @function
     * @summary - Adds one map feature to the layer
     * @param {tf.map.Feature} mapFeature - the feature
     * @param {boolean} withHoldAddFeature - if <b>true</b> the feature is effectively added only when the function [AddWithheldFeatures]{@link tf.map.FeatureLayer#AddWithheldFeatures} 
     * is called, to improve performance when adding a large number of features in sequence. if <b>false</b> the feature is immediately added
     * @returns {void} - | {@link void} no return value
    */
    this.AddMapFeature = function (mapFeature, withHoldAddFeature) { return addMapFeature(mapFeature, withHoldAddFeature); }
    /**
     * @public
     * @function
     * @summary - Removes one map feature from the layer
     * @param {tf.map.Feature} mapFeature - the feature
     * @param {boolean} withHoldDelFeature - if <b>true</b> the feature is effectively deleted only when the function [DelWithheldFeatures]{@link tf.map.FeatureLayer#DelWithheldFeatures} 
     * is called, to improve performance when removing a large number of features in sequence. if <b>false</b> the feature is immediately removed
     * @returns {void} - | {@link void} no return value
    */
    this.DelMapFeature = function (mapFeature, withholdDelFeature) { return delMapFeature(mapFeature, withholdDelFeature) }
    /**
     * @public
     * @function
     * @summary - Determines if the this layer contains the given feature
     * @param {tf.map.Feature} mapFeature - the feature
     * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
    */
    this.ContainsMapFeature = function (mapFeature) {
        return !!olSourceVector && tf.js.GetIsInstanceOf(mapFeature, tf.map.Feature) && !!olSourceVector.getFeatureById(mapFeature.getAPIFeature().getId());
    }
    /**
     * @public
     * @function
     * @summary - Removes all features from the layer
     * @returns {void} - | {@link void} no return value
    */
    this.RemoveAllFeatures = function () {
        if (!!notifyDelFeatures) { notifyDelFeatures(olSourceVector.getFeatures()) };
        keyedFeatureList = {};
        createSourceVector();
    }
    function updateLayerVisibility() { if (!!olLayerVector) { olLayerVector.setVisible(isVisible && !isForcedInvisible); } }
    function notifyListeners(eventName, extraAttributes) { allEventDispatchers.Notify(eventName, tf.js.ShallowMerge(extraAttributes, { sender: theThis, eventName: eventName })); }
    function doNotifyVisibilityChange() {
        if (!!notifyVisibilityChange) { notifyVisibilityChange.call(tMap, this); }
        notifyListeners(tf.consts.mapFeatureLayerVisibilityChangeEvent, { isVisible: isVisible });
    }
    function getOpacity() { return olLayerVector.getOpacity(); }
    function setOpacity(opacitySet) {
        opacitySet = tf.js.GetFloatNumberInRange(opacitySet, 0, 1, 1);
        if (opacity != opacitySet) {
            opacity = opacitySet;
            if (!!olLayerVector) { olLayerVector.setOpacity(opacity); }
        }
    }
    function getZIndex() { return zIndex; /*olLayerVector.getZIndex();*/ }
    function setZIndex(zIndexSet) {
        zIndexSet = tf.js.GetFloatNumber(zIndexSet, 0);
        if (zIndex != zIndexSet) {
            zIndex = zIndexSet;
            if (!!olLayerVector) { olLayerVector.setZIndex(zIndex); }
        }
    }
    function addMapFeature(mapFeature, withholdAddFeature) {
        if (mapFeature instanceof tf.map.Feature) {
            var APIFeature = mapFeature.getAPIFeature();
            if (!!withholdAddFeature) { featuresAddWithheld.push(APIFeature); } else { olSourceVector.addFeature(APIFeature); }
        }
    }
    function delMapFeature(mapFeature, withholdDelFeature) {
        if (mapFeature instanceof tf.map.Feature) {
            var APIFeature = mapFeature.getAPIFeature();
            if (!!withholdDelFeature) { featuresDelWithheld.push(APIFeature); } else {
                if (!!notifyDelFeatures) { notifyDelFeatures(APIFeature); }
                olSourceVector.removeFeature(APIFeature);
            }
        }
    }
    function addKeyedFeature(keyedFeature, styleName, withHoldAddFeature) {
        if (keyedFeature instanceof tf.map.KeyedFeature) {
            var keyedFeatureKey = keyedFeature.GetFeatureKey();
            var listItem = keyedFeatureList[keyedFeatureKey];
            if (!listItem) {
                var mapFeature = keyedFeature.GetMapFeature(styleName);
                if (!!mapFeature) {
                    keyedFeatureList[keyedFeatureKey] = { keyedFeature: keyedFeature, styleName: styleName, mapFeature: mapFeature };
                    addMapFeature(mapFeature, withHoldAddFeature);
                }
            }
            /*else { tf.GetDebug().LogIfTest('adding double keyed!'); }*/
        }
    }
    function containsKeyedFeature(keyedFeature) {
        return keyedFeature instanceof tf.map.KeyedFeature && keyedFeatureList[keyedFeature.GetFeatureKey()] !== undefined;
    }
    function delKeyedFeature(keyedFeature, withHoldDelFeature) {
        if (keyedFeature instanceof tf.map.KeyedFeature) {
            var keyedFeatureKey = keyedFeature.GetFeatureKey();
            var listItem = keyedFeatureList[keyedFeatureKey];
            if (!!listItem) {
                //var styleName = listItem.styleName;
                var mapFeature = listItem.mapFeature;
                delete keyedFeatureList[keyedFeatureKey];
                //delMapFeature(keyedFeature.GetMapFeature(styleName), withHoldDelFeature);
                delMapFeature(mapFeature, withHoldDelFeature);
            }
            /*else { tf.GetDebug().LogIfTest('deleting unexisting key!'); }*/
        }
    }
    function removeFromOLMap() { if (olLayerVector) { olMap.removeLayer(olLayerVector); olLayerVector = null; } }
    function clusterStyleFunction(feature, resolution) {
        var features = feature.get('features');
        var size = features.length;
        var style = null;
        if (size == 1) {
            var props = features [0].getProperties();
            if (props != null) { var mapFeature = props.mapFeature; if (mapFeature) { style = mapFeature.getAPIStyle(); } }
        }
        if (!style) {
            style = styleCache[size];
            if (!style) {
                if (!!clusterStyle) {
                    if (!!clusterLabelStyle) {
                        clusterLabelStyle = tf.js.ShallowMerge(clusterLabelStyle, { label: size.toString() });
                        if (tf.js.GetIsArray(clusterStyle)) {
                            var allStyle = clusterStyle.slice(0); allStyle.push(clusterLabelStyle) ;
                            var clusterS = tf.map.GetOrCreateFeatureStyle(allStyle);
                            style = clusterS.getAPIStyle();
                        }
                        else {
                            var allStyle;
                            if (clusterStyle.style == undefined && clusterStyle.hoverStyle == undefined) {
                                allStyle = [clusterStyle, clusterLabelStyle];
                            }
                            else {
                                var cstyle = clusterStyle.style;
                                var choverStyle = !!clusterStyle.hoverStyle ? clusterStyle.hoverStyle : cstyle;
                                allStyle = {
                                    /*style: [cstyle, clusterLabelStyle],
                                    hoverStyle: [choverStyle, clusterLabelStyle]*/
                                    style: cstyle
                                };
                                allStyle = [cstyle, clusterLabelStyle];
                            }
                            var clusterS = tf.map.GetOrCreateFeatureStyle(allStyle);
                            style = clusterS.getAPIStyle();
                        }
                    }
                    else {
                        var clusterS = tf.map.GetOrCreateFeatureStyle(clusterStyle);
                        style = clusterS.getAPIStyle();
                    }
                }
                else { style = [new ol.style.Style({ zindex:100, text: new ol.style.Text({ text: size.toString(), font: textFont, fill: new ol.style.Fill({ color: '#000' }) }) })]; }
                styleCache[size] = style;
            }
        }
        return style;
    }
    this.SetClusterFeatureDistance = function (newDistance) {
        if (useClusters && !!olClusterSource && newDistance != clusterFeatureDistance) {
            olClusterSource.setDistance(clusterFeatureDistance = newDistance);
        }
    }
    function createSourceVector() {
        var newLayerVector = !olLayerVector;
        olSourceVector = new ol.source.Vector();
        if (useClusters) {
            (typeof clustersIconFileName === "string" && clustersIconFileName.length > 0) || (clustersIconFileName = null);
            olClusterSource = new ol.source.Cluster({ distance: clusterFeatureDistance, source: olSourceVector });
            if (newLayerVector) {
                olLayerVector = new ol.layer.Vector({
                    source: olClusterSource, visible: isVisible, style: clusterStyleFunction, zIndex: zIndex, opacity: opacity,// renderOrder: zIndex,
                    updateWhileAnimating: true, updateWhileInteracting: true
                });
            }
            else {
                olLayerVector.setStyle(clusterStyleFunction);
                olLayerVector.setSource(olClusterSource);
            }
        }
        else {
            if (newLayerVector) {
                olLayerVector = new ol.layer.Vector({
                    source: olSourceVector, visible: isVisible, zIndex: zIndex, opacity: opacity,// renderOrder: zIndex,
                    updateWhileAnimating: true, updateWhileInteracting: true
                });
            }
            else {
                olLayerVector.setSource(olSourceVector);
            }
        }
        if (newLayerVector) { olMap.addLayer(olLayerVector); }
    }
    function setMinMaxLevels(minLevel, maxLevel) {
        var minMaxLevels = tf.js.GetMinMaxLevelsFrom(minLevel, maxLevel);
        minLevel = minMaxLevels.minLevel;
        maxLevel = minMaxLevels.maxLevel;
        var minRes = tf.units.GetResolutionByLevel(minLevel);
        var maxRes = tf.units.GetResolutionByLevel(maxLevel);
        olLayerVector.setMinResolution(minRes);
        olLayerVector.setMaxResolution(maxRes);
    }
    this.SetClusterStyle = function (newClusterStyle) {
        if (useClusters) {
            styleCache = {};
            clusterStyle = newClusterStyle;
            olClusterSource.forEachFeature(function(feature) {
                var props = feature.getProperties();
                var mapFeature = props.mapFeature;
                if (mapFeature) {
                    mapFeature.RefreshStyle();
                }
            });
        }
    }
    function initialize() {
        zIndex = 0;
        opacity = 1;
        featuresAddWithheld = [];
        featuresDelWithheld = [];
        styleCache = {};
        keyedFeatureList = {};
        isForcedInvisible = false;
        allEventDispatchers = new tf.events.MultiEventNotifier({ eventNames: tf.consts.allMapFeatureLayerEventNames });
        textFont = tf.GetStyles().GetSubStyles().markerFontFamily;
        strLayerName = tf.js.GetNonEmptyString(settings.name, '');
        strLayerDesc = tf.js.GetNonEmptyString(settings.description, '');
        isVisible = tf.js.GetBoolFromValue(settings.isVisible, true);
        isHidden = tf.js.GetBoolFromValue(settings.isHidden, false);
        if (settings.zIndex !== undefined) { setZIndex(settings.zIndex); }
        if (settings.opacity !== undefined) { setOpacity(settings.opacity); }
        tMap = tf.js.GetMapFrom(settings.map);
        olMap = settings.olMap;
        notifyDelFeatures = tf.js.GetFunctionOrNull(settings.notifyDelFeatures);
        notifyVisibilityChange = tf.js.GetFunctionOrNull(settings.notifyVisibilityChange);
        useClusters = tf.js.GetBoolFromValue(settings.useClusters, false);
        clusterFeatureDistance = tf.js.GetIntNumberInRange(settings.clusterFeatureDistance, 5, 1000, 24);
        clusterStyle = tf.js.GetIsValidObject(settings.clusterStyle) ? settings.clusterStyle : null;
        clusterLabelStyle = tf.js.GetIsValidObject(settings.clusterLabelStyle) ? settings.clusterLabelStyle : null;
        if (tf.js.GetFunctionOrNull(settings.setDeleteCmdCallBack)) { settings.setDeleteCmdCallBack.call(tMap, theThis, removeFromOLMap); }
        createSourceVector();
        if (tf.js.GetIsValidObject(settings.minMaxLevels)) { setMinMaxLevels(settings.minMaxLevels.minLevel, settings.minMaxLevels.maxLevel); }
    }
    (function actualConstructor(theLayerThis) { theThis = theLayerThis; initialize(); })(this);
};

// SOURCE FILE: mapfeature.js
/**
 * Settings used in the creation of [Map Feature]{@link tf.map.Feature} instances
 * @public
 * @typedef {object} tf.types.MapFeatureSettings
 * @property {tf.map.FeatureGeom} geom - a geometry instance to be associated with the map feature, if this property is not defined, then <b>type</b> and <b>coordinates</b> are mandatory
 * @property {tf.types.GeoJSONGeometryType} type - the map feature type, mandatory if <b>geom</b> is not defined
 * @property {tf.types.GeoJSONGeometryCoordinates} coordinates - the map feature coordinates, mandatory if <b>geom</b> is not defined
 * @property {tf.types.MapFeatureStyleLike} style - the map feature style
 * @property {tf.types.MapFeatureStyleLike} hoverStyle - the style assumed by the map feature when the mouse pointer is hovering over it
 * @property {tf.map.KeyedFeature} keyedFeature - the keyed feature instance associated with this map feature, if any
 * @property {tf.map.FeatureWithNamedStyles} mapFeatureWithNamedStyles - the map feature with named styles instance associated with this map feature, if any
 * @property {string} styleName - the style name, used by map features that are associated with instances of {@link tf.map.MapFeatureWithNamedStyles}
*/
tf.map.nextFeatureId = 0;
/**
 * @public
 * @class
 * @summary Map Features can be displayed in one or more [Feature Layers]{@link tf.map.FeatureLayer} of the same or different [Maps]{@link tf.map.Map} using a single geometry and set of styles 
 * @param {tf.types.MapFeatureSettings} settings - map feature creation settings
 */
tf.map.Feature = function (settings) {
    var theThis, mapFeatureStyle, mapFeatureNormalStyle, mapFeatureHoverStyle, mapFeatureGeom;
    var APIFeature, keyedFeature, mapFeatureWithNamedStyles, styleName;
    var onRollOverListener, onClickListener, onDoubleClickListener, onHoverInOutListener;
    var isInHover, alwaysInHover, processInHover, id;
    this.GetSettings = function () { return settings; }
    this.SetStyles = function (style, hoverStyle) {
        if (tf.js.GetIsInstanceOf(style, tf.map.FeatureStyle) && tf.js.GetIsInstanceOf(hoverStyle, tf.map.FeatureStyle)) {
            mapFeatureNormalStyle = style;
            mapFeatureHoverStyle = hoverStyle;
            theThis.RefreshStyle();
        }
    }
    /**
     * @public
     * @function
     * @summary - Changes the geometry of a feature
     * @param {tf.map.FeatureGeom} geom - the new geometry
     * @returns {void} - | {@link void} no return value
    */
    this.SetGeom = function (geom) {
        if (tf.js.GetIsInstanceOf(geom, tf.map.FeatureGeom) && ((!mapFeatureGeom) || (mapFeatureGeom.GetType() == geom.GetType()))) { mapFeatureGeom = geom; refreshGeom(); return true; } return false;
    }
    /**
     * @public
     * @function
     * @summary - Retrieves the geometry instance associated with this feature
     * @returns {tf.map.FeatureGeom} - | {@link tf.map.FeatureGeom} the geometry
    */
    this.GetGeom = function () { return mapFeatureGeom; }
    /**
     * @public
     * @function
     * @summary - Retrieves the style instance associated with this feature
     * @returns {tf.map.FeatureStyle} - | {@link tf.map.FeatureStyle} the style
    */
    this.GetStyle = function () { return mapFeatureStyle; }
    /**
     * @public
     * @function
     * @summary - Forces the re-creation of the feature geometry
     * @returns {void} - | {@link void} no return value
    */
    this.RefreshGeom = function () { return refreshGeom(); }
    /**
     * @public
     * @function
     * @summary - Forces the re-creation of the feature style
     * @returns {void} - | {@link void} no return value
    */
    this.RefreshStyle = function () { return refreshStyle(); }
    /**
     * @public
     * @function
     * @summary - Changes the features's style
     * @param {tf.types.MapFeatureStyleLike} strStyleOrObj - map feature style settings
     * @returns {void} - | {@link void} no return value
    */
    this.ChangeStyle = function (strStyleOrObj) { return changeStyle(strStyleOrObj); }
    /**
     * @public
     * @function
     * @summary - Checks if the type of geometry associated with this feature is "point"
     * @returns {boolean} - | {@link boolean} <b>true</b> if the geometry type is "point", <b>false</b> otherwise
    */
     this.GetIsPoint = function () { return !!mapFeatureGeom ? mapFeatureGeom.GetIsPoint() : false; }
    /**
     * @public
     * @function
     * @summary - Changes the map coordinates of a "point" feature
     * @param {tf.types.mapCoordinates} pointCoords - the feature coordinates
     * @returns {void} - | {@link void} no return value
    */
     this.SetPointCoords = function (pointCoords) { if (!!mapFeatureGeom && mapFeatureGeom.SetPointCoords(pointCoords)) { refreshGeom(); return true; } return false; }
    /**
     * @public
     * @function
     * @summary - Retrieves the current coordinates of a "point" feature
     * @returns {tf.types.mapCoordinates} - | {@link tf.types.mapCoordinates} the coordinates
    */
     this.GetPointCoords = function () { return theThis.GetIsPoint() ? mapFeatureGeom.GetPointCoords() : theThis.GetMidExtentCoords(); }
     this.GetMidExtentCoords = function () { return tf.js.GetMidExtentCoord(theThis.GetExtent()); }
     this.GetExtent = function () { return !!mapFeatureGeom ? mapFeatureGeom.GetExtent() : undefined; }
     this.GetClosestPoint = function (pointCoords) { return !!mapFeatureGeom ? mapFeatureGeom.GetClosestPoint(pointCoords) : undefined; }
    /**
     * @public
     * @function
     * @summary - Sets a listener for {@link tf.consts.mapFeatureHoverInOutEvent} map events associated with this feature, replacing the previous listener, if any
     * @param {tf.types.MapEventCallBack} callBack - the callback for event notifications
     * @returns {void} - | {@link void} no return value
    */
     this.SetOnHoverInOutListener = function (callBack) { onHoverInOutListener = tf.js.GetFunctionOrNull(callBack); }
    /**
     * @public
     * @function
     * @summary - Sets a listener for {@link tf.consts.mapFeatureMouseMoveEvent} map events associated with this feature, replacing the previous listener, if any
     * @param {tf.types.MapEventCallBack} callBack - the callback for event notifications
     * @returns {void} - | {@link void} no return value
    */
     this.SetOnMouseMoveListener = function (callbackFunction) { onRollOverListener = tf.js.GetFunctionOrNull(callbackFunction); }
    /**
     * @public
     * @function
     * @summary - Sets a listener for {@link tf.consts.mapFeatureClickEvent} map events associated with this feature, replacing the previous listener, if any
     * @param {tf.types.MapEventCallBack} callBack - the callback for event notifications
     * @returns {void} - | {@link void} no return value
    */
     this.SetOnClickListener = function (callbackFunction) { onClickListener = tf.js.GetFunctionOrNull(callbackFunction); }
    /**
     * @public
     * @function
     * @summary - Sets a listener for {@link tf.consts.mapFeatureDblClickEvent} map events associated with this feature, replacing the previous listener, if any
     * @param {tf.types.MapEventCallBack} callBack - the callback for event notifications
     * @returns {void} - | {@link void} no return value
    */
     this.SetOnDoubleClickListener = function (callbackFunction) { onDoubleClickListener = tf.js.GetFunctionOrNull(callbackFunction); }
    /**
     * @public
     * @function
     * @summary - Checks if the feature is currently being hovered over
     * @returns {boolean} - | {@link boolean} <b>true</b> if the feature is being hovered over, <b>false</b> otherwise
    */
     this.GetIsInHover = function () { return isInHover; }
     this.GetIsAlwaysInHover = function () { return alwaysInHover; }
     this.SetIsAlwaysInHover = function (bool) { if (alwaysInHover != (bool = !!bool)) { alwaysInHover = bool; setHoverNonHoverStyle() }; }
     this.GetIsDisplayingInHover = function () { return isInHover || alwaysInHover; }
     this.GetProcessInHover = function () { return processInHover; }
     this.SetProcessInHover = function (bool) { if (processInHover != (bool = !!bool)) { processInHover = bool; setHoverNonHoverStyle() }; }
    /**
     * @public
     * @function
     * @summary - Retrieves the keyed feature instance associated with this map feature, if any
     * @returns {tf.map.KeyedFeature} - | {@link tf.map.KeyedFeature} the keyed feature
    */
     this.GetKeyedFeature = function () { return keyedFeature; }
    /**
     * @public
     * @function
     * @summary - Retrieves the map feature with named styles instance associated with this map feature, if any
     * @returns {tf.map.FeatureWithNamedStyles} - | {@link tf.map.FeatureWithNamedStyles} the map feature with named styles instance
    */
     this.GetMapFeatureWithNamedStyles = function () { return mapFeatureWithNamedStyles; }
    /**
     * @public
     * @function
     * @summary - Receives {@link tf.consts.mapFeatureHoverInOutEvent} event notifications from maps, notifies a listener, if one is set
     * @param {tf.types.MapEventNotification} notification - the notification
     * @returns {void} - | {@link void} no return value
    */
     this.onHoverInOut = function (notification) { return onHoverInOut(notification); }
    /**
     * @public
     * @function
     * @summary - Receives {@link tf.consts.mapFeatureMouseMoveEvent} event notifications from maps, notifies a listener, if one is set
     * @param {tf.types.MapEventNotification} notification - the notification
     * @returns {void} - | {@link void} no return value
    */
     this.onMouseMove = function (notification) { return notifyListener(onRollOverListener, notification); }
    /**
     * @public
     * @function
     * @summary - Receives {@link tf.consts.mapFeatureClickEvent} event notifications from maps, notifies a listener, if one is set
     * @param {tf.types.MapEventNotification} notification - the notification
     * @returns {void} - | {@link void} no return value
    */
     this.onClick = function (notification) { return notifyListener(onClickListener, notification); }
    /**
     * @public
     * @function
     * @summary - Receives {@link tf.consts.mapFeatureDblClickEvent} event notifications from maps, notifies a listener, if one is set
     * @param {tf.types.MapEventNotification} notification - the notification
     * @returns {void} - | {@link void} no return value
    */
     this.onDoubleClick = function (notification) { return notifyListener(onDoubleClickListener, notification); }
    /**
     * @private
     * @function
     * @summary - Returns underlying map engine object associated with this feature's geometry
     * @returns {ol.Feature} - | the map engine object
    */
     this.getAPIFeature = function () { return APIFeature; }
    /**
     * @private
     * @function
     * @summary - Returns underlying map engine object associated with this feature's style
     * @returns {ol.Style} - | the map engine object
    */
     this.getAPIStyle = function () { return getAPIStyle(); }
    /**
     * @private
     * @function
     * @summary - Returns the style name set when this instance was created
     * @returns {string} - | {@link string} the style name
    */
     this.getStyleName = function () { return styleName; }
     function notifyListener(theListener, notification) { if (!!theListener) { theListener(notification); } }
     function setHoverNonHoverStyle() {
         var useHover = (!!processInHover && !!isInHover) || alwaysInHover;
         mapFeatureStyle = !!useHover ? mapFeatureHoverStyle : mapFeatureNormalStyle;
         refreshStyle();
     }
    function onHoverInOut(notification) {
        isInHover = notification.isInHover;
        if (!!mapFeatureHoverStyle) { setHoverNonHoverStyle(); }
        notifyListener(onHoverInOutListener, notification);
    }
    function styleFunction (feature, resolution) {
        var APIStyle;
        if (feature instanceof ol.feature) {
            var mapFeature = feature.getProperties().mapFeature;
            if (mapFeature) { APIStyle = null; }
        }
        return APIStyle;
    }
    function doGetAPIStyle(fromFeatureStyle) {
        var APIStyle = null;
        if (fromFeatureStyle instanceof tf.map.FeatureStyle) { APIStyle = fromFeatureStyle.getAPIStyle(); }
        else if (typeof fromFeatureStyle === "function") {
            var obj = !!keyedFeature ? keyedFeature : theThis;
            var style = tf.map.GetOrCreateFeatureStyle(fromFeatureStyle(obj, theThis));
            APIStyle = style instanceof (tf.map.FeatureStyle) ? style.getAPIStyle() : null ;
        }
        return APIStyle;
    }
    function getAPIStyle() { return doGetAPIStyle(mapFeatureStyle); }
    function refreshGeom() {
        if (!!APIFeature) {
            //APIFeature.setGeometry(null);
            APIFeature.setGeometry(mapFeatureGeom.getAPIGeom());
        }
    }
    function refreshStyle() {
        if (!!APIFeature) {
            //APIFeature.setStyle(null);
            //APIFeature.setStyle(mapFeatureStyle.getAPIStyle());
            APIFeature.setStyle(getAPIStyle());
        }
    }
    function refreshFeature() { refreshGeom(); refreshStyle(); }
    function changeStyle(strStyleOrObj) {
        if (strStyleOrObj instanceof tf.map.FeatureStyle) {
            mapFeatureStyle = strStyleOrObj;
            refreshStyle();
        }
        else if (mapFeatureStyle instanceof tf.map.FeatureStyle) {
            mapFeatureStyle.UpdateAttributesFrom(strStyleOrObj);
            refreshStyle();
        }
    }
    function updateAPIFeature() {
        APIFeature = new ol.Feature({ mapFeature: theThis });
        APIFeature.setId(id);
        refreshFeature();
    }
    function initialize() {
        isInHover = false;
        alwaysInHover = false;
        processInHover = true;
        id = ++tf.map.nextFeatureId;
        keyedFeature = settings.keyedFeature;
        mapFeatureWithNamedStyles = settings.mapFeatureWithNamedStyles instanceof tf.map.FeatureWithNamedStyles ? settings.mapFeatureWithNamedStyles : null;
        mapFeatureNormalStyle = mapFeatureStyle = tf.map.GetOrCreateFeatureStyle(settings.style);
        mapFeatureHoverStyle = !!settings.hoverStyle ? tf.map.GetOrCreateFeatureStyle(settings.hoverStyle) : null;
        mapFeatureGeom = settings.geom instanceof tf.map.FeatureGeom ? settings.geom : new tf.map.FeatureGeom({ type: settings.type, coordinates: settings.coordinates });
        styleName = tf.js.GetNonEmptyString(settings.styleName, "");
        updateAPIFeature();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * Settings used in the creation of [Map Feature]{@link tf.map.Feature} instances
 * @public
 * @typedef {object} tf.types.MapFeatureWithNamedStylesSettings
 * @property {tf.map.FeatureGeom} geom - a geometry instance to be associated with the map feature, if this property is not defined, then <b>type</b> and <b>coordinates</b> are mandatory
 * @property {tf.types.GeoJSONGeometryType} type - the map feature type, mandatory if <b>geom</b> is not defined
 * @property {tf.types.GeoJSONGeometryCoordinates} coordinates - the map feature coordinates, mandatory if <b>geom</b> is not defined
 * @property {tf.types.NamedFeatureStyleSettings} styleSettings - style settings
 * @property {tf.map.KeyedFeature} keyedFeature - the keyed feature instance associated with this map feature, if any
*/
/**
 * @public
 * @class
 * @summary Map Features with Named Styles can be displayed in one or more [Feature Layers]{@link tf.map.FeatureLayer} of the same or different [Maps]{@link tf.map.Map}. 
 * Each instance of this class manages one or more instances of [Map Feature]{@link tf.map.Feature}, all sharing the same geometry instance, and each with a different set of named styles 
 * @param {tf.types.MapFeatureWithNamedStylesSettings} settings - map feature creation settings
 */
tf.map.FeatureWithNamedStyles = function (settings) {
    var theThis, keyedFeature, mapFeatures, mapFeatureGeom;
    /**
     * @public
     * @function
     * @summary - Retrieves the geometry instance associated with this feature
     * @returns {tf.map.FeatureGeom} - | {@link tf.map.FeatureGeom} the geometry
    */
    this.GetGeom = function () { return mapFeatureGeom; }
    this.SetGeom = function (geom) {
        if (tf.js.GetIsInstanceOf(geom, tf.map.FeatureGeom) && ((!mapFeatureGeom) || (mapFeatureGeom.GetType() == geom.GetType()))) {
            mapFeatureGeom = geom;
            for (var i in mapFeatures) { mapFeatures[i].SetGeom(geom); }
            return true;
        }
        return false;
    }
    this.GetExtent = function () { return !!mapFeatureGeom ? mapFeatureGeom.GetExtent() : undefined; }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Map Feature]{@link tf.map.Feature} associated with the given style name
     * @param {string} styleName - the name of the style
     * @returns {tf.map.Feature} - | {@link tf.map.Feature} the map feature
    */
    this.GetMapFeature = function (styleName) { return getMapFeature(styleName); }
    /**
     * @public
     * @function
     * @summary - Retrieves the [Map Feature Style]{@link tf.map.FeatureStyle} associated with the given style name
     * @param {string} styleName - the name of the style
     * @returns {tf.map.FeatureStyle} - | {@link tf.map.FeatureStyle} the map feature style
    */
    this.GetStyle = function (styleName) { return getMapFeatureStyle(styleName).GetStyle(); }
    /**
     * @public
     * @function
     * @summary - Forces the re-creation of one or more of the feature's named styles
     * @param {string | enumerable<string>} styleNameOrNames - the name of the style to refresh, or an enumerable of style names to refresh
     * @returns {void} - | {@link void} no return value
    */
    this.RefreshStyle = function (styleNameOrNames) { return refreshStyle(styleNameOrNames); }
    this.RefreshGeom = function () { for (var i in mapFeatures) { mapFeatures[i].RefreshGeom(); } }
    this.SetIsAlwaysInHover = function (setBool, styleNameOrNames) { return setIsAlwaysInHover(setBool, styleNameOrNames); }
    /**
     * @public
     * @function
     * @summary - Checks if the type of geometry associated with this map feature is "point"
     * @returns {boolean} - | {@link boolean} <b>true</b> if the geometry type is "point", <b>false</b> otherwise
    */
    this.GetIsPoint = function () { return !!mapFeatureGeom ? mapFeatureGeom.GetIsPoint() : false; }
    /**
     * @public
     * @function
     * @summary - Changes the map coordinates of a "point" feature
     * @param {tf.types.mapCoordinates} pointCoords - the feature coordinates
     * @returns {void} - | {@link void} no return value
    */
    this.SetPointCoords = function (pointCoords) { return setPointCoords(pointCoords); }
    /**
     * @public
     * @function
     * @summary - Retrieves the current coordinates of a "point" feature
     * @returns {tf.types.mapCoordinates} - | {@link tf.types.mapCoordinates} the coordinates
    */
    this.GetPointCoords = function () { return !!mapFeatureGeom ? mapFeatureGeom.GetPointCoords() : [0,0]; }
    this.GetClosestPoint = function (pointCoords) { return !!mapFeatureGeom ? mapFeatureGeom.GetClosestPoint(pointCoords) : undefined; }
    /**
     * @public
     * @function
     * @summary - Retrieves the keyed feature instance associated with this map feature, if any
     * @returns {tf.map.KeyedFeature} - | {@link tf.map.KeyedFeature} the keyed feature
    */
    this.GetKeyedFeature = function () { return keyedFeature; }
    /**
     * @private
     * @function
     * @summary - Returns underlying map engine object associated with feature of the given style name
     * @param {string} styleName - the name of the style
     * @returns {ol.Feature} - | the map engine object
    */
    this.getAPIFeature = function (styleName) { return getMapFeature(styleName).getAPIFeature(); }
    /**
     * @private
     * @function
     * @summary - Returns underlying map engine object associated with feature of the given style name
     * @param {string} styleName - the name of the style
     * @returns {ol.Style} - | the map engine object
    */
    this.getAPIStyle = function (styleName) { return getMapFeature(styleName).getAPIStyle(); }
    function getMapFeature(styleName) {
        if (!styleName || !tf.js.GetIsNonEmptyString (styleName) || !mapFeatures[styleName]) {
            styleName = tf.consts.defaultMapFeatureStyleName;
        }
        return mapFeatures[styleName];
    }
    function setPointCoords(pointCoords) {
        if (!!mapFeatureGeom) {
            if (mapFeatureGeom.SetPointCoords(pointCoords)) {
                for (var i in mapFeatures) { mapFeatures[i].RefreshGeom(); }
            }
        }
    }
    function getMapFeatureStyle(styleName) { var mapFeature = getMapFeature(styleName); return mapFeature ? mapFeature.GetStyle() : null; }
    function doSetIsAlwaysInHover(setBool, styleName) { var mapFeature = getMapFeature(styleName); if (mapFeature) { mapFeature.SetIsAlwaysInHover(setBool); } }
    function setIsAlwaysInHover(setBool, styleNameOrNames) {
        if (tf.js.GetIsArray(styleNameOrNames)) {
            for (var i in styleNameOrNames) { doSetIsAlwaysInHover(setBool, styleNameOrNames[i]); }
        }
        else {
            if (styleNameOrNames == undefined) { for (var i in mapFeatures) { doSetIsAlwaysInHover(setBool, i); } }
            else { doSetIsAlwaysInHover(setBool, styleNameOrNames); }
        }
    }
    function doRefreshStyle(styleName) { var mapFeature = getMapFeature(styleName); return mapFeature ? mapFeature.RefreshStyle() : false; }
    function refreshStyle(styleNameOrNames) {
        var refreshed = false;
        if (tf.js.GetIsArray(styleNameOrNames)) {
            for (var i in styleNameOrNames) { refreshed = doRefreshStyle(styleNameOrNames[i]) || refreshed; }
        }
        else {
            if (styleNameOrNames == undefined) { for (var i in mapFeatures) { refreshed = doRefreshStyle(i) || refreshed; } }
            else { refreshed = doRefreshStyle(styleNameOrNames); }
        }
        return refreshed;
    }
    function initialize() {
        keyedFeature = settings.keyedFeature instanceof tf.map.KeyedFeature ? settings.keyedFeature : null;
        mapFeatureGeom = settings.geom instanceof tf.map.FeatureGeom ? settings.geom : new tf.map.FeatureGeom({ type: settings.type, coordinates: settings.coordinates });
        var propagateSettings = tf.js.ShallowMerge(settings, { geom: mapFeatureGeom, mapFeatureWithNamedStyles: theThis });
        settings = tf.js.GetValidObjectFrom(settings);
        var styleSettings = tf.js.GetValidObjectFrom(settings.styleSettings);
        if (tf.js.GetIsValidObject(styleSettings.styles)) {
            var firstFeature = null;
            var styles = styleSettings.styles;
            mapFeatures = {};
            for (var styleName in styles) {
                var theStyle = styles[styleName];
                if (typeof theStyle === "object") {
                    propagateSettings.style = tf.map.GetOrCreateFeatureStyle (theStyle.style);
                    propagateSettings.hoverStyle = tf.map.GetOrCreateFeatureStyle(theStyle.hoverStyle);
                    propagateSettings.styleName = styleName;
                    var thisFeature = new tf.map.Feature(propagateSettings);
                    mapFeatures[styleName] = thisFeature;
                    if (!firstFeature) { firstFeature = thisFeature; }
                }
            }
            if (!!firstFeature) {
                if (mapFeatures[tf.consts.defaultMapFeatureStyleName] === undefined) {
                    mapFeatures[tf.consts.defaultMapFeatureStyleName] = firstFeature;
                }
            }
            else {
                mapFeatures = null;
            }
        }
        else {
            propagateSettings.style = styleSettings.style;
            propagateSettings.hoverStyle = styleSettings.hoverStyle;
        }
        if (!mapFeatures) {
            propagateSettings.styleName = tf.consts.defaultMapFeatureStyleName;
            mapFeatures = {};
            mapFeatures[tf.consts.defaultMapFeatureStyleName] = new tf.map.Feature(propagateSettings);
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: mapfeaturestyle.js
/**
 * An icon anchor are horizontal and vertical offset factors of the icon's width and height, respectivelly and in that order, used to displace 
 * the icon from the feature's point coordinates: [0.5, 0.5] places the icon centered at the point coordinates, [0.5, 1.0] places the icon centered horizontally and
 * above the map coordinates, [0.0, 0.0] places the icon to the left and below the map coordinates, etc.
 * @public
 * @typedef {array<number,number>} tf.types.iconAnchor
*/
/**
 * A callback function that, upon request, returns an instance of [Map Feature Style]{@link tf.map.FeatureStyle} to be used with the given map feature
 * @public
 * @callback tf.types.MapFeatureStyleFunction
 * @param {tf.map.Feature|tf.map.KeyedFeature} mapFeature - the feature for which a style is requested
 * @returns {tf.map.FeatureStyle} - | {@link tf.map.FeatureStyle} the instance
 */
/**
 * A type accepted by many API functions and is either an instance of [Map Feature Style]{@link tf.map.FeatureStyle}, 
 * a [Map Feature Style Settings]{@link tf.types.MapFeatureStyleSettings} object, an array of [Map Feature Style Settings]{@link tf.types.MapFeatureStyleSettings},
 * of a function that returns an instance of [Map Feature Style]{@link tf.map.FeatureStyle}
 * @public
 * @typedef {tf.types.MapFeatureStyleSettings|array<tf.types.MapFeatureStyleSettings>|tf.types.MapFeatureStyleFunction} tf.types.MapFeatureStyleLike
*/
/**
 * An {@link object} with a Map feature style property and a Map feature style hover property
 * @public
 * @typedef {object} tf.types.MapFeatureStyleAndHoverStyle
 * @property {tf.types.MapFeatureStyleLike} style - a map feature style
 * @property {tf.types.MapFeatureStyleLike} hoverStyle - a style assumed by a map feature when the mouse pointer is hovering over it
*/
/**
 * An {@link object} whose property name specifies the style name and whose property value is a [Map Feature Style and Hover Style]{@link tf.types.MapFeatureStyleAndHoverStyle}
 * @public
 * @typedef {object} tf.types.NamedMapFeatureStyleAndHoverStyles
*/
/**
 * An {@link object} used in the creation of [Keyed Features]{@link tf.map.KeyedFeature} and [Map Features with Named Styles]{@link tf.map.FeatureWithNamedStyles}.
 * Specifies either a single default style/hoverStyle pair using the properties <b>style</b> and <b>hoverStyle</b>, or an enumerable of named style/hoverStyle pairs
 * @public
 * @typedef {object} tf.types.NamedFeatureStyleSettings
 * @property {enmumerable<tf.types.NamedMapFeatureStyleAndHoverStyles>} styles - an enumerable of named styles, if not defined <b>style</b> and <b>hoverStyle</b> are mandatory, 
 * and used to create a feature with the default style name ({@link tf.consts.defaultMapFeatureStyleName}). When defined, if none of the named styles is
 * named {@link tf.consts.defaultMapFeatureStyleName}, the first style is used as the default style.
 * @property {tf.types.MapFeatureStyleLike} style - the map feature style, mandatory if <b>styles</b> is not defined
 * @property {tf.types.MapFeatureStyleLike} hoverStyle - the style assumed by the map feature when the mouse pointer is hovering over it, mandatory if <b>styles</b> is not defined
*/
/**
 * @private
 * @function
 * @summary - Returns the given parameter if it is an instance of {@link tf.map.FeatureStyle} or a {@link function}, otherwise 
 * creates and returns a new instance of {@link tf.map.FeatureStyle} initialized with the given parameter. Used internally by the API
 * @param {tf.types.MapFeatureStyleLike} fromFeatureStyleSettingsObjectOrFunction - the given parameter
 * @returns {tf.types.MapFeatureStyleLike} - | {@link tf.types.MapFeatureStyleLike} the instance
*/
tf.map.GetOrCreateFeatureStyle = function (fromFeatureStyleSettingsObjectOrFunction) {
    var featureStyle, featureStyleSettings;
    if (!!fromFeatureStyleSettingsObjectOrFunction) {
        if ((fromFeatureStyleSettingsObjectOrFunction instanceof tf.map.FeatureStyle) || tf.js.GetFunctionOrNull(fromFeatureStyleSettingsObjectOrFunction)) {
            featureStyle = fromFeatureStyleSettingsObjectOrFunction;
        }
        else if (tf.js.GetIsValidObject(fromFeatureStyleSettingsObjectOrFunction)) { featureStyleSettings = fromFeatureStyleSettingsObjectOrFunction; }
    }
    if (!featureStyle) { featureStyle = new tf.map.FeatureStyle(featureStyleSettings); }
    return featureStyle;
}
/**
 * An object whose properties specify the visual attributes used to display [Map Features]{@link tf.map.Feature} on the [Map]{@link tf.map.Map}.
 * @public
 * @typedef {object} tf.types.MapFeatureStyleSettings
 *
 * @property {boolean} circle - Used with [point geometries]{@link tf.types.GeoJSONGeometryType} to display a circle at the point coordinates. Mutually exclusive
 * with other <b>point</b> styles. Uses the properties <b>circle_radius</b>, and the properties related to <b>line</b>, and <b>fill</b>
 *
 * @property {boolean} icon - Used with [point geometries]{@link tf.types.GeoJSONGeometryType} to display an image at the point coordinates. Mutually exclusive
 * with other <b>point</b> styles. Uses the property <b>icon_anchor</b> and either <b>icon_url</b>, or both <b>icon_img</b> and <b>icon_size</b>
 *
 * @property {boolean} marker - Used with [point geometries]{@link tf.types.GeoJSONGeometryType} to display a text bubble (a marker) pointing to the feature's coordinates. Mutually exclusive
 * with other <b>point</b> styles. Uses the properties <b>label</b> (the text), <b>font</b>, <b>font_height</b>, <b>font_color</b>, <b>font_opacity</b>, <b>border_color</b>, <b>border_opacity</b>,
 * <b>border_width</b>, <b>marker_color</b>, <b>marker_opacity</b>, and properties related to <b>line</b> (for optinal text stroke)
 *
 * @property {boolean} shape - Used with [point geometries]{@link tf.types.GeoJSONGeometryType} to display the shape of a regular polygon or a star at the point coordinates. Mutually exclusive
 * with other <b>point</b> styles. Controls shape settings with the properties <b>shape_points</b> and either the property <b>shape_radius</b>, or both <b>shape_radius1</b> and <b>shape_radius2</b>.
 * Uses the properties related with <b>line</b> and <b>fill</b>
 *
 * @property {boolean} text - Used with [point geometries]{@link tf.types.GeoJSONGeometryType} to display text at or near the point coordinates. Mutually exclusive
 * with other <b>point</b> styles. Uses the properties <b>label</b> (the text), <b>font</b>, <b>text_offsetx</b>, <b>text_offsety</b>, <b>text_align</b>, <b>text_baseline</b>,
 * and the properties related with <b>line</b> and <b>fill</b> for text stroke and fill respectivelly
 *
 * @property {boolean} round_rect - Used with [point geometries]{@link tf.types.GeoJSONGeometryType} to display a rectangle with rounded corners at or near the point coordinates. Mutually exclusive
 * with other <b>point</b> styles. Uses the properties <b>round_rect_width</b>, <b>round_rect_height</b>, <b>round_rect_radius</b>, and the properties related with <b>line</b> 
 * and <b>fill</b>
 *
 * @property {boolean} fill - Used with <b>fill_color</b> and <b>fill_opacity</b> to determine how shapes, circles, texts, and round_rects are filled
 *
 * @property {boolean} line - Used with <b>line_color</b>, <b>line_dash</b>, <b>line_opacity</b>, and <b>line_width</b> to determine how lines in shapes, circles, markers, round_rects,
 * and geometries other than <b>point</b> are drawn
 *
 * @property {number} border_width - In pixels, used with <b>marker<b>
 *
 * @property {number} circle_radius - In pixels, used with <b>circle</b>
 *
 * @property {tf.types.opacity0100} fill_alpha - <b>deprecated</b> Use <b>fill_opacity</b> instead
 *
 * @property {hexColor} fill_color - Used with <b>fill</b>
 *
 * @property {tf.types.opacity0100} fill_opacity - Opacity component for <b>fill_color</b>, used <b>fill</b>
 *
 * @property {tf.types.opacity0100} font_alpha - <b>deprecated</b> Use <b>font_opacity</b> instead
 *
 * @property {hexColor} font_color - Used only in conjunction with both the <b>font</b> property and the <b>marker</b> property
 *
 * @property {tf.types.opacity0100} font_opacity - Opacity component for <b>font_color</b>, used <b>font</b>
 *
 * @property {number} font_height - In pixels, used with <b>font</b> in conjunction with <b>marker</b>
 *
 * @property {string} font - Used with <b>font</b>, may include font size information, except when used in conjunction with <b>marker</b>
 *
 * @property {tf.types.iconAnchor} icon_anchor - Used with <b>icon</b>
 *
 * @property {HTMLElement} icon_img - An HTML img that has been preloaded, used with <b>icon</b>, requires <b>icon_size</b>, and is and mutually exclusive with <b>icon_url</b>
 *
 * @property {tf.types.pixelCoordinates} icon_size - The size of <b>icon_img</b> in pixels, required when using <b>icon_img</b>
 *
 * @property {string} icon_url - The location of an image file used with <b>icon</b> and mutually exclusive with <b>icon_img</b>
 *
 * @property {string} label - Text content used with <b>marker</b> and <b>text</b>
 *
 * @property {tf.types.opacity0100} line_alpha - <b>deprecated</b> Use <b>line_opacity</b> instead
 *
 * @property {string} line_cap - Used with <b>line</b>, one of "butt", "round", or "square", Defaults to "round"
 *
 * @property {hexColor} line_color - Used with <b>line</b>
 *
 * @property {array<number,number>} line_dash - Used with <b>line</b> to create a dashed line style instead of a solid style
 *
 * @property {string} line_join - Used with <b>line</b>, one of "bevel", "round", or "miter", Defaults to "round"
 *
 * @property {tf.types.opacity0100} line_opacity - Opacity component for <b>line_color</b>
 *
 * @property {number} line_width - Used with <b>line</b>
 *
 * @property {tf.types.opacity0100} marker_alpha - <b>deprecated</b> Use <b>marker_opacity</b> instead
 *
 * @property {number} marker_arrowlength - Used with <b>marker</b> to set the length of the callout arrow
 *
 * @property {hexColor} marker_color - The background color of the text bubble, used with <b>marker</b>
 *
 * @property {tf.types.opacity0100} marker_opacity - Opacity component for <b>marker_color</b>
 *
 * @property {tf.types.horizontalPositioning} marker_horpos - Horizontal positioning for <b>marker</b>, defaults to {@link tf.consts.positioningCenter}
 *
 * @property {tf.types.verticalPositioning} marker_verpos - Vertical positioning for <b>marker</b>, defaults to {@link tf.consts.positioningTop}
 *
 * @property {tf.types.opacity01} opacity - Controls the overall opacity of <b>icon</b>, <b>marker</b>, and <b>round_rect</b> styles
 *
 * @property {boolean} rotate_with_map - Used with [point geometries]{@link tf.types.GeoJSONGeometryType}, if set to <b>true</b> rotates the map feature style with the map, defaults to {@link void}
 *
 * @property {number} rotation_rad - Controls the rotational angle of <b>point</b> styles
 *
 * @property {number} round_rect_width - Used with <b>round_rect</b>
 *
 * @property {number} round_rect_height - Used with <b>round_rect</b>
 *
 * @property {number} round_rect_radius - Used with <b>round_rect</b>
 *
 * @property {number} scale - Controls the scale of <b>icon</b>, <b>marker</b>, and <b>round_rect</b> styles, defaults to 1
 *
 * @property {number} shape_radius - Controls the radius of the <b>shape</b> polygon, mutually exclusive with <b>shape_radius1</b> and <b>shape_radius2</b>
 *
 * @property {number} shape_radius1 - Controls the outer radius of the <b>shape</b> star, mutually exclusive with </b>shape_radius</b>, may be used with <b>shape_radius2</b>
 *
 * @property {number} shape_radius2 - Controls the inner radius of the <b>shape</b> star, mutually exclusive with </b>shape_radius</b>, may be used in addition to <b>shape_radius1</b>
 *
 * @property {number} shape_points - Controls the number of points (vertices) of the <b>shape</b> polygon or star
 *
 * @property {boolean} snaptopixel - Used by all <b>point</b> styles, if set <b>true</b> rounds coordinates to the closest pixel, producing crisper results, if <b>false</b> 
 * produces smoother results for animation. Defaults to <b>true</b>
 *
 * @property {number} text_offsetx - Horizontal offset, in pixels, used with <b>text</b>
 *
 * @property {number} text_offsety - Vertical offset, in pixels, used with <b>text</b>
 *
 * @property {string} text_align - HTML Canvas text align, one of 'left', 'right', 'center', 'end', 'start', defaults to 'start'
 *
 * @property {string} text_baseline - HTML Canvas text baseline, one of:  'bottom', 'top', 'middle', 'alphabetic', 'hanging', 'ideographic', defaults to 'alphabetic'
 *
 * @property {number} zindex - Controls the order in which sub styles are rendered, defaults to 0, used by all styles
 *
 * @see [Map Feature Style]{@link tf.map.FeatureStyle}
 * @see [Map Feature Sub Style]{@link tf.map.FeatureSubStyle}
 * @see {@link tf.map.Feature}
 */
/**
 * @public
 * @class
 * @summary Map Feature Sub Style instances describe the visual attributes used to display [Map Features]{@link tf.map.Feature} on the [Map]{@link tf.map.Map}.
 * @param {tf.types.MapFeatureStyleSettings} settings - creation settings
 */
tf.map.FeatureSubStyle = function (settings) {
    var theThis, debug, attrGetters, thisInstanceSettings, APISubStyle;
    /**
     * @public
     * @function
     * @summary - Changes the attributes of this Feature Sub Style instance based on the given settings
     * @param {tf.types.MapFeatureStyleSettings} styleSettings - the given settings
     * @returns {void} - | {@link void} no return value
    */
    this.UpdateAttributesFrom = function (styleSettings) { return updateAttributesFrom(styleSettings); }
    /**
     * @private
     * @function
     * @summary - Returns underlying map engine object associated with this sub style
     * @returns {ol.style} - | the map engine object
    */
    this.GetAPISubStyle = function () { return APISubStyle; }
/**
 * method tf.map.FeatureSubStyle.SetAttribute - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} attrName - parameter description?
 * @param {?} attrVal - parameter description?
*/
    //this.SetAttribute = function (attrName, attrVal) { return setAttribute(attrName, attrVal, false); }
/**
 * method tf.map.FeatureSubStyle.GetAttribute - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} attrName - parameter description?
*/
    //this.GetAttribute = function (attrName) { return getAttribute(attrName); }
    function createStarSubStyle() {
        return new ol.style.RegularShape({
            opacity: thisInstanceSettings.opacity,
            rotation: thisInstanceSettings.rotation_rad,
            //scale: thisInstanceSettings.scale,
            radius1: thisInstanceSettings.font_height,
            radius2: thisInstanceSettings.font_height / 2,
            stroke: new ol.style.Stroke({
                color: tf.js.GetRGBAColor(thisInstanceSettings.border_color, thisInstanceSettings.border_color, thisInstanceSettings.border_opacity),
                width: thisInstanceSettings.border_width
            }),
            fill: new ol.style.Fill({
                color: tf.js.GetRGBAColor(thisInstanceSettings.marker_color, thisInstanceSettings.marker_color, thisInstanceSettings.marker_opacity)
            }),
            points: 5
        });
    }
    function createTextCanvasSubStyle() {
        //var triW = thisInstanceSettings.font_height / 2;
        var options = {
            label: !!thisInstanceSettings.label ? thisInstanceSettings.label : '',
            font_height: thisInstanceSettings.font_height,
            font: thisInstanceSettings.font,
            arrow_length: thisInstanceSettings.marker_arrowlength,
            line_color: thisInstanceSettings.line_color,
            line_opacity: thisInstanceSettings.line_opacity,
            line_width: thisInstanceSettings.line_width,
            font_color: thisInstanceSettings.font_color,
            font_opacity: thisInstanceSettings.font_opacity,
            border_line_color: thisInstanceSettings.border_color,
            border_line_opacity: thisInstanceSettings.border_opacity,
            border_line_width: thisInstanceSettings.border_width,
            fill_color: thisInstanceSettings.marker_color,
            fill_opacity: thisInstanceSettings.marker_opacity,
            horpos: thisInstanceSettings.marker_horpos,
            verpos: thisInstanceSettings.marker_verpos
        };
        var memImage = tf.canvas.CreateMemoryImage({ drawFunction: tf.canvas.DrawTextMarkerImage, drawSettings: options });
        var textImageSubStyle = null;
        try {
            textImageSubStyle = new ol.style.Icon({
                opacity: thisInstanceSettings.opacity,
                rotation: thisInstanceSettings.rotation_rad,
                scale: thisInstanceSettings.scale,
                //src: memImage.image,
                img: memImage.image,
                imgSize: [memImage.image.width, memImage.image.height],
                anchor: memImage.anchor
            });
        }
        catch (e) { textImageSubStyle = null; }
        return textImageSubStyle;
    }
    function createRoundRectSubStyle() {
        var memImage = tf.canvas.CreateMemoryImage({
            canvas: null,
            drawFunction: tf.canvas.DrawRoundRect,
            drawSettings: {
                width: thisInstanceSettings.round_rect_width,
                height: thisInstanceSettings.round_rect_height,
                radius: thisInstanceSettings.round_rect_radius,
                fill: thisInstanceSettings.fill,
                fill_color: tf.js.GetRGBAColor(thisInstanceSettings.fill_color, thisInstanceSettings.fill_color, thisInstanceSettings.fill_opacity),
                line: thisInstanceSettings.line,
                line_color: tf.js.GetRGBAColor(thisInstanceSettings.line_color, thisInstanceSettings.line_color, thisInstanceSettings.line_opacity),
                line_width: thisInstanceSettings.line_width,
                line_dash: thisInstanceSettings.line_dash
            }
        });
        var styleSettings = {
            //src: memImage.image,
            img: memImage.image,
            imgSize: [memImage.image.width, memImage.image.height],
            anchor: thisInstanceSettings.icon_anchor
        };
        //var styleSettings = { src: tf.GetStyles().GetHiddenCanvas(), anchor: thisInstanceSettings.icon_anchor };
        return new ol.style.Icon(completeSubStyleSettings(styleSettings, true, true, false));
    }
    function createStrokeSubStyle() {
        return new ol.style.Stroke({
            color: tf.js.GetRGBAColor(thisInstanceSettings.line_color, thisInstanceSettings.line_color, thisInstanceSettings.line_opacity),
            width: thisInstanceSettings.line_width,
            lineDash: thisInstanceSettings.line_dash,
            lineCap: thisInstanceSettings.line_cap,
            lineJoin: thisInstanceSettings.line_join
        });
    }
    function createFillSubStyle() {
        return new ol.style.Fill({ color: tf.js.GetRGBAColor(thisInstanceSettings.fill_color, thisInstanceSettings.fill_color, thisInstanceSettings.fill_opacity) });
    }
    function completeSubStyleSettings(styleSettings, styleUsesOpacity, styleUsesScale, styleUsesDraw) {
        if (!!styleUsesOpacity) {
            styleSettings.opacity = thisInstanceSettings.opacity;
            styleSettings.snapToPixel = thisInstanceSettings.snaptopixel;
        }
        if (thisInstanceSettings.rotate_with_map) { styleSettings.rotateWithView = true; }
        styleSettings.rotation = thisInstanceSettings.rotation_rad;
        if (!!styleUsesScale) { styleSettings.scale = thisInstanceSettings.scale; }
        if (!!styleUsesDraw) {
            if (thisInstanceSettings.line) { styleSettings.stroke = createStrokeSubStyle() };
            if (thisInstanceSettings.fill) { styleSettings.fill = createFillSubStyle() };
        }
        return styleSettings;
    }
    function createCircleSubStyle() {
        var styleSettings = { radius: thisInstanceSettings.circle_radius };
        return new ol.style.Circle(completeSubStyleSettings(styleSettings, true, false, true));
    }
    function createRegularShapeSubStyle() {
        var styleSettings = { radius: thisInstanceSettings.shape_radius, radius1: thisInstanceSettings.shape_radius1, radius2: thisInstanceSettings.shape_radius2, points: thisInstanceSettings.shape_points };
        return new ol.style.RegularShape(completeSubStyleSettings(styleSettings, true, false, true));
    }
    function createIconSubStyle() {
        var styleSettings = {
            crossOrigin: "",
            src: thisInstanceSettings.icon_url, anchor: thisInstanceSettings.icon_anchor, img: thisInstanceSettings.icon_img, imgSize: thisInstanceSettings.icon_size, offset: thisInstanceSettings.icon_offset
        };
        return new ol.style.Icon(completeSubStyleSettings(styleSettings, true, true, false));
    }
    function createTextSubStyle() {
        var styleSettings = {
            text: !!thisInstanceSettings.label ? thisInstanceSettings.label : '',
            font: thisInstanceSettings.font,
            offsetX: thisInstanceSettings.text_offsetx,
            offsetY: thisInstanceSettings.text_offsety,
            textAlign: thisInstanceSettings.text_align,
            textBaseline: thisInstanceSettings.text_baseline
        };
        return new ol.style.Text(completeSubStyleSettings(styleSettings, false, false, true));
    }
    function createMarkerStyle() {
        var styleSettings = {};
        var label = typeof thisInstanceSettings.label === "string" ? thisInstanceSettings.label : "";
        var labelLen = label.length;
        var hasLabel = labelLen > 0 && (label.charAt(0) != '.');
        //hasLabel = false;
        if (hasLabel) { styleSettings.image = createTextCanvasSubStyle(); } else { styleSettings.image = createStarSubStyle(); }
        return styleSettings;
    }
    function createAPISubStyle() {
        var styleSettings = {};
        if (thisInstanceSettings.marker) {
            styleSettings = createMarkerStyle();
        }
        else if (thisInstanceSettings.icon) {
            styleSettings.image = createIconSubStyle();
        }
        else if (thisInstanceSettings.circle) {
            styleSettings.image = createCircleSubStyle();
        }
        else if (thisInstanceSettings.shape) {
            styleSettings.image = createRegularShapeSubStyle();
        }
        else if (thisInstanceSettings.round_rect) {
            styleSettings.image = createRoundRectSubStyle();
        }
        else if (thisInstanceSettings.text) {
            styleSettings.text = createTextSubStyle();
        }
        else {
            if (thisInstanceSettings.line) { styleSettings.stroke = createStrokeSubStyle() };
            if (thisInstanceSettings.fill) { styleSettings.fill = createFillSubStyle() };
        }
        styleSettings.zIndex = thisInstanceSettings.zindex;
        return new ol.style.Style(styleSettings);
    }
    function get01NumberFromValue0100 (fromValue0100, defaultValue01) {
        return ((fromValue0100 = tf.js.GetFloatNumber(fromValue0100, -1)) == -1) ? defaultValue01 : tf.js.GetFloatNumberInRange(fromValue0100 / 100, 0, 1, defaultValue01);
    }
    function setAttribute(attrName, attrVal, dontUpdateAPISubStyleBool) {
        var didSet = false;
        if (!!attrName && typeof attrName === "string" && attrName.length) {
            var attrGetter = attrGetters[attrName.toLowerCase()];
            if (typeof attrGetter === "function") {
                var newVal = attrGetter(attrVal, thisInstanceSettings[attrName]);
                if (!!debug) {
                    debug.LogIfTest('requested [' + attrName + '] = ' + attrVal);
                    debug.LogIfTest('+assigned [' + attrName + '] = ' + newVal);
                }
                didSet = true;
                thisInstanceSettings[attrName] = newVal;
                if (!dontUpdateAPISubStyleBool) { updateAPISubStyle(); }
            }
        }
        return didSet;
    }
    function getAttribute(attrName) { return thisInstanceSettings[attrName]; }
    function updateAPISubStyle() { APISubStyle = createAPISubStyle(); }
    function updateAttributesFrom(newSettings) {
        var didSet = false;
        if (typeof newSettings === "string") { newSettings = newSettings.length ? tf.js.ParseLegacyFormatString(newSettings) : null; }
        if (!!newSettings && typeof newSettings === "object") {
            for (var attr in newSettings) {
                if (setAttribute(attr, newSettings[attr], true)) { didSet = true; }
            }
            if (didSet) {
                updateAPISubStyle();
            }
        }
        return didSet;
    }
    function getValue01(value, defaultValue) { return tf.js.GetFloatNumberInRange(value, 0, 1, defaultValue); }
    function getAlpha(value, defaultValue) {
        return get01NumberFromValue0100(value, defaultValue);
    }
    function getColor(value, defaultValue) { return tf.js.GetHexColorStr(value, defaultValue); }
    function getTwoElementNumberArray(value, defaultValue) {
        var returnValue = defaultValue;
        if (!!value) {
            if (typeof value === "string") {
                var values = value.split(',');
                var nValues = values.length;
                if (nValues == 2) {
                    for (var i in values) {
                        var defaultV = !!defaultValue ? defaultValue[i] : undefined;
                        values[i] = tf.js.GetFloatNumber(values[i], defaultV);
                    }
                    returnValue = values;
                }
            }
            else if (typeof value === "object" && value.length == 2) {
                for (var i in value) {
                    var defaultV = !!defaultValue ? defaultValue[i] : undefined;
                    value[i] = tf.js.GetFloatNumber(value[i], defaultV);
                }
                returnValue = value;
            }
        }
        return returnValue;
    }
    function getRadius(value, defaultValue) { return value === undefined || value == null ? undefined : Math.abs(tf.js.GetFloatNumber(value, defaultValue)); }
    function getStringOrUndefined(value, defaultValue) { return !!value ? tf.js.GetNonEmptyString(value, defaultValue) : undefined; }
    function getImgObject(value, defaultValue) { if (!(value = tf.dom.GetHTMLElementFrom((value)))) { value = defaultValue; } return value; }
    function get_border_opacity(value, defaultValue) { return getAlpha(value, defaultValue); }
    function get_border_color(value, defaultValue) { return getColor(value, defaultValue) }
    function get_border_width(value, defaultValue) { return tf.js.GetNonNegativeIntFrom(value, defaultValue); }
    function get_circle(value, defaultValue) { return tf.js.GetBoolFromValue(value, defaultValue); }
    function get_circle_radius(value, defaultValue) { return getRadius(value, defaultValue); }
    function get_fill(value, defaultValue) { return tf.js.GetBoolFromValue(value, defaultValue); }
    function get_fill_opacity(value, defaultValue) { return getAlpha(value, defaultValue); }
    function get_fill_color(value, defaultValue) { return getColor(value, defaultValue); }
    function get_font_opacity(value, defaultValue) { return getAlpha(value, defaultValue); }
    function get_font_color(value, defaultValue) { return getColor(value, defaultValue); }
    function get_font_height(value, defaultValue) { return tf.js.GetIntNumberInRange(value, 8, 120, defaultValue); }
    function get_font(value, defaultValue) { return tf.js.GetNonEmptyString(value, defaultValue); }
    function get_icon(value, defaultValue) { return tf.js.GetBoolFromValue(value, defaultValue); }
    function get_icon_anchor(value, defaultValue) { return getTwoElementNumberArray(value, defaultValue); }
    function get_icon_offset(value, defaultValue) { return getTwoElementNumberArray(value, defaultValue); }
    function get_icon_size(value, defaultValue) { return getTwoElementNumberArray(value, defaultValue); }
    function get_icon_img(value, defaultValue) { return getImgObject(value, defaultValue); }
    function get_icon_url(value, defaultValue) { return tf.js.GetNonEmptyString(value, defaultValue); }
    function get_label(value, defaultValue) { return tf.js.GetNonEmptyString(value, defaultValue); }
    function get_line_cap(value, defaultValue) { return tf.js.GetNonEmptyString(value, defaultValue); }
    function get_line_join(value, defaultValue) { return tf.js.GetNonEmptyString(value, defaultValue); }
    function get_line(value, defaultValue) { return tf.js.GetBoolFromValue(value, defaultValue); }
    function get_line_opacity(value, defaultValue) { return getAlpha(value, defaultValue); }
    function get_line_color(value, defaultValue) { return getColor(value, defaultValue); }
    //function get_line_dash(value, defaultValue) { return getTwoElementNumberArray(value, defaultValue); }
    function get_line_dash(value, defaultValue) { return value == undefined ? defaultValue : value; }
    //function get_line_width(value, defaultValue) { return tf.js.GetNonNegativeIntFrom(value, defaultValue); }
    function get_line_width(value, defaultValue) { return tf.js.GetFloatNumber(value, defaultValue); }
    function get_marker(value, defaultValue) { return tf.js.GetBoolFromValue(value, defaultValue); }
    function get_marker_opacity(value, defaultValue) { return getAlpha(value, defaultValue); }
    function get_marker_arrowlength(value, defaultValue) { return tf.js.GetFloatNumber(value, defaultValue); }
    function get_marker_color(value, defaultValue) { return getColor(value, defaultValue); }
    function get_opacity(value, defaultValue) { return getValue01(value, defaultValue); }
    function get_rotate_with_view(value, defaultValue) { return tf.js.GetBoolFromValue(value, defaultValue); }
    function get_rotation_rad(value, defaultValue) { return tf.js.GetFloatNumber(value, defaultValue); }
    function get_scale(value, defaultValue) { return value !== undefined ? tf.js.GetFloatNumber(value, defaultValue) : value; }
    function get_shape(value, defaultValue) { return tf.js.GetBoolFromValue(value, defaultValue); }
    function get_shape_radius(value, defaultValue) { return getRadius(value, defaultValue); }
    function get_shape_radius1(value, defaultValue) { return getRadius(value, defaultValue); }
    function get_shape_radius2(value, defaultValue) { return getRadius(value, defaultValue); }
    function get_shape_points(value, defaultValue) { return tf.js.GetNonNegativeIntFrom(value, defaultValue); }
    function get_snaptopixel(value, defaultValue) { return tf.js.GetBoolFromValue(value, defaultValue); }
    function get_round_rect(value, defaultValue) { return tf.js.GetBoolFromValue(value, defaultValue); }
    function get_round_rect_width(value, defaultValue) { return tf.js.GetFloatNumber(value, defaultValue); }
    function get_round_rect_height(value, defaultValue) { return tf.js.GetFloatNumber(value, defaultValue); }
    function get_round_rect_radius(value, defaultValue) { return tf.js.GetFloatNumber(value, defaultValue); }
    function get_text(value, defaultValue) { return tf.js.GetBoolFromValue(value, defaultValue); }
    function get_marker_horpos(value, defaultValue) { return getStringOrUndefined(value, defaultValue); }
    function get_marker_verpos(value, defaultValue) { return getStringOrUndefined(value, defaultValue); }
    function get_text_align(value, defaultValue) { return getStringOrUndefined(value, defaultValue); }
    function get_text_baseline(value, defaultValue) { return getStringOrUndefined(value, defaultValue); }
    function get_text_offsetx(value, defaultValue) { return tf.js.GetFloatNumber(value, defaultValue); }
    function get_text_offsety(value, defaultValue) { return tf.js.GetFloatNumber(value, defaultValue); }
    function get_zindex(value, defaultValue) { return tf.js.GetNonNegativeIntFrom(value, defaultValue); }
    function initialize() {
        //debug = tf.GetDebug();
        var subStyles = tf.GetStyles().GetSubStyles();
        settings = tf.js.GetValidObjectFrom(settings);
        attrGetters = {
            border_alpha: get_border_opacity,
            border_color: get_border_color,
            border_opacity: get_border_opacity,
            border_width: get_border_width,
            circle: get_circle,
            circle_radius: get_circle_radius,
            fill: get_fill,
            fill_alpha: get_fill_opacity,
            fill_color: get_fill_color,
            fill_opacity: get_fill_opacity,
            font_alpha: get_font_opacity,
            font_color: get_font_color,
            font_opacity: get_font_opacity,
            font_height: get_font_height,
            font: get_font,
            icon: get_icon,
            icon_anchor: get_icon_anchor,
            icon_offset: get_icon_offset,
            icon_img: get_icon_img,
            icon_size: get_icon_size,
            icon_url: get_icon_url,
            label: get_label,
            marker: get_marker,
            marker_alpha: get_marker_opacity,
            marker_arrowlength: get_marker_arrowlength,
            marker_color: get_marker_color,
            marker_opacity: get_marker_opacity,
            marker_horpos: get_marker_horpos,
            marker_verpos: get_marker_verpos,
            opacity: get_opacity,
            line: get_line,
            line_alpha: get_line_opacity,
            line_cap: get_line_cap,
            line_color: get_line_color,
            line_dash: get_line_dash,
            line_join: get_line_join,
            line_opacity: get_line_opacity,
            line_width: get_line_width,
            rotate_with_map: get_rotate_with_view,
            rotation_rad: get_rotation_rad,
            round_rect: get_round_rect,
            round_rect_width: get_round_rect_width,
            round_rect_height: get_round_rect_height,
            round_rect_radius: get_round_rect_radius,
            scale: get_scale,
            shape: get_shape,
            shape_radius: get_shape_radius,
            shape_radius1: get_shape_radius1,
            shape_radius2: get_shape_radius2,
            shape_points: get_shape_points,
            snaptopixel: get_snaptopixel,
            text: get_text,
            text_align: get_text_align,
            text_baseline: get_text_baseline,
            text_offsetx: get_text_offsety,
            text_offsety: get_text_offsety,
            zindex: get_zindex
        };
        var defaultMapFeatureStyleSettings = {
            border_opacity: 1,
            border_color: "#000",
            border_width: 2,
            circle: false,
            circle_radius: 20,
            fill: false,
            fill_opacity: 1,
            fill_color: "#fff",
            font_opacity: 1,
            font_color: subStyles.darkTextColor,
            font_height: subStyles.markerFontSizePXNumber,
            font: subStyles.markerFontFamily,
            icon: false,
            icon_anchor: [0.5, 0.5],
            icon_img: undefined,
            icon_offset: [0, 0],
            icon_url: undefined,
            icon_size: undefined,
            label: '',
            line: false,
            line_opacity: 1,
            line_cap: "round",
            line_join: "round",
            line_color: "#000",
            line_dash: [20, 0],
            line_width: 1,
            marker: false,
            marker_opacity: 1,
            marker_arrowlength: 12,
            marker_color: "#3399FF",
            marker_horpos : tf.consts.positioningCenter,
            marker_verpos : tf.consts.positioningTop,
            opacity: 1,
            rotate_with_map: false,
            rotation_rad: 0,
            round_rect: false,
            round_rect_width: 10,
            round_rect_height: 10,
            round_rect_radius: 0,
            scale: 1.0,
            shape: false,
            shape_radius: undefined,
            shape_radius1: undefined,
            shape_radius2: undefined,
            shape_points: 4,
            snaptopixel: true,
            text: false,
            text_offsetx: 0,
            text_offsety: 0,
            text_align: undefined,
            text_baseline: undefined,
            zindex: 1
        };
        thisInstanceSettings = tf.js.ShallowMerge(defaultMapFeatureStyleSettings);
        updateAttributesFrom(settings);
        updateAPISubStyle();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * @public
 * @class
 * @summary Map Feature Style instances contain one or more [Map Feature Sub Style]{@link tf.map.FeatureSubStyle} instances
 * that together describe the visual attributes used to display [Map Features]{@link tf.map.Feature} on the [Map]{@link tf.map.Map}.
 * @param {tf.types.MapFeatureStyleSettings|array<tf.types.MapFeatureStyleSettings>} settings - creation settings, use a single 
 * settings object to create a single SubStyle, or an {@link array} of settings objects, one for each SubStyle to be created
 */
tf.map.FeatureStyle = function (settings) {
    var theThis, debug, APIStyle, subStyles;
    /**
     * @public
     * @function
     * @summary - Retrieves the number of [Feature Sub Style]{@link tf.map.FeatureSubStyle} instances associated with this Feature Style instance
     * @returns {number} - | {@link number} the number of instances
    */
    this.GetCount = function () { return !!subStyles ? subStyles.length : 0; }
    /**
     * @public
     * @function
     * @summary - Retrieves a [Feature Sub Style]{@link tf.map.FeatureSubStyle} instance associated with this Feature Style instance by the given index
     * @param {number} index - the given index
     * @returns {tf.map.FeatureSubStyle} - | {@link tf.map.FeatureSubStyle} the instance, or {@link void} if <b>index</b> is invalid
    */
    this.Get = function (index) { return index >= 0 && index < theThis.GetCount() ?  subStyles[index] : null; }
    /**
     * @public
     * @function
     * @summary - Changes the attributes of all [Feature Sub Style]{@link tf.map.FeatureSubStyle} instances of this Feature Style instance based on the given settings
     * @param {tf.types.MapFeatureStyleSettings} styleSettings - the given settings
     * @returns {void} - | {@link void} no return value
    */
    this.UpdateAttributesFrom = function (styleSettings) { return updateAttributesFrom(styleSettings); }
    /**
     * @private
     * @function
     * @summary - Returns underlying map engine object associated with this sub style
     * @returns {ol.style} - | the map engine object
    */
    this.getAPIStyle = function () { return APIStyle; }
/**
 * method tf.map.FeatureStyle.GetSubStyles - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
*/
    //this.GetSubStyles = function () { return subStyles; }
/**
 * method tf.map.FeatureStyle.SetAttribute - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} attrName - parameter description?
 * @param {?} attrVal - parameter description?
*/
    //this.SetAttribute = function (attrName, attrVal) { return subStyles[0].SetAttribute(attrName, attrVal, false); }
/**
 * method tf.map.FeatureStyle.GetAttribute - ?
 * @private
 * @function
 * @summary - method summary?
 * @description - method description?
 * @returns {?} - method returns?
 * @param {?} attrName - parameter description?
*/
    //this.GetAttribute = function (attrName) { return subStyles[0].GetAttribute(attrName); }
    function updateAttributesFrom(newSettings) {
        var updated = false;
        if (!!newSettings) {
            if (tf.js.GetIsNonEmptyArray(newSettings)) {
                var maxIndex = subStyles.length < newSettings.length ? subStyles.length : newSettings.length;
                for (var index = 0 ; index < maxIndex ; index++) {
                    if (subStyles[index].UpdateAttributesFrom(newSettings[i])) {
                        updated = true;
                    }
                }
            }
            else {
                updated = subStyles[0].UpdateAttributesFrom(newSettings);
            }
        }
        if (updated) { updateAPIStyle(); }
        return updated;
    }
    function createAPIStyle() { var apiStyle = []; for (var subStyle in subStyles) { apiStyle.push(subStyles[subStyle].GetAPISubStyle()); } return apiStyle; }
    function updateAPIStyle() { APIStyle = createAPIStyle(); }
    function getMapFeatureSubStyleFrom(theStyle) {
        return theStyle instanceof tf.map.FeatureSubStyle ? theStyle : new tf.map.FeatureSubStyle(theStyle) ;
    }
    function initialize() {
        subStyles = [];
        if (tf.js.GetIsNonEmptyArray(settings)) {
            var nStyles = settings.length;
            subStyles.push(getMapFeatureSubStyleFrom(settings[0]));
            for (var i = 1 ; i < nStyles ; i++) {
                subStyles.push(getMapFeatureSubStyleFrom(settings[i]));
            }
        }
        if (!subStyles.length) { subStyles.push(getMapFeatureSubStyleFrom(settings)); }
        updateAPIStyle();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: mapfeaturegeom.js
/*tf.js.SetLegacyCoordsTo = function (coords) {
    if (tf.js.GetIsArrayWithLength(coords, 2)) {
        coords.lon = coords.Lon = coords.Longitude = coords.longitude = coords[0];
        coords.lat = coords.Lat = coords.Latitude = coords.latitude = coords[1];
    }
}*/
/**
 * @public
 * @class
 * @summary Map Feature Geometries support [GeoJSON Geometries]{@link tf.types.GeoJSONGeometry} and can be shared among different [Map Features]{@link tf.map.Feature}
 * @param {tf.types.GeoJSONGeometry} settings - creation settings
 */
tf.map.FeatureGeom = function (settings) {
    var theThis, coordinates, geomCreateFunction, type, isPoint, APIGeom, simplifyTolerance;
    /**
     * @public
     * @function
     * @summary - Retrieves the type of this geometry instance
     * @returns {tf.types.GeoJSONGeometryType} - | {@link tf.types.GeoJSONGeometryType} the type
    */
    this.GetType = function () { return type; }
    /**
     * @public
     * @function
     * @summary - Checks if the type this geometry instance is "point"
     * @returns {boolean} - | {@link boolean} <b>true</b> if the geometry type is "point", <b>false</b> otherwise
    */
    this.GetIsPoint = function () { return isPoint; }
    /**
     * @public
     * @function
     * @summary - Changes the map coordinates of a "point" geometry
     * @param {tf.types.mapCoordinates} pointCoords - the coordinates
     * @returns {void} - | {@link void} no return value
    */
    this.SetPointCoords = function (pointCoords) {
        if (isPoint) {
            var coordsUse = tf.js.GetMapCoordsFrom(pointCoords);
            coordinates[0] = coordsUse[0]; coordinates[1] = coordsUse[1]; /*tf.js.SetLegacyCoordsTo(coordinates);*/ updateGeom(); return true;
        } return false;
    }
    /**
     * @public
     * @function
     * @summary - Retrieves the current coordinates of a "point" geometry
     * @returns {tf.types.mapCoordinates} - | {@link tf.types.mapCoordinates} the coordinates
    */
    this.GetPointCoords = function () { return isPoint ? coordinates : [0,0]; }
    this.GetCoordinates = function () { return coordinates; }
    /**
     * @public
     * @function
     * @summary - Retrieves the map extent of this geometry instance
     * @returns {tf.types.mapExtent} - | {@link tf.types.mapExtent} the extent
    */
    this.GetExtent = function () { return getExtent(); }
    this.GetClosestPoint = function (pointCoords) { return getClosestPoint(pointCoords); }
    this.GetLength = function () { return getLength(); }
    this.GetArea = function () { return getArea(); }
    this.GetContainsCoords = function (coords) {
        return type == 'polygon' ? APIGeom.intersectsCoordinate(tf.units.TM2OL(coords)) : false;
    }
    /**
     * @private
     * @function
     * @summary - Returns underlying map engine object associated with this geometry
     * @returns {ol.geom} - | the map engine object
    */
    this.getAPIGeom = function () { return APIGeom; }
    function getLength() {
        var length = 0;
        if (!theThis.GetIsPoint()) {
            var coords = type == 'polygon' ? coordinates[0] : coordinates;
            length = tf.units.GetTotalHaversineDistanceInMeters(coords);
        }
        return length;
    }
    function getArea() {
        var area = 0;
        if (!theThis.GetIsPoint()) {
            var isClosed = type == 'polygon';
            var coords = isClosed ? coordinates[0] : coordinates;
            area = tf.js.CalcPolyAreaInSquareMeters(coords, isClosed);
            //console.log('area ' + area);
            //console.log('area2 ' + APIGeom.getArea());
        }
        return area;
    }
    function getClosestPoint(pointCoords) {
        var closestPoint;
        if (!!APIGeom && tf.js.GetIsArrayWithMinLength(pointCoords, 2)) {
            closestPoint = pointCoords.slice(0);
            closestPoint = tf.units.TM2OL(closestPoint);
            if (!!(closestPoint = APIGeom.getClosestPoint(closestPoint))) {
                closestPoint = tf.units.OL2TM(closestPoint);
            }
        }
        return closestPoint;
    }
    function getExtent() {
        var extent = [0,0,0,0];
        if (!!APIGeom) { extent = ol.extent.applyTransform(APIGeom.getExtent(), ol.proj.getTransform(tf.consts.olSystem, tf.consts.tmSystem)); }
        return extent;
    }
    function createPointGeom() { isPoint = true; return new ol.geom.Point(coordinates); }
    function createPolygonGeom() { return new ol.geom.Polygon(coordinates); }
    function createMultiLineStringGeom() { return new ol.geom.MultiLineString(coordinates); }
    function createLineStringGeom() { return new ol.geom.LineString(coordinates); }
    function createMultiPointGeom() { return new ol.geom.MultiPoint(coordinates); }
    function createMultiPolygonGeom() { return new ol.geom.MultiPolygon(coordinates); }
    function updateGeom() {
        APIGeom = null;
        if (!!(APIGeom = geomCreateFunction())) {
            APIGeom.transform(tf.consts.tmSystem, tf.consts.olSystem);
            if (simplifyTolerance !== undefined) { APIGeom = APIGeom.simplify(simplifyTolerance); }
        }
    }
    function initialize() {
        var geomCreateFunctions = {
            point: createPointGeom,
            polygon: createPolygonGeom,
            linestring: createLineStringGeom,
            multilinestring: createMultiLineStringGeom,
            multipoint: createMultiPointGeom,
            multipolygon: createMultiPolygonGeom
        };
        if (!tf.js.GetIsValidObject(settings)) { settings = { type: "point", coordinates: [0, 0] }; }
        type = settings.type;
        if (!tf.js.GetIsNonEmptyString(type) || geomCreateFunctions[type = type.toLowerCase()] === undefined || !tf.js.GetIsNonEmptyArray(settings.coordinates)) {
            type = "point"; settings.coordinates = [0, 0];
        }
        //if (type == 'multilinestring') { console.log('creating multilinestring'); }
        geomCreateFunction = geomCreateFunctions[type];
        if (isPoint = (type === "point")) { coordinates = tf.js.GetIsArrayWithMinLength(settings.coordinates, 2) ? settings.coordinates.slice(0) : [0,0]; }
        else { coordinates = settings.coordinates.slice(0); }
        simplifyTolerance = settings.simplifyTolerance;
        if (tf.js.GetIsNonEmptyArray(coordinates)) { updateGeom(); }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: postrender.js
/**
 * A callback function that renders animations during [Map]{@link tf.map.Map} [Post Compose]{@link tf.consts.mapPostComposeEvent} events
 * @public
 * @callback tf.types.PostComposeAnimatorCallBack
 * @param {tf.map.Map} map - Map instance where animation will take place
 * @param {tf.types.MapShowFeatureImmediately} mapShowFeatureImmediately - A callback used to display map features
 * @param {number} elapsed01 - A number between <b>0</b> and <b>1</b> equal to the ratio (animation elapsed time) / (animation duration)
 * @returns {void} - | {@link void} no return value
 */
/**
 * @public
 * @class
 * @summary - Post Compose Animator instances automatically manage listening to [Post Compose]{@link tf.consts.mapPostComposeEvent} events
 * on the given [Map]{@link tf.map.Map} instance, and for the given duration of time call the given callback to perform an animation
 * @param {object} settings - creation settings
 * @param {tf.map.Map} settings.map - Map instance where animation will take place
 * @param {tf.types.PostComposeAnimatorCallBack} settings.animationFunction - callback that renders the animation
 * @param {number} settings.duration - the duration of the animation in  milliseconds
*/
tf.map.PostComposeAnimator = function (settings) {
    var theThis, listener, startTime, theMap, duration, animationFunction;
    /**
     * @public
     * @function
     * @summary - Starts the animation
     * @returns {void} - | {@link void} no return value
    */
    this.Start = function () { if (startTime === undefined) { if (!!theMap) { startTime = new Date().getTime(); renderMap(); } } }
    /**
     * @public
     * @function
     * @summary - Stops the animation, if it is ongoing
     * @returns {void} - | {@link void} no return value
    */
    this.Stop = function () { return stop(); }
    /**
     * @public
     * @function
     * @summary - Determines if the animation is ongoing
     * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
    */
    this.IsAnimating = function () { return startTime !== undefined && !listener; }
    function renderMap() { theMap.Render(); }
    function stop() { if (!!listener) { listener.OnDelete(); listener = null; setTimeout(renderMap, 10); } }
    function animate(notification) {
        if (startTime !== undefined) {
            var elapsed = new Date().getTime() - startTime;
            if (elapsed > duration) { stop(); }
            else {
                animationFunction(notification.sender, notification.showFeatureImmediately, tf.js.GetFloatNumberInRange(elapsed / duration, 0, 1, 1));
                notification.continueAnimation();
            }
        }
    }
    function initialize() {
        theMap = tf.js.GetMapFrom(settings.map);
        if (tf.js.GetIsMap(theMap) &&
            (!!(animationFunction = tf.js.GetFunctionOrNull(settings.animationFunction)))) {
            duration = tf.js.GetFloatNumberInRange(settings.duration, 1000, 10000, 100);
            listener = theMap.AddListener(tf.consts.mapPostComposeEvent, animate);
        } else { theMap = null; animationFunction = null; }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * A callback function that produces a [Feature Style Settings]{@link tf.types.MapFeatureStyleSettings} object
 * for the given animation elapsed time ratio. Used by [Geometries Style Animator]{@link tf.map.GeometriesStyleAnimator}
 * @public
 * @callback tf.types.GeometriesStyleAnimatorCallBack
 * @param {number} elapsed01 - A number between <b>0</b> and <b>1</b> equal to the ratio (animation elapsed time) / (animation duration)
 * @returns {tf.types.MapFeatureStyleSettings} - | {@link tf.types.MapFeatureStyleSettings} the style settings to be used at <b>elapsed01</b>
 */
/**
 * @public
 * @class
 * @summary - Geometries Style Animator instances repeatedly refresh the style of one or more given geometries, 
 * using the given style generator callback and for the given time duration, to display style animations on 
 * the on the given [Map]{@link tf.map.Map} instance
 * @param {object} settings - creation settings
 * @param {tf.map.Map} settings.map - Map instance where animation will take place
 * @param {tf.types.GeometriesStyleAnimatorCallBack} settings.getStyle - callback that produces style settings
 * @param {number} settings.duration - the duration of the animation in  milliseconds
*/
tf.map.GeometriesStyleAnimator = function (settings) {
    var theThis, geometries, getStyleMethod, animator;
    /**
     * @public
     * @function
     * @summary - Starts the animation
     * @returns {void} - | {@link void} no return value
    */
    this.Start = function () { if (!!animator) { animator.Start(); } }
    /**
     * @public
     * @function
     * @summary - Stops the animation, if it is ongoing
     * @returns {void} - | {@link void} no return value
    */
    this.Stop = function () { if (!!animator) { animator.Stop(); } }
    /**
     * @public
     * @function
     * @summary - Determines if the animation is ongoing
     * @returns {boolean} - | {@link boolean} <b>true</b> if yes, <b>false</b> otherwise
    */
    this.IsAnimating = function () { return !!animator ? animator.IsAnimating() : false; }
    function getDefaultStyle(elapsed01) {
        var radius = 4 + Math.pow(elapsed01, 1 / 2) * 16;
        var opacity = 1 - Math.pow(elapsed01, 3);
        var line_width = (2 - elapsed01);
        var defaultStyle = {
            circle: true,
            circle_radius: radius,
            snapToPixel: false,
            line: true,
            line_width: line_width,
            line_color: tf.js.GetRandomHexColorStr(),//"#f00",
            line_alpha: opacity * 100
        };
        return defaultStyle;
    }
    function animate(theMap, showFeatureImmediately, elapsed01) {
        var animatedStyle = getStyleMethod(elapsed01);
        for (var i in geometries) {
            var geom = geometries[i];
            var animatedFeature = new tf.map.Feature({ geom: geom, style: animatedStyle });
            showFeatureImmediately(animatedFeature);
        }
    }
    function initialize() {
        if (!(getStyleMethod = tf.js.GetFunctionOrNull(settings.getStyle))) { getStyleMethod = getDefaultStyle; }
        if (!!(geometries = settings.geometries) && (typeof geometries === "object")) {
            animator = new tf.map.PostComposeAnimator({ map: settings.map, duration: settings.duration, animationFunction: animate });
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
/**
 * @public
 * @class
 * @summary - Points Style Animator instances repeatedly display an arbitrary number of [Point Geometries]{@link tf.types.GeoJSONGeometryType} 
 * obtained from the given providers on the given [Maps]{@link tf.map.Map}, using styles obtained from the given style generator callback,
 * producing an animation with the given duration
 * @param {object} settings - creation settings
 * @param {enumerable<tf.map.Map>} settings.maps - an arbitrary number of Map instances where animation will take place
 * @param {enumerable<object>} settings.pointProviders - an arbitrary number of objects, each containing a function named <b>GetPointCoords</b> returning
 * [Map Coordinates]{@link tf.types.mapCoordinates}
 * @param {tf.types.GeometriesStyleAnimatorCallBack} settings.getStyle - callback that produces style settings
 * @param {number} settings.duration - the duration of the animation in  milliseconds
*/
tf.map.PointsStyleAnimator = function (settings) {
    var theThis;
    /**
     * @private
     * @function
     * @summary - Retrieves the single [Map Feature Geometry]{@link tf.map.FeatureGeom} instance containing all map coordinates whose style is being animated
     * @returns {tf.map.FeatureGeom} - | {@link tf.map.FeatureGeom} the instance
    */
    //this.GetPointListGeometry = function () { return pointListGeometry; }
    function createGeometry(pointProviders) {
        var coordinates = [];
        var pointListGeometry;
        for (var i in pointProviders) {
            var pp = pointProviders[i];
            if (tf.js.GetIsValidObject(pp)) {
                var coords;
                if (tf.js.GetFunctionOrNull(pp.GetPointCoords)) {
                    coords = pp.GetPointCoords();
                }
                else if (tf.js.GetIsArrayWithMinLength(pp, 2)) {
                    coords = pp;
                }
                if (!!coords) { coordinates.push(coords); }
            }
        }
        if (!!coordinates.length) { pointListGeometry = new tf.map.FeatureGeom({ type: "multipoint", coordinates: coordinates }); }
        return pointListGeometry;
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        var settingsMaps = settings.maps;
        var pointProviders = settings.pointProviders;
        if (tf.js.GetIsValidObject(settingsMaps) && tf.js.GetIsValidObject(pointProviders)) {
            var pointListGeometry = createGeometry(pointProviders);
            if (!!pointListGeometry) {
                var animators = [];
                for (var i in settingsMaps) {
                    var map = tf.js.GetMapFrom(settingsMaps[i]);
                    if (!!map) {
                        animators.push(new tf.map.GeometriesStyleAnimator({ map: map, geometries: [pointListGeometry], getStyle: settings.getStyle, duration: settings.duration }));
                    }
                }
                if (animators.length > 0) { for (var i in animators) { animators[i].Start(); } }
            }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: vector3.js
tf.math.Vector3 = function (settings) {
    var theThis;
    this.length = function() { return 3; }
    this.Update = function (x, y, z) { return update(x, y, z); }
    this.GetSettings = function () { return { x: theThis[0], y: theThis[1], z: theThis[2] }; }
    this.GetAsJSArray = function () { return [x, y, z]; }
    this.GetAsFloat32Array = function () { return new Float32Array(theThis.GetAsJSArray()); }
    this.CopyFrom = function (otherVector3) {
        /*if (otherVector3 instanceof tf.math.Vector3) {*/ theThis[0] = otherVector3[0]; theThis[1] = otherVector3[1]; theThis[2] = otherVector3[2]; /*}*/
        if (!!otherVector3) { theThis[0] = otherVector3[0]; theThis[1] = otherVector3[1]; theThis[2] = otherVector3[2]; }
        return theThis;
    }
    this.CopyTo = function (otherVector3) {
        if (!!otherVector3){ otherVector3[0] = theThis[0]; otherVector3[1] = theThis[1]; otherVector3[2] = theThis[2]; }
        ///*if (otherVector3 instanceof tf.math.Vector3) {*/ otherVector3[0] = theThis[0]; otherVector3[1] = theThis[1]; otherVector3[2] = theThis[2]; /*}*/
        //return theThis;
        return otherVector3;
    }
    this.GetMagnitude = function () { return theThis[0] * theThis[0] + theThis[1] * theThis[1] + theThis[2] * theThis[2]; }
    this.GetLength = function () { return Math.sqrt(theThis.GetMagnitude()); }
    this.Normalize = function () { var mag = theThis.GetMagnitude(); if (mag != 0 && mag != 1) { theThis.MultByScalar(1 / Math.sqrt(mag)); } return theThis; }
    this.MultByScalar = function (scalar) { if (typeof scalar == 'number' && scalar != 1) { theThis[0] *= scalar; theThis[1] *= scalar; theThis[2] *= scalar; } return theThis; }
    this.MultByMatrix = function (matrix) {
        if (!!matrix){
            var x = theThis[0], y = theThis[1], z = theThis[2], m = matrix.getMatrix();
            var w = m.m44 + x * m.m14 + y * m.m24 + z * m.m34;
            theThis[0] = m.m41 + x * m.m11 + y * m.m21 + z * m.m31;
            theThis[1] = m.m42 + x * m.m12 + y * m.m22 + z * m.m32;
            theThis[2] = m.m43 + x * m.m13 + y * m.m23 + z * m.m33;
            if (w != 1 && w != 0) { w = 1 / w; theThis[0] *= w; theThis[1] *= w; theThis[2] *= w; }
        }
        return theThis;
    }
    this.MultDirectionByMatrix = function (matrix) {
        if (!!matrix) {
            var x = theThis[0], y = theThis[1], z = theThis[2], m = matrix.getMatrix();
            theThis[0] = x * m.m11 + y * m.m21 + z * m.m31;
            theThis[1] = x * m.m12 + y * m.m22 + z * m.m32;
            theThis[2] = x * m.m13 + y * m.m23 + z * m.m33;
        }
        return theThis;
    }
    this.Dot = function (otherVector3) {
        //return otherVector3 instanceof tf.math.Vector3 ? theThis[0] * otherVector3[0] + theThis[1] * otherVector3[1] + theThis[2] * otherVector3[2] : 0;
        return !!otherVector3 ? theThis[0] * otherVector3[0] + theThis[1] * otherVector3[1] + theThis[2] * otherVector3[2] : 0;
        //return theThis[0] * otherVector3[0] + theThis[1] * otherVector3[1] + theThis[2] * otherVector3[2];
    }
    this.Cross = function (otherVector3) {
        //if (otherVector3 instanceof tf.math.Vector3) {
            var x = theThis[1] * otherVector3[2] - theThis[2] * otherVector3[1];
            var y = -theThis[0] * otherVector3[2] + theThis[2] * otherVector3[0];
            theThis[2] = theThis[0] * otherVector3[1] - theThis[1] * otherVector3[0];
            theThis[0] = x; theThis[1] = y;
        //}
        return theThis;
    }
    this.CrossRight = function (otherVector3) {
        //if (otherVector3 instanceof tf.math.Vector3) {
        var x = otherVector3[1] * theThis[2] - otherVector3[2] * theThis[1];
        var y = -otherVector3[0] * theThis[2] + otherVector3[2] * theThis[0];
        theThis[2] = otherVector3[0] * theThis[1] - otherVector3[1] * theThis[0];
        theThis[0] = x; theThis[1] = y;
        //}
        return theThis;
    }
    this.Add = function (otherVector3) { if (!!otherVector3/*otherVector3 instanceof tf.math.Vector3*/) { theThis[0] += otherVector3[0]; theThis[1] += otherVector3[1]; theThis[2] += otherVector3[2]; } return theThis; }
    this.Sub = function (otherVector3) { if (!!otherVector3/*otherVector3 instanceof tf.math.Vector3*/) { theThis[0] -= otherVector3[0]; theThis[1] -= otherVector3[1]; theThis[2] -= otherVector3[2]; } return theThis; }
    function update(xSet, ySet, zSet) {
        if (tf.js.GetIsValidObject(xSet)) {
            if (tf.js.GetIsArrayWithMinLength(xSet, 3)) { zSet = xSet[2]; ySet = xSet[1], xSet = xSet[0]; }
            else { zSet = xSet.z; ySet = xSet.y; xSet = xSet.x; }
        }
        theThis[0] = tf.js.GetFloatNumber(xSet, 0);
        theThis[1] = tf.js.GetFloatNumber(ySet, 0);
        theThis[2] = tf.js.GetFloatNumber(zSet, 0);
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (!!settings.vector/*settings.vector instanceof tf.math.Vector3*/) { theThis.CopyFrom(settings.vector); }
        else { update(settings); }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: matrix4.js
tf.math.GetDeterminant2x2 = function(a, b, c, d) { return a * d - b * c; }
tf.math.GetDeterminant3x3 = function (a1, a2, a3, b1, b2, b3, c1, c2, c3) {
    return a1 * tf.math.GetDeterminant2x2(b2, b3, c2, c3) - b1 * tf.math.GetDeterminant2x2(a2, a3, c2, c3) + c1 * tf.math.GetDeterminant2x2(a2, a3, b2, b3);
}
tf.math.GetDeterminant4x4 = function (a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4) {
    return a1 * tf.math.GetDeterminant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4) - b1 * tf.math.GetDeterminant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4) +
        c1 * tf.math.GetDeterminant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4) - d1 * tf.math.GetDeterminant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);
}
tf.math.GetCSSMatrixInfo = function () {
    if (tf.math.hasCSSMatrix == undefined) {
        if (tf.math.hasCSSMatrix = ("WebKitCSSMatrix" in window && ("media" in window && window.media.matchMedium("(-webkit-transform-3d)")) ||
            ("styleMedia" in window && window.styleMedia.matchMedium("(-webkit-transform-3d)")))) {
            tf.math.hasCSSMatrixCopy = "copy" in WebKitCSSMatrix.prototype;
        }
        else { tf.math.hasCSSMatrixCopy = false; }
        //tf.math.hasCSSMatrix = tf.math.hasCSSMatrixCopy = false;
        //tf.math.hasCSSMatrixCopy = false;
    }
    return { hasCSSMatrix: tf.math.hasCSSMatrix, hasCSSMatrixCopy: tf.math.hasCSSMatrixCopy };
}
tf.math.Matrix4 = function (settings) {
    var theThis, matrix;
    this.GetInStaticFloat32Array = function () {
        if (tf.math.Matrix4.staticFloat32Array  == undefined) { tf.math.Matrix4.staticFloat32Array = new Float32Array(16); }
        if (tf.math.hasCSSMatrixCopy)
            matrix.copy(tf.math.Matrix4.staticFloat32Array);
        else {
            if (tf.math.Matrix4.staticJSArray == undefined) { tf.math.Matrix4.staticJSArray = new Array(16); }
            tf.math.Matrix4.staticJSArray[0] = matrix.m11; tf.math.Matrix4.staticJSArray[1] = matrix.m12;
            tf.math.Matrix4.staticJSArray[2] = matrix.m13; tf.math.Matrix4.staticJSArray[3] = matrix.m14;
            tf.math.Matrix4.staticJSArray[4] = matrix.m21; tf.math.Matrix4.staticJSArray[5] = matrix.m22;
            tf.math.Matrix4.staticJSArray[6] = matrix.m23; tf.math.Matrix4.staticJSArray[7] = matrix.m24;
            tf.math.Matrix4.staticJSArray[8] = matrix.m31; tf.math.Matrix4.staticJSArray[9] = matrix.m32;
            tf.math.Matrix4.staticJSArray[10] = matrix.m33; tf.math.Matrix4.staticJSArray[11] = matrix.m34;
            tf.math.Matrix4.staticJSArray[12] = matrix.m41; tf.math.Matrix4.staticJSArray[13] = matrix.m42;
            tf.math.Matrix4.staticJSArray[14] = matrix.m43; tf.math.Matrix4.staticJSArray[15] = matrix.m44;
            tf.math.Matrix4.staticFloat32Array.set(tf.math.Matrix4.staticJSArray);
        }
        return tf.math.Matrix4.staticFloat32Array;
    }
    this.GetAsJSArray = function () { return getAsJSArray(); }
    this.GetAsFloat32Array = function () { return getAsFloat32Array(); }
    this.CopyTo = function (otherMatrix) { return copyTo(otherMatrix); }
    this.CopyFrom = function (otherMatrix) { return copyFrom(otherMatrix); }
    function copyFrom(otherMatrix) {
        if (otherMatrix instanceof tf.math.Matrix4) {
            var otherMat = otherMatrix.getMatrix();
            matrix.m11 = otherMat.m11; matrix.m12 = otherMat.m12; matrix.m13 = otherMat.m13; matrix.m14 = otherMat.m14;
            matrix.m21 = otherMat.m21; matrix.m22 = otherMat.m22; matrix.m23 = otherMat.m23; matrix.m24 = otherMat.m24;
            matrix.m31 = otherMat.m31; matrix.m32 = otherMat.m32; matrix.m33 = otherMat.m33; matrix.m34 = otherMat.m34;
            matrix.m41 = otherMat.m41; matrix.m42 = otherMat.m42; matrix.m43 = otherMat.m43; matrix.m44 = otherMat.m44;
        }
        else if (tf.js.GetIsArrayWithMinLength(otherMatrix, 16)) {
            var i = 0;
            /*matrix.m11 = otherMatrix[i++]; matrix.m12 = otherMatrix[i++]; matrix.m13 = otherMatrix[i++]; matrix.m14 = otherMatrix[i++];
            matrix.m21 = otherMatrix[i++]; matrix.m22 = otherMatrix[i++]; matrix.m23 = otherMatrix[i++]; matrix.m24 = otherMatrix[i++];
            matrix.m31 = otherMatrix[i++]; matrix.m32 = otherMatrix[i++]; matrix.m33 = otherMatrix[i++]; matrix.m34 = otherMatrix[i++];
            matrix.m41 = otherMatrix[i++]; matrix.m42 = otherMatrix[i++]; matrix.m43 = otherMatrix[i++]; matrix.m44 = otherMatrix[i++];*/
            matrix.m11 = otherMatrix[0]; matrix.m21 = otherMatrix[1]; matrix.m31 = otherMatrix[2]; matrix.m41 = otherMatrix[3];
            matrix.m12 = otherMatrix[4]; matrix.m22 = otherMatrix[5]; matrix.m32 = otherMatrix[6]; matrix.m42 = otherMatrix[7];
            matrix.m13 = otherMatrix[8]; matrix.m23 = otherMatrix[9]; matrix.m33 = otherMatrix[10]; matrix.m43 = otherMatrix[11];
            matrix.m14 = otherMatrix[12]; matrix.m24 = otherMatrix[13]; matrix.m34 = otherMatrix[14]; matrix.m44 = otherMatrix[15];
        }
        return theThis;
    }
    function copyTo(otherMatrix) { if (otherMatrix instanceof tf.math.Matrix4) { otherMatrix.CopyFrom(theThis); } return theThis; }
    this.ToIdentity = function () { return toIdentity(); }
    this.ToTransposed = function () { return toTransposed(); }
    this.ToInverse = function () { return toInverse(); }
    this.ToAdjoint = function () { return toAdjoint; }
    this.MultByMatrix = function (otherMatrix) { return multByMatrix(otherMatrix); }
    this.MultByScalar = function (scalar) { return multByScalar(scalar); }
    this.GetDeterminant = function () { return getDeterminant(); }
    this.getMatrix = function () { return matrix; }
    this.setMatrix = function (otherMatrix) { if (!!otherMatrix) { matrix = otherMatrix; } }
    function getAsJSArray() {
        return [matrix.m11, matrix.m12, matrix.m13, matrix.m14, matrix.m21, matrix.m22, matrix.m23, matrix.m24,
            matrix.m31, matrix.m32, matrix.m33, matrix.m34, matrix.m41, matrix.m42, matrix.m43, matrix.m44];
    }
    function getAsFloat32Array() {
        var array;
        if (tf.math.hasCSSMatrix) { array = new Float32Array(16); matrix.copy(array); }
        else { array = new Float32Array(getAsJSArray()); }
        return array;
    }
    function toIdentity() {
        matrix.m11 = 1; matrix.m12 = 0; matrix.m13 = 0; matrix.m14 = 0;
        matrix.m21 = 0; matrix.m22 = 1; matrix.m23 = 0; matrix.m24 = 0;
        matrix.m31 = 0; matrix.m32 = 0; matrix.m33 = 1; matrix.m34 = 0;
        matrix.m41 = 0; matrix.m42 = 0; matrix.m43 = 0; matrix.m44 = 1;
        return theThis;
    }
    function toTransposed () {
        var tmp = matrix.m12; matrix.m12 = matrix.m21; matrix.m21 = tmp;
        tmp = matrix.m13; matrix.m13 = matrix.m31; matrix.m31 = tmp;
        tmp = matrix.m14; matrix.m14 = matrix.m41; matrix.m41 = tmp;
        tmp = matrix.m23; matrix.m23 = matrix.m32; matrix.m32 = tmp;
        tmp = matrix.m24; matrix.m24 = matrix.m42; matrix.m42 = tmp;
        tmp = matrix.m34; matrix.m34 = matrix.m43; matrix.m43 = tmp;
        return theThis;
    }
    function toInverse() {
        if (tf.math.hasCSSMatrix) { try { matrix = matrix.inverse(); } catch (e) { } }
        else { var det = getDeterminant(); if (Math.abs(det) >= 1e-8) { toAdjoint(); multByScalar(1 / det); } }
        return theThis;
    }
    function toAdjoint() {
        var a1 = matrix.m11, b1 = matrix.m12, c1 = matrix.m13, d1 = matrix.m14;
        var a2 = matrix.m21, b2 = matrix.m22, c2 = matrix.m23, d2 = matrix.m24;
        var a3 = matrix.m31, b3 = matrix.m32, c3 = matrix.m33, d3 = matrix.m34;
        var a4 = matrix.m41, b4 = matrix.m42, c4 = matrix.m43, d4 = matrix.m44;
        matrix.m11 = tf.math.GetDeterminant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4);
        matrix.m21 = -tf.math.GetDeterminant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4);
        matrix.m31 = tf.math.GetDeterminant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4);
        matrix.m41 = -tf.math.GetDeterminant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);
        matrix.m12 = -tf.math.GetDeterminant3x3(b1, b3, b4, c1, c3, c4, d1, d3, d4);
        matrix.m22 = tf.math.GetDeterminant3x3(a1, a3, a4, c1, c3, c4, d1, d3, d4);
        matrix.m32 = -tf.math.GetDeterminant3x3(a1, a3, a4, b1, b3, b4, d1, d3, d4);
        matrix.m42 = tf.math.GetDeterminant3x3(a1, a3, a4, b1, b3, b4, c1, c3, c4);
        matrix.m13 = tf.math.GetDeterminant3x3(b1, b2, b4, c1, c2, c4, d1, d2, d4);
        matrix.m23 = -tf.math.GetDeterminant3x3(a1, a2, a4, c1, c2, c4, d1, d2, d4);
        matrix.m33 = tf.math.GetDeterminant3x3(a1, a2, a4, b1, b2, b4, d1, d2, d4);
        matrix.m43 = -tf.math.GetDeterminant3x3(a1, a2, a4, b1, b2, b4, c1, c2, c4);
        matrix.m14 = -tf.math.GetDeterminant3x3(b1, b2, b3, c1, c2, c3, d1, d2, d3);
        matrix.m24 = tf.math.GetDeterminant3x3(a1, a2, a3, c1, c2, c3, d1, d2, d3);
        matrix.m34 = -tf.math.GetDeterminant3x3(a1, a2, a3, b1, b2, b3, d1, d2, d3);
        matrix.m44 = tf.math.GetDeterminant3x3(a1, a2, a3, b1, b2, b3, c1, c2, c3);
        return theThis;
    }
    function multByScalar(scalar) {
        if (typeof scalar == 'number' && scalar != 1) {
            matrix.m11 *= scalar; matrix.m12 *= scalar; matrix.m13 *= scalar; matrix.m14 *= scalar;
            matrix.m21 *= scalar; matrix.m22 *= scalar; matrix.m23 *= scalar; matrix.m24 *= scalar;
            matrix.m31 *= scalar; matrix.m32 *= scalar; matrix.m33 *= scalar; matrix.m34 *= scalar;
            matrix.m41 *= scalar; matrix.m42 *= scalar; matrix.m43 *= scalar; matrix.m44 *= scalar;
        }
        return theThis;
    }
    function multByMatrix(otherMatrix) {
        if (otherMatrix instanceof tf.math.Matrix4) {
            var otherMat = otherMatrix.getMatrix();
            if (tf.math.hasCSSMatrix) { matrix = matrix.multiply(otherMat); }
            else {
                var m11 = otherMat.m11 * matrix.m11 + otherMat.m12 * matrix.m21 + otherMat.m13 * matrix.m31 + otherMat.m14 * matrix.m41;
                var m12 = otherMat.m11 * matrix.m12 + otherMat.m12 * matrix.m22 + otherMat.m13 * matrix.m32 + otherMat.m14 * matrix.m42;
                var m13 = otherMat.m11 * matrix.m13 + otherMat.m12 * matrix.m23 + otherMat.m13 * matrix.m33 + otherMat.m14 * matrix.m43;
                var m14 = otherMat.m11 * matrix.m14 + otherMat.m12 * matrix.m24 + otherMat.m13 * matrix.m34 + otherMat.m14 * matrix.m44;
                var m21 = otherMat.m21 * matrix.m11 + otherMat.m22 * matrix.m21 + otherMat.m23 * matrix.m31 + otherMat.m24 * matrix.m41;
                var m22 = otherMat.m21 * matrix.m12 + otherMat.m22 * matrix.m22 + otherMat.m23 * matrix.m32 + otherMat.m24 * matrix.m42;
                var m23 = otherMat.m21 * matrix.m13 + otherMat.m22 * matrix.m23 + otherMat.m23 * matrix.m33 + otherMat.m24 * matrix.m43;
                var m24 = otherMat.m21 * matrix.m14 + otherMat.m22 * matrix.m24 + otherMat.m23 * matrix.m34 + otherMat.m24 * matrix.m44;
                var m31 = otherMat.m31 * matrix.m11 + otherMat.m32 * matrix.m21 + otherMat.m33 * matrix.m31 + otherMat.m34 * matrix.m41;
                var m32 = otherMat.m31 * matrix.m12 + otherMat.m32 * matrix.m22 + otherMat.m33 * matrix.m32 + otherMat.m34 * matrix.m42;
                var m33 = otherMat.m31 * matrix.m13 + otherMat.m32 * matrix.m23 + otherMat.m33 * matrix.m33 + otherMat.m34 * matrix.m43;
                var m34 = otherMat.m31 * matrix.m14 + otherMat.m32 * matrix.m24 + otherMat.m33 * matrix.m34 + otherMat.m34 * matrix.m44;
                var m41 = otherMat.m41 * matrix.m11 + otherMat.m42 * matrix.m21 + otherMat.m43 * matrix.m31 + otherMat.m44 * matrix.m41;
                var m42 = otherMat.m41 * matrix.m12 + otherMat.m42 * matrix.m22 + otherMat.m43 * matrix.m32 + otherMat.m44 * matrix.m42;
                var m43 = otherMat.m41 * matrix.m13 + otherMat.m42 * matrix.m23 + otherMat.m43 * matrix.m33 + otherMat.m44 * matrix.m43;
                var m44 = otherMat.m41 * matrix.m14 + otherMat.m42 * matrix.m24 + otherMat.m43 * matrix.m34 + otherMat.m44 * matrix.m44;
                matrix.m11 = m11; matrix.m12 = m12; matrix.m13 = m13; matrix.m14 = m14;
                matrix.m21 = m21; matrix.m22 = m22; matrix.m23 = m23; matrix.m24 = m24;
                matrix.m31 = m31; matrix.m32 = m32; matrix.m33 = m33; matrix.m34 = m34;
                matrix.m41 = m41; matrix.m42 = m42; matrix.m43 = m43; matrix.m44 = m44;
            }
        }
        return theThis;
    }
    function getDeterminant() {
        return tf.math.GetDeterminant4x4(
            matrix.m11, matrix.m12, matrix.m13, matrix.m14, matrix.m21, matrix.m22, matrix.m23, matrix.m24,
            matrix.m31, matrix.m32, matrix.m33, matrix.m34, matrix.m41, matrix.m42, matrix.m43, matrix.m44);
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        tf.math.GetCSSMatrixInfo();
        matrix = tf.math.hasCSSMatrix ? new WebKitCSSMatrix : {};
        if (settings.matrix instanceof tf.math.Matrix4 || tf.js.GetIsArrayWithMinLength(settings.matrix, 16)) { copyFrom(settings.matrix); }
        else if (!settings.noInit) { toIdentity(); }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.math.ScaleMatrix4 = function (settings) {
    var theThis, sx, sy, sz;
    this.SetScale = function (sx, sy, sz) { return setScale(sx, sy, sz); }
    this.GetScale = function () { return { sx: sx, sy: sy, sz: sz }; }
    function setScale(sxSet, sySet, szSet) {
        var copied;
        if (tf.js.GetIsValidObject(sxSet)) {
            if (copied = sxSet instanceof tf.math.Matrix4) { theThis.CopyFrom(sxSet); }
            else { szSet = sxSet.sz; sySet = sxSet.sy; sxSet = sxSet.sx; }
        }
        if (!copied) {
            var matrix = theThis.getMatrix();
            matrix.m11 = sx = tf.js.GetFloatNumber(sxSet, 1);
            matrix.m22 = sy = tf.js.GetFloatNumber(sySet, 1);
            matrix.m33 = sz = tf.js.GetFloatNumber(szSet, 1);
        }
        return theThis;
    }
    function initialize() {
        tf.math.Matrix4.call(theThis);
        setScale(settings = tf.js.GetValidObjectFrom(settings));
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.math.ScaleMatrix4, tf.math.Matrix4);
tf.math.RotateMatrix4 = function (settings) {
    var theThis, angle, axisx, axisy, axisz;
    this.SetRotateAngleAxis = function (angle, axisx, axisy, axisz) { return setRotateAngleAxis(angle, axisx, axisy, axisz); }
    this.GetRotate = function () { return { angle: angle, axisx: axisx, axisy: axisy, axisz: axisz }; }
    function setRotateAngleAxis(angleSet, axisxSet, axisySet, axiszSet) {
        var copied;
        if (tf.js.GetIsValidObject(angleSet)) {
            if (copied = angleSet instanceof tf.math.Matrix4) { theThis.CopyFrom(angleSet); }
            else { axiszSet = angleSet.axisz; axisySet = angleSet.axisy; axisxSet = angleSet.axisx; angleSet = angleSet.angle; }
        }
        if (!copied) {
            var matrix = theThis.getMatrix();
            theThis.ToIdentity();
            angle = tf.js.GetFloatNumber(angleSet, 0);
            axisx = tf.js.GetFloatNumber(axisxSet, 0);
            axisy = tf.js.GetFloatNumber(axisySet, 0);
            axisz = tf.js.GetFloatNumber(axiszSet, 0);
            if (angle != 0 && (axisx != 0 || axisy != 0 || axisz != 0)) {
                if (tf.math.hasCSSMatrix) {
                    theThis.setMatrix(matrix.rotateAxisAngle(axisx, axisy, axisz, angle * 180 / Math.PI));
                }
                else {
                    angle /= 2;
                    var sinA = Math.sin(angle);
                    var cosA = Math.cos(angle);
                    var sinA2 = sinA * sinA;
                    var x = axisx, y = axisy, z = axisz;
                    var len = Math.sqrt(x * x + y * y + z * z);
                    if (len == 0) { x = 0; y = 0; z = 1; } else if (len != 1) { x /= len; y /= len; z /= len; }
                    if (x == 1 && y == 0 && z == 0) {
                        matrix.m11 = 1;
                        matrix.m12 = matrix.m13 = matrix.m21 = matrix.m31 = 0;
                        matrix.m22 = 1 - 2 * sinA2;
                        matrix.m23 = 2 * sinA * cosA;
                        matrix.m32 = -2 * sinA * cosA;
                        matrix.m33 = 1 - 2 * sinA2;
                    } else if (x == 0 && y == 1 && z == 0) {
                        matrix.m11 = 1 - 2 * sinA2;
                        matrix.m12 = matrix.m21 = matrix.m23 = matrix.m32 = 0;
                        matrix.m13 = -2 * sinA * cosA;
                        matrix.m22 = 1;
                        matrix.m31 = 2 * sinA * cosA;
                        matrix.m33 = 1 - 2 * sinA2;
                    } else if (x == 0 && y == 0 && z == 1) {
                        matrix.m11 = 1 - 2 * sinA2;
                        matrix.m12 = 2 * sinA * cosA;
                        matrix.m13 = matrix.m23 = matrix.m31 = matrix.m32 = 0;
                        matrix.m21 = -2 * sinA * cosA;
                        matrix.m22 = 1 - 2 * sinA2;
                        matrix.m33 = 1;
                    } else {
                        var x2 = x * x, y2 = y * y, z2 = z * z;
                        matrix.m11 = 1 - 2 * (y2 + z2) * sinA2;
                        matrix.m12 = 2 * (x * y * sinA2 + z * sinA * cosA);
                        matrix.m13 = 2 * (x * z * sinA2 - y * sinA * cosA);
                        matrix.m21 = 2 * (y * x * sinA2 - z * sinA * cosA);
                        matrix.m22 = 1 - 2 * (z2 + x2) * sinA2;
                        matrix.m23 = 2 * (y * z * sinA2 + x * sinA * cosA);
                        matrix.m31 = 2 * (z * x * sinA2 + y * sinA * cosA);
                        matrix.m32 = 2 * (z * y * sinA2 - x * sinA * cosA);
                        matrix.m33 = 1 - 2 * (x2 + y2) * sinA2;
                    }
                    matrix.m14 = matrix.m24 = matrix.m34 = matrix.m41 = matrix.m42 = matrix.m43 = 0;
                    matrix.m44 = 1;
                }
            }
        }
        return theThis;
    }
    function initialize() {
        tf.math.Matrix4.call(theThis, { noInit: true });
        setRotateAngleAxis(settings = tf.js.GetValidObjectFrom(settings));
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.math.RotateMatrix4, tf.math.Matrix4);
tf.math.TranslateMatrix4 = function (settings) {
    var theThis, tx, ty, tz;
    this.SetTranslate = function (tx, ty, tz) { return setTranslate(tx, ty, tz); }
    this.GetTranslate = function () { return { tx: tx, ty: ty, tz: tz }; }
    function setTranslate(txSet, tySet, tzSet) {
        var copied;
        if (tf.js.GetIsValidObject(txSet)) {
            if (copied = txSet instanceof tf.math.Matrix4) { theThis.CopyFrom(txSet); }
            else { tzSet = txSet.tz; tySet = txSet.ty; txSet = txSet.tx; }
        }
        if (!copied) {
            var matrix = theThis.getMatrix();
            matrix.m41 = tx = tf.js.GetFloatNumber(txSet, 0);
            matrix.m42 = ty = tf.js.GetFloatNumber(tySet, 0);
            matrix.m43 = tz = tf.js.GetFloatNumber(tzSet, 0);
        }
        return theThis;
    }
    function initialize() {
        tf.math.Matrix4.call(theThis);
        setTranslate(settings = tf.js.GetValidObjectFrom(settings));
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.math.TranslateMatrix4, tf.math.Matrix4);
tf.math.WorldMatrix4 = function (settings) {
    var theThis, matScale, matRotate, matTranslate;
    this.UpdateWorld = function (settings) { return updateWorld(settings); }
    this.GetScale = function () { return matScale; }
    this.GetTranslate = function () { return matTranslate; }
    this.GetRotate = function () { return matRotate; }
    function updateWorld(settings) {
        var isCopy;
        if (tf.js.GetIsValidObject(settings)) {
            if (! (isCopy = tf.js.GetIsValidObject(settings.matrix))) {
                if (tf.js.GetIsValidObject(settings.scale)) {
                    if (matScale === undefined) { matScale = new tf.math.ScaleMatrix4(settings.scale); }
                    else { matScale.SetScale(settings.scale); }
                }
                if (tf.js.GetIsValidObject(settings.rotate)) {
                    if (matRotate === undefined) { matRotate = new tf.math.RotateMatrix4(settings.rotate); }
                    else { matRotate.SetRotateAngleAxis(settings.rotate); }
                }
                if (tf.js.GetIsValidObject(settings.translate)) {
                    if (matTranslate === undefined) { matTranslate = new tf.math.TranslateMatrix4(settings.translate); }
                    else { matTranslate.SetTranslate(settings.translate); }
                }
            }
        }
        if (!!isCopy) { theThis.CopyFrom(settings.matrix); }
        else {
            theThis.ToIdentity();
            if (matTranslate !== undefined) { theThis.MultByMatrix(matTranslate); }
            if (matRotate !== undefined) { theThis.MultByMatrix(matRotate); }
            if (matScale !== undefined) { theThis.MultByMatrix(matScale); }
        }
        return theThis;
    }
    function initialize() {
        tf.math.Matrix4.call(theThis, { noInit: true });
        updateWorld(tf.js.GetValidObjectFrom(settings));
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
}
tf.js.InheritFrom(tf.math.WorldMatrix4, tf.math.Matrix4);
tf.math.ViewMatrix4 = function (settings) {
    var theThis, inverse, vFrom, vTo, vUp, vUnitTo, vUnitUp, vUnitRight;
    this.GetInverse = function () { return inverse; }
    this.UpdateView = function (settings) { return updateView(settings); }
    this.GetView = function () { return { vFrom: vFrom, vTo: vTo, vUp: vUp, vUnitTo: vUnitTo, vUnitUp: vUnitUp, vUnitRight: vUnitRight}; }
    function updateView(settings) {
        settings = tf.js.GetValidObjectFrom(settings);
        vFrom = tf.js.GetIsArrayWithMinLength(settings.vFrom, 3) ? settings.vFrom : [0, 0, 1];
        vTo = settings.vTo !== undefined ? settings.vTo : [0, 0, 0];
        vUp = settings.vUp !== undefined ? settings.vUp : [0, 1, 0];
        var eyex = vFrom[0], eyey = vFrom[1], eyez = vFrom[2], atx = vTo[0], aty = vTo[1], atz = vTo[2], upx = vUp[0], upy = vUp[1], upz = vUp[2]
        var zAxisX = eyex - atx, zAxisY = eyey - aty, zAxisZ = eyez - atz;
        var mag = Math.sqrt(zAxisX * zAxisX + zAxisY * zAxisY + zAxisZ * zAxisZ);
        if (mag != 0 && mag != 1) { mag = 1 / mag; zAxisX *= mag; zAxisY *= mag; zAxisZ *= mag; }
        vUnitTo = [zAxisX, zAxisY, zAxisZ];
        var yAxisX = upx, yAxisY = upy, yAxisZ = upz;
        mag = Math.sqrt(yAxisX * yAxisX + yAxisY * yAxisY + yAxisZ * yAxisZ);
        if (mag != 0 && mag != 1) { mag = 1 / mag; yAxisX *= mag; yAxisY *= mag; yAxisZ *= mag; }
        var xAxisX = yAxisY * zAxisZ - yAxisZ * zAxisY, xAxisY = yAxisZ * zAxisX - yAxisX * zAxisZ, xAxisZ = yAxisX * zAxisY - yAxisY * zAxisX;
        mag = Math.sqrt(xAxisX * xAxisX + xAxisY * xAxisY + xAxisZ * xAxisZ);
        if (mag != 0 && mag != 1) { mag = 1 / mag; xAxisX *= mag; xAxisY *= mag; xAxisZ *= mag; }
        vUnitRight = [xAxisX, xAxisY, xAxisZ];
        yAxisX = zAxisY * xAxisZ - zAxisZ * xAxisY; yAxisY = zAxisZ * xAxisX - zAxisX * xAxisZ; yAxisZ = zAxisX * xAxisY - zAxisY * xAxisX;
        mag = Math.sqrt(yAxisX * yAxisX + yAxisY * yAxisY + yAxisZ * yAxisZ);
        if (mag != 0 && mag != 1) { mag = 1 / mag; yAxisX *= mag; yAxisY *= mag; yAxisZ *= mag; }
        vUnitUp = [yAxisX, yAxisY, yAxisZ];
        var xAxisDot = xAxisX * eyex + xAxisY * eyey + xAxisZ * eyez;
        var yAxisDot = yAxisX * eyex + yAxisY * eyey + yAxisZ * eyez;
        var zAxisDot = zAxisX * eyex + zAxisY * eyey + zAxisZ * eyez;
        var matrix = inverse.getMatrix();
        matrix.m14 = matrix.m24 = matrix.m34 = 0;
        matrix.m44 = 1;
        matrix.m11 = xAxisX; matrix.m12 = xAxisY; matrix.m13 = xAxisZ; 
        matrix.m21 = yAxisX; matrix.m22 = yAxisY; matrix.m23 = yAxisZ; 
        matrix.m31 = zAxisX; matrix.m32 = zAxisY; matrix.m33 = zAxisZ; 
        matrix.m41 = eyex; matrix.m42 = eyey; matrix.m43 = eyez; 
        theThis.CopyFrom(inverse);
        theThis.ToInverse();
        return theThis;
    }
    function initialize() {
        var noInit = { noInit: true };
        inverse = new tf.math.Matrix4(noInit);
        tf.math.Matrix4.call(theThis, noInit);
        updateView(settings);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
}
tf.js.InheritFrom(tf.math.ViewMatrix4, tf.math.Matrix4);
tf.math.FrustumMatrix4 = function (settings) {
    var theThis, left, right, bottom, top, near, far, halfWidth, halfHeight;
    this.UpdateFrustum = function (settings) { return updateFrustum(settings); }
    this.GetFrustum = function () { return { left: left, right: right, top: top, bottom: bottom, near: near, far: far, halfWidth: halfWidth, halfHeight: halfHeight }; }
    function updateFrustum(settings) {
        settings = tf.js.GetValidObjectFrom(settings);
        left = tf.js.GetFloatNumber(settings.left, -1);
        right = tf.js.GetFloatNumber(settings.right, 1);
        bottom = tf.js.GetFloatNumber(settings.bottom, -1);
        top = tf.js.GetFloatNumber(settings.top, 1);
        near = tf.js.GetFloatNumber(settings.near, 1);
        far = tf.js.GetFloatNumber(settings.far, 1000);
        var near2 = near + near;
        var W = right - left;
        var invW = W == 0 ? 1 : 1 / W;
        var H = top - bottom;
        var invH = H == 0 ? 1 : 1 / H;
        var D = near - far;
        var invD = D == 0 ? 1 : 1 / D;
        var matrix = theThis.getMatrix();
        halfWidth = W / 2;
        halfHeight = H / 2;
        matrix.m12 = matrix.m13 = matrix.m14 = matrix.m21 = matrix.m23 = matrix.m24 = matrix.m41 = matrix.m42 = matrix.m44 = 0;
        matrix.m34 = -1;
        matrix.m11 = near2 * invW;
        matrix.m22 = near2 * invH;
        matrix.m31 = (right + left) * invW;
        matrix.m32 = (top + bottom) * invH;
        matrix.m33 = (far + near) * invD;
        matrix.m43 = (far * near2) * invD;
        return theThis;
    }
    function initialize() {
        tf.math.Matrix4.call(theThis, { noInit: true });
        if (!tf.js.GetIsValidObject(settings) || !settings.noInit) { updateFrustum(settings); }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
}
tf.js.InheritFrom(tf.math.FrustumMatrix4, tf.math.Matrix4);
tf.math.PerspectiveFOVMatrix4 = function (settings) {
    var theThis, near, far, fovy, aspect, tangent;
    this.UpdatePerspective = function (settings) { return updatePerspective(settings); }
    this.UpdateAspect = function (aspect) { return updateAspect(aspect); }
    this.GetPerspective = function () { return { fovy: fovy, aspect: aspect, tangent: tangent, frustum: theThis.GetFrustum() }; }
    function updateAspect(aspectSet) {
        aspect = tf.js.GetFloatNumberInRange(aspectSet, 0.0000001, 99999999, 1);
        tangent = Math.tan(fovy / 2);
        var top = tangent * near, bottom = -top;
        var left = aspect * bottom, right = aspect * top;
        theThis.UpdateFrustum({ left: left, right: right, top: top, bottom: bottom, near: near, far: far });
        return theThis;
    }
    function updatePerspective(settings) {
        settings = tf.js.GetValidObjectFrom(settings);
        near = tf.js.GetFloatNumberInRange(settings.near, 0.0001, 9999999, 1);
        far = tf.js.GetFloatNumberInRange(settings.far, 0.0001, 9999999, 1);
        fovy = tf.js.GetFloatNumberInRange(settings.fovy, Math.PI / 64, Math.PI * 2, Math.PI / 6);
        return updateAspect(settings.aspect);
    }
    function initialize() {
        tf.math.FrustumMatrix4.call(theThis, { noInit: true });
        updatePerspective(settings);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
}
tf.js.InheritFrom(tf.math.PerspectiveFOVMatrix4, tf.math.FrustumMatrix4);
tf.math.OrthoMatrix4 = function (settings) {
    var theThis;
    this.UpdateOrtho = function (settings) { return updateOrtho(settings); }
    function updateOrtho(settings) {
        settings = tf.js.GetValidObjectFrom(settings);
        var left = tf.js.GetFloatNumber(settings.left, -1);
        var right = tf.js.GetFloatNumber(settings.right, 1);
        var bottom = tf.js.GetFloatNumber(settings.bottom, -1);
        var top = tf.js.GetFloatNumber(settings.top, 1);
        var near = tf.js.GetFloatNumber(settings.near, 1);
        var far = tf.js.GetFloatNumber(settings.far, 1000);
        var tx = (left + right) / (left - right);
        var ty = (top + bottom) / (top - bottom);
        var tz = (far + near) / (far - near);
        var matrix = theThis.getMatrix();
        matrix.m12 = matrix.m13 = matrix.m14 = matrix.m21 = matrix.m23 = matrix.m24 = matrix.m31 = matrix.m32 = matrix.m34 = 0;
        matrix.m44 = 1;
        matrix.m11 = 2 / (left - right);
        matrix.m22 = 2 / (top - bottom);
        matrix.m33 = -2 / (far - near);
        matrix.m41 = tx;
        matrix.m42 = ty;
        matrix.m43 = tz;
    }
    function initialize() {
        tf.math.Matrix4.call(theThis, { noInit: true });
        if (!tf.js.GetIsValidObject(settings) || !settings.noInit) { updateOrtho(settings); }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
}
tf.js.InheritFrom(tf.math.OrthoMatrix4, tf.math.Matrix4);
tf.math.Plane = function (settings) {
    var theThis, normal, d;
    this.Update = function (newSettings) {
        settings = tf.js.GetValidObjectFrom(newSettings);
        normal = new tf.math.Vector3({ vector: settings.normal });
        normal.Normalize();
        d = -normal.Dot(settings.point);
    }
    this.GetDistanceTo = function (point) { return d + normal.Dot(point); }
    function initialize() {
        theThis.Update(settings);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.math.ViewFrustum = function (settings) {
    var theThis, perspective, view, pNear, pFar, pLeft, pRight, pTop, pBot, planes, eyePos, X, Y, Z,
        nearCenter, farCenter, ptTemp, ptTemp2, halfWidth, halfHeight, far, near, tangent, aspect;
    this.GetSphereIsVisible = function (center, radius) {
        var result = { isVisible: true, intersects: 0 };
        if (!isDeleted()) {
            for (var i = 0 ; i < 6 ; ++i) {
                var dist = planes[i].GetDistanceTo(center);
                if (dist < -radius) { result.isVisible = false; break; } // sphere is outside of this plane
                else if (dist < radius) { ++result.intersects; } // sphere intersect's with this plane
            }
        }
        return result;
    }
    this.GetIsPointVisible = function (point) {
        if (!isDeleted()) {
            var pcz, pcx, pcy, aux;
            ptTemp.CopyFrom(point); ptTemp.Sub(eyePos);
            pcz = -ptTemp.Dot(Z); if (pcz > far || pcz < near) { return false; }
            pcy = ptTemp.Dot(Y);
            aux = pcz * tangent;
            if (pcy > aux || pcy < -aux) { return false; }
            pcx = ptTemp.Dot(X);
            aux *= aspect;
            if (pcx > aux || pcx < -aux) { return false; }
        }
        return true;
    }
    this.GetIsPointVisibleByPlanes = function (point) {
        if (!isDeleted()) {
            for (var i = 0 ; i < 6 ; ++i) { if (planes[i].GetDistanceTo(point) < 0) { return false; } }
            //if (pTop.GetDistanceTo(point) < 0) { return false; }
            //if (pBot.GetDistanceTo(point) < 0) { return false; }
            //if (pLeft.GetDistanceTo(point) < 0) { return false; }
            //if (pRight.GetDistanceTo(point) < 0) { return false; }
            //if (pNear.GetDistanceTo(point) < 0) { return false; }
            //if (pFar.GetDistanceTo(point) < 0) { return false; }
        }
        return true;
    }
    this.OnUpdate = function () { return onUpdate(); }
    this.OnDelete = function () { return onDelete(); }
    this.IsDeleted = function () { return isDeleted(); }
    function isDeleted() { return perspective == undefined; }
    function onDelete() {
        if (!isDeleted()) {
            perspective = view = pNear = pFar = pLeft = pRight = pTop = pBot = planes = undefined;
        }
    }
    function onUpdate() {
        if (!isDeleted()) {
            var perspectiveSettings = perspective.GetPerspective();
            var frustumSettings = perspectiveSettings.frustum;
            var viewSettings = view.GetView();
            tangent = perspectiveSettings.tangent;
            aspect = perspectiveSettings.aspect;
            near = frustumSettings.near;
            far = frustumSettings.far;
            eyePos.CopyFrom(viewSettings.vFrom);
            X.CopyFrom(viewSettings.vUnitRight);
            Y.CopyFrom(viewSettings.vUnitUp);
            Z.CopyFrom(viewSettings.vUnitTo);
            halfWidth = frustumSettings.halfWidth;
            halfHeight = frustumSettings.halfHeight;
            nearCenter.CopyFrom(eyePos);
            ptTemp.CopyFrom(Z);
            ptTemp.MultByScalar(-near);
            nearCenter.Add(ptTemp);
            farCenter.CopyFrom(eyePos);
            ptTemp.CopyFrom(Z);
            ptTemp.MultByScalar(-far);
            farCenter.Add(ptTemp);
            ptTemp.CopyFrom(Z);
            pFar.Update({ normal: ptTemp, point: farCenter });
            ptTemp.MultByScalar(-1);
            pNear.Update({ normal: ptTemp, point: nearCenter });
            ptTemp.CopyFrom(Y);
            ptTemp.MultByScalar(halfHeight);
            ptTemp.Add(nearCenter);
            ptTemp2.CopyFrom(ptTemp);
            ptTemp2.Sub(eyePos);
            ptTemp2.Normalize();
            ptTemp2.Cross(X);
            pTop.Update({ normal: ptTemp2, point: ptTemp });
            ptTemp.CopyFrom(Y);
            ptTemp.MultByScalar(-halfHeight);
            ptTemp.Add(nearCenter);
            ptTemp2.CopyFrom(ptTemp);
            ptTemp2.Sub(eyePos);
            ptTemp2.Normalize();
            ptTemp2.CrossRight(X);
            pBot.Update({ normal: ptTemp2, point: ptTemp });
            ptTemp.CopyFrom(X);
            ptTemp.MultByScalar(-halfWidth);
            ptTemp.Add(nearCenter);
            ptTemp2.CopyFrom(ptTemp);
            ptTemp2.Sub(eyePos);
            ptTemp2.Normalize();
            ptTemp2.Cross(Y);
            pLeft.Update({ normal: ptTemp2, point: ptTemp });
            ptTemp.CopyFrom(X);
            ptTemp.MultByScalar(halfWidth);
            ptTemp.Add(nearCenter);
            ptTemp2.CopyFrom(ptTemp);
            ptTemp2.Sub(eyePos);
            ptTemp2.Normalize();
            ptTemp2.CrossRight(Y);
            pRight.Update({ normal: ptTemp2, point: ptTemp });
        }
    };
    function initialize() {
        if (tf.js.GetIsValidObject(settings) &&
            tf.js.GetIsInstanceOf(settings.view, tf.math.ViewMatrix4) &&
            tf.js.GetIsInstanceOf(settings.perspective, tf.math.PerspectiveFOVMatrix4)) {
            view = settings.view;
            perspective = settings.perspective;
            pNear = new tf.math.Plane();
            pFar = new tf.math.Plane();
            pLeft = new tf.math.Plane();
            pRight = new tf.math.Plane();
            pTop = new tf.math.Plane();
            pBot = new tf.math.Plane();
            planes = [pTop, pBot, pLeft, pRight, pNear, pFar];
            X = new tf.math.Vector3();
            Y = new tf.math.Vector3();
            Z = new tf.math.Vector3();
            eyePos = new tf.math.Vector3();
            ptTemp = new tf.math.Vector3();
            ptTemp2 = new tf.math.Vector3();
            nearCenter = new tf.math.Vector3();
            farCenter = new tf.math.Vector3();
            onUpdate();
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: webgl.js
tf.webgl = {
};
tf.g_WebGL = null;
tf.webgl.GetWebGL = function () { if (!tf.g_WebGL) { tf.g_WebGL = new tf.webgl.WebGL(); } return tf.g_WebGL; }
tf.webgl.WebGL = function (settings) {
    var theThis, contextName, requestAnimFrame, cancelAnimFrame;
    this.RequestAnimFrame = function (callback, element) {
        return tf.js.GetFunctionOrNull(callback) ? requestAnimFrame(callback, element) : undefined;
    }
    this.CancelAnimFrame = function (requestID) { return requestID !== undefined ? cancelAnimFrame(requestID) : undefined; }
    this.GetHasWebGL = function () { return getHasWebGL(); }
    this.GetContextName = function () { return contextName; }
    function getHasWebGL() { return contextName !== undefined; }
    function getContextName() {
        var contextNames = ['experimental-webgl', 'webgl', 'webkit-3d', 'moz-webgl'];
        var canvas = document.createElement('canvas');
        for (var i in contextNames) {
            try {
                var cn = contextNames[i], context = canvas.getContext(cn);
                if (!!context && tf.js.GetFunctionOrNull(context.getParameter)) {
                    contextName = cn;
                    break;
                }
            }
            catch (e) { }
        }
    }
    function initialize() {
        requestAnimFrame = window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                function (/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {
                    return window.setTimeout(callback, 1000 / 60);
                };
        cancelAnimFrame = window.cancelAnimationFrame ||
                window.webkitCancelAnimationFrame ||
                window.mozCancelAnimationFrame ||
                window.oCancelAnimationFrame ||
                window.msCancelAnimationFrame ||
                window.clearTimeout;
        if (window.WebGLRenderingContext) {
            getContextName();
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: context.js
tf.webgl.Context = function (settings) {
    var theThis, webgl, context, canvas, lostListener, restoredListener, lastRequestID, frameCallBack, lostCallBack, restoredCallBack;
    var shaderSettings, textureColorFS, textureColorVS, textureColorProgram,
        textureColorPickFS, textureColorPickVS, textureColorPickProgram, materialFS, materialVS, materialProgram, WEBGL_lose_context;
    var fourColorTexture, isContextLost;
    var shaders, programs;
    var texture2sCollection, buffersCollection, frameBuffersCollection, pickCollection;
    var onePixelTransparentCanvas, onePixelTransparentTexture;
    this.RegisterTexture2 = function (texture2) { return texture2sCollection.Add(texture2); }
    this.UnRegisterTexture2 = function (textureId) { return texture2sCollection.Del(textureId); }
    this.RegisterBuffer = function (buffer) { return buffersCollection.Add(buffer); }
    this.UnRegisterBuffer = function (bufferId) { return buffersCollection.Del(bufferId); }
    this.RegisterFrameBuffer = function (frameBuffer) { return frameBuffersCollection.Add(frameBuffer); }
    this.UnRegisterFrameBuffer = function (frameBufferId) { return frameBuffersCollection.Del(frameBufferId); }
    this.RegisterForPick = function (object) { return pickCollection.Add(object); }
    this.UnRegisterForPick = function (objectId) {
        return pickCollection.Del(objectId);
    }
    this.GetPickObject = function (objectId) { return pickCollection.Get(objectId); }
    this.IsContextLost = function () { return isContextLost; }
    this.LoseContext = function () { return loseContext(); }
    this.RestoreContext = function () { return restoreContext(); }
    this.IsDeleted = function () { return isDeleted(); }
    this.OnDelete = function () { return onDelete(); }
    this.GetOnePixelTransparentCanvas = function () { return getOnePixelTransparentCanvas(); }
    this.GetOnePixelTransparentTexture = function () { return getOnePixelTransparentTexture(); }
    this.GetFourColorTexture = function () {
        if (!fourColorTexture) { fourColorTexture = createFourColorTexture(); }
        return fourColorTexture;
    }
    this.GetMaterialFS = function () {
        if (!materialFS) { materialFS = createShaderObject(tf.webgl.MaterialFS); }
        return materialFS;
    }
    this.GetMaterialVS = function () {
        if (!materialVS) { materialVS = createShaderObject(tf.webgl.MaterialVS); }
        return materialVS;
    }
    this.GetMaterialProgram = function () {
        if (!materialProgram) { materialProgram = createShaderProgram(tf.webgl.MaterialProgram); }
        return materialProgram;
    }
    this.GetTextureColorFS = function () {
        if (!textureColorFS) { textureColorFS = createShaderObject(tf.webgl.TextureColorFS); }
        return textureColorFS;
    }
    this.GetTextureColorVS = function () {
        if (!textureColorVS) { textureColorVS = createShaderObject(tf.webgl.TextureColorVS); }
        return textureColorVS;
    }
    this.GetTextureColorProgram = function () {
        if (!textureColorProgram) { textureColorProgram = createShaderProgram(tf.webgl.TextureColorProgram); }
        return textureColorProgram;
    }
    this.GetTextureColorPickFS = function () {
        if (!textureColorPickFS) { textureColorPickFS = createShaderObject(tf.webgl.TextureColorPickFS); }
        return textureColorPickFS;
    }
    this.GetTextureColorPickVS = function () {
        if (!textureColorPickVS) { textureColorPickVS = createShaderObject(tf.webgl.TextureColorPickVS); }
        return textureColorPickVS;
    }
    this.GetTextureColorPickProgram = function () {
        if (!textureColorPickProgram) { textureColorPickProgram = createShaderProgram(tf.webgl.TextureColorPickProgram); }
        return textureColorPickProgram;
    }
    this.GetContext = function () { return context; }
    this.GetCanvas = function () { return canvas; }
    this.RequestAnimFrame = function () { return requestAnimFrame(); }
    this.CancelAnimFrame = function () { return cancelAnimFrame(); }
    function isDeleted() { return context == undefined; }
    function onDelete() {
        if (!isDeleted()) {
            if (!!lostListener) { lostListener.OnDelete(); }
            if (!!restoredListener) { restoredListener.OnDelete(); }
            if (!!programs) { for (var i in programs) { programs[i].OnDelete(); } }
            if (!!onePixelTransparentTexture) { onePixelTransparentTexture.OnDelete(); }
            if (!!fourColorTexture) { fourColorTexture.OnDelete(); }
            if (!!pickCollection) { pickCollection.Empty(); }
            if (!!texture2sCollection) { texture2sCollection.Empty(); }
            if (!!buffersCollection) { buffersCollection.Empty(); }
            if (!!frameBuffersCollection) { frameBuffersCollection.Empty(); }
            pickCollection = texture2sCollection = buffersCollection = frameBuffersCollection =
                fourColorTexture = onePixelTransparentTexture = programs = lostListener = restoredListener = context = undefined;
        }
    }
    function createShaderObject(type, isProgram) {
        var shaderObject = isDeleted() ? undefined : new type(shaderSettings);
        if (shaderObject !== undefined && !isProgram) { shaders.push(shaderObject); }
        return shaderObject;
    }
    function createShaderProgram(type) {
        var shaderProgram = createShaderObject(type, true);
        if (!!shaderProgram) { programs.push(shaderProgram); }
        return shaderProgram;
    }
    function loseContext() { if (!isDeleted()) { if (!!WEBGL_lose_context) { WEBGL_lose_context.loseContext(); } } }
    function restoreContext() { if (!isDeleted()) { if (!!WEBGL_lose_context) { WEBGL_lose_context.restoreContext(); } } }
    function getOnePixelTransparentCanvas() {
        if (!isDeleted()) {
            if (!onePixelTransparentCanvas) {
                onePixelTransparentCanvas = document.createElement('canvas');
                onePixelTransparentCanvas.width = onePixelTransparentCanvas.height = 1;
                var ctx = onePixelTransparentCanvas.getContext('2d');
                ctx.beginPath(); ctx.clearRect(-1, -1, 2, 2); ctx.closePath();
            }
        }
        return onePixelTransparentCanvas;
    }
    function getOnePixelTransparentTexture() {
        if (!isDeleted()) {
            if (!onePixelTransparentTexture) {
                onePixelTransparentTexture = new tf.webgl.Texture2({ context: theThis, img: getOnePixelTransparentCanvas(), flipVerticalBool: false });
            }
        }
        return onePixelTransparentTexture;
    }
    function createFourColorTexture() {
        var texture;
        if (!isDeleted()) {
            var canvas = document.createElement('canvas');
            var ctx = canvas.getContext('2d');
            canvas.width = canvas.height = 2;
            ctx.beginPath();
            ctx.fillStyle = "#f00"; ctx.fillRect(0, 0, 1, 1);
            ctx.fillStyle = "#0f0"; ctx.fillRect(1, 0, 1, 1);
            ctx.fillStyle = "#00f"; ctx.fillRect(0, 1, 1, 1);
            ctx.fillStyle = "#ff0"; ctx.fillRect(1, 1, 1, 1);
            //ctx.strokeStyle = "#000"; ctx.strokeRect(0, 0, 1, 1);
            ctx.closePath();
            texture = new tf.webgl.Texture2({ context: theThis, img: canvas, flipVerticalBool: true });
        }
        return texture;
    }
    function requestAnimFrame() {
        if (!isDeleted()) {
            cancelAnimFrame(); lastRequestID = !!webgl ? webgl.RequestAnimFrame(frameCallBack, canvas) : undefined;
        }
    }
    function cancelAnimFrame() {
        if (!isDeleted) {
            if (!!webgl && lastRequestID !== undefined) { webgl.CancelAnimFrame(lastRequestID); lastRequestID = undefined; }
        }
    }
    function onContextLost(e) {
        e.preventDefault();
        isContextLost = true;
        cancelAnimFrame();
        var onLostDevice = function (obj) { obj.OnLostDevice(); }
        frameBuffersCollection.ForEach(onLostDevice);
        buffersCollection.ForEach(onLostDevice);
        texture2sCollection.ForEach(onLostDevice);
        for (var i in shaders) { shaders[i].OnLostDevice(); }
        for (var i in programs) { programs[i].OnLostDevice(); }
        if (!!lostCallBack) { lostCallBack({ sender: theThis }); }
    }
    function onContextRestored() {
        isContextLost = false;
        initContext();
        var onRestoredDevice = function (obj) { obj.OnRestoredDevice(); }
        frameBuffersCollection.ForEach(onRestoredDevice);
        buffersCollection.ForEach(onRestoredDevice);
        texture2sCollection.ForEach(onRestoredDevice);
        for (var i in shaders) { shaders[i].OnRestoredDevice(); }
        for (var i in programs) { programs[i].OnRestoredDevice(); }
        if (!!restoredCallBack) { restoredCallBack({ sender: theThis }); }
    }
    function initContext() {
        context = canvas.getContext(webgl.GetContextName(), settings.optionalAttributes);
        isContextLost = context.isContextLost();
        WEBGL_lose_context = context.getExtension('WEBGL_lose_context');
        context.getExtension("OES_element_index_uint");
        context.getExtension('OES_standard_derivatives');
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (webgl = tf.webgl.GetWebGL()) {
            if (webgl.GetHasWebGL()) {
                shaders = [];
                programs = [];
                pickCollection = new tf.js.Collection();
                texture2sCollection = new tf.js.Collection({ type: tf.webgl.Texture2 });
                buffersCollection = new tf.js.Collection({ type: tf.webgl.ArrayBuffer });
                frameBuffersCollection = new tf.js.Collection({ type: tf.webgl.FrameBuffer });
                shaderSettings = { context: theThis, debug: true };
                frameCallBack = tf.js.GetFunctionOrNull(settings.onFrame);
                lostCallBack = tf.js.GetFunctionOrNull(settings.onLost);
                restoredCallBack = tf.js.GetFunctionOrNull(settings.onRestored);
                canvas = document.createElement('canvas');
                lostListener = new tf.events.AddDOMEventListener(canvas, 'webglcontextlost', onContextLost);
                restoredListener = new tf.events.AddDOMEventListener(canvas, 'webglcontextrestored', onContextRestored);
                initContext();
            }
            else { webgl = undefined; }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: material.js
tf.webgl.Material = function (settings) {
    var theThis;
    this.GetSettings = function () { return settings; }
    this.SetUniforms = function (ctx, uniformLocations) { return setUniforms(ctx, uniformLocations); }
    function setColor(ctx, colorLoc, color) {
        if (!!colorLoc) { ctx.uniform3f(colorLoc, color[0], color[1], color[2]); }
    }
    function setUniforms(ctx, uniformLocations) {
        if (tf.js.GetIsValidObject(uniformLocations) && !!ctx) {
            if (!!uniformLocations.opacityShininessLoc) {
                ctx.uniform4f(uniformLocations.opacityShininessLoc, settings.opacityF, settings.shininessF, 0, 0);
            }
            setColor(ctx, uniformLocations.ambientColor3Loc, settings.ambientColor3);
            setColor(ctx, uniformLocations.diffuseColor3Loc, settings.diffuseColor3);
            setColor(ctx, uniformLocations.emissiveColor3Loc, settings.emissiveColor3);
            setColor(ctx, uniformLocations.specularColor3Loc, settings.specularColor3);
        }
    }
    function getColor(fromColor, defaultColor) {
        var theColor;
        if (fromColor !== undefined) {
            if (tf.js.GetIsArrayWithMinLength(fromColor, 3)) {
                if (tf.js.GetFunctionOrNull(fromColor.slice)) { theColor = fromColor.slice(0); }
                else { theColor = [fromColor[0], fromColor[1], fromColor[2]]; }
            }
            else if (tf.js.GetIsValidObject(fromColor)) {
                fromColor[0] = tf.js.GetFloatNumberInRange(fromColor.r, 0, 1, defaultColor[0]);
                fromColor[1] = tf.js.GetFloatNumberInRange(fromColor.r, 0, 1, defaultColor[1]);
                fromColor[2] = tf.js.GetFloatNumberInRange(fromColor.r, 0, 1, defaultColor[2]);
            }
        }
        else { theColor = defaultColor; }
        return theColor;
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        settings.name = tf.js.GetNonEmptyString(settings.name, "unnamed");
        settings.opacityF = tf.js.GetFloatNumberInRange(settings.opacity, 0, 1, 1);
        settings.shininessF = tf.js.GetFloatNumberInRange(settings.shininess, 0, 1, 1);
        settings.ambientColor3 = getColor(settings.ambient, [1, 1, 1]);
        settings.diffuseColor3 = getColor(settings.diffuse, [0, 0, 0]);
        settings.emissiveColor3 = getColor(settings.emissive, [0, 0, 0]);
        settings.specularColor3 = getColor(settings.specular, [1, 1, 1]);
        settings.texFile = tf.js.GetNonEmptyString(settings.texFile);
        delete settings.opacity;
        delete settings.shininess;
        delete settings.ambient;
        delete settings.diffuse;
        delete settings.emissive;
        delete settings.specular;
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: buffers.js
tf.webgl.ArrayBuffer = function (settings) {
    var theThis, context, buffer, data, length, bufferType, isIndices, count, glSize, glType, normalized, stride, offset, contextId;
    this.OnLostDevice = function () { return onLostDevice(); }
    this.OnRestoredDevice = function () { return onRestoredDevice(); }
    this.GetContext = function () { return context; }
    this.GetCtx = function () { return context ? context.GetContext() : undefined ; }
    this.GetLength = function () { return length; }
    this.GetCount = function () { return count; }
    this.GetType = function () { return bufferType; }
    this.IsIndices = function () { return isIndices; }
    this.GetBuffer = function () { return buffer; }
    this.Bind = function (toLocation) { return bind(toLocation); }
    this.Update = function (data) { return update(data); }
    this.GetData = function () { return data; }
    this.OnDelete = function () { return onDelete(); }
    this.IsDeleted = function () { return isDeleted(); }
    function isOperational() { return !isDeleted() && buffer !== undefined; }
    function isDeleted() { return context == undefined; }
    function onDelete() {
        if (!isDeleted()) {
            context.UnRegisterBuffer(contextId);
            contextId = bufferType = context = buffer = undefined;
            count = length = 0;
            isIndices = false;
        }
    }
    function deleteBuffer() {
        if (!isDeleted()) {
            if (buffer != undefined) { var ctx = context.GetContext(); if (!!ctx) { ctx.deleteBuffer(buffer); buffer = undefined; } }
        }
    }
    function onLostDevice() { deleteBuffer(); }
    function onRestoredDevice() {
        if (!isDeleted()) {
            var ctx = context.GetContext();
            buffer = ctx.createBuffer();
            update(settings.data);
        }
    }
    function bind(toLocation) {
        if (isOperational()) {
            var ctx = context.GetContext();
            if (isIndices) {
                ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, buffer);
            }
            else if (toLocation >= 0) {
                ctx.enableVertexAttribArray(toLocation);
                ctx.bindBuffer(ctx.ARRAY_BUFFER, buffer);
                ctx.vertexAttribPointer(toLocation, glSize, glType, normalized, stride, offset);
            }
        }
    }
    function update(data) {
        if (isOperational()) {
            var ctx = context.GetContext();
            var dataType = isIndices ? ctx.STREAM_DRAW : ctx.STATIC_DRAW;
            ctx.bindBuffer(bufferType, buffer);
            ctx.bufferData(bufferType, data, dataType);
            ctx.bindBuffer(bufferType, null);
        }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        length = 0;
        if (tf.js.GetIsNonEmptyArray(settings.data)) {
            if (tf.js.GetIsInstanceOf(settings.context, tf.webgl.Context) && !!settings.context.GetContext()) {
                context = settings.context;
                data = settings.data;
                length = data.length;
                isIndices = !!settings.isIndices;
                glSize = settings.glSize !== undefined ? tf.js.GetIntNumberInRange(settings.glSize, 1, 999999999, 1) : 1;
                normalized = settings.normalized !== undefined ? !!settings.normalized : false;
                stride = settings.stride !== undefined ? tf.js.GetIntNumberInRange(settings.stride, 0, 999999999, 0) : 0;
                offset = settings.offset !== undefined ? tf.js.GetIntNumberInRange(settings.offset, 0, 999999999, 0) : 0;
                var ctx = context.GetContext();
                bufferType = isIndices ? ctx.ELEMENT_ARRAY_BUFFER : ctx.ARRAY_BUFFER;
                if (!isIndices) {
                    glType = settings.glType !== undefined ? settings.glType : ctx.FLOAT;
                    count = Math.floor(length / glSize);
                }
                else { count = length; }
                contextId = context.RegisterBuffer(theThis);
                onRestoredDevice();
            }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.webgl.PosBuffer = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsNonEmptyArray(settings.data)) {
            settings.glSize = 3;
            if (settings.data.length % settings.glSize != 0) { tf.GetDebug().LogIfTest("tf.webgl.PosBuffer: Data length not multiple of " + settings.glSize); }
            settings.isIndices = false;
            tf.webgl.ArrayBuffer.call(theThis, settings);
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.PosBuffer, tf.webgl.ArrayBuffer);
tf.webgl.NorBuffer = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsNonEmptyArray(settings.data)) {
            settings.glSize = 3;
            if (settings.data.length % settings.glSize != 0) { tf.GetDebug().LogIfTest("tf.webgl.NorBuffer: Data length not multiple of " + settings.glSize); }
            settings.isIndices = false;
            tf.webgl.ArrayBuffer.call(theThis, settings);
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.NorBuffer, tf.webgl.ArrayBuffer);
tf.webgl.Tex2DBuffer = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsNonEmptyArray(settings.data)) {
            settings.glSize = 2;
            if (settings.data.length % settings.glSize != 0) {
                tf.GetDebug().LogIfTest("tf.webgl.Tex2DBuffer: Data length not multiple of " + settings.glSize);
            }
            settings.isIndices = false;
            tf.webgl.ArrayBuffer.call(theThis, settings);
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.Tex2DBuffer, tf.webgl.ArrayBuffer);
tf.webgl.IndexBuffer = function (settings) {
    var theThis, indexType;
    this.Draw = function (useLines) {
        if (!theThis.IsDeleted()) {
            var ctx = theThis.GetCtx();
            if (!!ctx) {
                ctx.drawElements((!!useLines ? ctx.LINES : ctx.TRIANGLES), theThis.GetLength(), indexType, 0);
                //ctx.drawElements(ctx.LINES, theThis.GetLength(), indexType, 0);
            }
        }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsNonEmptyArray(settings.data)) {
            settings.isIndices = true;
            tf.webgl.ArrayBuffer.call(theThis, settings);
            if (!theThis.IsDeleted()) {
                var ctx = theThis.GetCtx();
                if (!!settings.is8) { indexType = ctx.UNSIGNED_BYTE; }
                else if (!!settings.is16) { indexType = ctx.UNSIGNED_SHORT; }
                else if (!!settings.is32) { indexType = ctx.UNSIGNED_INT; }
                else { indexType = ctx.UNSIGNED_BYTE; }
            }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.IndexBuffer, tf.webgl.ArrayBuffer);

// SOURCE FILE: vertexformats.js
tf.webgl.MergeBuffers = function (vertexBuffers) {
    var mergedBuffer;
    //return;
    function addBuffers(newPos, newNor, newTex2, newIndices, v, posIndex, indexIndex) {
        var pos = v.GetPos(), ind = v.GetIndices();
        var nor = v.GetNor(), tex2 = v.GetTex2D();
        var nVertices = pos.GetLength(), nIndices = ind.GetLength();
        var posData = pos.GetData(), indexData = ind.GetData();
        var norData = !!nor ? nor.GetData() : undefined;
        for (var j = 0 ; j < nVertices ; ++j) {
            var destIndex = posIndex + j;
            newPos[destIndex] = posData[j];
            if (!!norData) { newNor[destIndex] = norData[j]; } else { newNor[destIndex] = 1; }
        }
        if (newTex2) {
            var nTex2 = Math.floor(nVertices * 2 / 3);
            var tex2Data = !!tex2 ? tex2.GetData() : undefined;
            for (var j = 0 ; j < nTex2 ; ++j) {
                var destIndex = posIndex + j;
                if (!!tex2Data) { newTex2[destIndex] = tex2Data[j]; } else { newTex2[destIndex] = 0; }
            }
        }
        var offIndex = posIndex / 3;
        for (var j = 0 ; j < nIndices ; ++j) {
            newIndices[indexIndex + j] = indexData[j] + offIndex;
        }
    }
    function addBuffer(v, actualBuffers, desiredContext) {
        var nVertices = 0, nIndices = 0, context = undefined;
        if (tf.js.GetIsInstanceOf(v, tf.webgl.VertexBuffer) && !v.IsDeleted()) {
            var pos = v.GetPos(), ind = v.GetIndices();
            if (!!pos && !!ind) {
                var thisContext = v.GetContext();
                var sameContext = desiredContext == undefined || desiredContext == thisContext;
                if (sameContext) {
                    context = thisContext;
                    nVertices = pos.GetLength(); nIndices = ind.GetLength(); actualBuffers.push(v);
                    if (!hasNor) { hasNor = !!v.GetNor(); }
                    if (!hasTex2) { hasTex2 = !!v.GetTex2D(); }
                }
            }
        }
        return { nVertices: nVertices, nIndices: nIndices, context: context };
    }
    if (tf.js.GetIsValidObject(vertexBuffers)) {
        var totalVertices = 0, totalIndices = 0, hasNor, hasTex2;
        var context;
        var actualBuffers = [];
        for (var i in vertexBuffers) {
            var addResult = addBuffer(vertexBuffers[i], actualBuffers, context);
            if (addResult.nVertices > 0) {
                totalVertices += addResult.nVertices;
                totalIndices += addResult.nIndices;
                context = addResult.context;
            }
        }
        if (!!actualBuffers.length) {
            var newPos = new Float32Array(totalVertices);
            var vertexCount = totalVertices / 3;
            var is8 = vertexCount < 256, is16 = vertexCount < 256 * 256, is32 = !is16;
            var newIndices = is8 ? new Uint8Array(totalIndices) : (is16 ? new Uint16Array(totalIndices) : new Uint32Array(totalIndices));
            var newNor = hasNor ? new Float32Array(totalVertices) : undefined;
            var newTex2 = hasTex2 ? new Float32Array(Math.floor(totalVertices * 2 / 3)) : undefined;
            var posIndex = 0, indexIndex = 0;
            for (var i in actualBuffers) {
                var v = actualBuffers[i];
                addBuffers(newPos, newNor, newTex2, newIndices, v, posIndex, indexIndex);
                posIndex += v.GetPos().GetLength();
                indexIndex += v.GetIndices().GetLength();
            }
            var newPosBuffer = new tf.webgl.PosBuffer({ context: context, data: newPos });
            var newIndexBuffer = new tf.webgl.IndexBuffer({ context: context, data: newIndices, is8: is8, is16: is16, is32: is32 });
            var newNorBuffer = !!newNor ? new tf.webgl.NorBuffer({ context: context, data: newNor }) : undefined;
            var newTex2Buffer = !!newTex2 ? new tf.webgl.Tex2DBuffer({ context: context, data: newTex2 }) : undefined;
            var foundLast;
            for (var i in newIndices) {
                var index = newIndices[i];
                if (index < 0 || index >= vertexCount) {
                    console.log('invalid index');
                }
                if (index == vertexCount - 1) {
                    foundLast = true;
                }
            }
            if (!foundLast) {
                console.log('no last index');
            }
            mergedBuffer = new tf.webgl.VertexBuffer({
                cullFrontFace: false,
                context: context, pos: newPosBuffer, nor: newNorBuffer, tex2d: newTex2Buffer, indices: newIndexBuffer
            });
        }
    }
    return mergedBuffer;
} 
tf.webgl.VertexBuffer = function (settings) {
    var theThis, context, ctx, pos, nor, tex2d, indices;
    this.OnLostDevice = function () {
        if (!isDeleted()) {
            if (!!pos) { pos.OnLostDevice(); }
            if (!!nor) { nor.OnLostDevice(); }
            if (!!tex2d) { tex2d.OnLostDevice(); }
            if (!!indices) { indices.OnLostDevice(); }
            ctx = undefined;
        }
    }
    this.OnRestoredDevice = function () {
        if (!isDeleted()) {
            if (!!pos) { pos.OnRestoredDevice(); }
            if (!!nor) { nor.OnRestoredDevice(); }
            if (!!tex2d) { tex2d.OnRestoredDevice(); }
            if (!!indices) { indices.OnRestoredDevice(); }
            ctx = context.GetContext();
        }
    }
    this.GetContext = function () { return context; }
    this.GetPos = function () { return pos; }
    this.GetNor = function () { return nor; }
    this.GetTex2D = function () { return tex2d; }
    this.GetIndices = function () { return indices; }
    this.BindBuffers = function (posLoc, norLoc, tex2dLoc) { return bindBuffers(posLoc, norLoc, tex2dLoc); }
    this.Draw = function (useLines) { return draw(useLines); }
    this.OnDelete = function (deleteSubBuffers) { return onDelete(deleteSubBuffers); }
    this.IsDeleted = function () { return isDeleted(); }
    function bindBuffers(posLoc, norLoc, tex2dLoc) {
        if (isOperational()) {
            if (posLoc >= 0) { if (!!pos) { pos.Bind(posLoc); } else { ctx.disableVertexAttribArray(posLoc); } }
            if (norLoc >= 0) { if (!!nor) { nor.Bind(norLoc); } else { ctx.disableVertexAttribArray(norLoc); } }
            if (tex2dLoc >= 0) {
                if (!!tex2d) { tex2d.Bind(tex2dLoc); } else {
                    ctx.disableVertexAttribArray(tex2dLoc);
                }
            }
            if (!!indices) { indices.Bind(); }
        }
    }
    function draw(useLines) { if (!isDeleted()) { indices.Draw(useLines); } }
    function isOperational() { return ctx != undefined; }
    function isDeleted() { return context == undefined; }
    function onDelete(deleteSubBuffers) {
        if (!isDeleted()) {
            if (!!deleteSubBuffers) {
                if (!!pos) { pos.OnDelete(); }
                if (!!nor) { nor.OnDelete(); }
                if (!!tex2d) { tex2d.OnDelete(); }
                if (!!indices) { indices.OnDelete(); }
            }
            pos = nor = tex2d = indices = ctx = context = undefined;
        }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsInstanceOf(settings.context, tf.webgl.Context) && !!settings.context.GetContext() &&
            (settings.pos == undefined || tf.js.GetIsInstanceOf(settings.pos, tf.webgl.PosBuffer)) &&
            (settings.nor == undefined || tf.js.GetIsInstanceOf(settings.nor, tf.webgl.NorBuffer)) &&
            (settings.tex2d == undefined || tf.js.GetIsInstanceOf(settings.tex2d, tf.webgl.Tex2DBuffer)) &&
            (settings.indices == undefined || tf.js.GetIsInstanceOf(settings.indices, tf.webgl.IndexBuffer))) {
            context = settings.context;
            ctx = context.GetContext();
            pos = settings.pos;
            nor = settings.nor;
            tex2d = settings.tex2d;
            if (!!pos) {
                var nPos = pos.GetLength();
                if (!!nor) { if (nor.GetLength() != nPos) { tf.GetDebug().LogIfTest('inconsistent number of pos / nor'); } }
                if (!!tex2d) { if (tex2d.GetLength() * 3 / 2 != nPos) { tf.GetDebug().LogIfTest('inconsistent number of pos / tex2d'); } }
            }
            indices = settings.indices;
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.webgl.MatTex2VertCombo = function (settings) {
    var theThis, material, texture2, normalsTexture2, vertices;
    //this.GetHasTexture2 = function () { return texture2 != undefined; }
    //this.SetTexture2 = function (texture2Set) { texture2 = texture2Set; }
    //this.SetTexture2 = function (texture2Set) { texture2 = texture2Set; }
    this.Render = function (ctx, posLoc, norLoc, tex2dLoc, renderSettings, uniformLocations) {
        if (!isDeleted()) {
            if (!!material) { material.SetUniforms(ctx, uniformLocations); }
            var hasTexture = !!texture2 ? 1 : 0, hasNormalTexture = !!normalsTexture2 ? 1 : 0;
            if (hasTexture) { texture2.Bind(); }
            if (hasNormalTexture) { normalsTexture2.Bind(); }
            if (!!uniformLocations.hasTextureLoc) { ctx.uniform1i(uniformLocations.hasTextureLoc, hasTexture); }
            if (!!uniformLocations.hasNormalTextureLoc) { ctx.uniform1i(uniformLocations.hasNormalTextureLoc, hasNormalTexture); }
            for (var i in vertices) {
                var vertex = vertices[i];
                vertex.BindBuffers(posLoc, norLoc, tex2dLoc);
                vertex.Draw(renderSettings.useLines);
            }
        }
    }
    this.GetVertCount = function () { return isDeleted() ? 0 : vertices.length; }
    this.MergeBuffers = function () {
        if (!isDeleted()) {
            if (vertices.length > 1) {
                var newVertices = tf.webgl.MergeBuffers(vertices);
                if (!!newVertices) {
                    deleteAllVertices();
                    vertices = [newVertices];
                }
            }
        }
    }
    this.AddVertexBuffer = function (vertexBuffer) { return addVertexBuffer(vertexBuffer); }
    this.OnDelete = function (deleteTexture, deleteVertices) { return onDelete(deleteTexture, deleteVertices); }
    this.IsDeleted = function () { return isDeleted(); }
    function isDeleted() { return vertices == undefined; }
    function deleteAllVertices() { if (!isDeleted) { for (var i in vertices) { vertices[i].OnDelete(); } vertices = []; } }
    function onDelete(deleteTexture, deleteVertices) {
        if (!isDeleted()) {
            if (!!deleteTexture) {
                if (!!texture2) { texture2.OnDelete(); }
                if (!!normalsTexture2) { normalsTexture2.OnDelete(); }
            }
            if (!!deleteVertices) { deleteAllVertices(); }
            material = texture2 = normalsTexture2 = vertices = undefined;
        }
    }
    function addVertexBuffer(vertexBuffer) {
        if (!isDeleted()) {
            if (tf.js.GetIsInstanceOf(vertexBuffer, tf.webgl.VertexBuffer)) { vertices.push(vertexBuffer); }
            else if (tf.js.GetIsNonEmptyArray(vertexBuffer)) { for (var i in vertexBuffer) { addVertexBuffer(vertexBuffer[i]); } }
        }
    }
    function initialize() {
        if (tf.js.GetIsValidObject(settings)) {
            if (tf.js.GetIsInstanceOf(settings.material, tf.webgl.Material)) { material = settings.material; }
            if (tf.js.GetIsInstanceOf(settings.texture2, tf.webgl.Texture2)) { texture2 = settings.texture2; }
            if (tf.js.GetIsInstanceOf(settings.normalsTexture2, tf.webgl.Texture2)) { normalsTexture2 = settings.normalsTexture2; }
            vertices = [];
            addVertexBuffer(settings.vertices);
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.webgl.MatTex2VertComboList = function (settings) {
    var theThis, list;
    this.Render = function (ctx, posLoc, norLoc, tex2dLoc, renderSettings, uniformLocations) {
        if (!isDeleted()) {
            for (var i in list) {
                list[i].Render(ctx, posLoc, norLoc, tex2dLoc, renderSettings, uniformLocations);
            }
        }
    }
    this.Add = function (matTex2VertCombo) { return add(matTex2VertCombo); }
    this.GetCount = function () { return isDeleted() ? 0 : list.length; }
    this.MergeBuffers = function () { return mergeBuffers(); }
    this.OnDelete = function (deleteItems, deleteTextures, deleteVertices) { return onDelete(deleteItems, deleteTextures, deleteVertices); }
    this.IsDeleted = function () { return isDeleted(); }
    function isDeleted() { return list == undefined; }
    function onDelete(deleteItems, deleteTextures, deleteVertices) {
        if (!isDeleted()) {
            if (!!deleteItems) { for (var i in list) { list[i].OnDelete(deleteTextures, deleteVertices); } }
            list = undefined;
        }
    }
    function add(matTex2VertCombo) {
        if (!isDeleted()) {
            if (tf.js.GetIsInstanceOf(matTex2VertCombo, tf.webgl.MatTex2VertCombo)) { list.push(matTex2VertCombo); }
            else if (tf.js.GetIsNonEmptyArray(matTex2VertCombo)) { for (var i in matTex2VertCombo) { add(matTex2VertCombo[i]); } }
        }
    }
    function mergeBuffers() {
        if (!isDeleted()) {
            var nList = list.length;
            for (var i = 0 ; i < nList ; ++i) {
                list[i].MergeBuffers();
            }
        }
    }
    function initialize() {
        list = [];
        if (tf.js.GetIsValidObject(settings)) {
            add(settings.combos);
            if (!!settings.mergeBuffers) { mergeBuffers(); }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: primitives.js
// quadXY
//  v1------v0
//  |       |
//  |       |
//  v2------v3
tf.webgl.QuadXY = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        var z = 0;
        var vertices = new Float32Array([0.5, 0.5, z, -0.5, 0.5, z, -0.5, -0.5, z, 0.5, -0.5, z]);
        var normals = new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);
        var texCoords = new Float32Array([1, 1, 0, 1, 0, 0, 1, 0]);
        var indices = new Uint8Array([0, 1, 2, 0, 2, 3]);
        tf.webgl.VertexBuffer.call(theThis, {
            context: settings.context,
            pos: new tf.webgl.PosBuffer({ context: settings.context, data: vertices }),
            nor: new tf.webgl.NorBuffer({ context: settings.context, data: normals }),
            tex2d: new tf.webgl.Tex2DBuffer({ context: settings.context, data: texCoords }),
            indices: new tf.webgl.IndexBuffer({ context: settings.context, data: indices, is8: true })
        });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.QuadXY, tf.webgl.VertexBuffer);
// box
//    v6----- v5
//   /|      /|
//  v1------v0|
//  | |     | |
//  | |v7---|-|v4
//  |/      |/
//  v2------v3
tf.webgl.Box = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        var dim = 0.5;
        var vertices = new Float32Array(
            [dim, dim, dim, -dim, dim, dim, -dim, -dim, dim, dim, -dim, dim,    // v0-vdim-v2-v3 front
                dim, dim, dim, dim, -dim, dim, dim, -dim, -dim, dim, dim, -dim,    // v0-v3-v4-v5 right
                dim, dim, dim, dim, dim, -dim, -dim, dim, -dim, -dim, dim, dim,    // v0-v5-v6-vdim top
                -dim, dim, dim, -dim, dim, -dim, -dim, -dim, -dim, -dim, -dim, dim,    // vdim-v6-v7-v2 left
                -dim, -dim, -dim, dim, -dim, -dim, dim, -dim, dim, -dim, -dim, dim,    // v7-v4-v3-v2 bottom
                dim, -dim, -dim, -dim, -dim, -dim, -dim, dim, -dim, dim, dim, -dim]   // v4-v7-v6-v5 back
        );
        var normals = new Float32Array(
            [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,     // v0-v1-v2-v3 front
                1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,     // v0-v3-v4-v5 right
                0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,     // v0-v5-v6-v1 top
                -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0,     // v1-v6-v7-v2 left
                0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0,     // v7-v4-v3-v2 bottom
                0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1]    // v4-v7-v6-v5 back
            );
        var texCoords = new Float32Array(
            [1, 1, 0, 1, 0, 0, 1, 0,    // v0-v1-v2-v3 front
                0, 1, 0, 0, 1, 0, 1, 1,    // v0-v3-v4-v5 right
                1, 0, 1, 1, 0, 1, 0, 0,    // v0-v5-v6-v1 top
                1, 1, 0, 1, 0, 0, 1, 0,    // v1-v6-v7-v2 left
                0, 0, 1, 0, 1, 1, 0, 1,    // v7-v4-v3-v2 bottom
                0, 0, 1, 0, 1, 1, 0, 1]   // v4-v7-v6-v5 back
            );
        var indices = new Uint8Array(
            [0, 1, 2, 0, 2, 3,    // front
                4, 5, 6, 4, 6, 7,    // right
                8, 9, 10, 8, 10, 11,    // top
                12, 13, 14, 12, 14, 15,    // left
                16, 17, 18, 16, 18, 19,    // bottom
                20, 21, 22, 20, 22, 23]   // back
            );
        tf.webgl.VertexBuffer.call(theThis, {
            context: settings.context,
            pos: new tf.webgl.PosBuffer({ context: settings.context, data: vertices }),
            nor: new tf.webgl.NorBuffer({ context: settings.context, data: normals }),
            tex2d: new tf.webgl.Tex2DBuffer({ context: settings.context, data: texCoords }),
            indices: new tf.webgl.IndexBuffer({ context: settings.context, data: indices, is8: true })
        });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.Box, tf.webgl.VertexBuffer);
tf.webgl.Sphere = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        var radius, lats, longs;
        radius = tf.js.GetFloatNumberInRange(settings.radius, 0.00001, 9999999, 0.5);
        lats = tf.js.GetIntNumberInRange(settings.nVer, 3, 100, 10);
        longs = tf.js.GetIntNumberInRange(settings.nHor, 3, 100, 10);
        var geometryData = [];
        var normalData = [];
        var texCoordData = [];
        var indexData = [];
        for (var latNumber = 0; latNumber <= lats; ++latNumber) {
            for (var longNumber = 0; longNumber <= longs; ++longNumber) {
                var theta = latNumber * Math.PI / lats;
                var phi = longNumber * 2 * Math.PI / longs;
                var sinTheta = Math.sin(theta);
                var sinPhi = Math.sin(phi);
                var cosTheta = Math.cos(theta);
                var cosPhi = Math.cos(phi);
                var x = cosPhi * sinTheta;
                var y = cosTheta;
                var z = sinPhi * sinTheta;
                var u = 1 - (longNumber / longs);
                var v = latNumber / lats;
                normalData.push(x);
                normalData.push(y);
                normalData.push(z);
                texCoordData.push(u);
                texCoordData.push(v);
                geometryData.push(radius * x);
                geometryData.push(radius * y);
                geometryData.push(radius * z);
            }
        }
        for (var latNumber = 0; latNumber < lats; ++latNumber) {
            for (var longNumber = 0; longNumber < longs; ++longNumber) {
                var first = (latNumber * (longs + 1)) + longNumber;
                var second = first + longs + 1;
                indexData.push(first);
                indexData.push(first + 1);
                indexData.push(second);
                indexData.push(second);
                indexData.push(first + 1);
                indexData.push(second + 1);
            }
        }
        tf.webgl.VertexBuffer.call(theThis, {
            context: settings.context,
            pos: new tf.webgl.PosBuffer({ context: settings.context, data: new Float32Array(geometryData) }),
            nor: new tf.webgl.NorBuffer({ context: settings.context, data: new Float32Array(normalData) }),
            tex2d: new tf.webgl.Tex2DBuffer({ context: settings.context, data: new Float32Array(texCoordData) }),
            indices: new tf.webgl.IndexBuffer({ context: settings.context, data: new Uint16Array(indexData), is16: true })
        });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.Sphere, tf.webgl.VertexBuffer);
tf.webgl.UVPrimitiveGenerator = function (settings) {
    var primitive;
    if (tf.js.GetIsValidObject(settings) && tf.js.GetIsInstanceOf(settings.context, tf.webgl.Context) && !!settings.context.GetContext()) {
        var getUVVertexCallBack;
        if (!!(getUVVertexCallBack = tf.js.GetFunctionOrNull(settings.getUVVertex))) {
            var context = settings.context;
            var defaultNQuads = 10;
            var nHorQuads = settings.nHor !== undefined ? tf.js.GetIntNumberInRange(settings.nHor, 1, 99999, defaultNQuads) : defaultNQuads;
            var nVerQuads = settings.nVer !== undefined ? tf.js.GetIntNumberInRange(settings.nVer, 1, 99999, defaultNQuads) : defaultNQuads;
            var fillCW = !!settings.fillCW;
            var nVertexRows = nVerQuads + 1;
            var nVerticesPerRow = nHorQuads + 1;
            var nFacesPerRow = 2 * nHorQuads;
            var nVertices = nVertexRows * nVerticesPerRow;
            var nVertexCoords = nVertices * 3;
            var nFaces = nFacesPerRow * nVerQuads;
            var nIndices = nFaces * 3;
            var is16 = nIndices > 255;
            var pos = new Float32Array(nVertexCoords);
            var nor = new Float32Array(nVertexCoords);
            var tex2d = new Float32Array(2 * nVertices);
            var indices = is16 ? new Uint16Array(nIndices) : new Uint8Array(nIndices);
            var vertexIndex = 0, textureIndex = 0, indexIndex = 0;
            var normalVec = new tf.math.Vector3();
            for (var iVertexRow = 0 ; iVertexRow < nVertexRows ; ++iVertexRow) {
                var tex2dY = iVertexRow / nVerQuads;
                for (var iVertexCol = 0 ; iVertexCol < nVerticesPerRow ; ++iVertexCol) {
                    var tex2dX = iVertexCol / nHorQuads;
                    var vertex = getUVVertexCallBack({col: iVertexCol, row: iVertexRow, nCols: nVerticesPerRow, nRows: nVertexRows, u: tex2dX, v: tex2dY});
                    pos[vertexIndex + 0] = vertex.pos.x;
                    pos[vertexIndex + 1] = vertex.pos.y;
                    pos[vertexIndex + 2] = vertex.pos.z;
                    normalVec.Update(vertex.nor);
                    normalVec.Normalize();
                    nor[vertexIndex++] = normalVec[0];
                    nor[vertexIndex++] = normalVec[1];
                    nor[vertexIndex++] = normalVec[2];
                    //nor[vertexIndex++] = vertex.nor.x;
                    //nor[vertexIndex++] = vertex.nor.y;
                    //nor[vertexIndex++] = vertex.nor.z;
                    tex2d[textureIndex++] = tex2dX;
                    tex2d[textureIndex++] = tex2dY;
                }
            }
            for (var row = 0; row < nVerQuads; ++row) {
                for (var col = 0; col < nHorQuads; ++col) {
                    var first = (row * (nHorQuads + 1)) + col;
                    var second = first + nHorQuads + 1;
                    if (fillCW) {
                        indices[indexIndex++] = first;
                        indices[indexIndex++] = first + 1;
                        indices[indexIndex++] = second;
                        indices[indexIndex++] = second;
                        indices[indexIndex++] = first + 1;
                        indices[indexIndex++] = second + 1;
                    }
                    else {
                        indices[indexIndex++] = first;
                        indices[indexIndex++] = second;;
                        indices[indexIndex++] = first + 1
                        indices[indexIndex++] = second;
                        indices[indexIndex++] = second + 1;
                        indices[indexIndex++] = first + 1;
                    }
                }
            }
            primitive = new tf.webgl.VertexBuffer({
                context: context,
                pos: new tf.webgl.PosBuffer({ context: context, data: pos }),
                nor: new tf.webgl.NorBuffer({ context: context, data: nor }),
                tex2d: new tf.webgl.Tex2DBuffer({ context: context, data: tex2d }),
                indices: new tf.webgl.IndexBuffer({ context: context, data: indices, is16: is16 })
            });
        }
    }
    return primitive;
};
tf.webgl.UVSphere = function (settings) {
    var primitive, radius;
    function getUVVertex(settings) {
        var verticalAngle = Math.PI * settings.v;
        var horizontalAngle = Math.PI * 2 * (1 - settings.u);
        var sinHor = Math.sin(horizontalAngle), cosHor = Math.cos(horizontalAngle);
        var sinVer = Math.sin(verticalAngle), cosVer = Math.cos(verticalAngle);
        var x = cosHor * sinVer;
        var y = cosVer;
        var z = sinHor * sinVer;
        return {
            pos: { x: x * radius, y: y * radius, z: z * radius },
            nor: { x: x, y: y, z: z }
        }
    }
    if (tf.js.GetIsValidObject(settings)) {
        radius = tf.js.GetFloatNumberInRange(settings.radius, 0.000001, 9999999, 0.5);
        primitive = new tf.webgl.UVPrimitiveGenerator({
            context: settings.context,
            isClosed: false,
            nHor: settings.nHor,
            nVer: settings.nVer,
            fillCW: settings.fillCW,
            getUVVertex: getUVVertex
        });
    }
    return primitive;
};

// SOURCE FILE: texture2.js
tf.webgl.Texture2 = function (settings) {
    var theThis, context, ctx, texture, img, flipVerticalBool, contextId, unit;
    this.GetTexture = function () { return texture; }
    this.Bind = function () { return bind(); }
    this.UpdateFromImage = function (img, flipVerticalBool) { return updateFromImage(img, flipVerticalBool); }
    this.OnLostDevice = function () { return onLostDevice(); }
    this.OnRestoredDevice = function () { return onRestoredDevice(); }
    this.OnDelete = function () { return onDelete(); }
    this.IsDeleted = function () { return isDeleted(); }
    function isDeleted() { return context == undefined; }
    function onDelete() {
        if (!isDeleted()) {
            context.UnRegisterTexture2(contextId);
            contextId = context = texture = img = undefined;
        }
    }
    function isOperational() { return !isDeleted() && texture !== undefined; }
    function onLostDevice() {
        if (!isDeleted()) {
            ctx = texture = undefined;
        }
    }
    function onRestoredDevice() {
        if (!isDeleted()) {
            ctx = context.GetContext();
            if (!!ctx) { texture = ctx.createTexture(); }
            doUpdateFromImage();
        }
    }
    function bind() {
        if (isOperational()) {
            //var ctx = context.GetContext();
            ctx.activeTexture(ctx.TEXTURE0 + unit);
            ctx.bindTexture(ctx.TEXTURE_2D, texture);
            ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE);
            ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);
            //ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.REPEAT);
            //ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.REPEAT);
            ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.LINEAR);
            ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.LINEAR);
        }
    }
    function doUpdateFromImage() {
        if (isOperational() && img !== undefined) {
            //var ctx = context.GetContext();
            ctx.activeTexture(ctx.TEXTURE0 + unit);
            ctx.bindTexture(ctx.TEXTURE_2D, texture);
            ctx.pixelStorei(ctx.UNPACK_FLIP_Y_WEBGL, !!flipVerticalBool);
            ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE);
            ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);
            ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.LINEAR);
            ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.LINEAR);
            ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, ctx.RGBA, ctx.UNSIGNED_BYTE, img);
            if (!!settings.mipMaps) { ctx.generateMipmap(ctx.TEXTURE_2D); }
            //ctx.generateMipmap(ctx.TEXTURE_2D);
            ctx.bindTexture(ctx.TEXTURE_2D, null);
        }
    }
    function setImg(imgSet, flipVerticalBoolSet) {
        img = tf.js.GetIsValidObject(imgSet) ? imgSet : undefined;
        flipVerticalBool = tf.js.GetBoolFromValue(flipVerticalBoolSet, true);
    }
    function updateFromImage(img, flipVerticalBool) { setImg(img, flipVerticalBool); doUpdateFromImage(); }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsInstanceOf(settings.context, tf.webgl.Context) && !!settings.context.GetContext()) {
            context = settings.context;
            ctx = context.GetContext();
            contextId = context.RegisterTexture2(theThis);
            unit = tf.js.GetIntNumberInRange(settings.unit, 0, 1000, 0);
            if (tf.js.GetIsNonEmptyString(settings.url)) {
                setImg(context.GetOnePixelTransparentCanvas(), settings.flipVerticalBool);
                onRestoredDevice();
                new tf.dom.Img({
                    crossOrigin: true, src: settings.url,
                    onLoad: function (imgLoaded) {
                        if (imgLoaded.GetIsValid()) {
                            setImg(imgLoaded.GetImg(), flipVerticalBool);
                            onRestoredDevice();
                        }
                    }
                });
            }
            else {
                setImg(settings.img, settings.flipVerticalBool);
                onRestoredDevice();
            }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: scene.js
tf.webgl.SceneObject = function (settings) {
    var theThis, context, program, attributes, texture, objectToSceneMatrix, useLines, subObjects, material, onPreRenderCallBack;
    var isVisible, subObjectsAreVisible, cullFaceBool, cullFrontFaceBool, useDepth, usesNonUniformScaling, pickColor, combinedWorldMatrix, comboList, renderMatrix;
    this.SetRenderMatrix = function (renderMatrixSet) { renderMatrix = renderMatrixSet; }
    this.GetRenderMatrix = function (renderMatrixSet) { return renderMatrix; }
    this.OnPreRender = function (onPreRenderSettings) { return onPreRender(onPreRenderSettings); }
    this.SeUsesNonUniformScaling = function (bool) { usesNonUniformScaling = !!bool; }
    this.GetUsesNonUniformScaling = function () { return usesNonUniformScaling; }
    this.SetUseDepth = function (bool) { useDepth = !!bool; }
    this.GetUseDepth = function () { return useDepth; }
    this.GetPickColor = function () { return pickColor; }
    this.SetPickColor = function (newPickColor) { pickColor = newPickColor; }
    this.GetIsVisible = function () { return isVisible; }
    this.SetIsVisible = function (bool) { return isVisible = !!bool; }
    this.GetAreSubObjectsVisible = function () { return subObjectsAreVisible; }
    this.SetAreSubObjectsVisible = function (bool) { return subObjectsAreVisible = !!bool; }
    this.GetAttributes = function () { return attributes; }
    this.GetComboList = function () { return comboList; }
    this.GetObjectToSceneMatrix = function () { return objectToSceneMatrix; }
    this.RenderSelf = function (renderSettings) { return renderSelf(renderSettings); }
    this.AddSubObject = function (subObject) {
        if (!theThis.IsDeleted() && tf.js.GetIsInstanceOf(subObject, tf.webgl.SceneObject)) {
            subObjects.push(subObject);
        }
    }
    this.DelSubObject = function (subObject) {
        if (!theThis.IsDeleted() && tf.js.GetIsInstanceOf(subObject, tf.webgl.SceneObject)) {
            var index = subObjects.find(subObject);
            if (index != -1) { subObject.splice(index, 1); }
        }
    }
    this.GetSubObjects = function () { return subObjects; }
    this.DelAllSubObjects = function () { if (!theThis.IsDeleted()) { subObjects = []; } }
    this.SetOnPreRender = function(onPreRenderSet) {
        onPreRenderCallBack = tf.js.GetFunctionOrNull(onPreRenderSet);
    }
    this.OnDelete = function (delSubObjects, delVertexAndTextures, delVertexSubBuffers) { return onDelete(delSubObjects, delVertexAndTextures, delVertexSubBuffers); }
    this.IsDeleted = function () { return isDeleted(); }
    function isDeleted() { return context == undefined; }
    function onDelete(delSubObjects, delVertexAndTextures, delVertexSubBuffers) {
        if (!isDeleted()) {
            if (!!delSubObjects) {
                for (var i in subObjects) { subObjects[i].OnDelete(delSubObjects, delVertexAndTextures, delVertexSubBuffers); }
            }
            if (!!delVertexAndTextures) {
                if (!!attributes) { attributes.OnDelete(delVertexSubBuffers); }
                if (!!texture) { texture.OnDelete(); }
            }
            renderMatrix = combinedWorldMatrix = subObjects = program = attributes = material = texture = objectToSceneMatrix = context = undefined;
        }
    }
    function onPreRender(onPreRenderSettings) {
        if (!isDeleted()) {
            renderMatrix = undefined;
            if (isVisible) {
                var parentObjectToSceneMatrix = onPreRenderSettings.parentObjectToSceneMatrix;
                if (!!onPreRenderCallBack) { onPreRenderCallBack(theThis); }
                combinedWorldMatrix.CopyFrom(parentObjectToSceneMatrix);
                combinedWorldMatrix.MultByMatrix(objectToSceneMatrix);
                if (!!program) {
                    var point = new tf.math.Vector3([0, 0, 0]);
                    point.MultByMatrix(combinedWorldMatrix);
                    /*var length = new tf.math.Vector3([1, 1, 1]);
                    length.MultByMatrix(combinedWorldMatrix);*/
                    var frustumVisible = onPreRenderSettings.frustum.GetIsPointVisible(point);
                    onPreRenderSettings.toRender.push({ sceneObject: theThis, objectToSceneMatrix: combinedWorldMatrix, frustumVisible: frustumVisible });
                }
                if (subObjectsAreVisible) {
                    for (var i in subObjects) {
                        onPreRenderSettings.parentObjectToSceneMatrix = combinedWorldMatrix;
                        subObjects[i].OnPreRender(onPreRenderSettings);
                    }
                    onPreRenderSettings.parentObjectToSceneMatrix = parentObjectToSceneMatrix;
                }
            }
        }
    }
    function renderSelf(renderSettings) {
        if (!isDeleted()) {
            if (isVisible) {
                var ctx = context.GetContext();
                var scene = renderSettings.scene;
                var useProgram = renderSettings.useProgram;
                var isForPick = renderSettings.isForPick;
                if (!!program) {
                    if (!isForPick || !!pickColor) {
                        if (!!cullFaceBool) { ctx.enable(ctx.CULL_FACE); if (!!cullFrontFaceBool) { ctx.cullFace(ctx.FRONT); } else { ctx.cullFace(ctx.BACK); } }
                        else { ctx.disable(ctx.CULL_FACE); }
                        if (!!useDepth) { ctx.enable(ctx.DEPTH_TEST); } else { ctx.disable(ctx.DEPTH_TEST); }
                        //ctx.disable(ctx.DEPTH_TEST);
                        //ctx.disable(ctx.CULL_FACE);
                        if (useProgram == undefined) { useProgram = program; }
                        useProgram.Render({
                            usesNonUniformScaling: usesNonUniformScaling || renderSettings.usesNonUniformScaling,
                            comboList: comboList,
                            attributes: attributes,
                            texture: texture,
                            material: material,
                            scene: scene,
                            objectToSceneMatrix: renderMatrix,
                            useLines: renderSettings.useLines || useLines,
                            //useLines: true,
                            pickColor: pickColor
                        });
                    }
                }
                if (subObjectsAreVisible && !!renderSettings.renderSubObjects) {
                    var savedUsesNonUniformScaling = renderSettings.usesNonUniformScaling;
                    renderSettings.usesNonUniformScaling |= usesNonUniformScaling;
                    for (var i in subObjects) { subObjects[i].RenderSelf(renderSettings); }
                    renderSettings.usesNonUniformScaling = savedUsesNonUniformScaling;
                }
            }
        }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsInstanceOf(settings.context, tf.webgl.Context) && !!settings.context.GetContext()) {
            objectToSceneMatrix = new tf.math.WorldMatrix4(settings);
            combinedWorldMatrix = new tf.math.WorldMatrix4();
            context = settings.context;
            subObjects = [];
            isVisible = !tf.js.GetIsFalseNotUndefined(settings.isVisible);
            subObjectsAreVisible = !tf.js.GetIsFalseNotUndefined(settings.subObjectsAreVisible);
            if (tf.js.GetIsInstanceOf(settings.program, tf.webgl.Program)) {
                cullFaceBool = settings.cullFace !== undefined ? !!settings.cullFace : true;
                cullFrontFaceBool = settings.cullFrontFace !== undefined ? !!settings.cullFrontFace : false;
                useLines = !!settings.useLines;
                useDepth = !tf.js.GetIsFalseNotUndefined(settings.useDepth);
                usesNonUniformScaling = !!settings.usesNonUniformScaling;
                program = settings.program;
                comboList = tf.js.GetIsInstanceOf(settings.comboList, tf.webgl.MatTex2VertComboList) ? settings.comboList : undefined;
                attributes = tf.js.GetIsInstanceOf(settings.attributes, tf.webgl.VertexBuffer) ? settings.attributes : undefined;
                texture = tf.js.GetIsInstanceOf(settings.texture, tf.webgl.Texture2) ? settings.texture : undefined;
                material = settings.material;
                onPreRenderCallBack = tf.js.GetFunctionOrNull(settings.onPreRender);
            }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.webgl.Scene = function (settings) {
    var theThis, context, canvas, objects, clearColor, ambientColor, clearDepth, world, view, perspective, lightDir, lightColor, viewProj, lastProgram;
    var preRenderArray, frustum;
    this.OnPreRender = function () { return onPreRender(); }
    this.GetLastProgram = function () { return lastProgram; }
    this.SetLastProgram = function (lastProgramSet) { return lastProgram = lastProgramSet; }
    this.RenderOn = function (sceneRenderSettings) { return renderOn(sceneRenderSettings); }
    this.GetViewProj = function () { return viewProj; }
    this.GetWorld = function () { return world; }
    this.GetView = function () { return view; }
    this.GetPerspective = function () { return perspective; }
    this.SetClearColor = function (color) { return setClearColor(color); }
    this.GetClearColor = function () { return clearColor.slice(0); }
    this.SetAmbientColor = function (color) { return setAmbientColor(color); }
    this.GetAmbientColor = function () { return ambientColor.slice(0); }
    this.GetLightDir = function () { return lightDir; }
    this.SetLightDir = function (lightDir) { return setLightDir(lightDir); }
    this.SetLightColor = function (color) { return setLightColor(color); }
    this.GetLightColor = function () { return lightColor.slice(0); }
    this.AddObject = function (object) {
        if (!isDeleted()) {
            if (tf.js.GetIsValidObject(object) && !!tf.js.GetFunctionOrNull(object.RenderSelf)) {
                objects.push(object);
            }
        }
    }
    this.DelObject = function (object) {
        if (!isDeleted()) {
            if (tf.js.GetIsValidObject(object)) {
                var index = objects.indexOf(object);
                if (index != -1) { objects.splice(index, 1); }
            }
        }
    }
    this.ClearObjects = function () { return clearObjects(); }
    this.OnDelete = function () { return onDelete(); }
    this.IsDeleted = function () { return isDeleted(); }
    function clearObjects() { if (!isDeleted()) { objects = []; } }
    function isDeleted() { return context == undefined; }
    function onDelete() {
        context = canvas = undefined; objects = null;
    }
    function onPreRender() {
        if (!isDeleted()) {
            preRenderArray = [];
            frustum.OnUpdate();
            var onPreRenderSettings = {
                frustum: frustum,
                parentObjectToSceneMatrix: world,
                toRender: preRenderArray
            };
            for (var i in objects) { objects[i].OnPreRender(onPreRenderSettings); }
        }
    }
    function renderOn(sceneRenderSettings) {
        function renderImmediate(object, renderSubObjects) {
            if (tf.js.GetIsInstanceOf(object, tf.webgl.SceneObject)) {
                renderSettings.renderSubObjects = !!renderSubObjects;
                object.RenderSelf(renderSettings);
            }
        }
        if (!isDeleted()) {
            lastProgram = undefined;
            viewProj.CopyFrom(perspective);
            viewProj.MultByMatrix(view);
            var ctx = context.GetContext();
            var viewportWidth = sceneRenderSettings.viewportWidth;
            var viewportHeight = sceneRenderSettings.viewportHeight;
            ctx.viewport(0, 0, viewportWidth, viewportHeight);
            //ctx.bindFramebuffer(ctx.FRAMEBUFFER, sceneRenderSettings.frameBuffer);
            if (!!sceneRenderSettings.frameBuffer) {
                ctx.bindFramebuffer(ctx.FRAMEBUFFER, sceneRenderSettings.frameBuffer);
            }
            else {
                ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
            }
            ctx.depthRange(0.0, 1.0);
            ctx.depthFunc(ctx.LEQUAL);
            ctx.clearDepth(clearDepth);
            ctx.enable(ctx.BLEND);
            //ctx.enable(ctx.SAMPLE_COVERAGE);
            //ctx.sampleCoverage(2, false);
            ctx.blendFunc(ctx.SRC_ALPHA, ctx.ONE_MINUS_SRC_ALPHA);
            /*ctx.activeTexture(ctx.TEXTURE0 + 0);
            ctx.bindTexture(ctx.TEXTURE_2D, null);
            ctx.activeTexture(ctx.TEXTURE0 + 1);
            ctx.bindTexture(ctx.TEXTURE_2D, null);*/
            var clearColorUse = sceneRenderSettings.clearColor !== undefined ? sceneRenderSettings.clearColor : clearColor;
            ctx.clearColor(clearColorUse[0], clearColorUse[1], clearColorUse[2], clearColorUse[3]);
            ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT);
            ctx.frontFace(ctx.CCW);
            var renderSettings = {
                scene: theThis,
                renderSubObjects: false,
                parentObjectToSceneMatrix: world,
                useProgram: sceneRenderSettings.useProgram,
                isForPick: sceneRenderSettings.isForPick
            };
            var total = preRenderArray.length, visible = 0;
            for (var i in preRenderArray) {
                var pr = preRenderArray[i], so = pr.sceneObject;
                if (pr.frustumVisible) {
                    ++visible;
                    so.SetRenderMatrix(pr.objectToSceneMatrix);
                    so.RenderSelf(renderSettings);
                }
                //so.SetRenderMatrix(pr.objectToSceneMatrix);
                //so.RenderSelf(renderSettings);
            }
            //console.log('total: ' + total + ' visible: ' + visible);
            if (tf.js.GetFunctionOrNull(sceneRenderSettings.onPostCompose)) {
                sceneRenderSettings.onPostCompose({ sender: theThis, renderImmediate: renderImmediate });
            }
        }
    }
    function setLightDir(lightDirSet) {
        lightDir = tf.js.GetIsArrayWithLength(lightDirSet, 3) ? lightDirSet.slice(0) : [0, 0, 1];
    }
    function getColorFrom(color, nComponents, defaultColor) { return tf.js.GetIsArrayWithLength(color, nComponents) ? color.slice(0) : defaultColor; }
    function setClearColor(color) { clearColor = getColorFrom(color, 4, [0, 0, 0.5, 1]); }
    function setAmbientColor(color) { ambientColor = getColorFrom(color, 3, [0, 0, 0]); }
    function setLightColor(color) { lightColor = getColorFrom(color, 3, [0, 0, 0]); }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsInstanceOf(settings.context, tf.webgl.Context) && !!settings.context.GetContext()) {
            context = settings.context;
            canvas = context.GetCanvas();
            viewProj = new tf.math.Matrix4({ noInit: true });
            world = new tf.math.WorldMatrix4(settings.world);
            view = new tf.math.ViewMatrix4(settings.view);
            perspective = new tf.math.PerspectiveFOVMatrix4(settings.perspective);
            frustum = new tf.math.ViewFrustum({ perspective: perspective, view: view });
            clearDepth = typeof settings.clearDepth == 'number' ? settings.clearDepth : 1;
            setClearColor(settings.clearColor);
            setAmbientColor(settings.ambientColor);
            setLightDir(settings.lightDir);
            setLightColor(settings.lightColor);
            clearObjects();
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.webgl.SceneContainer = function (settings) {
    var theThis, styles, subStyles, context, ctx, canvas, scene, aspect, container, containerHTML;
    var renderCount, pickFrameBufferRenderCount, pickFrameBufferDim, pickFrameBuffer, pickedColor;
    var onFrameCallBack, onPostComposeCallBack;
    this.GetObjectFromPixel = function(pixelCoords) { return getObjectFromPixel(pixelCoords); }
    this.OnFrame = function () { return onFrame(); }
    this.GetContext = function () { return context; }
    this.GetScene = function () { return scene; }
    this.GetAspect = function () { return aspect; }
    this.OnDelete = function () { return onDelete(); }
    this.IsDeleted = function () { return isDeleted(); }
    function isDeleted() { return context == undefined; }
    function isOperational() { return ctx != undefined; }
    function onDelete() {
        if (!isDeleted()) {
            if (!!containerHTML && !!canvas) { containerHTML.removeChild(canvas); }
            if (!!scene) { scene.OnDelete(); }
            if (!!pickFrameBuffer) { pickFrameBuffer.OnDelete(); }
            if (!!context) { context.OnDelete(); }
            containerHTML = container = canvas = ctx = context = scene = pickFrameBuffer = undefined;
        }
    }
    function getObjectFromPixel(pixelCoords) {
        var obj;
        if (isOperational()) {
            if (!!pickFrameBuffer && tf.js.GetIsArrayWithMinLength(pixelCoords, 2)) {
                ctx.bindFramebuffer(ctx.FRAMEBUFFER, pickFrameBuffer.GetFrameBuffer());
                ctx.readPixels(pixelCoords[0], pixelCoords[1], 1, 1, ctx.RGBA, ctx.UNSIGNED_BYTE, pickedColor);
                ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
                obj = context.GetPickObject(tf.webgl.DecodeColorIntoInt(pickedColor));
            }
        }
        return obj;
    };
    function updatePerspective() {
        if (canvas.clientWidth != canvas.width || canvas.clientHeight != canvas.height) {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            aspect = canvas.clientWidth > 0 ? canvas.clientHeight / canvas.clientWidth : 1;
            scene.GetPerspective().UpdateAspect(1 / aspect);
        }
    }
    function drawFrame() {
        if (isOperational()) {
            updatePerspective();
            if (!!onFrameCallBack) { onFrameCallBack({ sender: theThis }); }
            scene.OnPreRender();
            var renderOptions = {
                onPostCompose: onPostComposeCallBack,
                viewportWidth: canvas.width, viewportHeight: canvas.height,
                isForPick: false,
                frameBuffer: undefined, clearColor: undefined, useProgram: undefined
            };
            scene.RenderOn(renderOptions);
            if (!!pickFrameBuffer) {
                if ((renderCount % pickFrameBufferRenderCount) == 0) {
                    renderOptions.viewportWidth = renderOptions.viewportHeight = pickFrameBufferDim;
                    renderOptions.isForPick = true;
                    renderOptions.frameBuffer = pickFrameBuffer.GetFrameBuffer();
                    renderOptions.clearColor = [0, 0, 0, 0];
                    renderOptions.useProgram = context.GetTextureColorPickProgram();
                    scene.RenderOn(renderOptions);
                }
            }
            renderCount++;
        }
    }
    function restoreContext() { if (!!context) { context.RestoreContext(); } }
    function onFrame() { drawFrame(); context.RequestAnimFrame(); }
    function onLost() { ctx = undefined; setTimeout(restoreContext, 1000); }
    function onRestored() { ctx = context.GetContext(); drawFrame(); }
    function createScene() {
        var viewAngle = 30 * Math.PI / 180;
        var viewRadius = 1;
        var sceneNear = 1, sceneFar = 1000, viewY, viewZ, vFrom, vTo, viewZOff = 0;
        viewY = Math.sin(viewAngle) * viewRadius;
        viewZ = Math.cos(viewAngle) * viewRadius;
        vFrom = [viewZ, viewZ, 0]; vTo = [0, 0, 0];
        var view = { vFrom: vFrom, vTo: vTo, vUp: [0, 1, 0] };
        var ambientComponent = 1;
        var lightComponent = 0.75;
        scene = new tf.webgl.Scene({
            context: context, clearColor: [0, 0, 0, 1], clearDepth: 1,
            ambientColor: [ambientComponent, ambientComponent, ambientComponent],
            lightDir: [0, 1, 0],
            lightColor: [lightComponent, lightComponent, lightComponent],
            view: view,
            perspective: { fovy: 30 * Math.PI / 180, near: sceneNear, far: sceneFar }
        });
    }
    function initialize() {
        if (tf.js.GetIsValidObject(settings) && tf.dom.GetHTMLElementFrom(settings.container)) {
            styles = tf.GetStyles(); subStyles = styles.GetSubStyles();
            aspect = 1;
            container = settings.container;
            containerHTML = container.GetHTMLElement();
            onFrameCallBack = tf.js.GetFunctionOrNull(settings.onFrame);
            onPostComposeCallBack = tf.js.GetFunctionOrNull(settings.onPostCompose);
            if (tf.webgl.GetWebGL().GetHasWebGL()) {
                var canvasStyles = { backgroundColor: "rgba(0,0,0,1)", width: "100%", height: "100%", position: 'relative', display: 'block' };
                context = new tf.webgl.Context({ optionalAttributes: { antialias: true }, onFrame: onFrame, onLost: onLost, onRestored: onRestored });
                canvas = context.GetCanvas();
                ctx = context.GetContext();
                pickedColor = new Uint8Array(4);
                renderCount = 0;
                if (!settings.noPickFrameBuffer) {
                    pickFrameBufferRenderCount = 10;
                    pickFrameBufferDim = 512;
                    pickFrameBuffer = new tf.webgl.FrameBuffer({ context: context, width: pickFrameBufferDim, height: pickFrameBufferDim });
                }
                createScene();
                styles.ApplyStyleProperties(canvas, canvasStyles);
                containerHTML.appendChild(canvas);
            }
            else { containerHTML.innerHTML = "<h3>WebGL not available</h3>"; }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: framebuffer.js
tf.webgl.FrameBuffer = function (settings) {
    var theThis, context, frameBuffer, texture, renderBuffer, contextId;
    this.OnLostDevice = function () { return onLostDevice(); }
    this.OnRestoredDevice = function () { return onRestoredDevice(); }
    this.GetFrameBuffer = function () { return frameBuffer; }
    this.GetTexture = function () { return texture; }
    //this.Bind = function () { return bind(); }
    this.OnDelete = function () { return onDelete(); }
    this.IsDeleted = function () { return isDeleted(); }
    function isOperational() { return !isDeleted() && frameBuffer !== undefined; }
    function isDeleted() { return context == undefined; }
    function onDelete() {
        if (!isDeleted()) {
            context.UnRegisterFrameBuffer(contextId);
            if (!!texture) { texture.OnDelete(); }
            contextId = context = undefined;
        }
    }
    function onLostDevice() { if (!isDeleted()) { frameBuffer = undefined; texture.OnDelete(); texture = undefined; } }
    function onRestoredDevice() {
        if (!isDeleted()) {
            var ctx = context.GetContext();
            frameBuffer = ctx.createFramebuffer();
            ctx.bindFramebuffer(ctx.FRAMEBUFFER, frameBuffer);
            frameBuffer.width = typeof settings.width == 'number' ? settings.width : 512;
            frameBuffer.height = typeof settings.height == 'number' ? settings.height : 512;
            //texture = ctx.createTexture();
            texture = new tf.webgl.Texture2({ context: context });
            var tex = texture.GetTexture();
            //ctx.activeTexture(ctx.TEXTURE0);
            ctx.bindTexture(ctx.TEXTURE_2D, tex);
            ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.LINEAR);
            ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.LINEAR_MIPMAP_NEAREST);
            //ctx.generateMipmap(ctx.TEXTURE_2D);
            ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, frameBuffer.width, frameBuffer.height, 0, ctx.RGBA, ctx.UNSIGNED_BYTE, null);
            renderBuffer = ctx.createRenderbuffer();
            ctx.bindRenderbuffer(ctx.RENDERBUFFER, renderBuffer);
            ctx.renderbufferStorage(ctx.RENDERBUFFER, ctx.DEPTH_COMPONENT16, frameBuffer.width, frameBuffer.height);
            ctx.framebufferTexture2D(ctx.FRAMEBUFFER, ctx.COLOR_ATTACHMENT0, ctx.TEXTURE_2D, tex, 0);
            ctx.framebufferRenderbuffer(ctx.FRAMEBUFFER, ctx.DEPTH_ATTACHMENT, ctx.RENDERBUFFER, renderBuffer);
            ctx.bindTexture(ctx.TEXTURE_2D, null);
            ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);
            ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
        }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsInstanceOf(settings.context, tf.webgl.Context) && !!settings.context.GetContext()) {
            context = settings.context;
            contextId = context.RegisterFrameBuffer(theThis);
            onRestoredDevice();
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: program.js
tf.webgl.Shader = function (settings) {
    var theThis, context, shader, shaderType;
    this.OnLostDevice = function () { return onLostDevice(); }
    this.OnRestoredDevice = function () { return onRestoredDevice(); }
    this.GetShader = function () { return shader; }
    this.GetShaderType = function () { return shaderType; }
    this.IsDeleted = function () { return isDeleted(); }
    this.OnDelete = function () { return onDelete(); }
    function isOperational() { return !isDeleted() && shader !== undefined; }
    function isDeleted() { return context == undefined; }
    function onDelete() {
        if (!isDeleted()) {
            if (!!context && !!shader) {
                var ctx = context.GetContext();
                if (!!ctx) { ctx.deleteShader(shader); }
            }
            shaderType = context = shader = undefined;
        }
    }
    function onLostDevice() { if (!isDeleted()) { shader = undefined; } }
    function onRestoredDevice() {
        if (!isDeleted()) {
            var ctx = context.GetContext();
            if (!!ctx) {
                var shaderText = tf.js.GetNonEmptyString(settings.text);
                if (!!shaderText) {
                    shaderType = tf.js.GetNonEmptyString(settings.type);
                    var glShaderType;
                    if (shaderType !== undefined) {
                        switch (shaderType = shaderType.toLowerCase()[0]) {
                            case 'f': glShaderType = ctx.FRAGMENT_SHADER; break;
                            case 'v': glShaderType = ctx.VERTEX_SHADER; break;
                            default: shaderType = undefined; break;
                        }
                    }
                    if (glShaderType !== undefined) {
                        shader = ctx.createShader(glShaderType);
                        ctx.shaderSource(shader, shaderText);
                        ctx.compileShader(shader);
                        var compiled = ctx.getShaderParameter(shader, ctx.COMPILE_STATUS);
                        if (!compiled && !ctx.isContextLost()) {
                            if (!!settings.debug) {
                                var error = ctx.getShaderInfoLog(shader);
                                tf.GetDebug().LogIfTest("*** Error compiling shader: " + error);
                            }
                            onDelete();
                        }
                    }
                }
            }
        }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsInstanceOf(settings.context, tf.webgl.Context) && !!settings.context.GetContext()) {
            context = settings.context;
            onRestoredDevice();
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.webgl.Program = function (settings) {
    var theThis, program, context, ctx, keyes, vshader, fshader, renderCallBack;
    this.GetProgram = function () { return program; }
    this.OnLostDevice = function () { return onLostDevice(); }
    this.OnRestoredDevice = function () { return onRestoredDevice(); }
    this.Render = function (renderSettings) { return render(renderSettings); }
    this.GetUniformLocation = function (name) { return getUniformLocation (name); }
    this.GetAttribLocation = function (name) { return getAttribLocation (name); }
    function render(renderSettings) {
        if (isOperational() && tf.js.GetIsValidObject(renderSettings)) {
            /*if (tf.js.GetIsInstanceOf(renderSettings.attributes, tf.webgl.VertexBuffer) &&
                tf.js.GetIsInstanceOf(renderSettings.texture, tf.webgl.Texture2) &&
                tf.js.GetIsInstanceOf(renderSettings.objectToSceneMatrix, tf.math.Matrix4) &&
                tf.js.GetIsInstanceOf(renderSettings.scene, tf.webgl.Scene)) {*/
            if (renderSettings.isNewProgram = (renderSettings.scene.GetLastProgram() != theThis)) {
                ctx.useProgram(program);
                renderSettings.scene.SetLastProgram(theThis);
            }
            //else { console.log('.'); }
            renderCallBack(renderSettings);
            //}
        }
    }
    this.OnDelete = function () { return onDelete(); }
    this.IsDeleted = function () { return isDeleted(); }
    this.IsOperational = function () { return isOperational(); }
    function getUniformLocation(name) { return !isOperational() || !tf.js.GetIsNonEmptyString(name) ? undefined : ctx.getUniformLocation(program, name); }
    function getAttribLocation(name) { return !isOperational() || !tf.js.GetIsNonEmptyString(name) ? undefined : ctx.getAttribLocation(program, name); }
    function isOperational() { return !isDeleted() && program !== undefined; }
    function isDeleted() { return context == undefined; }
    function onDelete() {
        if (!isDeleted()) {
            if (!!program && !!ctx) { ctx.deleteProgram(program); }
            context = ctx = program = vshader = fshader = undefined;
        }
    }
    function onLostDevice() { if (!isDeleted()) { ctx = undefined; program = undefined; } }
    function onRestoredDevice() {
        if (!isDeleted()) {
            ctx = context.GetContext();
            program = ctx.createProgram();
            ctx.attachShader(program, vshader.GetShader());
            ctx.attachShader(program, fshader.GetShader());
            ctx.linkProgram(program);
            var linked = ctx.getProgramParameter(program, ctx.LINK_STATUS);
            if (!linked && !ctx.isContextLost()) {
                if (!!settings.debug) {
                    var error = ctx.getProgramInfoLog(program);
                    tf.GetDebug().LogIfTest("Error in program linking: " + error);
                }
                onDelete();
            }
            else {
                if (tf.js.GetFunctionOrNull(settings.init)) { settings.init(ctx); }
            }
        }
    }
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsInstanceOf(settings.context, tf.webgl.Context) && !!settings.context.GetContext() &&
            tf.js.GetIsInstanceOf(settings.vshader, tf.webgl.Shader) && settings.vshader.GetShaderType() == 'v' &&
            tf.js.GetIsInstanceOf(settings.fshader, tf.webgl.Shader) && settings.fshader.GetShaderType() == 'f' &&
            !!(renderCallBack = tf.js.GetFunctionOrNull(settings.render))){
            context = settings.context;
            vshader = settings.vshader;
            fshader = settings.fshader;
            onRestoredDevice();
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: programs.js
tf.webgl.EncodeIntIntoColor = function (value) {
    var r = value % 256; value = value >> 8;
    var g = value % 256; value = value >> 8;
    var b = value % 256;
    var obj = [1 - r / 255, 1 - g / 255, 1 - b / 255];
    obj.rgb = { r: obj[0], g: obj[1], b: obj[2], value: value };
    return obj;
}
tf.webgl.DecodeColorIntoInt = function (color) {
    return !!color[3] ? (255 - color[0]) + 256 * (255 - color[1]) + 32768 * (255 - color[2]) : 0;
}
tf.webgl.GetTextureColorVSText = function () {
    return "uniform mat4 uModelMatrix;" + "\n" +
            "uniform mat4 uViewProjMatrix;" + "\n" +
            "attribute vec3 aPosition;" + "\n" +
            "attribute vec3 aTexCoord;" + "\n" +
            "varying vec2 vTexCoord;" + "\n" +
            "void main()" + "\n" +
            "{" + "\n" +
                "gl_Position = uViewProjMatrix * uModelMatrix * vec4(aPosition, 1.0);" + "\n" +
                "vTexCoord = aTexCoord.st;" + "\n" +
            "}";
}
tf.webgl.GetTextureColorFSText = function () {
    return "precision mediump float;" + "\n" +
        "uniform sampler2D diffuseTex;" + "\n" +
        "varying vec2 vTexCoord;" + "\n" +
        "void main()" + "\n" +
        "{" + "\n" +
            "vec4 color = texture2D(diffuseTex, vTexCoord);" + "\n" +
            "if (color.a == 0.0) discard;" + "\n" +
            "else gl_FragColor = color;" + "\n" +
            //"else gl_FragColor = vec4(color.xyz, 0.5);" + "\n" +
            //"gl_FragColor = vec4(1, 0, 0, 1);" + "\n" +
        "}";
}
tf.webgl.GetTextureColorPickVSText = function () {
    return "uniform mat4 uModelMatrix;" + "\n" +
            "uniform mat4 uViewProjMatrix;" + "\n" +
            "attribute vec3 aPosition;" + "\n" +
            "attribute vec3 aTexCoord;" + "\n" +
            "varying vec2 vTexCoord;" + "\n" +
            "void main()" + "\n" +
            "{" + "\n" +
                "gl_Position = uViewProjMatrix * uModelMatrix * vec4(aPosition, 1.0);" + "\n" +
                "vTexCoord = aTexCoord.st;" + "\n" +
            "}";
}
tf.webgl.GetTextureColorPickFSText = function () {
    return "precision mediump float;" + "\n" +
        "uniform sampler2D diffuseTex;" + "\n" +
        "varying vec2 vTexCoord;" + "\n" +
        "uniform vec3 uPickColor;" + "\n" +
        "void main()" + "\n" +
        "{" + "\n" +
            "vec4 color = texture2D(diffuseTex, vTexCoord);" + "\n" +
            "if (color.a == 0.0) discard;" + "\n" +
            "else gl_FragColor = vec4(uPickColor, 1);" + "\n" +
        "}";
}
tf.webgl.TextureColorVS = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        tf.webgl.Shader.call(theThis, {
            debug: settings.debug,
            context: settings.context,
            type: 'v',
            text: tf.webgl.GetTextureColorVSText()
    });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.TextureColorVS, tf.webgl.Shader);
tf.webgl.TextureColorFS = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        tf.webgl.Shader.call(theThis, {
            debug: settings.debug,
            context: settings.context,
            type: 'f',
            text: tf.webgl.GetTextureColorFSText()
        });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.TextureColorFS, tf.webgl.Shader);
tf.webgl.TextureColorProgram = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsInstanceOf(settings.context, tf.webgl.Context) && !!settings.context.GetContext()) {
            var context = settings.context;
            var posLoc, tex2dLoc;
            var diffuseTexLoc, uModelMatrixLoc, uViewProjMatrixLoc;
            tf.webgl.Program.call(theThis, {
                debug: settings.debug,
                context: context,
                vshader: context.GetTextureColorVS(),
                fshader: context.GetTextureColorFS(),
                init: function (ctx) {
                    posLoc = theThis.GetAttribLocation("aPosition");
                    tex2dLoc = theThis.GetAttribLocation("aTexCoord");
                    diffuseTexLoc = theThis.GetUniformLocation("diffuseTex");
                    uModelMatrixLoc = theThis.GetUniformLocation("uModelMatrix");
                    uViewProjMatrixLoc = theThis.GetUniformLocation("uViewProjMatrix");
                },
                render: function (renderSettings) {
                    var ctx = context.GetContext();
                    var scene = renderSettings.scene;
                    if (renderSettings.isNewProgram) {
                        if (!!diffuseTexLoc) { ctx.uniform1i(diffuseTexLoc, 0); }
                        ctx.uniformMatrix4fv(uViewProjMatrixLoc, false, scene.GetViewProj().GetInStaticFloat32Array());
                        //ctx.activeTexture(ctx.TEXTURE0 + 1);
                        //ctx.bindTexture(ctx.TEXTURE_2D, null);
                    }
                    ctx.uniformMatrix4fv(uModelMatrixLoc, false, renderSettings.objectToSceneMatrix.GetInStaticFloat32Array());
                    renderSettings.attributes.BindBuffers(posLoc, undefined, tex2dLoc);
                    renderSettings.texture.Bind();
                    renderSettings.attributes.Draw(renderSettings.useLines);
                }
            });
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.TextureColorProgram, tf.webgl.Program);
tf.webgl.TextureColorPickVS = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        tf.webgl.Shader.call(theThis, {
            debug: settings.debug,
            context: settings.context,
            type: 'v',
            text: tf.webgl.GetTextureColorPickVSText()
        });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.TextureColorPickVS, tf.webgl.Shader);
tf.webgl.TextureColorPickFS = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        tf.webgl.Shader.call(theThis, {
            debug: settings.debug,
            context: settings.context,
            type: 'f',
            text: tf.webgl.GetTextureColorPickFSText()
        });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.TextureColorPickFS, tf.webgl.Shader);
tf.webgl.TextureColorPickProgram = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsInstanceOf(settings.context, tf.webgl.Context) && !!settings.context.GetContext()) {
            var context = settings.context;
            var posLoc, tex2dLoc;
            var diffuseTexLoc, uModelMatrixLoc, uViewProjMatrixLoc, uPickColorLoc;
            tf.webgl.Program.call(theThis, {
                debug: settings.debug,
                context: context,
                vshader: context.GetTextureColorPickVS(),
                fshader: context.GetTextureColorPickFS(),
                init: function (ctx) {
                    posLoc = theThis.GetAttribLocation("aPosition");
                    tex2dLoc = theThis.GetAttribLocation("aTexCoord");
                    diffuseTexLoc = theThis.GetUniformLocation("diffuseTex");
                    uModelMatrixLoc = theThis.GetUniformLocation("uModelMatrix");
                    uViewProjMatrixLoc = theThis.GetUniformLocation("uViewProjMatrix");
                    uPickColorLoc = theThis.GetUniformLocation("uPickColor");
                },
                render: function (renderSettings) {
                    var ctx = context.GetContext();
                    var scene = renderSettings.scene;
                    if (renderSettings.isNewProgram) {
                        if (!!diffuseTexLoc) { ctx.uniform1i(diffuseTexLoc, 0); }
                        ctx.uniformMatrix4fv(uViewProjMatrixLoc, false, scene.GetViewProj().GetInStaticFloat32Array());
                        //ctx.activeTexture(ctx.TEXTURE0 + 1);
                        //ctx.bindTexture(ctx.TEXTURE_2D, null);
                    }
                    if (!!uPickColorLoc) { var pc = renderSettings.pickColor; ctx.uniform3f(uPickColorLoc, pc[0], pc[1], pc[2]); }
                    ctx.uniformMatrix4fv(uModelMatrixLoc, false, renderSettings.objectToSceneMatrix.GetInStaticFloat32Array());
                    renderSettings.attributes.BindBuffers(posLoc, undefined, tex2dLoc);
                    renderSettings.texture.Bind();
                    renderSettings.attributes.Draw(renderSettings.useLines);
                }
            });
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.TextureColorPickProgram, tf.webgl.Program);
tf.webgl.MaterialVS = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        tf.webgl.Shader.call(theThis, {
            debug: settings.debug,
            context: settings.context,
            type: 'v',
            text: tf.webgl.GetMaterialVSText()
        });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.MaterialVS, tf.webgl.Shader);
tf.webgl.MaterialFS = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        tf.webgl.Shader.call(theThis, {
            debug: settings.debug,
            context: settings.context,
            type: 'f',
            text: tf.webgl.GetMaterialFSText()
        });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.MaterialFS, tf.webgl.Shader);
tf.webgl.MaterialProgram = function (settings) {
    var theThis;
    function initialize() {
        settings = tf.js.GetValidObjectFrom(settings);
        if (tf.js.GetIsInstanceOf(settings.context, tf.webgl.Context) && !!settings.context.GetContext()) {
            var context = settings.context;
            var posLoc, norLoc, tex2dLoc, normalMatrix, modelViewMatrix, lightDirVec, hasTextureLoc, hasNormalTextureLoc;
            var uModelMatrixLoc, uNormalMatrixLoc, uViewProjMatrixLoc, uProjMatrixLoc, uModelViewMatrixLoc, uNormalViewMatrixLoc;
            var ambientLightLoc, cameraPosLoc, lightDirLoc, lightColorLoc, uniformLocations, diffuseTexLoc, normalTexLoc;
            tf.webgl.Program.call(theThis, {
                debug: settings.debug,
                context: context,
                vshader: context.GetMaterialVS(),
                fshader: context.GetMaterialFS(),
                init: function (ctx) {
                    posLoc = theThis.GetAttribLocation("aPosition");
                    norLoc = theThis.GetAttribLocation("aNormal");
                    tex2dLoc = theThis.GetAttribLocation("aTexCoord");
                    cameraPosLoc = theThis.GetUniformLocation("uCameraPos");
                    lightDirLoc = theThis.GetUniformLocation("uLightDir");
                    lightColorLoc = theThis.GetUniformLocation("uLightColor");
                    ambientLightLoc = theThis.GetUniformLocation("uAmbientLight");
                    hasTextureLoc = theThis.GetUniformLocation("hasTexture");
                    hasNormalTextureLoc = theThis.GetUniformLocation("hasNormalTexture");
                    diffuseTexLoc = theThis.GetUniformLocation("diffuseTex");
                    normalTexLoc = theThis.GetUniformLocation("normalTex");
                    uniformLocations = {
                        hasTextureLoc: hasTextureLoc,
                        hasNormalTextureLoc: hasNormalTextureLoc,
                        ambientColor3Loc: theThis.GetUniformLocation("uAmbientColor"),
                        diffuseColor3Loc: theThis.GetUniformLocation("uDiffuseColor"),
                        emissiveColor3Loc: theThis.GetUniformLocation("uEmissiveColor"),
                        specularColor3Loc: theThis.GetUniformLocation("uSpecularColor"),
                        opacityShininessLoc: theThis.GetUniformLocation("uOpacityShininess")
                    };
                    uModelMatrixLoc = theThis.GetUniformLocation("uModelMatrix");
                    uNormalMatrixLoc = theThis.GetUniformLocation("uNormalMatrix");
                    uViewProjMatrixLoc = theThis.GetUniformLocation("uViewProjMatrix");
                    uProjMatrixLoc = theThis.GetUniformLocation("uProjMatrix");
                    uModelViewMatrixLoc = theThis.GetUniformLocation("uModelViewMatrix");
                    uNormalViewMatrixLoc = theThis.GetUniformLocation("uNormalViewMatrix");
                    normalMatrix = new tf.math.Matrix4({ noInit: true });
                    modelViewMatrix = new tf.math.Matrix4({ noInit: true });
                    lightDirVec = new tf.math.Vector3();
                },
                render: function (renderSettings) {
                    var ctx = context.GetContext();
                    var scene = renderSettings.scene;
                    var viewMatrix = scene.GetView();
                    if (renderSettings.isNewProgram) {
                        if (!!ambientLightLoc) {
                            var ambientLight = scene.GetAmbientColor();
                            ctx.uniform3f(ambientLightLoc, ambientLight[0], ambientLight[1], ambientLight[2]);
                        }
                        if (!!cameraPosLoc) {
                            var cameraPos = viewMatrix.GetView().vFrom;
                            ctx.uniform3f(cameraPosLoc, cameraPos[0], cameraPos[1], cameraPos[2]);
                        }
                        if (!!lightDirLoc) {
                            lightDirVec.CopyFrom(scene.GetLightDir());
                            lightDirVec.MultDirectionByMatrix(viewMatrix);
                            lightDirVec.Normalize();
                            ctx.uniform3f(lightDirLoc, lightDirVec[0], lightDirVec[1], lightDirVec[2]);
                        }
                        if (!!lightColorLoc) {
                            var lightColor = scene.GetLightColor();
                            ctx.uniform3f(lightColorLoc, lightColor[0], lightColor[1], lightColor[2]);
                        }
                        if (!!uViewProjMatrixLoc) {
                            ctx.uniformMatrix4fv(uViewProjMatrixLoc, false, scene.GetViewProj().GetInStaticFloat32Array());
                        }
                        if (!!uProjMatrixLoc) {
                            ctx.uniformMatrix4fv(uProjMatrixLoc, false, scene.GetPerspective().GetInStaticFloat32Array());
                        }
                        if (!!diffuseTexLoc) { ctx.uniform1i(diffuseTexLoc, 0); }
                        if (!!normalTexLoc) { ctx.uniform1i(normalTexLoc, 1); }
                        var tTex = context.GetOnePixelTransparentTexture().GetTexture();
                        ctx.activeTexture(ctx.TEXTURE0 + 0);
                        ctx.bindTexture(ctx.TEXTURE_2D, tTex);
                        ctx.activeTexture(ctx.TEXTURE0 + 1);
                        ctx.bindTexture(ctx.TEXTURE_2D, tTex);
                    }
                    if (!!uModelMatrixLoc) {
                        ctx.uniformMatrix4fv(uModelMatrixLoc, false, renderSettings.objectToSceneMatrix.GetInStaticFloat32Array());
                    }
                    if (!!uModelViewMatrixLoc) {
                        modelViewMatrix.CopyFrom(viewMatrix);
                        modelViewMatrix.MultByMatrix(renderSettings.objectToSceneMatrix);
                        ctx.uniformMatrix4fv(uModelViewMatrixLoc, false, modelViewMatrix.GetInStaticFloat32Array());
                        if (!!uNormalViewMatrixLoc) {
                            normalMatrix.CopyFrom(modelViewMatrix);
                            if (!!renderSettings.usesNonUniformScaling) { normalMatrix.ToInverse(); normalMatrix.ToTransposed(); }
                            ctx.uniformMatrix4fv(uNormalViewMatrixLoc, false, normalMatrix.GetInStaticFloat32Array());
                        }
                    }
                    if (!!uNormalMatrixLoc) {
                        normalMatrix.CopyFrom(renderSettings.objectToSceneMatrix);
                        if (!!renderSettings.usesNonUniformScaling) { normalMatrix.ToInverse(); normalMatrix.ToTransposed(); }
                        ctx.uniformMatrix4fv(uNormalMatrixLoc, false, normalMatrix.GetInStaticFloat32Array());
                    }
                    if (tf.js.GetIsInstanceOf(renderSettings.material, tf.webgl.Material)) { renderSettings.material.SetUniforms(ctx, uniformLocations); }
                    var isComboList = tf.js.GetIsInstanceOf(renderSettings.comboList, tf.webgl.MatTex2VertComboList);
                    if (isComboList) { renderSettings.comboList.Render(ctx, posLoc, norLoc, tex2dLoc, renderSettings, uniformLocations); }
                    else if (tf.js.GetIsInstanceOf(renderSettings.attributes, tf.webgl.VertexBuffer)) {
                        if (!!hasTextureLoc) { var hasTexture = !!texture; ctx.uniform1i(hasTextureLoc, hasTexture ? 1 : 0); }
                        renderSettings.attributes.BindBuffers(posLoc, norLoc, tex2dLoc);
                        renderSettings.attributes.Draw(renderSettings.useLines);
                    }
                }
            });
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.MaterialProgram, tf.webgl.Program);
tf.webgl.GetMaterialVSText = function () {
    return "uniform mat4 uProjMatrix;" + "\n" +
            "uniform mat4 uNormalViewMatrix;" + "\n" +
            "uniform mat4 uModelViewMatrix;" + "\n" +
            "uniform bool hasTexture;" + "\n" +
            "attribute vec3 aPosition;" + "\n" +
            "attribute vec3 aNormal;" + "\n" +
            "attribute vec2 aTexCoord;" + "\n" +
            "varying vec4 vPosition;" + "\n" +
            "varying vec4 vNormal;" + "\n" +
            "varying vec2 vTexCoord;" + "\n" +
            "void main()" + "\n" +
            "{" + "\n" +
                "vPosition = uModelViewMatrix * vec4(aPosition, 1.0);" + "\n" +
                "vNormal = uNormalViewMatrix * normalize(vec4(aNormal, 0.0));" + "\n" +
                "if(hasTexture != false) { vTexCoord = aTexCoord.st; }" + "\n" +
                "gl_Position = uProjMatrix * vPosition;" + "\n" +
            "}";
}
tf.webgl.GetMaterialFSText = function () {
    return "#extension GL_OES_standard_derivatives : enable" + "\n" +
        "precision mediump float;" + "\n" +
        "uniform bool hasTexture;" + "\n" +
        "uniform bool hasNormalTexture;" + "\n" +
        "uniform sampler2D diffuseTex;" + "\n" +
        "uniform sampler2D normalTex;" + "\n" +
        "uniform vec3 uLightDir;" + "\n" +
        "uniform vec3 uLightColor;" + "\n" +
        "uniform vec3 uAmbientLight;" + "\n" +
        "uniform vec3 uAmbientColor;" + "\n" +
        "uniform vec3 uDiffuseColor;" + "\n" +
        "uniform vec3 uEmissiveColor;" + "\n" +
        "uniform vec3 uSpecularColor;" + "\n" +
        "uniform vec4 uOpacityShininess;" + "\n" +
        "varying vec4 vPosition;" + "\n" +
        "varying vec4 vNormal;" + "\n" +
        "varying vec2 vTexCoord;" + "\n" +
        "void main() {" + "\n" +
            "vec3 N = normalize(vNormal.xyz);" + "\n" +
            "vec3 V = -normalize(vPosition.xyz);" + "\n" +
            "vec4 color;" + "\n" +
            "vec3 textureColor;" + "\n" +
            "color = texture2D(diffuseTex, vTexCoord);" + "\n" +
            "if(hasTexture) { textureColor = color.xyz; color.xyz *= uAmbientLight; /*color.a *= uOpacityShininess.x;*/ }" + "\n" +
            "else { color = vec4(uEmissiveColor + uAmbientColor * uAmbientLight, uOpacityShininess.x); }" + "\n" +
            //"if(hasTexture != false) { color = vec4(0.0,0.0,1.0,1.0); }" + "\n" + "else { color = vec4(1.0,0.0,0.0,1.0); }" + "\n" +
            "if (color.a == 0.0) discard;" + "\n" +
            "else {" + "\n" +
                "float dnl = dot(N, uLightDir);" + "\n" +
                "if (dnl > 0.0) {" + "\n" +
                    "if(hasTexture) { color.xyz += uLightColor * textureColor * dnl; } else { color.xyz += uLightColor * uDiffuseColor * dnl; }" + "\n" +
                    //"color.xyz += uLightColor * uDiffuseColor * dnl;" + "\n" +
                    "vec3 R = reflect(-uLightDir, N);" + "\n" +
                    "float specular = pow(max(dot(R, V), 0.0), uOpacityShininess.y);" + "\n" +
                    "color.xyz += uSpecularColor * uLightColor * specular;" + "\n" +
                "}" + "\n" +
                "gl_FragColor = color;" + "\n" +
                //"if(hasNormalTexture) { gl_FragColor = texture2D(normalTex, vTexCoord); }" + "\n" +
            "}" + "\n" +
        "}"
}
/*tf.webgl.GetMaterialFSText = function () {
    return "#extension GL_OES_standard_derivatives : enable" + "\n" +
        "precision mediump float;" + "\n" +
        "uniform bool hasTexture;" + "\n" +
        "uniform bool hasNormalTexture;" + "\n" +
        "uniform sampler2D diffuseTex;" + "\n" +
        "uniform sampler2D normalTex;" + "\n" +
        "uniform vec3 uLightDir;" + "\n" +
        "uniform vec3 uLightColor;" + "\n" +
        "uniform vec3 uAmbientLight;" + "\n" +
        "uniform vec3 uAmbientColor;" + "\n" +
        "uniform vec3 uDiffuseColor;" + "\n" +
        "uniform vec3 uEmissiveColor;" + "\n" +
        "uniform vec3 uSpecularColor;" + "\n" +
        "uniform vec4 uOpacityShininess;" + "\n" +
        "varying vec4 vPosition;" + "\n" +
        "varying vec4 vNormal;" + "\n" +
        "varying vec2 vTexCoord;" + "\n" +
        "mat3 getLocalMat(vec3 N, vec3 p, vec2 uv) {" + "\n" +
            "vec3 dp1 = dFdx(p);" + "\n" +
            "vec3 dp2 = dFdy(p);" + "\n" +
            "vec2 duv1 = dFdx(uv);" + "\n" +
            "vec2 duv2 = dFdy(uv);" + "\n" +
            "vec3 dp2perp = cross(dp2, N);" + "\n" +
            "vec3 dp1perp = cross(N, dp1);" + "\n" +
            "vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;" + "\n" +
            "vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;" + "\n" +
            "float invmax = inversesqrt(max(dot(T,T), dot(B,B)));" + "\n" +
            "return mat3(T * invmax, B * invmax, N);" + "\n" +
        "}" + "\n" +
        "vec3 mapNormal(vec3 vMap, vec3 N, vec3 V, vec2 texcoord) {" + "\n" +
            //"vec3 vMap = texture2D(normalTex, texcoord).xyz;" + "\n" +
            "vMap = vMap * 255./127. - 128./127.;" + "\n" +
            "mat3 localMat = getLocalMat(N, -V, texcoord);" + "\n" +
            "return normalize(localMat * vMap);" + "\n" +
        "}" + "\n" +
        "void main() {" + "\n" +
            "vec3 N = normalize(vNormal.xyz);" + "\n" +
            "vec3 V = -normalize(vPosition.xyz);" + "\n" +
            "vec4 color;" + "\n" +
            "vec3 textureColor;" + "\n" +
            "vec3 vMap = texture2D(normalTex, vTexCoord).xyz;" + "\n" +
            "if(hasNormalTexture) { N = mapNormal(vMap, N, V, vTexCoord); }" + "\n" +
            "color = texture2D(diffuseTex, vTexCoord);" + "\n" +
            "if(hasTexture) { textureColor = color.xyz; color.xyz *= uAmbientLight; }" + "\n" +
            "else { color = vec4(uEmissiveColor + uAmbientColor * uAmbientLight, uOpacityShininess.x); }" + "\n" +
            //"if(hasTexture != false) { color = vec4(0.0,0.0,1.0,1.0); }" + "\n" + "else { color = vec4(1.0,0.0,0.0,1.0); }" + "\n" +
            "if (color.a == 0.0) discard;" + "\n" +
            "else {" + "\n" +
                "float dnl = dot(N, uLightDir);" + "\n" +
                "if (dnl > 0.0) {" + "\n" +
                    "if(hasTexture) { color.xyz += uLightColor * textureColor * dnl; } else { color.xyz += uLightColor * uDiffuseColor * dnl; }" + "\n" +
                    //"color.xyz += uLightColor * uDiffuseColor * dnl;" + "\n" +
                    "vec3 R = reflect(-uLightDir, N);" + "\n" +
                    "float specular = pow(max(dot(R, V), 0.0), uOpacityShininess.y);" + "\n" +
                    "color.xyz += uSpecularColor * uLightColor * specular;" + "\n" +
                "}" + "\n" +
                "gl_FragColor = color;" + "\n" +
                //"if(hasNormalTexture) { gl_FragColor = texture2D(normalTex, vTexCoord); }" + "\n" +
            "}" + "\n" +
        "}"
};*/
/*
"mat3 getLocalMat(vec3 N, vec3 p, vec2 uv) {" + "\n" +
    "vec3 dp1 = dFdx(p);" + "\n" +
    "vec3 dp2 = dFdy(p);" + "\n" +
    "vec2 duv1 = dFdx(uv);" + "\n" +
    "vec2 duv2 = dFdy(uv);" + "\n" +
    "vec3 dp2perp = cross(dp2, N);" + "\n" +
    "vec3 dp1perp = cross(N, dp1);" + "\n" +
    "vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;" + "\n" +
    "vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;" + "\n" +
    "float invmax = inversesqrt(max(dot(T,T), dot(B,B)));" + "\n" +
    "return mat3(T * invmax, B * invmax, N);" + "\n" +
"}" + "\n" +
"vec3 mapNormal(vec3 N, vec3 V, vec2 texcoord) {" + "\n" +
    "vec3 vMap = texture2D(normalTex, texcoord).xyz;" + "\n" +
    "vMap = vMap * 255./127. - 128./127.;" + "\n" +
    "mat3 localMat = getLocalMat(N, -V, texcoord);" + "\n" +
    "return normalize(localMat * vMap);" + "\n" +
"}" + "\n" +
*/

// SOURCE FILE: model3DS.js
tf.webgl.CreateMaterialFrom3DSMeshMaterial = function (meshMaterial) {
    var name, opacity, shininess, ambient, diffuse, emissive, specular, texFile, normalsFile;
    if (tf.js.GetIsValidObject(meshMaterial) && tf.js.GetIsNonEmptyArray(meshMaterial.properties)) {
        var props = meshMaterial.properties;
        for (var i in props) {
            var prop = props[i];
            var key = prop.key;
            if (tf.js.GetIsStringWithMinLength(key, 2)) {
                switch (key.substr(1).toLowerCase()) {
                    case "mat.name": name = prop.value; break;
                    case "mat.opacity": opacity = prop.value; break;
                    case "mat.shininess": shininess = prop.value / 100; break;
                    case "mat.shadingm": break;
                    case "mat.shinpercent": break;
                    case "mat.bumpscaling": break;
                    case "clr.ambient": ambient = prop.value; break;
                    case "clr.diffuse": diffuse = prop.value; break;
                    case "clr.emissive": emissive = prop.value; break;
                    case "clr.specular": specular = prop.value; break;
                    case "tex.mapmodeu": break;
                    case "tex.mapmodev": break;
                    case "tex.uvtrafo": break;
                    case "tex.file": case "tex.file.diffuse": texFile = prop.value; break;
                    case "tex.file.normals": normalsFile = prop.value; break;
                    case "tex.blend": break;
                }
            }
        }
    }
    return new tf.webgl.Material({
        name: name, opacity: opacity, shininess: shininess, ambient: ambient, diffuse: diffuse, emissive: emissive, specular: specular,
        texFile: texFile, normalsFile: normalsFile
    });
}
tf.webgl.CreateVertexBufferFrom3DSMesh = function (context, mesh, scale) {
    var vertexBuffer, maxs, mins;
    if (tf.js.GetIsInstanceOf(context, tf.webgl.Context) && !!context.GetContext() &&
        tf.js.GetIsValidObject(mesh)) {
        var pos;
        scale = scale !== undefined ? tf.js.GetFloatNumber(scale) : 1;
        if (scale == 0) { scale = 1 }
        var nVertices, maxVertexIndex;
        if (mesh.vertices != undefined) {
            var verts = mesh.vertices;
            nVertices = verts.length;
            maxVertexIndex = Math.floor(nVertices / 3);
            if (maxVertexIndex > 0) {
                maxs = [verts[0] * scale, verts[1] * scale, verts[2] * scale];
                mins = [maxs[0], maxs[1], maxs[2]];
                for (var index = 0, i = 0 ; i < maxVertexIndex ; ++i) {
                    for (var j = 0 ; j < 3 ; ++j, ++index) {
                        var val = verts[index] * scale;
                        if (val < mins[j]) { mins[j] = val; } else if (val > maxs[j]) { maxs[j] = val; }
                        verts[index] = val;
                    }
                }
            }
            pos = new tf.webgl.PosBuffer({ context: context, data: new Float32Array(mesh.vertices) })
        }
        else {
            maxVertexIndex = nVertices = 0;
        }
        var nor = mesh.normals != undefined ? new tf.webgl.NorBuffer({ context: context, data: new Float32Array(mesh.normals) }) : undefined;
        var tex2d, tex2dData;
        if (mesh.texturecoords == undefined) {
            //tex2dData = new Float32Array(maxVertexIndex * 2);
        }
        else {
            tex2dData = new Float32Array(mesh.texturecoords[0]);
        }
        var tex2d = tex2dData !== undefined ? new tf.webgl.Tex2DBuffer({ context: context, data: tex2dData }) : undefined;
        //tex2d = undefined;
        var indices;
        if (mesh.faces != undefined) {
            var faces = mesh.faces;
            var nFaces = faces.length;
            var nIndices = nFaces * 3;
            var is8 = maxVertexIndex < 256, is16 = maxVertexIndex < 256 * 256, is32 = !is16;
            var indexData = is8 ? new Uint8Array(nIndices) : (is16 ? new Uint16Array(nIndices) : new Uint32Array(nIndices));
            for (var j = 0, k = 0 ; j < nFaces ; ++j) { for (var l = 0 ; l < 3 ; ++l) { indexData[k++] = faces[j][l]; } }
            indices = new tf.webgl.IndexBuffer({ context: context, data: indexData, is8: is8, is16: is16, is32: is32 });
        }
        vertexBuffer = new tf.webgl.VertexBuffer({
            cullFrontFace: false,
            context: context, pos: pos, nor: nor, tex2d: tex2d, indices: indices
        });
    }
    return { vertexBuffer: vertexBuffer, maxs: maxs, mins: mins };
}
tf.webgl.Load3DSModel2 = function (context, object, scale, mergeBuffers) {
    var comboList, combos, namedMeshes, mins, maxs;
    function createVertexBuffers(node) {
        if (tf.js.GetIsValidObject(node)) {
            if (tf.js.GetIsNonEmptyArray(node.meshes)) {
                var nMeshes = node.meshes.length;
                for (var i = 0 ; i < nMeshes ; ++i) {
                    var meshIndex = node.meshes[i];
                    if (meshIndex == "$$$DUMMY") {
                        console.log('here');
                    }
                    var mesh = namedMeshes[meshIndex];
                    if (tf.js.GetIsValidObject(mesh)) {
                        var meshMaterialIndex = mesh.materialindex;
                        if (meshMaterialIndex >= 0 && meshMaterialIndex < combos.length) {
                            var results = tf.webgl.CreateVertexBufferFrom3DSMesh(context, mesh, scale);
                            if (!!results && !!results.vertexBuffer) {
                                if (mins == undefined) { mins = results.mins.slice(0); maxs = results.maxs.slice(0); }
                                else {
                                    for (var minMaxIndex = 0; minMaxIndex < 3 ; ++minMaxIndex) {
                                        if (mins[minMaxIndex] > results.mins[minMaxIndex]) { mins[minMaxIndex] = results.mins[minMaxIndex]; }
                                        if (maxs[minMaxIndex] < results.maxs[minMaxIndex]) { maxs[minMaxIndex] = results.maxs[minMaxIndex]; }
                                    }
                                }
                                combos[meshMaterialIndex].AddVertexBuffer(results.vertexBuffer);
                            }
                        }
                    }
                }
            }
            for (var i in node.children) { createVertexBuffers(node.children[i]); }
        }
    }
    if (tf.js.GetIsInstanceOf(context, tf.webgl.Context) && !!context.GetContext() &&
        tf.js.GetIsValidObject(object) && tf.js.GetIsValidObject(object.rootnode) &&
        tf.js.GetIsNonEmptyArray(object.materials) &&
        tf.js.GetIsNonEmptyArray(object.meshes)) {
        combos = [];
        namedMeshes = {};
        scale = tf.js.GetFloatNumber(scale, 1.0);
        for (var i in object.materials) {
            var mat3ds = object.materials[i];
            var mat = tf.webgl.CreateMaterialFrom3DSMeshMaterial(mat3ds);
            var matSettings = mat.GetSettings();
            var texFile = matSettings.texFile;
            var texture2 = tf.js.GetIsNonEmptyString(texFile) ? new tf.webgl.Texture2({ context: context, url: texFile }) : undefined;
            var normalsFile = matSettings.normalsFile;
            var normalsTexture2 = tf.js.GetIsNonEmptyString(normalsFile) ? new tf.webgl.Texture2({ context: context, url: normalsFile, unit: 1 }) : undefined;
            var combo = new tf.webgl.MatTex2VertCombo({ material: mat, texture2: texture2, normalsTexture2: normalsTexture2, vertices: undefined });
            combos.push(combo);
        }
        for (var i in object.meshes) { var mesh = object.meshes[i]; namedMeshes[mesh.name] = mesh; }
        createVertexBuffers(object.rootnode);
        comboList = new tf.webgl.MatTex2VertComboList({ combos: combos, mergeBuffers: mergeBuffers });
        //sceneObject = new tf.webgl.SceneObject({ context: context, program: context.GetMaterialProgram(), comboList: comboList, attributes: undefined, texture: undefined, matrix: undefined });
    }
    return { comboList: comboList, mins: mins, maxs: maxs };
};
tf.webgl.Load3DSModel = function (context, object, scale, mergeBuffers) {
    var comboList, combos, mins, maxs;
    if (tf.js.GetIsInstanceOf(context, tf.webgl.Context) && !!context.GetContext() &&
        tf.js.GetIsValidObject(object) && tf.js.GetIsValidObject(object.rootnode) &&
        tf.js.GetIsNonEmptyArray(object.materials) &&
        tf.js.GetIsNonEmptyArray(object.meshes)) {
        combos = [];
        scale = tf.js.GetFloatNumber(scale, 1.0);
        for (var i in object.materials) {
            var mat3ds = object.materials[i];
            var mat = tf.webgl.CreateMaterialFrom3DSMeshMaterial(mat3ds);
            var matSettings = mat.GetSettings();
            var texFile = matSettings.texFile;
            var texture2 = tf.js.GetIsNonEmptyString(texFile) ? new tf.webgl.Texture2({ context: context, url: texFile }) : undefined;
            var normalsFile = matSettings.normalsFile;
            var normalsTexture2 = tf.js.GetIsNonEmptyString(normalsFile) ? new tf.webgl.Texture2({ context: context, url: normalsFile, unit: 1 }) : undefined;
            var combo = new tf.webgl.MatTex2VertCombo({ material: mat, texture2: texture2, normalsTexture2: normalsTexture2, vertices: undefined });
            combos.push(combo);
        }
        for (var i in object.meshes) {
            var mesh = object.meshes[i];
            if (tf.js.GetIsValidObject(mesh)) {
                var meshMaterialIndex = mesh.materialindex;
                if (meshMaterialIndex >= 0 && meshMaterialIndex < combos.length) {
                    var results = tf.webgl.CreateVertexBufferFrom3DSMesh(context, mesh, scale);
                    if (!!results && !!results.vertexBuffer) {
                        if (mins == undefined) { mins = results.mins.slice(0); maxs = results.maxs.slice(0); }
                        else {
                            for (var minMaxIndex = 0; minMaxIndex < 3 ; ++minMaxIndex) {
                                if (mins[minMaxIndex] > results.mins[minMaxIndex]) { mins[minMaxIndex] = results.mins[minMaxIndex]; }
                                if (maxs[minMaxIndex] < results.maxs[minMaxIndex]) { maxs[minMaxIndex] = results.maxs[minMaxIndex]; }
                            }
                        }
                        combos[meshMaterialIndex].AddVertexBuffer(results.vertexBuffer);
                    }
                }
            }
        }
        comboList = new tf.webgl.MatTex2VertComboList({ combos: combos, mergeBuffers: mergeBuffers });
        //sceneObject = new tf.webgl.SceneObject({ context: context, program: context.GetMaterialProgram(), comboList: comboList, attributes: undefined, texture: undefined, matrix: undefined });
    }
    return { comboList: comboList, mins: mins, maxs: maxs };
};
/*
tf.webgl.Load3DSModel2 = function (context, object, scale) {
    function buildSceneObjectNode(root, node) {
        var sceneObject;
        if (tf.js.GetIsValidObject(node)) {
            //var transformMatrix = new tf.math.Matrix4({ matrix: node.transformation })
            sceneObject = new tf.webgl.SceneObject({ context: context, attributes: undefined, texture: undefined, program: undefined });
            if (tf.js.GetIsNonEmptyArray(node.meshes)) {
                var nMeshes = node.meshes.length;
                //var program = context.GetTextureColorProgram();
                var program = context.GetMaterialProgram();
                var texture = context.GetFourColorTexture();
                for (var i = 0 ; i < nMeshes ; ++i) {
                    var meshIndex = node.meshes[i];
                    var mesh = root.namedMeshes[meshIndex];
                    if (!!mesh) {
                        var attributes = tf.webgl.CreateVertexBufferFrom3DSMesh(context, mesh, scale).vertexBuffer;
                        var material;
                        var meshMaterial = root.materials[mesh.materialindex];
                        if (!!meshMaterial) { material = tf.webgl.CreateMaterialFrom3DSMeshMaterial(meshMaterial); }
                        var meshObject = new tf.webgl.SceneObject({
                            material: material,
                            context: context, attributes: attributes, texture: texture, program: program
                        });
                        sceneObject.AddSubObject(meshObject);
                    }
                }
            }
            if (tf.js.GetIsNonEmptyArray(node.children)) {
                for (var i in node.children) {
                    var subObj = buildSceneObjectNode(root, node.children[i]);
                    if (!!subObj) { sceneObject.AddSubObject(subObj); }
                }
            }
        }
        return sceneObject;
    }
    var sceneObject;
    if (tf.js.GetIsInstanceOf(context, tf.webgl.Context) && !!context.GetContext() &&
        tf.js.GetIsValidObject(object) && tf.js.GetIsValidObject(object.rootnode)) {
        scale = tf.js.GetFloatNumber(scale, 1.0);
        object.namedMeshes = {};
        for (var i in object.meshes) {
            var mesh = object.meshes[i];
            var meshName = mesh.name;
            object.namedMeshes[meshName] = mesh;
        }
        sceneObject = buildSceneObjectNode(object, object.rootnode)
    }
    return sceneObject;
};
tf.webgl.Check3DSModel = function (object) {
    function dumpNode(level, node) {
        if (tf.js.GetIsValidObject(node)) {
            var logStr = 'level: ' + level + ' node: ' + node.name + ' ';
            if (tf.js.GetIsValidObject(node.meshes)) {
                if (!tf.js.GetIsArrayWithLength(node.meshes, 1)) {
                    console.log(logStr + node.meshes.length + ' meshes');
                }
            }
            else {
                console.log(logStr + 'no meshes');
            }
            if (tf.js.GetIsNonEmptyArray(node.children)) {
                for (var i in node.children) {
                    dumpNode(level + 1, node.children[i]);
                }
            }
        }
    }
    function checkMeshes(object) {
        var nWithTexture = 0, nWithNormals = 0;
        console.log('nMeshes: ' + object.meshes.length);
        var allMaxs, allMins;
        for (var i in object.meshes) {
            var mesh = object.meshes[i];
            var meshName = mesh.name;
            var primitiveTypes = mesh.primitivetypes;
            if (i != meshName) {
                if (object.namedMeshes[meshName] == undefined) {
                    console.log('mesh: ' + meshName + ' name differs from index and is not found');
                }
            }
            if (primitiveTypes != 4) {
                console.log('mesh: ' + meshName + ' primitiveTypes is not 4: ' + primitiveTypes);
            }
            if (!!mesh.texturecoords) { ++nWithTexture; }
            if (!!mesh.normals) { ++nWithNormals; }
            var vertices = mesh.vertices;
            if (tf.js.GetIsArrayWithMinLength(vertices, 1)) {
                var nVertices = vertices.length;
                var maxs = [vertices[0], vertices[1], vertices[2]];
                var mins = [vertices[0], vertices[1], vertices[2]];
                for (var j = 3 ; j < nVertices ; j += 3) {
                    for (var k = 0 ; k < 3 ; ++k) {
                        var thisCoord = vertices[j + k];
                        if (thisCoord > maxs[k]) { maxs[k] = thisCoord; }
                        if (thisCoord < mins[k]) { mins[k] = thisCoord; }
                    }
                }
                //console.log('mesh: ' + meshName + ' maxs: ' + maxs + ' mins: ' + mins);
                if (allMaxs == undefined) {
                    allMaxs = maxs.slice(0);
                    allMins = mins.slice(0);
                }
                else {
                    for (var j = 0 ; j < 3 ; ++j) {
                        var thisMax = maxs[j], thisMin = mins[j];
                        if (thisMax > allMaxs[j]) { allMaxs[j] = thisMax; }
                        if (thisMin < allMins[j]) { allMins[j] = thisMin; }
                    }
                }
                var faces = mesh.faces;
                if (tf.js.GetIsArrayWithMinLength(faces, 1)) {
                    for (var j in faces) {
                        var face = faces[j];
                        for (var k in face) {
                            var vertexIndex = face[k];
                            if (vertexIndex < 0 || vertexIndex >= nVertices) {
                                console.log('mesh: ' + meshName + ' face: ' + j + ' index: ' + k + ' is invalid: ' + vertexIndex + ' out of ' + nVertices);
                            }
                        }
                    }
                }
                else {
                    console.log('mesh: ' + meshName + ' has no faces');
                }
            }
            else {
                console.log('mesh: ' + meshName + ' has no vertices');
            }
        }
        console.log('meshes with texture: ' + nWithTexture + ' meshes with normals: ' + nWithNormals);
        if (!!allMaxs) { console.log('meshes allMaxs: ' + allMaxs + ' allMins: ' + allMins); }
    }
    function checkMaterials(object) {
        var materialFields = {};
        for (var i in object.materials) {
            var material = object.materials[i];
            for (var j in material.properties) {
                var prop = material.properties[j];
                var index = prop.index;
                var semantic = prop.semantic;
                var key = prop.key;
                if (index != 0) {
                    console.log('index mat/obj: ' + i + ' / ' + j + ' index: ' + index);
                }
                if (semantic != 0 && semantic != 1 && semantic != 5 && semantic != 7) {
                    console.log('semantic mat/obj: ' + i + ' / ' + j + ' semantic: ' + semantic);
                }
                if (materialFields[key] == undefined) {
                    materialFields[key] = {};
                }
                if (materialFields[key][typeof prop.value] == undefined) {
                    materialFields[key][typeof prop.value] = [];
                }
                materialFields[key][typeof prop.value].push(prop.value);
                switch (key) {
                    case "?mat.name":
                    case "$mat.opacity":
                    case "$mat.shininess":
                    case "$mat.shadingm":
                    case "$mat.shinpercent":
                    case "$mat.bumpscaling":
                    case "$clr.ambient":
                    case "$clr.diffuse":
                    case "$clr.emissive":
                    case "$clr.specular": break;
                    case "$tex.mapmodeu":
                    case "$tex.mapmodev":
                    case "$tex.uvtrafo":
                    case "$tex.file":
                    case "$tex.blend":
                        console.log(key + ' ' + prop.value);
                        break;
                    default:
                        console.log('new material key: ' + key);
                        break;
                }
            }
        }
        //console.log(materialFields);
    }
    if (tf.js.GetIsValidObject(object) && tf.js.GetIsValidObject(object.rootnode)) {
        object.namedMeshes = {};
        for (var i in object.meshes) {
            var mesh = object.meshes[i];
            var meshName = mesh.name;
            object.namedMeshes[meshName] = mesh;
        }
        dumpNode(0, object.rootnode);
        checkMeshes(object);
        checkMaterials(object);
    }
};
*/

// SOURCE FILE: global.js
tf.TFMap = {};
//toolTipClass = 
//tf.TFMap.DontHideToolTipsDebug = true;
tf.TFMap.DontHideToolTipsDebug = false;
tf.TFMap.UseCachedDataSets = false;
//tf.TFMap.UseCachedDataSets = true;
tf.TFMap.CompressClassNames = 0;
//tf.TFMap.CompressClassNames = -1;
tf.TFMap.CreateClassName = function(tag, name) {
    return tf.TFMap.CompressClassNames == -1 ? tag + name : "tf-css" + ++tf.TFMap.CompressClassNames;
};
tf.TFMap.BottomContentTypes = {
    photos: "photos"
};
tf.TFMap.LayoutSettings = {
    rootDivZIndex: 10,
    auxMapWrapperZIndexAdd: 3,
    changeMapTypeButtonAddZIndex: 500,
    baseLayersItemCommonZIndexAdd: 2,
    baseLayersToolBarWrapperZIndexAdd: 3,
    underBottomWrapperZIndexAdd: 2,
    toastZIndexAdd: 1000,
    overRootZIndexAdd: 1001,
    sidePanelWrapperZIndexAdd: 3,
    sidePanelCloseButtonZIndexAdd: 100,
    customAppContentWrapperZIndexAdd: 3,
    listFadeWrapperZIndexAdd: 10,
    directionsInputZIndexAdd: 1,
    directionsInputFadeZIndexAdd: 2,
    diretionsSearchButtonZIndexAdd: 3,
    moreMapToolsInfoContentWrapperZIndexAdd: 2,
    overMapCanvasZIndexAdd: 10,
    mapLogoAndCenterZIndexAdd: 11,
    photoDisplayerWrapperZIndexAdd: 50,
    photoDisplayerContentWrapperZIndexAdd: 1,
    photoDisplayerContentZIndexAdd: 1,
    photoDisplayerButtonZIndexAdd: 2,
    photoListDisplayerWrapperZIndexAdd: 1,
    photoListDisplayerContentZIndexAdd: 1,
    photoListDisplayerSelectRecordButtonZIndexAdd: 2,
    sidePaneWrapperZIndexAdd: 2,
    mapFeaturePropsDisplayerWrapperZIndexAdd: 2,
    propsDisplayerImgHeightPxInt: 186,
    showingAerialClassName: undefined,
    showingMapClassName: undefined,
    distances3Units: undefined,
    arrowLeftBackgroundClassName: undefined,
    arrowRightBackgroundClassName: undefined,
    customizedScrollBarClassName: undefined,
    defaultHorMarginsClassName: undefined,
    smallerTextClassName: undefined,
    hrDivClassName: undefined,
    redFontColorShadowClassName: undefined,
    wrapperAerialModeClassName: undefined,
    wrapperMapModeClassName: undefined,
    lightTextColor: "rgba(245,245,255,1.0)",
    darkTextColor: "#003377",
    inactiveTextColor: "#b0b0b0",
    lightTextShadow: "1px 1px 2px #222",
    darkTextShadow: "1px 1px 2px #fff",
    activeSVGColor: "#003366",
    inactiveSVGColor: "#808080",
    lightBackground: "rgba(240,245,255,0.98)",
    lightBackgroundHalfOpaque: "rgba(240,245,255,0.5)",
    backgroundLivelyColor: "rgb(30, 144, 255)", // "#1E90FF" "dodgerblue" 
    backgroundLivelyColorHex: "#1E90FF", // "dodgerblue" 
    toolTipContentBackground: "#696969",
    directionsSelectedColor: "#C6DAFC",
    listBorderColor: "darkgoldenrod"
};
tf.TFMap.SmallLayoutSettings = {
    mapCenterDimStr: "12rem",
    mapLogoPaddingLeftStr: "10px",
    mapLogoPaddingTopStr: "4px",
    mapLogoPaddingRightStr: "2px",
    mapLogoPaddingBottomStr: "1px",
    mapLogoDimStr: "3rem",
    mapLogoTopStr: "0.5rem",
    mapLogoRightStr: "0.5rem",
    itemInListTitletFontSizeInt: 10,
    itemInListTitleLineHeightInt: 12,
    buttonTextFontSizeInt: 14,
    baseLayersPaneTopCaptionFontSizeInt: 15,
    baseLayersPaneTopCaptionLineHeightInt: 18,
    baseLayersPaneTopCaptionVerPaddingInt: 8,
    baseLayersPaneDefaultFontSizeInt: 10,
    baseLayersPaneDefaultLineHeightInt: 12,
    baseLayersPaneTitleLineHeightInt: 14,
    baseLayersPaneTitlePaddingtInt: 4,
    baseLayersPaneDescFontSizeInt: 9,
    baseLayersPaneDescLineHeightInt: 9,
    baseLayersOptionsRowFontSizeInt: 12,
    baseLayersOptionsRowLineHeightInt: 16,
    measureToolEdgeWidthInt: 8,
    measureToolVertexRadiusInt: 10,
    clusterFeatureDistance: 24,
    clusterCircleRadius: 12,
    widthMapToolBarInt: 26,
    sidePanelCloseButtonTopInt: 12,
    sidePanelCloseButtonDimInt: 14,
    dimMapTypeAuxMarginInt: 2,
    directionsSubDirectionsButtonDimPxInt: 20,
    directionsDisclaimerWrapperHeightInt: 36,
    directionsDisclaimerFontSizeInt: 8,
    directionsDisclaimerLineHeightInt: 9,
    directionsItemDistanceFontSizeInt: 9,
    directionsResultsIconDimInt: 30,
    directionsResultsIconMarginLeftInt: 10,
    directionsResultsIconMarginTopInt: 10,
    directionsItemContentPaddingBottomInt: 10,
    directionsContentBotWrapperFadeHeightInt: 12,
    directionsItemContentFontSizeInt: 10,
    directionsItemContentLineHeightInt: 11,
    directionsSummaryPaddingInt: 8,
    directionsSummaryLargeFontSizeInt: 12,
    directionsSummaryLargeLineHeightInt: 12,
    directionsSummarySmallFontSizeInt: 10,
    directionsSummarySmallLineHeightInt: 10,
    directionsSummaryCommonWidthSubInt: 40,
    directionsCaptionPaddingTopInt: 10,
    directionsHeightInputInt: 16,
    directionsFontSizeInputInt: 12,
    directionsHeightWayPointAddressInt: 16,
    directionsCaptionContentHeightInt: 18,
    directionsSwitchStartEndTopInt: 60,
    paddingLeftWayPointAddressInt: 36,
    directionsCaptionMarginBottomInt: -6,
    propsDisplayerTextButtonFontSizeInt: 11,
    propsDisplayerTextButtonLineHeightInt: 12,
    propsDisplayerWrapperFontSizeInt: 11,
    propsDisplayerWrapperLineHeightInt: 12,
    propsDisplayerCoordsButtonFontSizeInt: 11,
    propsDisplayerCoordsButtonLineHeightInt: 12,
    propsDisplayerTextFontSizeInt: 10,
    propsDisplayerTextLineHeightInt: 11,
    propsDisplayerTitleFontSizeInt: 11,
    propsDisplayerTitleLineHeightInt: 12,
    propsDisplayerWrapperMaxWidthInt: 300,
    CSSLiteralMaxHeightMapFeaturePropsDisplayer: "calc(100% - 80px)",
    moreMapToolsRightInt: 140,
    toolBarToToolBarHorSpacingInt: 16,
    toolBarToScaleLineVerSpacingInt: 8,
    scaleLineHeightInt: 14,
    dimMapTypeAuxInt: 40,
    auxMapBorderDimInt: 1,
    searchBarInputWidthInt: 180,
    topMarginInt: 2,
    leftMarginInt: 2,
    sidePanelWidthInt: 292,
    searchBarPaddingHorInt: 4,
    searchBarPaddingVerInt: 4,
    searchBarInputHeightInt: 15,
    searchBarInputFontSizeInt: 12,
    heightSearchBoxInt: 20,
    underBottomPaneHeightInt: 60,
    toggleButtonHeightInt: 28,
    moreMapToolsFontSizeInt: 10,
    moreMapToolsLineHeightInt: 10,
    dataSetsRowHeightInt: 20,
    dataSetsToolBarHeightInt: 16,
    dataSetsWrapperMarginTopInt: 1
};
tf.TFMap.LayoutSettingsNormal = {
    mapCenterDimStr: "20rem",
    mapLogoPaddingLeftStr: "14px",
    mapLogoPaddingTopStr: "8px",
    mapLogoPaddingRightStr: "4px",
    mapLogoPaddingBottomStr: "2px",
    mapLogoDimStr: "5rem",
    mapLogoTopStr: "1.5rem",
    mapLogoRightStr: "2rem",
    itemInListTitletFontSizeInt: 14,
    itemInListTitleLineHeightInt: 16,
    buttonTextFontSizeInt: 18,
    baseLayersPaneTopCaptionFontSizeInt: 20,
    baseLayersPaneTopCaptionLineHeightInt: 30,
    baseLayersPaneTopCaptionVerPaddingInt: 18,
    baseLayersPaneDefaultFontSizeInt: 16,
    baseLayersPaneDefaultLineHeightInt: 30,
    baseLayersPaneTitleLineHeightInt: 16,
    baseLayersPaneTitlePaddingtInt: 10,
    baseLayersPaneDescFontSizeInt: 12,
    baseLayersPaneDescLineHeightInt: 12,
    baseLayersOptionsRowFontSizeInt: 14,
    baseLayersOptionsRowLineHeightInt: 24,
    measureToolEdgeWidthInt: 4,
    measureToolVertexRadiusInt: 8,
    clusterFeatureDistance: 20,
    clusterCircleRadius: 10,
    sidePanelCloseButtonTopInt: 24,
    sidePanelCloseButtonDimInt: 18,
    directionsSubDirectionsButtonDimPxInt: 32,
    directionsDisclaimerWrapperHeightInt: 60,
    directionsDisclaimerFontSizeInt: 11,
    directionsDisclaimerLineHeightInt: 12,
    directionsItemDistanceFontSizeInt: 11,
    directionsResultsIconDimInt: 40,
    directionsResultsIconMarginLeftInt: 16,
    directionsResultsIconMarginTopInt: 12,
    directionsItemContentPaddingBottomInt: 16,
    directionsContentBotWrapperFadeHeightInt: 30,
    directionsItemContentFontSizeInt: 12,
    directionsItemContentLineHeightInt: 14,
    directionsSummaryPaddingInt: 20,
    directionsSummaryLargeFontSizeInt: 14,
    directionsSummaryLargeLineHeightInt: 14,
    directionsSummarySmallFontSizeInt: 12,
    directionsSummarySmallLineHeightInt: 12,
    directionsSummaryCommonWidthSubInt: 58,
    directionsCaptionPaddingTopInt: 16,
    directionsHeightInputInt: 24,
    directionsFontSizeInputInt: 15,
    directionsHeightWayPointAddressInt: 30,
    paddingLeftWayPointAddressInt: 50,
    directionsCaptionContentHeightInt: 18,
    directionsCaptionMarginBottomInt: 0,
    directionsSwitchStartEndTopInt: 86,
    dimMapTypeAuxMarginInt: 8,
    propsDisplayerWrapperFontSizeInt: 14,
    propsDisplayerWrapperLineHeightInt: 16,
    propsDisplayerCoordsButtonFontSizeInt: 14,
    propsDisplayerCoordsButtonLineHeightInt: 16,
    CSSLiteralMaxHeightMapFeaturePropsDisplayer: "50%",
    propsDisplayerTextFontSizeInt: 14,
    propsDisplayerTextLineHeightInt: 16,
    propsDisplayerTitleFontSizeInt: 14,
    propsDisplayerTitleLineHeightInt: 16,
    propsDisplayerWrapperMaxWidthInt: 360,
    propsDisplayerTextButtonFontSizeInt: 14,
    propsDisplayerTextButtonLineHeightInt: 16,
    moreMapToolsRightInt: 160,
    toolBarToToolBarHorSpacingInt: 18,
    toolBarToScaleLineVerSpacingInt: 12,
    scaleLineHeightInt: 16,
    dimMapTypeAuxInt: 80,
    auxMapBorderDimInt: 3,
    zIndexToolTipInt: 100,
    arrowDimsToolTipInt: 16,
    fontSizeToolTipInt: 12,
    fontWeightToolTip: "600",
    altaSmallCanvasDim: 16,
    altaLargeCanvasDim: 24,
    topMarginInt: 8,
    leftMarginInt: 8,
    sidePanelWidthInt: 400,
    searchBarInputWidthInt: 240,
    searchBarHorizPaddingInt: 4,
    searchBarPaddingHorInt: 8,
    searchBarPaddingVerInt: 4,
    searchBarInputHeightInt: 24,
    searchBarInputFontSizeInt: 15,
    heightSearchBoxInt: 40,
    widthMapToolBarInt: 30,
    marginBottomBottomPaneWrapperInt: 0,
    underBottomPaneHeightInt: 100,
    propsToolBarButtonWidthInt: 24,
    maxFeaturePropsDisplayHeightInt: 300,
    minWidthPropsDisplayerInt: 150,
    toggleButtonHeightInt: 48,
    moreMapToolsFontSizeInt: 12,
    moreMapToolsLineHeightInt: 12,
    dataSetsRowHeightInt: 30,
    dataSetsToolBarHeightInt: 18,
    dataSetsWrapperMarginTopInt: 4
};
tf.TFMap.ImageUnavailableMsg = "Image<br />temporarily<br />unavailable";
tf.TFMap.CreateCSSClasses = function(cssClasses) {
    if (tf.js.GetIsValidObject(cssClasses)) {
        var styles = tf.GetStyles(), styleCreator = styles.GetStyleCreator(), cssStyles = [];
        for (var i in cssClasses) { var cssStr = cssClasses[i], cssName = '.' + i; cssStyles.push({ styleName: cssName, inherits: cssStr }); }
        styleCreator.CreateStyles(cssStyles);
    }
};
tf.TFMap.MakeHRDivHTML = function() { return "<div class='" + tf.TFMap.LayoutSettings.hrDivClassName + "'></div>"; };
tf.TFMap.MapTwoLineSpan = function(topLine, botLine) {
    var ls = tf.TFMap.LayoutSettings;
    var hrDivStr = tf.TFMap.MakeHRDivHTML();
    var classStr = "class='" + ls.defaultHorMarginsClassName + "'";
    var spanStart = "<span " + classStr + ">";
    return spanStart + topLine + "</span>" + hrDivStr + spanStart + botLine + '</span > ';
};
tf.TFMap.DirectionsFeatureDimMult = 1.8;
tf.TFMap.MaxDirectionsWayPoints = 5;
tf.TFMap.maxCharsAddressInput = 80;
tf.TFMap.directionModeWalk = tf.consts.routingServiceModeFoot;
tf.TFMap.directionModeDrive = tf.consts.routingServiceModeCar;
tf.TFMap.directionModeBike = tf.consts.routingServiceModeBicycle;
tf.TFMap.directionModeBus = tf.consts.routingServiceModeBus;
tf.TFMap.CAN_directionsMode = "directionsMode";
tf.TFMap.CAN_showingDirections = "showingDirections";
tf.TFMap.CAN_isSearchingAddress = "searchingAddress";
tf.TFMap.CAN_sidePanelVisible = "sidePaneVisible";
tf.TFMap.CAN_dataSetsPanelVisible = "dataSetsPaneVisible";
tf.TFMap.CAN_selectedSearch = "selectedSearch";
tf.TFMap.CAN_selectedToolTipSender = "selectedToolTipSender";
tf.TFMap.CAN_userLocation = "userLocation";
tf.TFMap.CAN_clickLocation = "clickLocation";
tf.TFMap.CAN_searchAddressLocation = "searchAddressLocation";
tf.TFMap.StartLocationName = "starting point";
tf.TFMap.EndLocationName = "destination";
//tf.TFMap.MinMapLevel = 11;
//tf.TFMap.MaxMapLevel = 18;
tf.TFMap.MinMapLevel = tf.consts.minLevel;
tf.TFMap.MaxMapLevel = tf.consts.maxLevel;
tf.TFMap.toolTipDelayMillis = 800;
tf.TFMap.MapFeatureToolTipDelayMillis = 300;
tf.TFMap.DelayDirections = 150;
tf.TFMap.DelayShowSearching = tf.TFMap.DelayDirections * 2;
tf.TFMap.AddWayPointToolTipDelayMillis = 800;
tf.TFMap.toolTipDataSetDelayMillis = 800;
tf.TFMap.dataSetListButtonToolTipDelayMillis = tf.TFMap.toolTipDataSetDelayMillis;
tf.TFMap.SearchResultsLayerZIndex = 1;
tf.TFMap.UserLocationLayerZIndex = 10;
tf.TFMap.UserFriendlyModeVerbs = {};
tf.TFMap.UserFriendlyModeVerbs[tf.TFMap.directionModeDrive] = "Driving";
tf.TFMap.UserFriendlyModeVerbs[tf.TFMap.directionModeBike] = "Cycling";
tf.TFMap.UserFriendlyModeVerbs[tf.TFMap.directionModeWalk] = "Walking";
tf.TFMap.UserFriendlyModeVerbs[tf.TFMap.directionModeBus] = "By Bus";
tf.TFMap.ValidateImageOrDisplayMessage = function(imageSrc, messageContainer, asyncCallBack, optionalParam) {
    new tf.dom.Img({
        src: imageSrc, onLoad:
        function onImageLoaded(theImage) {
            if (asyncCallBack(imageSrc, messageContainer, optionalParam, theImage)) {
                if (!theImage.GetIsValid()) {
                    //console.log('bum image');
                    tf.dom.GetHTMLElementFrom(messageContainer).innerHTML = tf.TFMap.ImageUnavailableMsg;
                }
            }
        }
    });
};
tf.TFMap.GetDirectionsDistanceText = function(totalDistanceMeters, useUSScaleUnits) {
    var text = "";
    if (useUSScaleUnits) {
        var distanceMiles = totalDistanceMeters * 0.000621371;
        if (distanceMiles > 0.1) { text = distanceMiles.toFixed(1) + ' mi'; }
        else { var distanceFeet = totalDistanceMeters * 3.28084; text = distanceFeet.toFixed(0) + ' ft'; }
    }
    else {
        if (totalDistanceMeters < 250) { text = totalDistanceMeters.toFixed(0) + ' m'; }
        else { text = (totalDistanceMeters / 1000).toFixed(1) + ' km'; }
    }
    return text;
};
tf.TFMap.GetWalkRideDistanceStr = function (walkDistanceKM, rideDistanceKM, useUSScaleUnits) {
    var walkRideDistanceStr = ""
    if (walkDistanceKM > 0) {
        var walkDistanceText = tf.TFMap.GetDirectionsDistanceText(walkDistanceKM * 1000, useUSScaleUnits);
        walkRideDistanceStr += "walk " + walkDistanceText;
    }
    if (rideDistanceKM > 0) {
        var rideDistanceText = tf.TFMap.GetDirectionsDistanceText(rideDistanceKM * 1000, useUSScaleUnits);
        if (walkDistanceKM > 0) { walkRideDistanceStr += ", "; }
        walkRideDistanceStr += "ride " + rideDistanceText;
    }
    return walkRideDistanceStr;
};
tf.TFMap.FindNearestAddress = function(then, coords, props) {
    var routingService;
    if (tf.js.GetFunctionOrNull(then)) {
        routingService = new tf.services.Routing({ callBack: then, nearestOnly: true, coords: coords, requestProps: props });
    }
    return routingService;
};
tf.TFMap.FindLocationAddress = function(then, coords, props) {
    var routingService;
    if (tf.js.GetFunctionOrNull(then)) {
        routingService = new tf.services.Routing({ callBack: then, locateOnly: true, coords: coords, requestProps: props });
    }
    return routingService;
};
tf.TFMap.ReplaceHTML = function(str) {
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
};
tf.TFMap.GetSearchFeature = function(mapFeature) { return !!mapFeature ? mapFeature.GetSettings().searchFeature : undefined; }
tf.TFMap.GetSearchProps = function(mapFeature) { var searchFeature = tf.TFMap.GetSearchFeature(mapFeature); return !!searchFeature ? searchFeature.properties : undefined; }
tf.TFMap.GetMapFeatureToolTipProps = function(mapFeature) { return !!mapFeature ? mapFeature.GetSettings().toolTipProps : undefined; }
tf.TFMap.SetMapFeatureToolTipProps = function(mapFeature, toolTipProps) {
    if (!!mapFeature) {
        if (!!toolTipProps) {
            toolTipProps.mapFeature = mapFeature;
            mapFeature.GetSettings().toolTipProps = toolTipProps;
        }
        else {
            if (!!mapFeature.GetSettings().toolTipProps) {
                delete mapFeature.GetSettings().toolTipProps.mapFeature;
                delete mapFeature.GetSettings().toolTipProps;
            }
        }
    }
}
tf.TFMap.SetVerticalMapToolTipStyle = function(size, pixelCoords, styleContent, styleArrow) {
    var ls = tf.TFMap.LayoutSettings;
    var arrowDimsToolTipInt = ls.arrowDimsToolTipInt;
    var fraction = 1 / 4;
    var isTop = pixelCoords[1] < size[1] * fraction;
    var isBottom = pixelCoords[1] > size[1] * (1 - fraction);
    var offSetTopInt = arrowDimsToolTipInt;
    var transformText;
    if (isTop) { styleContent.top = (pixelCoords[1] - offSetTopInt) + "px"; transformText = "translateY(0%)"; }
    else if (isBottom) { styleContent.top = (pixelCoords[1] + offSetTopInt) + "px"; transformText = "translateY(-100%)"; }
    else { transformText = "translateY(-50%)"; }
    styleContent["-webkit-transform"] = styleContent.transform = transformText;
};
tf.TFMap.MapToolTipLeftRightStyle = function(mapFeatureSender, rectWrapper, rectObj, styleContent, styleArrow, isLeft) {
    var ls = tf.TFMap.LayoutSettings;
    var arrowDimsToolTipInt = ls.arrowDimsToolTipInt;
    var halfToolTipDim = arrowDimsToolTipInt / 2;
    var map = mapFeatureSender.map, size = map.GetPixelSize(), pointCoords = mapFeatureSender.coords,
        pixelCoords = map.MapToPixelCoords(pointCoords);
    var offsetX = mapFeatureSender.offsetX != undefined ? mapFeatureSender.offsetX : 0;
    var offsetY = mapFeatureSender.offsetY != undefined ? mapFeatureSender.offsetY : 0;
    var sign = isLeft ? 1 : -1;
    pixelCoords[0] += offsetX * sign;
    pixelCoords[1] += offsetY * sign;
    styleContent.top = pixelCoords[1] + "px";
    styleArrow.top = (pixelCoords[1] - halfToolTipDim) + "px";
    if (isLeft) { styleContent.left = (pixelCoords[0]) + "px"; styleArrow.left = (pixelCoords[0] - halfToolTipDim) + "px"; }
    else { styleContent.right = (size[0] - pixelCoords[0]) + "px"; styleArrow.right = (size[0] - (pixelCoords[0] + halfToolTipDim)) + "px"; }
    tf.TFMap.SetVerticalMapToolTipStyle(size, pixelCoords, styleContent, styleArrow);
};
tf.TFMap.MapToolTipLeftStyle = function(mapFeatureSender, rectWrapper, rectObj, styleContent, styleArrow) {
    return tf.TFMap.MapToolTipLeftRightStyle(mapFeatureSender, rectWrapper, rectObj, styleContent, styleArrow, true);
};
tf.TFMap.MapToolTipRightStyle = function(mapFeatureSender, rectWrapper, rectObj, styleContent, styleArrow) {
    return tf.TFMap.MapToolTipLeftRightStyle(mapFeatureSender, rectWrapper, rectObj, styleContent, styleArrow, false);
};
tf.TFMap.GetDynamicMapFeatureToolTipProps = function (map, mapFeature, pointCoords, sidePanelWidthInt) {
    var mapFeatureToolTipProps = tf.TFMap.GetMapFeatureToolTipProps(mapFeature);
    var pixelCoords = map.MapToPixelCoords(pointCoords);
    var size = map.GetPixelSize();
    var toolTipArrowClass, toolTipStyle;
    var isOnRightSide = pixelCoords[0] > (size[0] + sidePanelWidthInt) / 2;
    if (isOnRightSide) {
        toolTipArrowClass = "right";
        toolTipStyle = tf.TFMap.MapToolTipRightStyle;
    }
    else {
        toolTipArrowClass = "left"
        toolTipStyle = tf.TFMap.MapToolTipLeftStyle;
    }
    return tf.js.ShallowMerge({
        toolTipArrowClass: toolTipArrowClass, delayMillis: tf.TFMap.MapFeatureToolTipDelayMillis, toolTipStyle: toolTipStyle, toolTipText: ""
    }, mapFeatureToolTipProps);
};
tf.TFMap.SetContentToolTipInfo = function (toolTipProps, toolTipText, wrapper, delayUse, toolTipClassName,
    toolTipArrowClassName, toolTipStyle, keepOnHoverOutTarget, toolTipFunction, insertWrapper) {
    toolTipProps.toolTipText = toolTipText;
    toolTipProps.toolTipFunction = toolTipFunction;
    toolTipProps.wrapper = wrapper;
    toolTipProps.insertWrapper = insertWrapper;
    toolTipProps.delayUse = delayUse != undefined ? delayUse : 0;
    toolTipProps.toolTipClassName = toolTipClassName;
    toolTipProps.toolTipArrowClassName = toolTipArrowClassName;
    toolTipProps.toolTipStyle = toolTipStyle;
    toolTipProps.keepOnHoverOutTarget = !!keepOnHoverOutTarget;
};
tf.TFMap.SetButtonToolTipInfo = function(button, toolTipText, wrapper, delayUse, toolTipClassName, toolTipArrowClassName, toolTipStyle,
    keepOnHoverOutTarget, toolTipFunction, insertWrapper, offsetX, offsetY) {
    button.element = button.GetButton();
    tf.TFMap.SetContentToolTipInfo(button, toolTipText, wrapper, delayUse, toolTipClassName, toolTipArrowClassName, toolTipStyle, keepOnHoverOutTarget, toolTipFunction, insertWrapper)
    button.offsetX = offsetX;
    button.offsetY = offsetY;
};
tf.TFMap.GetMapFeatureToolTipInfo = function(mapFeature, map, toolTipText, wrapper, delayUse, toolTipClassName, toolTipArrowClassName,
    toolTipStyle, coords, offsetX, offsetY, onClick, keepOnHoverOutTarget) {
    var coordsUse;
    if (coords != undefined) { coordsUse = coords; }
    else { coordsUse = mapFeature.GetPointCoords(); }
    var mapFeatureToolTipInfo = {
        startInHover: true,
        mapFeature: mapFeature, map: map, coords: coordsUse, offsetX: offsetX, offsetY: offsetY,
        onClick: onClick
    };
    tf.TFMap.SetContentToolTipInfo(mapFeatureToolTipInfo, toolTipText, wrapper, delayUse, toolTipClassName, toolTipArrowClassName, toolTipStyle, keepOnHoverOutTarget)
    return mapFeatureToolTipInfo;
};
tf.TFMap.CreateSVGButton = function (appContent, buttonSettings, svgHTML, buttonClass, toolTipText, svgAddClasses, modeVerb) {
    var button = appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, {
        svgHTML: svgHTML,
        buttonClass: buttonClass + " ripple", toolTipText: toolTipText
    }));
    button.GetSettings().modeVerb = modeVerb;
    var buttonSVG = button.GetButton().firstChild;
    if (svgAddClasses != undefined) { tf.dom.AddCSSClass(buttonSVG, svgAddClasses); }
    return button;
};

// SOURCE FILE: perspectivemap.js
tf.consts.perspectiveMapLostDeviceEvent = "lostdevice";
tf.consts.perspectiveMapRestoredDeviceEvent = "restoreddevice";
tf.consts.perspectiveMapVisibilityChangeEvent = "visibilityChange";
tf.consts.allPerspectiveMapEventNames = [
    tf.consts.perspectiveMapLostDeviceEvent,
    tf.consts.perspectiveMapRestoredDeviceEvent,
    tf.consts.perspectiveMapVisibilityChangeEvent
];
tf.webgl.PerspectiveMap = function (settings) {
    var theThis, allEventDispatchers, map, webGL, context, ctx, canvas, mapTexture, wrapper;
    var scene, mapSceneObject, objectCreationSettings;
    var viewRadius, viewAngle, mapSize, mapAspect;
    var renderCount, pickFrameBufferRenderCount, pickFrameBufferDim, pickFrameBuffer, pickedColor;
    var inversePerspective, ptOrigin, vYAxisUnit, cameraPos, cameraDir;
    var renderMap, renderMapXScale, renderMapYScale, renderAspect, forceUpdatePerspective;
    var isVisible, onDelaySetMapSize, mapLeftInt, mapTopInt, sceneAspect, sceneNear, tempVec3;
    this.PixelActualToVirtual = function (coords) { return pixelActualToVirtual(coords); }
    this.PixelVirtualToActual = function (coords) { return pixelVirtualToActual(coords); }
    this.GetMapSize = function () { return mapSize; }
    this.AddListener = function (eventName, callBack) { return allEventDispatchers.AddListener(eventName, callBack); }
    this.GetIsVisible = function () { return getIsVisible(); }
    this.SetIsVisible = function (bool) { return setIsVisible(bool); }
    this.IsDeleted = function () { return isDeleted(); }
    this.OnDelete = function () { return onDelete(); }
    this.GetContext = function () { return context; }
    this.GetMap = function () { return map; }
    this.GetScene = function () { return scene; }
    function onDelete() { if (!isDeleted()) { webGL = undefined; } }
    function isDeleted() { return webGL == undefined; }
    function getIsVisible() { return !isDeleted() && isVisible; }
    function setIsVisible(bool) {
        if (!isDeleted()) {
            if (getIsVisible() != (bool = !!bool)) {
                isVisible = bool;
                checkControlVisible();
                notifyListeners(tf.consts.perspectiveMapVisibilityChangeEvent);
                if (bool) { if (context.IsContextLost()) { context.RestoreContext(); } else { onFrame(); } }
                checkMapSize();
            }
        }
    }
    function checkControlVisible() {
        //wrapper.GetHTMLElement().style.zIndex = isVisible ? '11' : '9';
        wrapper.GetHTMLElement().style.opacity = isVisible ? '1' : '0';
    }
    function checkMapSize() {
        var mapContainer = settings.appContent.GetMapDiv(), mapContainerE = mapContainer.GetHTMLElement();
        var mapMapContainer = settings.appContent.GetMapMapDiv(), mapMapContainerE = mapMapContainer.GetHTMLElement(), mapMapContainerES = mapMapContainerE.style;
        var wMapContainer = mapContainerE.clientWidth, hMapContainer = mapContainerE.clientHeight;
        var left, top, width, height, widthStr, heightStr;
        var needChange;
        if (isVisible) {
            width = Math.round(wMapContainer * renderMapXScale);
            height = Math.round(hMapContainer * renderMapYScale);
            mapLeftInt = (wMapContainer - width) / 2;
            mapTopInt = (hMapContainer - height) / 2;
            widthStr = width + 'px';
            heightStr = height + 'px';
            needChange = parseInt(mapMapContainerES.width, 10) != width || parseInt(mapMapContainerES.height, 10) != height;
        }
        else {
            mapLeftInt = mapTopInt = 0;
            widthStr = heightStr = "100%";
            width = wMapContainer;
            height = wMapContainer;
            needChange = mapMapContainerES.width != widthStr;
        }
        if (!!needChange) {
            //console.log('changed map size');
            forceUpdatePerspective = true;
            mapMapContainerES.left = mapLeftInt + "px";
            mapMapContainerES.top = mapTopInt + "px";
            mapMapContainerES.width = widthStr;
            mapMapContainerES.height = heightStr;
            onDelaySetMapSize.DelayCallBack();
        }
    }
    function delayedSetMapSize() { map.OnResize(); forceUpdatePerspective = true; updateMapSettings(); }
    function updateInversePerspective() {
        if (!isDeleted()) {
            inversePerspective.CopyFrom(scene.GetPerspective()); inversePerspective.ToInverse();
            if (!!mapSceneObject) {
                var dim = 0.5;
                var x = dim / (mapAspect), y = 0, z = dim;
                var vertices = new Float32Array([x, y, -z, -x, y, -z, -x, y, z, x, y, z]);
                mapSceneObject.GetAttributes().GetPos().Update(vertices);
            }
        }
    }
    function updateMapSettings() {
        mapSize = map.GetActualPixelSize();
        //console.log('map pixel size: ' + mapSize);
        if (mapSize[0] <= 0) { mapSize[0] = 1; }
        if (mapSize[1] <= 0) { mapSize[1] = 1; }
        mapAspect = mapSize[1] / mapSize[0];
        if (canvas.clientWidth != canvas.width || canvas.clientHeight != canvas.height || forceUpdatePerspective) {
            forceUpdatePerspective = false;
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            var scenePersp = !!canvas.height && !!canvas.width ? canvas.width / canvas.height : 1;
            sceneAspect = scenePersp;
            scene.GetPerspective().UpdateAspect(scenePersp);
            updateInversePerspective();
            //console.log('updated perspective ' + scenePersp);
        }
    }
    function mapQuadCoordsToPerspectiveMapPixelCoords(mapQuadCoords) {
        var coords = mapQuadCoordsToMapPixelCoords(mapQuadCoords);
        return !!coords ? [coords[0] + mapLeftInt, coords[1] + mapTopInt] : coords;
    }
    function intersectRayPlane(rayOrigin, rayDirection, planeOrigin, planeNormal) {
        var ptIntersect, planeNormalDotRayDirection = planeNormal.Dot(rayDirection);
        if (Math.abs(planeNormalDotRayDirection) > 0.0000001) {
            var diffV = new tf.math.Vector3({ vector: planeOrigin }); diffV.Sub(rayOrigin);
            var planeNormalDotDiffV = planeNormal.Dot(diffV);
            var distance = planeNormalDotDiffV / planeNormalDotRayDirection;
            var rayDir = new tf.math.Vector3({ vector: rayDirection });
            rayDir.MultByScalar(distance);
            ptIntersect = new tf.math.Vector3({ vector: rayOrigin });
            ptIntersect.Add(rayDir);
        }
        return ptIntersect;
    }
    function quadCoordsToPerspectiveMapQuadCoords(quadCoords) {
        var view = scene.GetView();
        cameraPos.Update(view.GetView().vFrom);
        cameraDir.Update({ x: quadCoords[0], y: quadCoords[1], z: 1 });
        cameraDir.MultByMatrix(inversePerspective);
        cameraDir.MultByMatrix(view.GetInverse());
        cameraDir.Sub(cameraPos);
        cameraDir.Normalize();
        return intersectRayPlane(cameraPos, cameraDir, ptOrigin, vYAxisUnit);
    }
    function canvasPixelCoordsToPerspectiveMapQuadCoords(canvasPixelCoords) {
        var x = (2 * canvasPixelCoords[0]) / canvas.width - 1;
        var y = 1 - (2 * canvasPixelCoords[1] / canvas.height);
        return quadCoordsToPerspectiveMapQuadCoords([x, y]);
    }
    function mapPixelCoordsToMapPixelCoordsLeftTopZero(mapPixelCoords) { return [mapPixelCoords[0] + mapLeftInt, mapPixelCoords[1] + mapTopInt]; }
    function mapPixelCoordsToPerspectiveMapQuadCoords(mapPixelCoords) {
        return !!mapPixelCoords ?
            canvasPixelCoordsToPerspectiveMapQuadCoords(mapPixelCoordsToMapPixelCoordsLeftTopZero(mapPixelCoords)) :
            mapPixelCoords;
    }
    function mapQuadCoordsToMapPixelCoords(mapQuadCoords) { return [((mapQuadCoords[0] * mapAspect) + 0.5) * mapSize[0], (mapQuadCoords[2] + 0.5) * mapSize[1] ]; }
    function mapActualPixelToMapTransformedPixel(mapPixelCoords) {
        var mapQuadCoords = mapPixelCoordsToPerspectiveMapQuadCoords(mapPixelCoords);
        if (!!mapQuadCoords) { return mapQuadCoordsToMapPixelCoords(mapQuadCoords); }
    }
    function pixelActualToVirtual(pixelCoords) { if (getIsVisible()) { return mapActualPixelToMapTransformedPixel(pixelCoords); } }
    function mapPixelCoordsTransformedToMapPixelCoordsLeftTopZero(mapPixelCoords) { return [mapPixelCoords[0] - mapLeftInt, mapPixelCoords[1] - mapTopInt]; }
    this.PointCoordsToQuadCoords = function (pointCoords) { return mapCanvasPixelToMapQuadCoords(pointCoords); }
    function mapCanvasPixelToMapQuadCoords(canvasPixelCoords) {
        var pX = canvasPixelCoords[0], w = mapSize[0], w2 = w / 2
        var pY = canvasPixelCoords[1], h = mapSize[1], h2 = h / 2
        pX -= w2; pX /= w * mapAspect;
        pY -= h2; pY /= h;
        return [pX, pY];
    }
    function mapQuadCoordsToCanvasTransformedPixelCoords(mapQuadCoords) {
        tempVec3.Update({ x: mapQuadCoords[0], y: 0, z: mapQuadCoords[1] });
        tempVec3.MultByMatrix(scene.GetViewProj());
        return [(tempVec3[0] + 1) * canvas.width / 2, canvas.height - (tempVec3[1] + 1) * canvas.height / 2];
    }
    function mapCanvasPixelToCanvasTransformedPixel(canvasPixelCoords) { return mapQuadCoordsToCanvasTransformedPixelCoords(mapCanvasPixelToMapQuadCoords(canvasPixelCoords)); }
    function pixelVirtualToActual(pixelCoords) { if (getIsVisible()) { return mapCanvasPixelToCanvasTransformedPixel(pixelCoords); } }
    function drawFrame(onContext) {
        var mapCanvas = map.GetCanvas();;
        if (!!mapCanvas) {
            updateMapSettings();
            mapTexture.UpdateFromImage(mapCanvas, true);
            scene.OnPreRender();
            var renderOptions = {
                onPostCompose: onScenePostCompose,
                viewportWidth: canvas.width, viewportHeight: canvas.height,
                isForPick: false, frameBuffer: undefined, clearColor: [0, 0, 0, 0]/* undefined*/, useProgram: undefined
            };
            scene.RenderOn(renderOptions);
            if (((++renderCount) % pickFrameBufferRenderCount) == 0) {
                renderOptions.viewportWidth = renderOptions.viewportHeight = pickFrameBufferDim;
                renderOptions.isForPick = true;
                renderOptions.frameBuffer = pickFrameBuffer.GetFrameBuffer();
                renderOptions.clearColor = [0, 0, 0, 0];
                renderOptions.useProgram = context.GetTextureColorPickProgram();
                scene.RenderOn(renderOptions);
            }
        }
    }
    function restoreContext() { if (!!context) { context.RestoreContext(); } }
    function onFrame(notification) { if (getIsVisible()) { checkMapSize(); drawFrame(context); context.RequestAnimFrame(); } }
    function onLost(notification) { notifyListeners(tf.consts.perspectiveMapLostDeviceEvent); if (getIsVisible()) { setIsVisible(false); } }
    function onRestored(notification) { if (!!webGL) { forceUpdatePerspective = true; notifyListeners(tf.consts.perspectiveMapRestoredDeviceEvent); setTimeout(function () { return onFrame(notification); }, 100); } }
    function notifyListeners(eventName, moreArgs) { allEventDispatchers.Notify(eventName, tf.js.ShallowMerge(moreArgs, { sender: theThis, eventName: eventName })); }
    function onScenePostCompose(notification) { notifyListeners(tf.consts.perspectiveMapPostComposeEvent, { sender: theThis, sceneNotification: notification }); }
    function initContext(onContext) {
        var sceneFar = 100;
        var viewY = Math.sin(viewAngle) * viewRadius;
        var viewZ = Math.cos(viewAngle) * viewRadius;
        var vFrom = [0, viewY, viewZ], vTo = [0, 0, 0];
        var view = { vFrom: vFrom, vTo: vTo, vUp: [0, 1, 0] };
        var ambientComponent = 1, lightComponent = 0.75;
        var normals = new Float32Array([0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0]);
        var program = onContext.GetTextureColorProgram(), quad = new tf.webgl.QuadXY({ context: onContext });
        scene = new tf.webgl.Scene({
            context: onContext, clearColor: [1, 1, 1, 1], clearDepth: 1,
            ambientColor: [ambientComponent, ambientComponent, ambientComponent],
            lightDir: [0, 0, 1], lightColor: [lightComponent, lightComponent, lightComponent],
            view: view, perspective: { fovy: 30 * Math.PI / 180, near: sceneNear, far: sceneFar }
        });
        updateInversePerspective();
        mapSceneObject = new tf.webgl.SceneObject({ context: onContext, attributes: quad, texture: mapTexture, program: program });
        mapSceneObject.GetAttributes().GetNor().Update(normals);
        scene.AddObject(mapSceneObject);
        //createTests(onContext);
    }
    var cssTag, cssClassNames;
    function createCSSClassNames() {
        cssClassNames = {
            wrapperClassName: tf.TFMap.CreateClassName(cssTag, "Wrapper"),
            canvasClassName: tf.TFMap.CreateClassName(cssTag, "Canvas")
        };
    }
    function createCSSClasses() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var cssClasses = [];
        //var ls = tf.TFMap.LayoutSettings;
        var commonSettings = {
            inherits: [CSSClasses.robotoFontFamily, CSSClasses.fontSize16px, CSSClasses.overflowHidden, CSSClasses.noMarginNoBorderNoPadding,
            CSSClasses.WHOneHundred, CSSClasses.displayBlock, CSSClasses.cursorDefault, CSSClasses.positionAbsolute, CSSClasses.leftTopZero, CSSClasses.pointerEventsNone],
            background: "white"
        };
        cssClasses[cssClassNames.wrapperClassName] = {
            inherits: [commonSettings, CSSClasses.transitionPoint2s],
            zIndex: "11"
        };
        cssClasses[cssClassNames.canvasClassName] = {
            inherits: [commonSettings]
        };
        return cssClasses;
    }
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function getDisplayPixelSize() { return getIsVisible() ? [canvas.width, canvas.height] : undefined; }
    function initialize() {
        cssTag = 'perspectiveMap';
        createCSSClassNames();
        registerCSSClasses();
        settings = tf.js.GetValidObjectFrom(settings);
        //viewAngle = 90 * Math.PI / 180;
        //viewRadius = 2.5;
        //viewRadius = 2;
        //viewRadius = 1.5;
        viewRadius = 0.66;
        viewAngle = 35 * Math.PI / 180;
        sceneNear = viewRadius / 2;
        var scaleScale = 1.4;
        renderMapXScale = 1 * scaleScale;
        renderMapYScale = 1.5 * scaleScale;
        renderAspect = renderMapXScale / renderMapYScale;
        mapSize = [100, 100];
        mapAspect = 1;
        inversePerspective = new tf.math.Matrix4({ noInit: true });
        ptOrigin = new tf.math.Vector3({ x: 0, y: 0, z: 0 });
        vYAxisUnit = new tf.math.Vector3({ x: 0, y: 1, z: 0 });
        tempVec3 = new tf.math.Vector3({ x: 0, y: 1, z: 0 });
        cameraPos = new tf.math.Vector3();
        cameraDir = new tf.math.Vector3();
        allEventDispatchers = new tf.events.MultiEventNotifier({ eventNames: tf.consts.allPerspectiveMapEventNames });
        sceneAspect = 1;
        if (map = tf.js.GetMapFrom(settings.map)) {
            webGL = tf.webgl.GetWebGL();
            if (webGL.GetHasWebGL()) {
                onDelaySetMapSize = new tf.events.DelayedCallBack(50, delayedSetMapSize, theThis);
                context = new tf.webgl.Context({ optionalAttributes: { antialias: true }, onFrame: onFrame, onLost: onLost, onRestored: onRestored });
                objectCreationSettings = { map: map, context: context, perspectiveMap: theThis };
                mapTexture = new tf.webgl.Texture2({ context: context, img: map.GetCanvas() });
                ctx = context.GetContext();
                canvas = context.GetCanvas();
                canvas.className = cssClassNames.canvasClassName;
                pickedColor = new Uint8Array(4);
                renderCount = 0;
                pickFrameBufferRenderCount = 10;
                pickFrameBufferDim = 512;
                pickFrameBuffer = new tf.webgl.FrameBuffer({ context: context, width: pickFrameBufferDim, height: pickFrameBufferDim });
                wrapper = new tf.dom.Div({ cssClass: cssClassNames.wrapperClassName });
                wrapper.AddContent(canvas);
                initContext(context);
                forceUpdatePerspective = true;
                updateMapSettings();
                map.SetActualToVirtualPixelTranslateCallBacks(pixelActualToVirtual, pixelVirtualToActual, getDisplayPixelSize);
                onFrame();
                setIsVisible(!tf.js.GetIsFalseNotUndefined(settings.isVisible));
                settings.appContent.GetMapDiv().AddContent(wrapper);
            }
            else { webGL = map = undefined; }
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.webgl.AssociateMapFeatureAndPerspectivePointFeature = function (mapFeature, perspectivePointFeature) {
    var OK = false;
    if (!!mapFeature && !!perspectivePointFeature) {
        if (mapFeature.GetIsPoint()) {
            var mfs = mapFeature.GetSettings();
            mfs.perspectiveFeature = perspectivePointFeature;
            perspectivePointFeature.mapFeature = mapFeature;
            OK = true;
        }
    }
    return OK;
};
tf.webgl.DessociateMapFeatureAndPerspectivePointFeature = function (mapFeature, perspectivePointFeature) {
    var OK = false;
    if (!!mapFeature && !!perspectivePointFeature) {
        if (mapFeature.GetIsPoint()) {
            var mfs = mapFeature.GetSettings();
            delete mfs.perspectiveFeature;
            delete perspectivePointFeature.mapFeature;
            OK = true;
        }
    }
    return OK;
};
tf.webgl.PerspectivePointFeatureFromMapFeature = function (mapFeature) { return !!mapFeature ? mapFeature.GetSettings().perspectiveFeature : undefined; }
tf.webgl.MapFeatureFromPerspectivePointFeature = function (perspectivePointFeature) { return !!perspectivePointFeature ? perspectivePointFeature.mapFeature : undefined; }
tf.webgl.PerspectivePointFeature = function (settings) {
    var theThis, sceneObj, objTexture, objCanvas;
    this.GetIsDeleted = function () { return sceneObj == undefined; }
    this.OnDelete = function () {
        deleteSceneObj();
        tf.webgl.DessociateMapFeatureAndPerspectivePointFeature(settings.mapFeature, theThis);
        settings.mapFeature = undefined;
    }
    function deleteSceneObj() {
        if (!!sceneObj) {
            var pLayer = settings.perspectiveLayer, pMap = pLayer.GetPerspectiveMap(), scene = pMap.GetScene();
            var sceneObjSaved = sceneObj;
            sceneObj = undefined;
            scene.DelObject(sceneObjSaved);
        }
        if (!!objTexture) { objTexture.OnDelete(); objTexture = undefined; }
        if (!!objCanvas) { objCanvas = undefined; }
    }
    function updateObj() {
        var mapFeature = tf.webgl.MapFeatureFromPerspectivePointFeature(theThis);
        if (!!mapFeature) {
            var pLayer = settings.perspectiveLayer;
            pLayer.UpdatePosition(mapFeature, sceneObj)
            pLayer.UpdateTexture(mapFeature, objTexture);
        }
    }
    function onPreRender() {
        updateObj();
    }
    function createObj(mapFeature) {
        if (!!mapFeature) {
            var pLayer = settings.perspectiveLayer, pMap = pLayer.GetPerspectiveMap(), scene = pMap.GetScene(), onContext = pMap.GetContext();
            var program = onContext.GetTextureColorProgram(), quad = new tf.webgl.QuadXY({ context: onContext });
            var normals = new Float32Array([0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0]);
            objTexture = new tf.webgl.Texture2({ context: onContext });
            sceneObj = new tf.webgl.SceneObject({ context: onContext, attributes: quad, texture: objTexture, program: program, onPreRender: onPreRender });
            var objAttr = sceneObj.GetAttributes();
            objAttr.GetNor().Update(normals);
            updateObj();
            scene.AddObject(sceneObj);
        }
    }
    function initialize() {
        if (tf.webgl.AssociateMapFeatureAndPerspectivePointFeature(settings.mapFeature, theThis)) { createObj(settings.mapFeature); }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.webgl.PerspectiveLayer = function (settings) {
    var theThis, superAddMapFeature, superDelMapFeature, canvasDimInt, vectorContext, pointFeature, objCanvas;
    this.UpdateTexture = function (mapFeature, texture) {
        if (!!mapFeature) {
            var ctx = objCanvas.getContext("2d");
            ctx.save();
            ctx.clearRect(0, 0, canvasDimInt, canvasDimInt);
            var APIStyle = mapFeature.getAPIStyle(); for (var i in APIStyle) { vectorContext.drawFeature(pointFeature, APIStyle[i]); }
            ctx.restore();
            texture.UpdateFromImage(objCanvas, true);
        }
    };
    this.UpdatePosition = function (mapFeature, sceneObj) {
        if (!!mapFeature && !!sceneObj) {
            var mapFeatureMapCoords = mapFeature.GetPointCoords();
            var mapFeaturePixelCoords = theThis.GetMap().ActualMapToPixelCoords(mapFeatureMapCoords);
            var mapFeatureQuadCoords = theThis.GetPerspectiveMap().PointCoordsToQuadCoords(mapFeaturePixelCoords);
            //mapFeatureQuadCoords = [0, 0];
            var scaleUse = 0.05;
            sceneObj.GetObjectToSceneMatrix().UpdateWorld({
                //rotate: { angle: 45 * Math.PI / 180, axisx: 0, axisy: 1, axisz: 0 },
                translate: { tx: mapFeatureQuadCoords[0], ty: 0 * scaleUse, tz: mapFeatureQuadCoords[1] },
                scale: { sx: scaleUse, sy: scaleUse, sz: scaleUse }
            });
            /*var dim = 0.05;
            var x = dim, y = 0.001, z = dim;
            var vertices = new Float32Array([
                x + mapFeatureQuadCoords[0], y, -z + mapFeatureQuadCoords[1],
                -x + mapFeatureQuadCoords[0], y, -z + mapFeatureQuadCoords[1],
                -x + mapFeatureQuadCoords[0], y, z + mapFeatureQuadCoords[1],
                x + mapFeatureQuadCoords[0], y, z + mapFeatureQuadCoords[1]
            ]);
            var attr = sceneObj.GetAttributes();
            attr.GetPos().Update(vertices);*/
        }
    };
    this.GetMapFromContent = function () { return settings.appContent.GetMap(); }
    this.GetCanvasDimInt = function () { return canvasDimInt; }
    this.GetPerspectiveMap = function() { return settings.appContent.GetPerspectiveMap(); }
    this.GetScene = function () { var pm = theThis.GetPerspectiveMap(); return !!pm ? pm.GetScene() : undefined; }
    this.GetSettings = function () { return settings; }
    function addMapFeature() {
        new tf.webgl.PerspectivePointFeature({ mapFeature: arguments[0], perspectiveLayer: theThis });
        superAddMapFeature.apply(theThis, arguments);
    }
    function delMapFeature() {
        var perspectivePointFeature = tf.webgl.PerspectivePointFeatureFromMapFeature(arguments[0]);
        if (!!perspectivePointFeature) { perspectivePointFeature.OnDelete(); }
        superDelMapFeature.apply(theThis, arguments);
    }
    function createObjCanvas() {
        objCanvas = document.createElement('canvas');
        objCanvas.height = objCanvas.width = canvasDimInt;
    }
    function initialize() {
        canvasDimInt = 80;
        createObjCanvas();
        vectorContext = ol.render.toContext(objCanvas.getContext('2d'), { size: [canvasDimInt, canvasDimInt] });
        pointFeature = new ol.Feature({ geometry: new ol.geom.Point([canvasDimInt / 2, canvasDimInt / 2]) });
        tf.map.FeatureLayer.call(theThis, settings);
        superAddMapFeature = theThis.AddMapFeature;
        superDelMapFeature = theThis.DelMapFeature;
        theThis.AddMapFeature = addMapFeature;
        theThis.DelMapFeature = delMapFeature;
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.webgl.PerspectiveLayer, tf.map.FeatureLayer);

// SOURCE FILE: styles.js
tf.TFMap.Styles = function (settings) {
    var theThis, CSSClasses, allEventDispatchers, layoutChangeEventName;
    var redMarkerImage, loadingImage;
    var isShowingAerial;
    var onOffSVG, addSVG, geolocationSVG, minusSVG, compassSVG, arrowDownSVG, arrowDownFlipSVG, XMarkSVG;
    var bikeSVG, walkSVG, carSVG, searchSVG, upDownArrowSVG;
    var tapImage, mapMarkerSearchImage, geolocationImage;
    var arrowRightSVGNoColor, arrowLeftSVGNoColor;
    var busPNGImage;
    var minNonSmallScreenWidth, minNonSmallScreenHeight;
    var minNonSmallScreenWidthAddValue;
    var measuringSVG, downloadSVG, layersSVG;
    var dustBinSVG;
    var fenceSVG;
    var refreshSVG, mapCenterSVG;
    var playerSVGs;
    var refreshGrayData, goFullScreenData, restoreFullScreenData, arrowLeftData, arrowRightData, menuData;
    var inactiveSearchData, activeSearchData;
    var closeData, directionsData;
    var greenCheckMarkData, buttonXRedData;
    var loadingData;
    var fromImage, toImage;
    var directionStepsSVGs;
    var poweredByTerraFlySVG, poweredByTerraFlySVGForMap;
    var directionsMapArrowImage;
    var noClusterData, clusterData; 
    var mapMarker1SVG, mapMarker1Data, mapMarker1Image;
    var arrowSquareRightSVG, arrowSquareRightData, arrowSquareRightImage;
    var arrowSmallRightSVG, arrowSmallRightData, arrowSmallRightImage;
    var altaMarkerStyles;
    var arrowRightSVG, arrowLeftSVG;
    var isSmallScreen;
    var busSVG, busImage;
    var busStopSVG;
    this.GetFenceSVG = function () { return fenceSVG; }
    this.GetBusPNGImage = function () { return busPNGImage; }
    this.AddRangeClasses = function (addRangeSettings) {
        var className = addRangeSettings.className;
        var cssClassesUse = addRangeSettings.cssClasses;
        cssClassesUse[className] = {};
        cssClassesUse[className + " input[type=range]"] = { "-webkit-appearance": "none", inherits: [addRangeSettings.rangeSettings] };
        cssClassesUse[className + " input[type=range]::-ms-tooltip"] = { display: "none" };
        cssClassesUse[className + " input[type=range]:focus"] = { outline: "none" };
        cssClassesUse[className + " input[type=range]::-ms-track"] = { inherits: [addRangeSettings.trackSettings] };
        cssClassesUse[className + " input[type=range]::-moz-range-track"] = { inherits: [addRangeSettings.trackSettings] };
        cssClassesUse[className + " input[type=range]::-webkit-slider-runnable-track"] = { inherits: [addRangeSettings.trackSettings] };
        cssClassesUse[className + " input[type=range]::-moz-range-thumb"] = { inherits: [addRangeSettings.thumbSettings] };
        cssClassesUse[className + " input[type=range]::-ms-thumb"] = { inherits: [addRangeSettings.thumbSettings] };
        cssClassesUse[className + " input[type=range]::-webkit-slider-thumb"] = {
            inherits: [addRangeSettings.thumbSettings], "-webkit-appearance": "none", marginTop: 2 - (addRangeSettings.thumbHeightInt + addRangeSettings.thumbBorderInt) / 2 + "px"
        };
    }
    this.GetPlayerSVGs = function () { return playerSVGs; }
    this.GetRefreshSVG = function () { return refreshSVG; }
    this.GetMapCenterSVG = function () { return mapCenterSVG; }
    this.SetMinNonSmallScreenWidthAddValue = function (newMinNonSmallScreenWidthAddValue) {
        if (newMinNonSmallScreenWidthAddValue != minNonSmallScreenWidthAddValue) {
            minNonSmallScreenWidthAddValue = newMinNonSmallScreenWidthAddValue;
            theThis.CheckLayoutChange();
        }
    }
    this.GetPoweredByTerraFlySVGForMap = function () { return poweredByTerraFlySVGForMap; }
    this.CheckIsSmallDeviceScreen = function () {
        return window.screen.width <= minNonSmallScreenDim + minNonSmallScreenWidthAddValue || window.screen.height <= minNonSmallScreenDim;
    }
    this.CheckIsSmallScreen = function () {
        var winDims = tf.dom.GetWindowDims(); return winDims[0] <= minNonSmallScreenWidth + minNonSmallScreenWidthAddValue || winDims[1] <= minNonSmallScreenHeight;
    }
    this.GetIsSmallScreen = function () { return isSmallScreen; }
    this.CheckLayoutChange = function () {
        var nowIsSmallScreen = theThis.CheckIsSmallScreen();
        //console.log('isSmallScreen: ' + nowIsSmallScreen);
        if (nowIsSmallScreen != isSmallScreen) {
            isSmallScreen = nowIsSmallScreen; theThis.RefreshLayout();
        }
    }
    this.RefreshLayout = function () {
        var appContent = settings.appContent;
        calcLayoutSettings();
        appContent.StartLayoutChange();
        notify(layoutChangeEventName);
        appContent.EndLayoutChange();
        settings.appContent.GetMap().Render();
    }
    this.AddOnLayoutChangeListener = function (callBack) { return allEventDispatchers.AddListener(layoutChangeEventName, callBack); }
    this.GetArrowRightSVG = function () { return arrowRightSVG; }
    this.GetArrowLeftSVG = function () { return arrowLeftSVG; }
    this.GetArrowRightSVGNoColor = function () { return arrowRightSVGNoColor; }
    this.GetArrowLeftSVGNoColor = function () { return arrowLeftSVGNoColor; }
    this.GetMapMarker1SVG = function () { return mapMarker1SVG; }
    this.GetCSSClasses = function () { return CSSClasses; }
    this.GetDirectionsMapArrowImage = function () { return directionsMapArrowImage; }
    this.GetPoweredByTerraFlySVG = function () { return poweredByTerraFlySVG; }
    this.GetDirectionsStepsSVGs = function () { return directionStepsSVGs; }
    this.GetBusSVG = function () { return busSVG; }
    this.GetBusImage = function () { return busImage; }
    this.GetBusStopSVG = function () { return busStopSVG; }
    this.GetTapImage = function () { return tapImage; }
    this.GetMapMarkerSearchImage = function () { return mapMarkerSearchImage; }
    this.GetGeolocationImage = function () { return geolocationImage; }
    this.GetFromImage = function () { return fromImage; }
    this.GetToImage = function () { return toImage; }
    this.GetMapMarker1Image = function () { return mapMarker1Image; }
    this.GetUpDownArrowSVG = function () { return upDownArrowSVG; }
    this.GetSearchSVG = function () { return searchSVG; }
    this.GetBikeSVG = function () { return bikeSVG; }
    this.GetWalkSVG = function () { return walkSVG; }
    this.GetCarSVG = function () { return carSVG; }
    this.GetXMarkSVG = function () { return XMarkSVG; }
    this.GetOnOffSVG = function () { return onOffSVG; }
    this.GetAddSVG = function () { return addSVG; }
    this.GetMinusSVG = function () { return minusSVG; }
    this.GetGeolocationSVG = function () { return geolocationSVG; }
    this.GetCompassSVG = function () { return compassSVG; }
    this.GetArrowDownSVG = function () { return arrowDownSVG; }
    this.GetArrowDownFlipSVG = function () { return arrowDownFlipSVG; }
    this.GetDustBinSVG = function () { return dustBinSVG; }
    this.GetMeasureSVG = function () { return measuringSVG; };
    this.GetDownloadSVG = function () { return downloadSVG; };
    this.GetLayersSVG = function () { return layersSVG; }
    this.SetIsShowingAerial = function (isShowingAerialSet) { isShowingAerial = isShowingAerialSet; }
    this.AddMapMarker1Style = function (geom) {
        geom.style = getMapMarker1FeatureStyle
        geom.hoverStyle = getMapMarker1FeatureStyle
        return geom;
    }
    this.GetSVGMapMarkerStyle = function (imageUse, imageSize, iconAnchor, bottomMargin, zIndex) {
        return createImageCanvas(imageSize, imageUse, iconAnchor, bottomMargin, zIndex);
    }
    this.GetSVGMapMarkerGeomAndStyles = function (coords, imageUse, imageSize, iconAnchor, bottomMargin, zIndex) {
        return {
            type: 'point',
            coordinates: coords != undefined ? coords : [0, 0],
            style: createImageCanvas(imageSize, imageUse, iconAnchor, bottomMargin, zIndex),
            hoverStyle: createImageCanvas([imageSize[0] + 2, imageSize[1] + 2], imageUse, iconAnchor, bottomMargin, zIndex + 1)
        };
    }
    this.CreateImageCanvasFromSettings = function (icSettings) { return createImageCanvasFromSettings(icSettings); }
    function createImageCanvasFromSettings(icSettings) {
        var sizeCanvas = icSettings.sizeCanvas, imageToPaint = icSettings.imageToPaint, iconAnchor = icSettings.iconAnchor, bottomMargin = icSettings.bottomMargin, zindex = icSettings.zindex;
        var canvas = document.createElement('canvas'), ctx = canvas.getContext("2d");
        if (!iconAnchor) { iconAnchor = [0.5, 0.5]; }
        ctx.canvas.width = sizeCanvas[0];
        ctx.canvas.height = sizeCanvas[1] + (bottomMargin != undefined ? bottomMargin : 0);
        ctx.clearRect(0, 0, sizeCanvas[0], sizeCanvas[1]);
        if (icSettings.circleRadius != undefined) {
            ctx.fillStyle = icSettings.circleFill;
            ctx.shadowColor = "rgba(0,0,0,0.3)";
            ctx.shadowBlur = 2;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.beginPath();
            ctx.arc(sizeCanvas[0] / 2, sizeCanvas[1] / 2, icSettings.circleRadius, 0, 2 * Math.PI, false);
            ctx.closePath();
            ctx.fill();
        }
        else if (icSettings.iconShadow) {
            ctx.shadowColor = "rgba(0,0,0,0.4)";
            ctx.shadowBlur = 2;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }
        var imageDims = icSettings.sizeImage != undefined ? icSettings.sizeImage : sizeCanvas;
        ctx.translate(sizeCanvas[0] / 2, sizeCanvas[1] / 2);
        ctx.drawImage(imageToPaint, -imageDims[0] / 2, -imageDims[1] / 2, imageDims[0], imageDims[1]);
        return { icon: true, icon_img: canvas, icon_size: [ctx.canvas.width, ctx.canvas.height], icon_anchor: iconAnchor, zindex: zindex, snaptopixel: true };
    }
    function createImageCanvas(sizeCanvas, imageToPaint, iconAnchor, bottomMargin, zindex) {
        return createImageCanvasFromSettings({ sizeCanvas: sizeCanvas, imageToPaint: imageToPaint, iconAnchor: iconAnchor, bottomMargin: bottomMargin, zindex: zindex });
    }
    function getMapMarker1FeatureStyle(keyedFeature, mapFeature) {
        var isHover = mapFeature.GetIsDisplayingInHover();
        var zindex = isHover ? 2 : 1;
        var snaptopixel = true;
        //var snaptopixel = false;
        var featureStyle = { zindex: zindex, snaptopixel: snaptopixel };
        var imageUse = mapMarker1Image;
        var scaleHover = 1.1;
        var baseW = 24;
        var baseH = 36;
        var imageSize = isHover ? [baseW * scaleHover, baseH * scaleHover] : [baseW, baseH];
        var imageAnchor = isHover ? [0.5, 0.92] : [0.5, 0.92];
        featureStyle = tf.js.ShallowMerge(createImageCanvas(imageSize, imageUse, imageAnchor, 0, zindex));
        return featureStyle;
    }
    this.GetLighterColor2 = function (color) {
        var rgbColor = tf.js.GetRGBFromColor(color);
        var offColor = 160;
        rgbColor.r = tf.js.GetIntNumberInRange(rgbColor.r + offColor, 0, 255, rgbColor.r);
        rgbColor.g = tf.js.GetIntNumberInRange(rgbColor.g + offColor, 0, 255, rgbColor.g);
        rgbColor.b = tf.js.GetIntNumberInRange(rgbColor.b + offColor, 0, 255, rgbColor.b);
        return "#" + rgbColor.r.toString(16) + rgbColor.g.toString(16) + rgbColor.b.toString(16);
    }
    this.GetLighterColor = function(color) {
        var rgbColor = tf.js.GetRGBFromColor(color);
        var off = 80, mult = 1.4;
        rgbColor.r = tf.js.GetIntNumberInRange(Math.floor((rgbColor.r + off) * mult), 16, 255, rgbColor.r);
        rgbColor.g = tf.js.GetIntNumberInRange(Math.floor((rgbColor.g + off) * mult), 16, 255, rgbColor.g);
        rgbColor.b = tf.js.GetIntNumberInRange(Math.floor((rgbColor.b + off) * mult), 16, 255, rgbColor.b);
        return "#" + rgbColor.r.toString(16) + rgbColor.g.toString(16) + rgbColor.b.toString(16);
    }
    function getImageFileName(fullURL) {
        var fileName;
        if (tf.js.GetIsNonEmptyString(fullURL)) {
            var pieces = fullURL.split('/'), nPieces = pieces.length;
            if (nPieces > 0) { fileName = pieces[nPieces - 1]; }
        }
        return fileName;
    }
    function onMapFeatureImageLoaded(theImage) {
        if (theImage.GetIsValid()) {
            var imgSettings = theImage.GetSettings(), img = theImage.GetImg(), imgDims = theImage.GetDimensions();
            var mapFeature = imgSettings.mapFeature;
            var zindex = imgSettings.zindex;
            var shape_radius = 6;
            var newStyle = { circle: true, shape_points: 3, shape_radius: shape_radius, fill: true, fill_color: "#fff", fill_opacity: 50, line: true, line_width: 2, line_color: "#37f", line_opacity: 50, zindex: ++zindex };
            var newHoverStyle = { circle: true, shape_points: 6, shape_radius: shape_radius + 4, fill: true, fill_color: "#fff", fill_opacity: 50, line: true, line_width: 2, line_color: "#37f", line_opacity: 50, zindex: ++zindex };
            var newStyleObj = new tf.map.FeatureStyle(newStyle);
            var newHoverStyleObj = new tf.map.FeatureStyle(newHoverStyle);
            console.log('loaded: ' + theImage.GetSrc());
            mapFeature.SetStyles(newStyleObj, newHoverStyleObj);
        }
    }
    function getSearchFeatureStyleCommon(isCurrent, isHover, color, text, imageSrc, mapDirectionAngle, showingHybrid, minZIndex) {
        var zIndexStep = 4;
        var zindex;
        if (isCurrent) { zindex = 1000; } else if (isHover) { zindex = 2000; } else { zindex = minZIndex; }
        var enlarge = isCurrent || isHover;
        var circle_radius = isHover ? 11 : 9;
        var square_radius = circle_radius - 3;
        var snaptopixel = true;
        var outerMarkerColor = showingHybrid ? "#fff" : "#494949";
        if (minZIndex != undefined) { zindex += minZIndex; }
        var featureStyle = [];
        var imageStyle;
        var addRadius;
        var subRadius;
        if (imageSrc != undefined) {
            var createIcon = true;
            var imageFileName = getImageFileName(imageSrc);
            var altaMarkerStyle = altaMarkerStyles[imageFileName];
            if (altaMarkerStyle != undefined) {
                var styleUse = enlarge ? altaMarkerStyle.hoverSettings : altaMarkerStyle.styleSettings;
                var imageStyle = createImageCanvasFromSettings(tf.js.ShallowMerge(styleUse, { zindex: ++zindex }));
                imageStyle.rotate_with_map = true;
                imageStyle.rotation_rad = altaMarkerStyle.angle;
                featureStyle.push(imageStyle);
                createIcon = false;
                //console.log(altaMarkerStyle.name + ' ' + altaMarkerStyle.angleDeg + ' ' + altaMarkerStyle.angle);
            }
            if (createIcon) {
                var scale = enlarge ? 1.2 : 1;
                featureStyle.push({ icon: true, icon_anchor: [0.5, 0.5], scale: scale, zindex: ++zindex, icon_url: imageSrc });
                /*var circle_radius = enlarge ? 8 : 5;
                featureStyle.push({ circle: true, circle_radius: circle_radius, fill: true, fill_color: "#fff", fill_opacity: 50, line: true, line_width: 2, line_color: "#37f", line_opacity: 50, zindex: ++zindex });
                if (!enlarge) {
                    new tf.dom.Img({ src: imageSrc, onLoad: onMapFeatureImageLoaded, mapFeature: mapFeature, zindex: zindex - 1 });
                }*/
            }
        }
        else if (text != undefined) {
            var textStyle;
            var layerColor = color;
            var borderWidth = 2, markerArrowLength = 16, borderOpacity = 60;
            var fontHeight = enlarge ? 14 : 12;
            var fontColor = showingHybrid ? "#fff" : "#025";
            var lineColor = showingHybrid ? "#025" : "#fff";
            var lineWidth = showingHybrid ? 3 : 2;
            var markerBoderColor = showingHybrid ? "#bfbfbf" : "#000";
            var markerOpacity = showingHybrid ? 75 : 65;
            var lineOpacity = showingHybrid ? 50 : 70;
            textStyle = {
                marker_arrowlength: markerArrowLength,
                marker: true, font_height: fontHeight, border_color: "#000", border_width: borderWidth, zindex: ++zindex, line_color: lineColor, line_opacity: lineOpacity, line_width: lineWidth,
                marker_color: layerColor, font_color: fontColor, marker_opacity: markerOpacity, border_opacity: borderOpacity, label: text
            };
            featureStyle.push(textStyle);
        }
        return featureStyle;
    }
    function getSearchFeatureStyle(keyedFeature, mapFeature) {
        var appCtx = settings.appContent.GetAppCtx();
        var isCurrent = mapFeature == appCtx.GetCtxAttribute(tf.TFMap.CAN_selectedSearch);
        var isHover = mapFeature.GetIsDisplayingInHover();
        var mapFeatureSettings = mapFeature.GetSettings();
        return getSearchFeatureStyleCommon(isCurrent, isHover, mapFeatureSettings.color, mapFeatureSettings.text,
            mapFeatureSettings.imageSrc, mapFeatureSettings.compassDirectionAngle,
            mapFeatureSettings.isForHybrid, mapFeatureSettings.minZIndex);
    }
    function getSearchFeatureStyle2(mapFeatureSettings, isHover) {
        var isCurrent = false;
        return getSearchFeatureStyleCommon(isCurrent, isHover, mapFeatureSettings.color, mapFeatureSettings.text,
            mapFeatureSettings.imageSrc, mapFeatureSettings.compassDirectionAngle,
            mapFeatureSettings.isForHybrid, mapFeatureSettings.minZIndex);
    }
    this.AddSearchFeatureStyles = function (geom, props) {
        geom.style = getSearchFeatureStyle2(props, false);
        geom.hoverStyle = getSearchFeatureStyle2(props, true);
        return geom;
    }
    this.GetSVGMapMarkerWithFrameStyle = function (zIndex, imageUse, imageSizeUse, radiusMaxUse, colorFillUse, iconAnchor, bottomMargin, actualColorFill, actualLineWidth) {
        return getSVGMapMarkerWithFrameStyle(zIndex, imageUse, imageSizeUse, radiusMaxUse, colorFillUse, iconAnchor, bottomMargin, actualColorFill, actualLineWidth);
    }
    function getSVGMapMarkerWithFrameStyle(zIndex, imageUse, imageSizeUse, radiusMaxUse, colorFillUse, iconAnchor, bottomMargin, actualColorFill, actualLineWidth) {
        var colorFill = colorFillUse != undefined ? colorFillUse : "#00f";
        var colorStroke = "#494949";
        var lineWidthUse = actualLineWidth != undefined ? actualLineWidth : 1;
        var radiusMax = radiusMaxUse != undefined ? radiusMaxUse : 14;
        var radiusDiff = lineWidthUse;
        var outlineRadius = radiusMax + radiusDiff;
        var insideRadius = radiusMax - radiusDiff;
        var snaptopixel = true;
        var imageDim = (insideRadius - radiusDiff) * 2;
        var sizeCanvas = imageSizeUse != undefined ? imageSizeUse : [imageDim, imageDim];
        var canvas = document.createElement('canvas'), ctx = canvas.getContext("2d");
        if (!iconAnchor) { iconAnchor = [0.5, 0.5]; }
        ctx.canvas.width = outlineRadius;;
        ctx.canvas.height = outlineRadius + (bottomMargin != undefined ? bottomMargin : 0);
        ctx.clearRect(0, 0, sizeCanvas[0], sizeCanvas[1]);
        var actualColorFillUse = actualColorFill != undefined ? actualColorFill : "#fff";
        ctx.fillStyle = actualColorFillUse;
        ctx.beginPath();
        tf.canvas.circle(ctx, 0, 0, outlineRadius);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = colorFill;
        ctx.lineWidth = lineWidthUse;
        ctx.beginPath();
        tf.canvas.circle(ctx, radiusDiff, radiusDiff, radiusMax - radiusDiff);
        ctx.closePath();
        //ctx.fill();
        ctx.stroke();
        ctx.fillStyle = actualColorFillUse;
        ctx.beginPath();
        tf.canvas.circle(ctx, 2 * radiusDiff, 2 * radiusDiff, radiusMax - 3 * radiusDiff);
        ctx.closePath();
        ctx.fill();
        ctx.translate(outlineRadius / 2, outlineRadius / 2);
        ctx.drawImage(imageUse, -sizeCanvas[0] / 2, -sizeCanvas[1] / 2, sizeCanvas[0], sizeCanvas[1]);
        return { icon: true, icon_img: canvas, icon_size: [ctx.canvas.width, ctx.canvas.height], icon_anchor: iconAnchor, zindex: zIndex };
    }
    this.GetSVGMapMarkerWithFrameGeom = function (coords, imageUse, imageSizeUse, radiusMaxUse, colorFillUse, iconAnchor, bottomMargin) {
        var radiusMax = radiusMaxUse != undefined ? radiusMaxUse : 14;
        var radiusDiff = 1;
        var insideRadius = radiusMax - 2;
        var imageDim = (insideRadius - radiusDiff) * 2;
        var imageSize = imageSizeUse != undefined ? imageSizeUse : [imageDim, imageDim];
        var zIndex = 0;
        var style = getSVGMapMarkerWithFrameStyle(++zIndex, imageUse, imageSize, radiusMax, colorFillUse, iconAnchor, bottomMargin);
        var hoverStyle = getSVGMapMarkerWithFrameStyle(++zIndex, imageUse, [imageSize[0]/* + 2*/, imageSize[1]/* + 2*/], radiusMax + 2, colorFillUse, iconAnchor, bottomMargin);
        return { type: 'point', coordinates: coords, style: style, hoverStyle: hoverStyle };
    }
    this.FlashCoords = function (map, coordsToFlash, color) {
        if (isShowingAerial) { color = "#fff" };
        new tf.map.PointsStyleAnimator({ maps: [map], pointProviders: coordsToFlash, duration: 800, getStyle: function flash(elapsed01) { return theThis.GetFlashStyleAtTime(elapsed01, color); } });
    }
    this.GetFlashStyleAtTime = function(elapsed01, color) {
        var radius = 4 + Math.pow(elapsed01, 1 / 2) * 16, opacity = 1 - Math.pow(elapsed01, 3), line_width = (2 - elapsed01);
        var flashStyle = { circle: true, circle_radius: radius, snapToPixel: false, line: true, line_width: line_width, line_color: color, line_opacity: opacity * 100 };
        return flashStyle;
    }
    function makeDataFromSVG(fromSVG) { return "data:image/svg+xml;utf8," + encodeURIComponent(fromSVG); }
    function makeSearchSVG(fillColor) {
        var svgStr = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="32px" height="32px" viewBox="0 0 56.966 56.966" style="enable-background:new 0 0 56.966 56.966;" xml:space="preserve"> <path ';
        if (fillColor != undefined) { svgStr += 'fill="' + fillColor + '" '; }
        svgStr += 'd="M55.146,51.887L41.588,37.786c3.486-4.144,5.396-9.358,5.396-14.786c0-12.682-10.318-23-23-23s-23,10.318-23,23 s10.318,23,23,23c4.761,0,9.298-1.436,13.177-4.162l13.661,14.208c0.571,0.593,1.339,0.92,2.162,0.92 c0.779,0,1.518-0.297,2.079-0.837C56.255,54.982,56.293,53.08,55.146,51.887z M23.984,6c9.374,0,17,7.626,17,17s-7.626,17-17,17 s-17-7.626-17-17S14.61,6,23.984,6z"/> </svg>';
        return svgStr;
    }
    function createSVGImage(data) { var image = document.createElement('img'); image.src = data; return image; }
    function initCSSClasses() {
        var layoutSettings = tf.TFMap.LayoutSettings;
        var toolTipContentBackground = layoutSettings.toolTipContentBackground;
        var fontSizeToolTipInt = layoutSettings.fontSizeToolTipInt;
        var fontWeightToolTip = layoutSettings.fontWeightToolTip;
        var activeSVGColor = layoutSettings.activeSVGColor;
        var inactiveSVGColor = layoutSettings.inactiveSVGColor;
        var lightBackground = layoutSettings.lightBackground;
        var lightTextShadow = layoutSettings.lightTextShadow; 
        var darkTextShadow = layoutSettings.darkTextShadow; 
        var darkTextColor = layoutSettings.darkTextColor; 
        var lightTextColor = layoutSettings.lightTextColor;
        var zIndexToolTipInt = layoutSettings.zIndexToolTipInt;
        var zIndexToolTipStr = "" + zIndexToolTipInt;
        CSSClasses = {
            lightBackground: { background: lightBackground },
            lightTextShadow: { textShadow: lightTextShadow },
            darkTextShadow: { textShadow: darkTextShadow },
            lightTextColor: { color: lightTextColor },
            darkTextColor: { color: darkTextColor },
            fillActiveSVGColor: { fill: activeSVGColor },
            toolTipBackground: { background: toolTipContentBackground },
            directionsButtonBackground: { background: lightBackground + " url(" + directionsData + (isSmallScreen ? ") center/75% no-repeat" : ") center/70% no-repeat") },
            directionsButtonBackground2: { background: lightBackground + " url(" + directionsData + ") center/80% no-repeat" },
            closeButtonBackground: { background: lightBackground + " url(" + closeData + ") center/50% no-repeat" },
            activeSearchButtonBackground: { background: lightBackground + " url(" + activeSearchData + ") center/50% no-repeat" },
            inactiveSearchButtonBackground: { background: lightBackground + " url(" + inactiveSearchData + ") center/50% no-repeat" },
            menuButtonBackground: { background: lightBackground + " url(" + menuData + ") center/50% no-repeat" },
            arrowRightBackground: { background: lightBackground + " url(" + arrowRightData + ") center/38% no-repeat" },
            arrowLeftBackground: { background: lightBackground + " url(" + arrowLeftData + ") center/38% no-repeat" },
            goFullScreenBackground: { background: lightBackground + " url(" + goFullScreenData + ") center/50% no-repeat" },
            restoreFullScreenBackground: { background: lightBackground + " url(" + restoreFullScreenData + ") center/50% no-repeat" },
            loadingBackgroundTransparent: { background: "url(" + loadingData + ") center/90% no-repeat" },
            loadedOKBackgroundTransparent: { background: "url(" + greenCheckMarkData + ") center/90% no-repeat" },
            refreshGrayBackground: { background: "url(" + refreshGrayData + ") center/100% no-repeat" },
            failedToLoadBackground: { background: "url(" + buttonXRedData + ") center/90% no-repeat" },
            loadingBackground: { background: lightBackground + " url(" + loadingData + ") center/70% no-repeat" },
            noClusterBackground: { background: lightBackground + " url(" + noClusterData + ") center/100% no-repeat" },
            clusterBackground: { background: lightBackground + " url(" + clusterData + ") center/90% no-repeat" },
            borderLeftD4: { borderLeft: "1px solid #D4D4D4" },
            boxShadow002003: { boxShadow: "0px 0px 20px rgba(0,0,0,0.5)" },
            boxShadow01403: { boxShadow: "0px 1px 6px rgba(0,0,0,0.3)" },
            WHOneRem: { width: "1rem", height: "1rem" },
            WHTwoRem: { width: "2rem", height: "2rem" },
            robotoFontFamily: { fontFamily: "Roboto" },
            fontSize16px: { fontSize: "16px" },
            WHOneHundred: { width: "100%", height: "100%" },
            WOneHundred: { width: "100%" },
            HOneHundred: { height: "100%" },
            overflowHidden: { overflow: "hidden" },
            overflowVisible: { overflow: "visible" },
            textOverflowEllipsis: { textOverflow: "ellipsis" },
            displayFlex: { display: "flex" },
            displayBlock: { display: "block" },
            displayNone: { display: "none" },
            displayInlineBlock: { display: "inline-block" },
            displayInline: { display: "inline" },
            flexFlowColumnNoWrap: { flexFlow: "column nowrap" },
            flexFlowColumnWrap: { flexFlow: "column wrap" },
            flexFlowRowNoWrap: { flexFlow: "row nowrap" },
            flexFlowRowWrap: { flexFlow: "row wrap" },
            flexFlowRowReverseNoWrap: { flexFlow: "row-reverse nowrap" },
            flexOne: { flex: "1" },
            flexZero: { flex: "0" },
            flexGrowOne: { flexGrow: "1" },
            flexGrowZero: { flexGrow: "0" },
            flexShrinkOne: { flexShrink: "1" },
            flexShrinkZero: {flexShrink: "0" },
            marginAuto: { margin: "auto" },
            borderRadius2px: { borderRadius: "2px" },
            cursorText: { cursor: "text" },
            cursorPointer: { cursor: "pointer" },
            cursorDefault: { cursor: "default" },
            listStyleNone: { listStyle: "none" },
            noBorder: { border: "0" },
            noMargin: { margin: "0px" },
            noPadding: { padding: "0px" },
            outline0: { outline: "0" },
            positionAbsolute: { position: "absolute" },
            positionRelative: { position: "relative" },
            leftTopZero: { left: "0px", top: "0px" },
            leftBotZero: { left: "0px", bottom: "0px" },
            fontInherit: { font: "inherit" },
            verticalAlignTop: { verticalAlign: "top" },
            verticalAlignBaseline: { verticalAlign: "baseline" },
            verticalAlignMiddle: { verticalAlign: "middle" },
            /*zIndex1: { zIndex: "1" },
            zIndex2: { zIndex: "2" },*/
            zIndex1: { zIndex: '' + (layoutSettings.rootDivZIndex + 1) },
            zIndex2: { zIndex: '' + (layoutSettings.rootDivZIndex + 2) },
            backgroundColorWhite: { backgroundColor: "white" },
            backgroundColorRed: { backgroundColor: "red" },
            backgroundColorGreen: { backgroundColor: "green" },
            backgroundColorBlue: { backgroundColor: "blue" },
            backgroundColorTransparent: { backgroundColor: "transparent" },
            visibilityHidden: { visibility: "hidden" },
            visibilityVisible: { visibility: "visible" },
            whiteSpaceNoWrap: { whiteSpace: "nowrap" },
            whiteSpaceNormal: { whiteSpace: "normal" },
            pointerEventsNone: { pointerEvents: "none" },
            pointerEventsAll: { pointerEvents: "all" },
            transitionBackground: {
                transitionProperty: "-webkit-transform,transform,opacity,visibility,left,top,right,bottom,width,height,background",
                transitionDuration: "0.5s",
                transitionTimingFunction: "cubic-bezier(0.0,0.0,0.2,1)"
            },
            transitionPoint2s: {
                transitionProperty: "-webkit-transform,transform,opacity,visibility,left,top,right,bottom,width,height",
                transitionDuration: "0.2s",
                transitionTimingFunction: "cubic-bezier(0.0,0.0,0.2,1)"
            },
            transitionWithColor: {
                transitionProperty: "-webkit-transform,transform,opacity,visibility,left,top,right,bottom,width,height,color",
                transitionDuration: "1s",
                transitionTimingFunction: "cubic-bezier(0.0,0.0,0.2,1)"
            }
        };
        CSSClasses.noMarginNoBorderNoPadding = { inherits: [CSSClasses.noMargin, CSSClasses.noBorder, CSSClasses.noPadding] };
        CSSClasses.noBorderNoPadding = { inherits: [CSSClasses.noBorder, CSSClasses.noPadding] };
        CSSClasses.baseTextButton = { inherits: [CSSClasses.robotoFontFamily, CSSClasses.cursorPointer, CSSClasses.outline0, CSSClasses.verticalAlignMiddle, CSSClasses.listStyleNone, CSSClasses.overflowVisible] };
        CSSClasses.transparentImageButton = { inherits: [CSSClasses.baseTextButton, CSSClasses.noMarginNoBorderNoPadding] };
        CSSClasses.inheritBackgroundAndColorImageButton = { inherits: [CSSClasses.transparentImageButton], background: 'inherit', color: 'inherit' };
        CSSClasses.baseImageButton = { inherits: [CSSClasses.transparentImageButton, CSSClasses.backgroundColorTransparent], border: "1px solid transparent" };
        CSSClasses.absoluteCenter = { inherits: [CSSClasses.positionAbsolute], left: "50%", top: "50%", transform: "translate(-50%, -50%)", "-webkit-transform": "translate(-50%,-50%)" };
    }
    function createElemClasses() {
        var elemClasses = {};
        var placeHolderClassNames = ["::-webkit-input-placeholder", "::-moz-placeholder", ":-ms-input-placeholder", ":-moz-placeholder"];
        for (var i in placeHolderClassNames) { elemClasses[placeHolderClassNames[i]] = { fontSize: "0.9rem", color: "rgba(0, 60, 130, 0.4)" }; }
        var selectionClassNames = ["::-moz-selection", "::selection"];
        for (var i in selectionClassNames) { elemClasses[selectionClassNames[i]] = { color: "white", background: "orange" }; }
        return elemClasses;
    }
    function createCSSClasses() {
        var styles = tf.GetStyles(tf.styles.GetGraphiteAPIStyleSpecifications());
        var styleCreator = styles.GetStyleCreator();
        var elemClasses = createElemClasses();
        var cssStyles = [];
        initCSSClasses();
        for (var i in elemClasses) { var cssStr = elemClasses[i], cssName = '' + i; cssStyles.push({ styleName: cssName, inherits: cssStr }); }
        //for (var i in CSSClasses) { var cssStr = CSSClasses[i], cssName = '.' + i; cssStyles.push({ styleName: cssName, inherits: cssStr }); }
        styleCreator.CreateStyles(cssStyles);
    }
    function onImagesCreated(notification) {
        var imgs = notification.GetImgs(), index = 0;
        var layoutSettings = tf.TFMap.LayoutSettings;
        var activeSVGColor = layoutSettings.activeSVGColor;
        var inactiveSVGColor = layoutSettings.inactiveSVGColor;
        redMarkerImage = imgs[index++].GetImg();
        loadingImage = imgs[index++].GetImg();
        mapMarker1Image = imgs[index++].GetImg();
        mapMarkerSearchImage = imgs[index++].GetImg();
        tapImage = imgs[index++].GetImg();
        geolocationImage = imgs[index++].GetImg();
        fromImage = imgs[index++].GetImg();
        toImage = imgs[index++].GetImg();
        directionsMapArrowImage = imgs[index++].GetImg();
        arrowSquareRightImage = imgs[index++].GetImg();
        arrowSmallRightImage = imgs[index++].GetImg();
        busImage = imgs[index++].GetImg();
        busPNGImage = imgs[index++].GetImg();
        var refreshGraySVG = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 491.236 491.236" style="fill:#ff5500;enable-background:new 0 0 491.236 491.236;" xml:space="preserve"> <g> <g> <path d="M55.89,262.818c-3-26-0.5-51.1,6.3-74.3c22.6-77.1,93.5-133.8,177.6-134.8v-50.4c0-2.8,3.5-4.3,5.8-2.6l103.7,76.2 c1.7,1.3,1.7,3.9,0,5.1l-103.6,76.2c-2.4,1.7-5.8,0.2-5.8-2.6v-50.3c-55.3,0.9-102.5,35-122.8,83.2c-7.7,18.2-11.6,38.3-10.5,59.4 c1.5,29,12.4,55.7,29.6,77.3c9.2,11.5,7,28.3-4.9,37c-11.3,8.3-27.1,6-35.8-5C74.19,330.618,59.99,298.218,55.89,262.818z M355.29,166.018c17.3,21.5,28.2,48.3,29.6,77.3c1.1,21.2-2.9,41.3-10.5,59.4c-20.3,48.2-67.5,82.4-122.8,83.2v-50.3 c0-2.8-3.5-4.3-5.8-2.6l-103.7,76.2c-1.7,1.3-1.7,3.9,0,5.1l103.6,76.2c2.4,1.7,5.8,0.2,5.8-2.6v-50.4 c84.1-0.9,155.1-57.6,177.6-134.8c6.8-23.2,9.2-48.3,6.3-74.3c-4-35.4-18.2-67.8-39.5-94.4c-8.8-11-24.5-13.3-35.8-5 C348.29,137.718,346.09,154.518,355.29,166.018z"/> </g> </g> </svg>';
        refreshGrayData = makeDataFromSVG(refreshGraySVG);
        var goFullScreenSVG = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 28.361 28.361" style="fill:' + activeSVGColor + ';enable-background:new 0 0 28.361 28.361;" xml:space="preserve"> <g> <g> <path d="M28.36,19.595c0-0.868-0.665-1.57-1.491-1.57c-0.819,0.002-1.492,0.702-1.492,1.57v3.25l-6.018-6.021 c-0.582-0.583-1.524-0.583-2.106,0c-0.582,0.582-0.582,1.527,0,2.109l5.989,5.987h-3.235c-0.881,0.002-1.591,0.669-1.591,1.491 c0,0.824,0.71,1.49,1.591,1.49h6.761c0.881,0,1.59-0.665,1.593-1.49c-0.003-0.022-0.006-0.039-0.009-0.061 c0.003-0.028,0.009-0.058,0.009-0.087v-6.668H28.36z"/> <path d="M9,16.824l-6.015,6.021v-3.25c0-0.868-0.672-1.568-1.493-1.57c-0.824,0-1.49,0.702-1.49,1.57L0,26.264 c0,0.029,0.008,0.059,0.01,0.087c-0.002,0.021-0.006,0.038-0.008,0.061c0.002,0.825,0.712,1.49,1.592,1.49h6.762 c0.879,0,1.59-0.666,1.59-1.49c0-0.822-0.711-1.489-1.59-1.491H5.121l5.989-5.987c0.58-0.582,0.58-1.527,0-2.109 C10.527,16.241,9.584,16.241,9,16.824z"/> <path d="M19.359,11.535l6.018-6.017v3.25c0,0.865,0.673,1.565,1.492,1.568c0.826,0,1.491-0.703,1.491-1.568V2.097 c0-0.029-0.006-0.059-0.009-0.085c0.003-0.021,0.006-0.041,0.009-0.062c-0.003-0.826-0.712-1.491-1.592-1.491h-6.761 c-0.881,0-1.591,0.665-1.591,1.491c0,0.821,0.71,1.49,1.591,1.492h3.235l-5.989,5.987c-0.582,0.581-0.582,1.524,0,2.105 C17.835,12.12,18.777,12.12,19.359,11.535z"/> <path d="M5.121,3.442h3.234c0.879-0.002,1.59-0.671,1.59-1.492c0-0.826-0.711-1.491-1.59-1.491H1.594 c-0.88,0-1.59,0.665-1.592,1.491C0.004,1.971,0.008,1.991,0.01,2.012C0.008,2.038,0,2.067,0,2.097l0.002,6.672 c0,0.865,0.666,1.568,1.49,1.568c0.821-0.003,1.493-0.703,1.493-1.568v-3.25L9,11.535c0.584,0.585,1.527,0.585,2.11,0 c0.58-0.581,0.58-1.524,0-2.105L5.121,3.442z"/> </g> </g> </svg>';
        goFullScreenData = makeDataFromSVG(goFullScreenSVG);
        var restoreFullScreenSVG = '<svg xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill:' + activeSVGColor + ';enable-background:new 0 0 28.361 28.361;" viewBox="0 0 28.361 28.361" y="0px" x="0px" version="1.1"><path d="m 16.8175,24.69275 c 0,0.868 0.665,1.57 1.491,1.57 0.819,-0.002 1.492,-0.702 1.492,-1.57 l 0,-3.25 6.018,6.021 c 0.582,0.583 1.524,0.583 2.106,0 0.582,-0.582 0.582,-1.527 0,-2.109 l -5.989,-5.987 3.235,0 c 0.881,-0.002 1.591,-0.669 1.591,-1.491 0,-0.824 -0.71,-1.49 -1.591,-1.49 l -6.761,0 c -0.881,0 -1.59,0.665 -1.593,1.49 0.003,0.022 0.006,0.039 0.009,0.061 -0.003,0.028 -0.009,0.058 -0.009,0.087 l 0,6.668 10e-4,0 z" /><path d="m 2.545,27.464875 6.015,-6.021 0,3.25 c 0,0.868 0.672,1.568 1.493,1.57 0.824,0 1.49,-0.702 1.49,-1.57 l 0.002,-6.669 c 0,-0.029 -0.008,-0.059 -0.01,-0.087 0.002,-0.021 0.006,-0.038 0.008,-0.061 -0.002,-0.825 -0.712,-1.49 -1.592,-1.49 l -6.762,0 c -0.879,0 -1.59,0.666 -1.59,1.49 0,0.822 0.711,1.489 1.59,1.491 l 3.235,0 -5.989,5.987 c -0.58,0.582 -0.58,1.527 0,2.109 0.583,0.584 1.526,0.584 2.11,10e-4 z" /><path d="m 25.8175,0.89762508 -6.018,6.01700002 0,-3.25 c 0,-0.865 -0.673,-1.565 -1.492,-1.568 -0.826,0 -1.491,0.703 -1.491,1.568 l 0,6.6709999 c 0,0.029 0.006,0.059 0.009,0.085 -0.003,0.021 -0.006,0.041 -0.009,0.062 0.003,0.826 0.712,1.491 1.592,1.491 l 6.761,0 c 0.881,0 1.591,-0.665 1.591,-1.491 0,-0.8209999 -0.71,-1.4899999 -1.591,-1.4919999 l -3.235,0 5.989,-5.987 c 0.582,-0.581 0.582,-1.524 0,-2.10500002 -0.582,-0.586 -1.524,-0.586 -2.106,-0.001 z" /><path d="m 6.424,8.99075 -3.234,0 c -0.879,0.002 -1.59,0.671 -1.59,1.492 0,0.826 0.711,1.491 1.59,1.491 l 6.761,0 c 0.88,0 1.59,-0.665 1.592,-1.491 -0.002,-0.021 -0.006,-0.041 -0.008,-0.062 0.002,-0.026 0.01,-0.055 0.01,-0.085 l -0.002,-6.672 c 0,-0.865 -0.666,-1.568 -1.49,-1.568 -0.821,0.003 -1.493,0.703 -1.493,1.568 l 0,3.25 -6.015,-6.016 c -0.584,-0.585 -1.527,-0.585 -2.11,0 -0.58,0.581 -0.58,1.524 0,2.105 l 5.989,5.988 z" /></svg>'
        restoreFullScreenData = makeDataFromSVG(restoreFullScreenSVG);
        onOffSVG = '<svg style="width:100%;height:100%" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 14.573 14.573" style="enable-background:new 0 0 14.573 14.573;" xml:space="preserve"> <g> <g> <path d="M7.286,14.573c-1.736,0-3.368-0.676-4.596-1.903c-1.227-1.228-1.904-2.86-1.904-4.597 s0.677-3.369,1.904-4.597c0.391-0.391,1.023-0.391,1.414,0s0.391,1.023,0,1.414c-0.85,0.851-1.318,1.981-1.318,3.183 s0.468,2.333,1.318,3.183s1.979,1.317,3.182,1.317s2.332-0.468,3.182-1.317c0.851-0.85,1.318-1.98,1.318-3.183 S11.318,5.74,10.469,4.89c-0.391-0.391-0.391-1.023,0-1.414s1.023-0.391,1.414,0c1.227,1.229,1.904,2.861,1.904,4.597 s-0.677,3.369-1.904,4.597C10.655,13.897,9.023,14.573,7.286,14.573z"/> </g> <g> <path d="M7.286,7c-0.553,0-1-0.448-1-1V1c0-0.552,0.447-1,1-1s1,0.448,1,1v5C8.286,6.552,7.84,7,7.286,7z" /> </g> </g> </svg>';
        arrowRightSVG = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 41.999 41.999" style="fill:' + activeSVGColor + '; enable-background:new 0 0 41.999 41.999;" xml:space="preserve"> <path d="M36.068,20.176l-29-20C6.761-0.035,6.363-0.057,6.035,0.114C5.706,0.287,5.5,0.627,5.5,0.999v40 c0,0.372,0.206,0.713,0.535,0.886c0.146,0.076,0.306,0.114,0.465,0.114c0.199,0,0.397-0.06,0.568-0.177l29-20 c0.271-0.187,0.432-0.494,0.432-0.823S36.338,20.363,36.068,20.176z"/> </svg>';
        arrowRightData = makeDataFromSVG(arrowRightSVG);
        arrowLeftSVG = '<svg xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill:' + activeSVGColor + '; enable-background:new 0 0 41.999 41.999;" viewBox="0 0 41.999 41.999" y="0px" x="0px" version="1.1"><path d="m 5.932,20.176 29,-20 c 0.307,-0.211 0.705,-0.233 1.033,-0.062 0.329,0.173 0.535,0.513 0.535,0.885 l 0,40 c 0,0.372 -0.206,0.713 -0.535,0.886 -0.146,0.076 -0.306,0.114 -0.465,0.114 -0.199,0 -0.397,-0.06 -0.568,-0.177 l -29,-20 C 5.661,21.635 5.5,21.328 5.5,20.999 5.5,20.67 5.662,20.363 5.932,20.176 Z" /></svg>';
        arrowLeftData = makeDataFromSVG(arrowLeftSVG);
        arrowRightSVGNoColor = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 41.999 41.999" enable-background:new 0 0 41.999 41.999;" xml:space="preserve"> <path d="M36.068,20.176l-29-20C6.761-0.035,6.363-0.057,6.035,0.114C5.706,0.287,5.5,0.627,5.5,0.999v40 c0,0.372,0.206,0.713,0.535,0.886c0.146,0.076,0.306,0.114,0.465,0.114c0.199,0,0.397-0.06,0.568-0.177l29-20 c0.271-0.187,0.432-0.494,0.432-0.823S36.338,20.363,36.068,20.176z"/> </svg>';
        arrowLeftSVGNoColor = '<svg xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" enable-background:new 0 0 41.999 41.999;" viewBox="0 0 41.999 41.999" y="0px" x="0px" version="1.1"><path d="m 5.932,20.176 29,-20 c 0.307,-0.211 0.705,-0.233 1.033,-0.062 0.329,0.173 0.535,0.513 0.535,0.885 l 0,40 c 0,0.372 -0.206,0.713 -0.535,0.886 -0.146,0.076 -0.306,0.114 -0.465,0.114 -0.199,0 -0.397,-0.06 -0.568,-0.177 l -29,-20 C 5.661,21.635 5.5,21.328 5.5,20.999 5.5,20.67 5.662,20.363 5.932,20.176 Z" /></svg>';
        var menuSVG = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 53 53" style="fill:' + activeSVGColor + '; enable-background:new 0 0 53 53;" xml:space="preserve"> <g> <g> <path d="M2,13.5h49c1.104,0,2-0.896,2-2s-0.896-2-2-2H2c-1.104,0-2,0.896-2,2S0.896,13.5,2,13.5z"/> <path d="M2,28.5h49c1.104,0,2-0.896,2-2s-0.896-2-2-2H2c-1.104,0-2,0.896-2,2S0.896,28.5,2,28.5z"/> <path d="M2,43.5h49c1.104,0,2-0.896,2-2s-0.896-2-2-2H2c-1.104,0-2,0.896-2,2S0.896,43.5,2,43.5z"/> </g> </g></svg>';
        menuData = makeDataFromSVG(menuSVG);
        var inactiveSearchSVG = makeSearchSVG(inactiveSVGColor);
        inactiveSearchData = makeDataFromSVG(inactiveSearchSVG);
        var activeSearchSVG = makeSearchSVG(activeSVGColor);
        activeSearchData = makeDataFromSVG(activeSearchSVG);
        searchSVG = makeSearchSVG(undefined);
        carSVG = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:a="http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/" x="0px" y="0px" width="16px" height="16px" viewBox="-1 -2.145 16 16" overflow="visible" enable-background="new -1 -2.145 16 16" xml:space="preserve"> <defs> </defs> <path d="M12.729,4.018l-1.147-2.963C11.367,0.487,10.898,0.004,10.011,0H8.392H5.626H3.979 c-0.883,0.004-1.352,0.487-1.57,1.055L1.262,4.018C0.805,4.077-0.002,4.612,0,5.626v3.773h1.12v1.204 c-0.003,1.485,2.098,1.468,2.098,0V9.399H7h3.772v1.204c0.004,1.468,2.106,1.485,2.107,0V9.399H14V5.626 C13.996,4.612,13.189,4.077,12.729,4.018z M2.483,7.702c-0.693,0.001-1.254-0.576-1.25-1.287C1.229,5.7,1.791,5.122,2.483,5.128 c0.69-0.006,1.25,0.572,1.25,1.288C3.733,7.126,3.174,7.703,2.483,7.702z M7,3.99H6.99H2.456l0.865-2.333 c0.104-0.331,0.267-0.568,0.649-0.574h3.02H7h3.03c0.377,0.006,0.539,0.243,0.648,0.574l0.865,2.333H7z M11.522,7.69 c-0.694,0.002-1.252-0.573-1.256-1.28c0.004-0.713,0.562-1.289,1.256-1.282c0.683-0.006,1.241,0.569,1.244,1.282 C12.764,7.117,12.205,7.692,11.522,7.69z"/> </svg>';
        walkSVG = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:a="http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/" x="0px" y="0px" width="16px" height="16px" viewBox="-3.466 0 16 16" overflow="visible" enable-background="new -3.466 0 16 16" xml:space="preserve"> <defs> </defs> <path d="M5.767,1.233C5.767,0.542,5.225,0,4.534,0C3.841,0,3.301,0.542,3.301,1.233c0,0.692,0.54,1.234,1.232,1.234 C5.225,2.467,5.767,1.925,5.767,1.233z M8.79,4.62c0,0-1.472-0.826-2.123-1.168C6.015,3.108,4.72,2.221,3.566,3.247 C3.042,3.713,2.438,6.096,2.438,6.096L0,7.6l0.4,0.558l2.656-0.966l0.742-0.961l0.786,1.733l-1.586,2.78l-1.252,4.674l1.295,0.436 l1.456-4.366l1.077-1.063L7.933,16l1.136-0.524L7.162,8.692c0,0,0.237-0.487,0.237-1.264c0-0.89-0.703-2.347-0.703-2.347 l1.151,0.265l0.258,2.898l0.726,0.068L8.79,4.62z"/> </svg>';
        bikeSVG = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:a="http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/" x="0px" y="0px" width="16px" height="16px" viewBox="0 -2 16 16" overflow="visible" enable-background="new 0 -2 16 16" xml:space="preserve"> <defs> </defs> <path d="M12.5,5c-0.355,0-0.691,0.068-1.014,0.168l-0.594-1.094L12.32,1l0.135-0.289 c0.072-0.154,0.061-0.336-0.031-0.48C12.332,0.088,12.172,0,12.002,0h-0.321H9.5C9.224,0,9,0.225,9,0.5C9,0.777,9.224,1,9.5,1h1.717 l-0.93,2H5.002C4.785,3,4.594,3.139,4.527,3.344L3.969,5.047C3.813,5.027,3.66,5,3.5,5C1.567,5,0,6.566,0,8.5S1.567,12,3.5,12 S7,10.434,7,8.5c0-1.422-0.852-2.639-2.068-3.188l0.213-0.65C5.273,4.268,5.641,4,6.057,4h3.635l0.07,0.131l0.598,1.09l0.201,0.367 C9.621,6.217,9,7.285,9,8.5c0,1.934,1.567,3.5,3.5,3.5S16,10.434,16,8.5S14.433,5,12.5,5z M6,8.5C6,9.879,4.879,11,3.5,11 S1,9.879,1,8.5S2.121,6,3.5,6c0.052,0,0.1,0.012,0.15,0.016L3.154,7.527C3.069,7.789,3.211,8.07,3.472,8.158 c0.126,0.041,0.264,0.031,0.383-0.027C3.973,8.07,4.062,7.965,4.104,7.84l0.512-1.564C5.434,6.688,6,7.525,6,8.5z M12.5,11 C11.121,11,10,9.879,10,8.5c0-0.834,0.416-1.57,1.047-2.025l1.274,2.328c0.13,0.234,0.421,0.326,0.661,0.207l0.002-0.002 c0.121-0.061,0.213-0.168,0.254-0.297s0.027-0.27-0.037-0.389l-1.23-2.264C12.142,6.021,12.318,6,12.5,6C13.879,6,15,7.121,15,8.5 S13.879,11,12.5,11z"/> <path d="M3.5,2H5c0.752,0,1.195-0.256,1.637-0.65c0.062-0.055,0.082-0.143,0.053-0.221S6.586,1,6.503,1H3.5 C3.224,1,3,1.225,3,1.5C3,1.777,3.224,2,3.5,2z"/> </svg>';
        upDownArrowSVG = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="71.753px" height="71.753px" viewBox="0 0 71.753 71.753" style="enable-background:new 0 0 71.753 71.753;" xml:space="preserve"> <g> <path d="M39.798,20.736H28.172v20.738L11.625,41.47V20.736H0L19.899,0.839L39.798,20.736z M51.855,70.914l19.897-19.896H60.129 V30.282l-16.547-0.004v20.74H31.957L51.855,70.914z"/> </g> </svg>';
        //XMarkSVG = '<svg xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" width="64px" height="64px" enable-background="new 0 0 64 64" viewBox="0 0 63.997501 63.553501" height="63.553501" version="1.1" width="63.997501"> <path d="m 28.93825,31.7865 -28.328,28.328 c -0.787,0.787 -0.787,2.062 0,2.849 0.393,0.394 0.909,0.59 1.424,0.59 0.516,0 1.031,-0.196 1.424,-0.59 l 28.541,-28.541 28.541,28.541 c 0.394,0.394 0.909,0.59 1.424,0.59 0.515,0 1.031,-0.196 1.424,-0.59 0.787,-0.787 0.787,-2.062 0,-2.849 l -28.327,-28.328 28.346,-28.348 c 0.787,-0.787 0.787,-2.062 0,-2.849 -0.787,-0.786 -2.062,-0.786 -2.848,0 l -28.559,28.561 -28.562,-28.56 c -0.787,-0.786 -2.061,-0.786 -2.848,0 -0.787,0.787 -0.787,2.062 0,2.849 l 28.348,28.347 z" style="fill-opacity:1" /> </svg>';
        XMarkSVG = '<svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" height="369.7908" width="369.79126" xml:space="preserve" viewBox="0 0 369.79127 369.79081" y="0px" x="0px" version="1.1"><g transform="matrix(0.70710678,-0.70710678,0.70710678,0.70710678,-162.90155,184.89552)" ><g ><path d="m 465.167,211.614 -184.922,0 0,-184.923 c 0,-8.424 -11.439,-26.69 -34.316,-26.69 -22.877,0 -34.316,18.267 -34.316,26.69 l 0,184.924 -184.923,0 C 18.267,211.614 0,223.053 0,245.929 c 0,22.876 18.267,34.316 26.69,34.316 l 184.924,0 0,184.924 c 0,8.422 11.438,26.69 34.316,26.69 22.878,0 34.316,-18.268 34.316,-26.69 l 0,-184.924 184.924,0 c 8.422,0 26.69,-11.438 26.69,-34.316 0,-22.878 -18.27,-34.315 -26.693,-34.315 z" /></g><g /></g></svg>';
        closeData = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIgogICB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgaWQ9InN2ZzY0MzQiCiAgIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDY0IDY0IgogICB2aWV3Qm94PSIwIDAgNjMuOTk3NTAxIDYzLjU1MzUwMSIKICAgaGVpZ2h0PSI2My41NTM1MDEiCiAgIHZlcnNpb249IjEuMSIKICAgd2lkdGg9IjYzLjk5NzUwMSI+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNjQ0NCI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgICA8ZGM6dGl0bGU+PC9kYzp0aXRsZT4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGRlZnMKICAgICBpZD0iZGVmczY0NDIiIC8+CiAgPHBhdGgKICAgICBkPSJtIDI4LjkzODI1LDMxLjc4NjUgLTI4LjMyOCwyOC4zMjggYyAtMC43ODcsMC43ODcgLTAuNzg3LDIuMDYyIDAsMi44NDkgMC4zOTMsMC4zOTQgMC45MDksMC41OSAxLjQyNCwwLjU5IDAuNTE2LDAgMS4wMzEsLTAuMTk2IDEuNDI0LC0wLjU5IGwgMjguNTQxLC0yOC41NDEgMjguNTQxLDI4LjU0MSBjIDAuMzk0LDAuMzk0IDAuOTA5LDAuNTkgMS40MjQsMC41OSAwLjUxNSwwIDEuMDMxLC0wLjE5NiAxLjQyNCwtMC41OSAwLjc4NywtMC43ODcgMC43ODcsLTIuMDYyIDAsLTIuODQ5IGwgLTI4LjMyNywtMjguMzI4IDI4LjM0NiwtMjguMzQ4IGMgMC43ODcsLTAuNzg3IDAuNzg3LC0yLjA2MiAwLC0yLjg0OSAtMC43ODcsLTAuNzg2IC0yLjA2MiwtMC43ODYgLTIuODQ4LDAgbCAtMjguNTU5LDI4LjU2MSAtMjguNTYyLC0yOC41NiBjIC0wLjc4NywtMC43ODYgLTIuMDYxLC0wLjc4NiAtMi44NDgsMCAtMC43ODcsMC43ODcgLTAuNzg3LDIuMDYyIDAsMi44NDkgbCAyOC4zNDgsMjguMzQ3IHoiCiAgICAgaWQ9InBhdGg2NDM4IgogICAgIHN0eWxlPSJmaWxsOiM0OTQ5NDk7ZmlsbC1vcGFjaXR5OjEiIC8+Cjwvc3ZnPgo=';
        var directionsSVG = '<svg xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill:' + activeSVGColor + '; enable-background:new 0 0 373.655 373.655;" viewBox="0 0 373.655 373.655" y="0px" x="0px" version="1.1"> <path d="m 138.84444,104.25104 c -1.07626,0.19891 -1.68142,0.89656 -1.60489,1.85368 l 5.14829,64.06458 c 0.089,1.10654 1.07189,2.36641 2.5102,3.21921 0.25541,0.15123 0.51778,0.28502 0.78073,0.39975 1.21886,0.53185 2.47781,0.66524 3.3728,0.32896 l 19.89439,-7.46431 c 20.98033,32.95554 13.88426,58.2558 6.99077,82.79226 -1.14939,4.0942 -2.3394,8.327 -3.34832,12.46395 l 37.53318,16.37742 c 0.94507,-3.87515 2.04635,-7.79431 3.21202,-11.94409 7.60663,-27.07599 16.9401,-60.34066 -13.58704,-105.53444 l 26.20507,-0.84794 c 1.37165,-0.0444 2.20417,-0.78239 2.12781,-1.88516 -0.0764,-1.10277 -1.04906,-2.36528 -2.48318,-3.22419 l -83.03496,-49.72496 c -1.23923,-0.74384 -2.63938,-1.07307 -3.71687,-0.87472 z" /><path d="M 369.261,176.221 197.434,4.394 c -5.857,-5.858 -15.355,-5.858 -21.213,0 L 4.394,176.221 c -5.858,5.858 -5.858,15.355 0,21.213 l 171.827,171.827 c 2.929,2.929 6.767,4.394 10.606,4.394 3.839,0 7.678,-1.464 10.606,-4.394 L 369.26,197.434 c 5.859,-5.858 5.859,-15.355 0.001,-21.213 z M 186.827,337.441 36.213,186.827 186.827,36.214 337.441,186.828 186.827,337.441 Z" /></svg>';
        directionsData = makeDataFromSVG(directionsSVG);
        geolocationSVG = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="100%" height="100%" viewBox="0 0 512 512" style="enable-background:new 0 0 512 512;" xml:space="preserve"> <g> <g> <path d="M256,0C114.84,0,0,114.842,0,256s114.84,256,256,256s256-114.842,256-256S397.16,0,256,0z M256,462.452 c-113.837,0-206.452-92.614-206.452-206.452S142.163,49.548,256,49.548S462.452,142.163,462.452,256S369.837,462.452,256,462.452z "/> </g> </g> <g> <g> <path d="M256,132.129c-68.302,0-123.871,55.569-123.871,123.871S187.698,379.871,256,379.871S379.871,324.302,379.871,256 S324.302,132.129,256,132.129z M256,330.323c-40.983,0-74.323-33.341-74.323-74.323c0-40.982,33.339-74.323,74.323-74.323 s74.323,33.341,74.323,74.323C330.323,296.981,296.983,330.323,256,330.323z"/> </g> </g> </svg>';
        greenCheckMarkData = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIgogICB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIKICAgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNTg3LjkxIDU4Ny45MTsiCiAgIHZpZXdCb3g9IjAgMCA1ODcuOTEgNTg3LjkxIgogICBoZWlnaHQ9IjU4Ny45MXB4IgogICB3aWR0aD0iNTg3LjkxcHgiCiAgIHk9IjBweCIKICAgeD0iMHB4IgogICBpZD0iQ2FwYV8xIgogICB2ZXJzaW9uPSIxLjEiPjxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTcwMzgiPjxyZGY6UkRGPjxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj48ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD48ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+PGRjOnRpdGxlPjwvZGM6dGl0bGU+PC9jYzpXb3JrPjwvcmRmOlJERj48L21ldGFkYXRhPjxkZWZzCiAgICAgaWQ9ImRlZnM3MDM2IiAvPjxnCiAgICAgc3R5bGU9ImZpbGw6IzAwMzM3NztmaWxsLW9wYWNpdHk6MSIKICAgICBpZD0iZzY5OTIiPjxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDojMDAzMzc3O2ZpbGwtb3BhY2l0eToxIgogICAgICAgaWQ9InBhdGg2OTk0IgogICAgICAgZD0ibSA4Ni40NTEsNTAxLjQ2IGMgMjYuOTM3LDI2LjkzNiA1OC4zMTUsNDguMDg4IDkzLjI2NSw2Mi44NzEgMzYuMjA3LDE1LjMxNCA3NC42NDIsMjMuMDc4IDExNC4yMzksMjMuMDc4IDM5LjU5NiwwIDc4LjAzMiwtNy43NjQgMTE0LjIzOSwtMjMuMDc4IDM0Ljk0OSwtMTQuNzgzIDY2LjMyOCwtMzUuOTM2IDkzLjI2NiwtNjIuODcxIDI2LjkzNiwtMjYuOTM4IDQ4LjA5LC01OC4zMTYgNjIuODcxLC05My4yNjYgMTUuMzE0LC0zNi4yMDcgMjMuMDgsLTc0LjY0MyAyMy4wOCwtMTE0LjIzOCAwLC0zOS41OTggLTcuNzY2LC03OC4wMzMgLTIzLjA4LC0xMTQuMjM5IEMgNTQ5LjU1LDE0NC43NjcgNTI4LjM5NSwxMTMuMzg5IDUwMS40Niw4Ni40NTIgNDc0LjUyMiw1OS41MTUgNDQzLjE0NCwzOC4zNjIgNDA4LjE5NCwyMy41OCAzNzEuOTg2LDguMjY1IDMzMy41NTEsMC41MDEgMjkzLjk1NSwwLjUwMSAyNTQuMzU4LDAuNTAxIDIxNS45MjMsOC4yNjYgMTc5LjcxNiwyMy41OCAxNDQuNzY2LDM4LjM2MiAxMTMuMzg4LDU5LjUxNiA4Ni40NTEsODYuNDUyIDU5LjUxNCwxMTMuMzg4IDM4LjM2MSwxNDQuNzY3IDIzLjU3OCwxNzkuNzE2IDguMjY1LDIxNS45MjMgMC41LDI1NC4zNTggMC41LDI5My45NTYgYyAwLDM5LjU5NiA3Ljc2NSw3OC4wMzEgMjMuMDc5LDExNC4yMzggMTQuNzgyLDM0Ljk1IDM1LjkzNiw2Ni4zMjggNjIuODcyLDkzLjI2NiB6IE0gMjkzLjk1NSw0My4zNDEgYyAxMzguNDExLDAgMjUwLjYxNCwxMTIuMjA0IDI1MC42MTQsMjUwLjYxNSAwLDEzOC40MSAtMTEyLjIwMywyNTAuNjEzIC0yNTAuNjE0LDI1MC42MTMgQyAxNTUuNTQ0LDU0NC41NjkgNDMuMzQsNDMyLjM2NiA0My4zNCwyOTMuOTU2IDQzLjM0LDE1NS41NDUgMTU1LjU0NCw0My4zNDEgMjkzLjk1NSw0My4zNDEgWiIgLz48cGF0aAogICAgICAgc3R5bGU9ImZpbGw6IzAwMzM3NztmaWxsLW9wYWNpdHk6MSIKICAgICAgIGlkPSJwYXRoNjk5NiIKICAgICAgIGQ9Im0gMjkzLjk1NSw1ODcuOTA5IGMgLTM5LjY2NywwIC03OC4xNjcsLTcuNzc4IC0xMTQuNDM0LC0yMy4xMTcgQyAxNDQuNTExLDU0OS45ODMgMTEzLjA3OSw1MjguNzk0IDg2LjA5OCw1MDEuODEzIDU5LjExNSw0NzQuODI5IDM3LjkyNiw0NDMuMzk2IDIzLjExOSw0MDguMzg4IDcuNzc4LDM3Mi4xMTkgMCwzMzMuNjE4IDAsMjkzLjk1NiAwLDI1NC4yOTMgNy43NzgsMjE1Ljc5MSAyMy4xMTgsMTc5LjUyMSAzNy45MjUsMTQ0LjUxMyA1OS4xMTUsMTEzLjA4MSA4Ni4wOTcsODYuMDk4IDExMy4wNzksNTkuMTE1IDE0NC41MTIsMzcuOTI2IDE3OS41MiwyMy4xMTkgMjE1Ljc5LDcuNzc5IDI1NC4yOTEsMC4wMDEgMjkzLjk1NCwwLjAwMSBjIDM5LjY2NiwwIDc4LjE2Nyw3Ljc3OCAxMTQuNDMzLDIzLjExOSAzNS4wMDksMTQuODA3IDY2LjQ0MSwzNS45OTcgOTMuNDI1LDYyLjk3OSAyNi45ODQsMjYuOTg1IDQ4LjE3Myw1OC40MTcgNjIuOTc5LDkzLjQyMyAxNS4zNDEsMzYuMjcgMjMuMTE5LDc0Ljc3MSAyMy4xMTksMTE0LjQzNCAwLDM5LjY2MiAtNy43NzgsNzguMTYzIC0yMy4xMTksMTE0LjQzMyAtMTQuODA2LDM1LjAwNyAtMzUuOTk0LDY2LjQzOSAtNjIuOTc5LDkzLjQyNSAtMjYuOTgyLDI2Ljk4IC01OC40MTUsNDguMTY5IC05My40MjUsNjIuOTc5IC0zNi4yNjYsMTUuMzM4IC03NC43NjcsMjMuMTE2IC0xMTQuNDMyLDIzLjExNiB6IG0gMCwtNTg2LjkwOCBDIDI1NC40MjYsMS4wMDEgMjE2LjA1Nyw4Ljc1MiAxNzkuOTExLDI0LjA0IDE0NS4wMjIsMzguNzk3IDExMy42OTYsNTkuOTE0IDg2LjgwNSw4Ni44MDUgNTkuOTEzLDExMy42OTcgMzguNzk2LDE0NS4wMjIgMjQuMDM5LDE3OS45MSA4Ljc1MSwyMTYuMDU3IDEsMjU0LjQyNyAxLDI5My45NTYgMSwzMzMuNDgzIDguNzUxLDM3MS44NTQgMjQuMDM5LDQwOCBjIDE0Ljc1NywzNC44ODkgMzUuODc0LDY2LjIxNCA2Mi43NjYsOTMuMTA2IDI2Ljg5LDI2Ljg4OSA1OC4yMTUsNDguMDA2IDkzLjEwNiw2Mi43NjUgMzYuMTQyLDE1LjI4NyA3NC41MTIsMjMuMDM4IDExNC4wNDQsMjMuMDM4IDM5LjUzMiwwIDc3LjkwMSwtNy43NTEgMTE0LjA0NCwtMjMuMDM5IDM0Ljg5LC0xNC43NTggNjYuMjE2LC0zNS44NzUgOTMuMTA2LC02Mi43NjQgMjYuODkzLC0yNi44OTUgNDguMDA5LC01OC4yMiA2Mi43NjQsLTkzLjEwNiAxNS4yODksLTM2LjE0NiAyMy4wNDEsLTc0LjUxNiAyMy4wNDEsLTExNC4wNDQgMCwtMzkuNTI5IC03Ljc1MiwtNzcuODk5IC0yMy4wNDEsLTExNC4wNDQgQyA1NDkuMTE1LDE0NS4wMjUgNTI3Ljk5OCwxMTMuNyA1MDEuMTA1LDg2LjgwNiA0NzQuMjEzLDU5LjkxNSA0NDIuODg3LDM4Ljc5OCA0MDcuOTk5LDI0LjA0MSAzNzEuODU1LDguNzUyIDMzMy40ODUsMS4wMDEgMjkzLjk1NSwxLjAwMSBaIG0gMCw1NDQuMDY4IEMgMjI2Ljg4LDU0NS4wNjkgMTYzLjgxOSw1MTguOTQ5IDExNi4zOSw0NzEuNTIgNjguOTYxLDQyNC4wOSA0Mi44NCwzNjEuMDMxIDQyLjg0LDI5My45NTYgYyAwLC02Ny4wNzUgMjYuMTIsLTEzMC4xMzYgNzMuNTUsLTE3Ny41NjUgNDcuNDI5LC00Ny40MjkgMTEwLjQ5LC03My41NSAxNzcuNTY1LC03My41NSA2Ny4wNzUsMCAxMzAuMTM1LDI2LjEyMSAxNzcuNTY0LDczLjU1IDQ3LjQzLDQ3LjQzIDczLjU1LDExMC40OSA3My41NSwxNzcuNTY1IDAsNjcuMDc1IC0yNi4xMiwxMzAuMTM1IC03My41NSwxNzcuNTY0IC00Ny40MjksNDcuNDI5IC0xMTAuNDksNzMuNTQ5IC0xNzcuNTY0LDczLjU0OSB6IG0gMCwtNTAxLjIyOCBjIC02Ni44MDgsMCAtMTI5LjYxNywyNi4wMTcgLTE3Ni44NTgsNzMuMjU3IC00Ny4yNCw0Ny4yNDEgLTczLjI1NywxMTAuMDUgLTczLjI1NywxNzYuODU4IDAsNjYuODA4IDI2LjAxNywxMjkuNjE3IDczLjI1NywxNzYuODU2IDQ3LjI0LDQ3LjI0IDExMC4wNSw3My4yNTcgMTc2Ljg1OCw3My4yNTcgNjYuODA4LDAgMTI5LjYxNywtMjYuMDE3IDE3Ni44NTcsLTczLjI1NyA0Ny4yNCwtNDcuMjM5IDczLjI1NywtMTEwLjA0OSA3My4yNTcsLTE3Ni44NTYgMCwtNjYuODA4IC0yNi4wMTcsLTEyOS42MTggLTczLjI1NywtMTc2Ljg1OCBDIDQyMy41NzEsNjkuODU3IDM2MC43NjMsNDMuODQxIDI5My45NTUsNDMuODQxIFoiIC8+PC9nPjxnCiAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMS4xMzcxMTI5LDAsMCwxLjA3Njc0MzQsLTQwLjMxMTU3NCwtMjIuNTU4NTgxKSIKICAgICBzdHlsZT0iZmlsbDojMDAzMzc3O2ZpbGwtb3BhY2l0eToxIgogICAgIGlkPSJnNjk5OCI+PHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOiMwMDMzNzc7ZmlsbC1vcGFjaXR5OjEiCiAgICAgICBpZD0icGF0aDcwMDAiCiAgICAgICBkPSJtIDIyOC45OTIsNDAwLjc5NCBjIDQuMDE3LDQuMDE4IDkuNDY1LDYuMjczIDE1LjE0Niw2LjI3MyA1LjY4MiwwIDExLjEyOSwtMi4yNTYgMTUuMTQ2LC02LjI3MyBMIDQ0Mi42NywyMTcuNDA5IGMgOC4zNjUsLTguMzY1IDguMzY1LC0yMS45MjcgMCwtMzAuMjkyIC04LjM2NSwtOC4zNjUgLTIxLjkyOCwtOC4zNjYgLTMwLjI5MywwIEwgMjQ0LjEzOCwzNTUuMzU3IDE3NS41MzIsMjg2Ljc1IGMgLTguMzY1LC04LjM2NiAtMjEuOTI3LC04LjM2NiAtMzAuMjkyLDAgLTguMzY1LDguMzY1IC04LjM2NSwyMS45MjcgMCwzMC4yOTIgbCA4My43NTIsODMuNzUyIHoiIC8+PHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOiMwMDMzNzc7ZmlsbC1vcGFjaXR5OjEiCiAgICAgICBpZD0icGF0aDcwMDIiCiAgICAgICBkPSJtIDI0NC4xMzgsNDA3LjU2NyBjIC01Ljg1NSwwIC0xMS4zNiwtMi4yOCAtMTUuNSwtNi40MiBsIC04My43NTIsLTgzLjc1MiBjIC04LjU0NiwtOC41NDcgLTguNTQ2LC0yMi40NTMgMCwtMzEgNC4xNCwtNC4xNDEgOS42NDUsLTYuNDIxIDE1LjUsLTYuNDIxIDUuODU1LDAgMTEuMzU5LDIuMjggMTUuNSw2LjQyMSBsIDY4LjI1Myw2OC4yNTMgMTY3Ljg4NSwtMTY3Ljg4NiBjIDQuMTQsLTQuMTQxIDkuNjQ1LC02LjQyIDE1LjUsLTYuNDIgNS44NTQsMCAxMS4zNTksMi4yOCAxNS41LDYuNDIgNC4xNDEsNC4xNCA2LjQyMSw5LjY0NSA2LjQyMSwxNS41IDAsNS44NTUgLTIuMjgsMTEuMzU5IC02LjQyMSwxNS41IEwgMjU5LjYzOCw0MDEuMTQ3IGMgLTQuMTM5LDQuMTQgLTkuNjQ0LDYuNDIgLTE1LjUsNi40MiB6IE0gMTYwLjM4NiwyODAuOTc1IGMgLTUuNTg4LDAgLTEwLjg0MSwyLjE3NiAtMTQuNzkyLDYuMTI4IC04LjE1Niw4LjE1NyAtOC4xNTYsMjEuNDI4IDAsMjkuNTg1IGwgODMuNzUyLDgzLjc1MiBjIDMuOTUxLDMuOTUxIDkuMjA0LDYuMTI3IDE0Ljc5Miw2LjEyNyA1LjU4OSwwIDEwLjg0MiwtMi4xNzYgMTQuNzkzLC02LjEyNyBMIDQ0Mi4zMTYsMjE3LjA1NSBjIDMuOTUxLC0zLjk1MSA2LjEyOCwtOS4yMDUgNi4xMjgsLTE0Ljc5MiAwLC01LjU4NyAtMi4xNzcsLTEwLjg0MiAtNi4xMjgsLTE0Ljc5MyAtMy45NTEsLTMuOTUyIC05LjIwNSwtNi4xMjcgLTE0Ljc5MywtNi4xMjcgLTUuNTg4LDAgLTEwLjg0MiwyLjE3NiAtMTQuNzkzLDYuMTI3IGwgLTE2OC41OTIsMTY4LjU5MyAtNjguOTYsLTY4Ljk2IGMgLTMuOTUxLC0zLjk1MiAtOS4yMDQsLTYuMTI4IC0xNC43OTIsLTYuMTI4IHoiIC8+PC9nPjxnCiAgICAgaWQ9Imc3MDA0IiAvPjxnCiAgICAgaWQ9Imc3MDA2IiAvPjxnCiAgICAgaWQ9Imc3MDA4IiAvPjxnCiAgICAgaWQ9Imc3MDEwIiAvPjxnCiAgICAgaWQ9Imc3MDEyIiAvPjxnCiAgICAgaWQ9Imc3MDE0IiAvPjxnCiAgICAgaWQ9Imc3MDE2IiAvPjxnCiAgICAgaWQ9Imc3MDE4IiAvPjxnCiAgICAgaWQ9Imc3MDIwIiAvPjxnCiAgICAgaWQ9Imc3MDIyIiAvPjxnCiAgICAgaWQ9Imc3MDI0IiAvPjxnCiAgICAgaWQ9Imc3MDI2IiAvPjxnCiAgICAgaWQ9Imc3MDI4IiAvPjxnCiAgICAgaWQ9Imc3MDMwIiAvPjxnCiAgICAgaWQ9Imc3MDMyIiAvPjxwYXRoCiAgICAgaWQ9InBhdGg3NTk1IgogICAgIGQ9Ik0gMjUzLjcyMjAzLDUzOS40MjkxNyBDIDIwMS44NzU1NCw1MzAuMDEwODEgMTYxLjE2NDg5LDUwOS44OTgxNiAxMjQuNDAxNCw0NzUuNTM5NzUgMTAxLjEzNjEyLDQ1My43OTY1IDg1LjAxNTQwNCw0MzEuODcyMzQgNzAuNTYzMTM1LDQwMi4zMTk3NSA1MC45NzU3MTksMzYyLjI2NjYxIDQ3LjM4MzAxNSwzNDUuNDcxMDcgNDcuMzgzMDE1LDI5My45NTQ5OSBjIDAsLTUxLjUxNjA5IDMuNTkyNzA0LC02OC4zMTE2MyAyMy4xODAxMiwtMTA4LjM2NDc3IEMgOTEuOTE0MDUyLDE0MS45MzEgMTI0LjgxNzM2LDEwNS42NTY0MSAxNjUuMjI1NjUsODEuMjI4NTQ0IDMxMi43OTk2OSwtNy45ODM4MTc0IDUwNC44MDcwOCw3Ny4xNjA3IDUzOC4yMDMzMywyNDYuNjIzMjUgYyA0LjcyMzUxLDIzLjk2ODQ4IDQuNzIzNTEsNzAuNjk0OTggMCw5NC42NjM0NyAtMTQuNTE4NjEsNzMuNjcxNzcgLTYyLjQzODE2LDEzNy44MTMzMiAtMTI5LjI5ODg5LDE3My4wNjk5MSAtNDcuMzYyMjUsMjQuOTc0NzcgLTEwNC43MTI3NSwzNC4yNDA3NyAtMTU1LjE4MjQxLDI1LjA3MjU0IHogbSA5Ni43ODAxOCwtMjE4LjY0NTg2IGMgNTUuMDgwMTYsLTUyLjA0OTkxIDEwNC40MzE4NywtOTguODE1NzUgMTA5LjY3MDUsLTEwMy45MjQxIDEyLjU2NDM4LC0xMi4yNTE5MyAxNC45NzM0OSwtMjUuOTMxODkgNi4zMTI1MywtMzUuODQ1MSAtNy41ODkzNSwtOC42ODY2MyAtMTguNjE5NjYsLTExLjc5NTQ0IC0yOS4wMTEwMiwtOC4xNzY1MiAtNC45NTUyOCwxLjcyNTc0IC00NC4xMDE3MSwzNi45NTg3MyAtMTAyLjc0MDEsOTIuNDY5MjQgLTUyLjEwMzk1LDQ5LjMyNDY1IC05NS42NjAxNyw5MC4wMDA3NSAtOTYuNzkxNTksOTAuMzkxMzMgLTEuMTMxNDMsMC4zOTA1OSAtMTUuMzkxMzgsLTExLjk0MDU3IC0zMS42ODg3OCwtMjcuNDAyNTggLTUyLjgzODI1LC01MC4xMjk3OCAtNTEuNzM0ODQsLTQ5LjI4NzQ2IC02NC41NjUyMywtNDkuMjg3NDYgLTguNzA3ODYsMCAtMTIuNzkwNjUsMS40MTE2IC0xNy4zOTIzNiw2LjAxMzMyIC04LjA0MDY0LDguMDQwNjUgLTEwLjIwMzI0LDE3LjY5ODc0IC01LjkyNjIyLDI2LjQ2NjI5IDQuNzc2MTgsOS43OTA4IDEwMC42MTc2MiwxMDAuMTg0OTkgMTA5LjY5MzEzLDEwMy40NTg2MSAxNi40MzAyNCw1LjkyNjUgMTYuOTI2MjgsNS41NDUwMyAxMjIuNDM5MTQsLTk0LjE2MzAzIHoiCiAgICAgc3R5bGU9ImZpbGw6IzAwZmY0MjtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzAwZmY0MjtzdHJva2Utd2lkdGg6MTU7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIgLz48L3N2Zz4=';
        var buttonXRedSVG = '<svg xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" version="1.1" x="0px" y="0px" width="587.91px" height="587.91px" viewBox="0 0 587.91 587.91" style="enable-background:new 0 0 587.91 587.91;" xml:space="preserve"><g style="fill:#003377;fill-opacity:1"><path d="m 86.451,501.46 c 26.937,26.936 58.315,48.088 93.265,62.871 36.207,15.314 74.642,23.078 114.239,23.078 39.596,0 78.032,-7.764 114.239,-23.078 34.949,-14.783 66.328,-35.936 93.266,-62.871 26.936,-26.938 48.09,-58.316 62.871,-93.266 15.314,-36.207 23.08,-74.643 23.08,-114.238 0,-39.598 -7.766,-78.033 -23.08,-114.239 C 549.55,144.767 528.395,113.389 501.46,86.452 474.522,59.515 443.144,38.362 408.194,23.58 371.986,8.265 333.551,0.501 293.955,0.501 254.358,0.501 215.923,8.266 179.716,23.58 144.766,38.362 113.388,59.516 86.451,86.452 59.514,113.388 38.361,144.767 23.578,179.716 8.265,215.923 0.5,254.358 0.5,293.956 c 0,39.596 7.765,78.031 23.079,114.238 14.782,34.95 35.936,66.328 62.872,93.266 z M 293.955,43.341 c 138.411,0 250.614,112.204 250.614,250.615 0,138.41 -112.203,250.613 -250.614,250.613 C 155.544,544.569 43.34,432.366 43.34,293.956 43.34,155.545 155.544,43.341 293.955,43.341 Z" style="fill:#003377;fill-opacity:1" /><path d="m 293.955,587.909 c -39.667,0 -78.167,-7.778 -114.434,-23.117 C 144.511,549.983 113.079,528.794 86.098,501.813 59.115,474.829 37.926,443.396 23.119,408.388 7.778,372.119 0,333.618 0,293.956 0,254.293 7.778,215.791 23.118,179.521 37.925,144.513 59.115,113.081 86.097,86.098 113.079,59.115 144.512,37.926 179.52,23.119 215.79,7.779 254.291,0.001 293.954,0.001 c 39.666,0 78.167,7.778 114.433,23.119 35.009,14.807 66.441,35.997 93.425,62.979 26.984,26.985 48.173,58.417 62.979,93.423 15.341,36.27 23.119,74.771 23.119,114.434 0,39.662 -7.778,78.163 -23.119,114.433 -14.806,35.007 -35.994,66.439 -62.979,93.425 -26.982,26.98 -58.415,48.169 -93.425,62.979 -36.266,15.338 -74.767,23.116 -114.432,23.116 z m 0,-586.908 C 254.426,1.001 216.057,8.752 179.911,24.04 145.022,38.797 113.696,59.914 86.805,86.805 59.913,113.697 38.796,145.022 24.039,179.91 8.751,216.057 1,254.427 1,293.956 1,333.483 8.751,371.854 24.039,408 c 14.757,34.889 35.874,66.214 62.766,93.106 26.89,26.889 58.215,48.006 93.106,62.765 36.142,15.287 74.512,23.038 114.044,23.038 39.532,0 77.901,-7.751 114.044,-23.039 34.89,-14.758 66.216,-35.875 93.106,-62.764 26.893,-26.895 48.009,-58.22 62.764,-93.106 15.289,-36.146 23.041,-74.516 23.041,-114.044 0,-39.529 -7.752,-77.899 -23.041,-114.044 C 549.115,145.025 527.998,113.7 501.105,86.806 474.213,59.915 442.887,38.798 407.999,24.041 371.855,8.752 333.485,1.001 293.955,1.001 Z m 0,544.068 C 226.88,545.069 163.819,518.949 116.39,471.52 68.961,424.09 42.84,361.031 42.84,293.956 c 0,-67.075 26.12,-130.136 73.55,-177.565 47.429,-47.429 110.49,-73.55 177.565,-73.55 67.075,0 130.135,26.121 177.564,73.55 47.43,47.43 73.55,110.49 73.55,177.565 0,67.075 -26.12,130.135 -73.55,177.564 -47.429,47.429 -110.49,73.549 -177.564,73.549 z m 0,-501.228 c -66.808,0 -129.617,26.017 -176.858,73.257 -47.24,47.241 -73.257,110.05 -73.257,176.858 0,66.808 26.017,129.617 73.257,176.856 47.24,47.24 110.05,73.257 176.858,73.257 66.808,0 129.617,-26.017 176.857,-73.257 47.24,-47.239 73.257,-110.049 73.257,-176.856 0,-66.808 -26.017,-129.618 -73.257,-176.858 C 423.571,69.857 360.763,43.841 293.955,43.841 Z" style="fill:#003377;fill-opacity:1" /></g> <path d="M 133.43898,415.74333 415.74333,133.43898 454.471,172.16666 172.16666,454.471 Z" style="fill:#003377;fill-opacity:1;stroke:none;stroke-width:1.69799995;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" /><path d="M 415.74333,454.471 C 321.64188,360.36955 227.54043,266.26811 133.43898,172.16666 c 12.90923,-12.90923 25.81845,-25.81845 38.72768,-38.72768 94.10145,94.10145 188.20289,188.2029 282.30434,282.30435 -12.90922,12.90922 -25.81845,25.81845 -38.72767,38.72767 z" style="fill:#003377;fill-opacity:1;stroke:none;stroke-width:1.69799995;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" /><path d="m 265.05969,541.8598 c -44.3069,-5.09104 -86.96292,-22.55802 -123.93441,-50.74921 -10.54216,-8.03852 -31.90275,-28.97808 -40.83133,-40.02652 -79.842285,-98.79872 -73.099008,-241.91187 15.6227,-331.56201 40.84256,-41.269949 90.3185,-65.709593 148.4555,-73.332604 17.17036,-2.251404 59.02046,-0.89136 75.70279,2.460188 101.31593,20.354774 178.36171,96.552506 198.42091,196.236866 20.14751,100.12323 -22.69892,201.63693 -109.11891,258.52937 -31.13079,20.49418 -70.06742,34.31326 -108.52881,38.51817 -13.95321,1.52548 -42.19323,1.4879 -55.78844,-0.0742 z m 89.67603,-147.45441 61.02787,61.01834 19.31152,-19.28138 c 10.62134,-10.60475 19.31152,-19.85082 19.31152,-20.54683 0,-0.696 -27.18463,-28.44575 -60.41029,-61.66611 l -60.41029,-60.40066 60.71683,-60.72631 60.71684,-60.72632 -19.613,-19.61299 -19.61299,-19.61299 -60.72632,60.71683 -60.7263,60.71683 -60.40067,-60.41029 c -33.22036,-33.22566 -60.97011,-60.41029 -61.66611,-60.41029 -0.69601,0 -9.94208,8.69018 -20.54684,19.31152 l -19.28137,19.31152 61.01834,61.02787 61.01834,61.02787 -60.71698,60.72647 -60.71698,60.72647 19.61304,19.61303 19.61304,19.61304 60.72646,-60.71697 60.72647,-60.71699 61.02787,61.01834 z" style="fill:#ff0000;fill-opacity:1;stroke:none;stroke-width:1.69799995;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" /></svg>';
        buttonXRedData = makeDataFromSVG(buttonXRedSVG);
        addSVG = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 491.86 491.86" style="enable-background:new 0 0 491.86 491.86;" xml:space="preserve"> <g> <g> <path d="M465.167,211.614H280.245V26.691c0-8.424-11.439-26.69-34.316-26.69s-34.316,18.267-34.316,26.69v184.924H26.69 C18.267,211.614,0,223.053,0,245.929s18.267,34.316,26.69,34.316h184.924v184.924c0,8.422,11.438,26.69,34.316,26.69 s34.316-18.268,34.316-26.69V280.245H465.17c8.422,0,26.69-11.438,26.69-34.316S473.59,211.614,465.167,211.614z"/> </g> </g> </svg>'
        minusSVG = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 491.858 491.858" style="enable-background:new 0 0 491.858 491.858;" xml:space="preserve"> <g> <g> <path d="M465.167,211.613H240.21H26.69c-8.424,0-26.69,11.439-26.69,34.316s18.267,34.316,26.69,34.316h213.52h224.959 c8.421,0,26.689-11.439,26.689-34.316S473.59,211.613,465.167,211.613z"/> </g> </g> </svg>';
        compassSVG = '<svg xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="enable-background:new 0 0 291.32 291.32;" viewBox="0 0 291.32 291.32" y="0px" x="0px" version="1.1"><path d="m 42.662827,42.662826 c -56.648446,56.648446 -56.648446,149.345904 0,205.994344 56.648445,56.64845 149.345903,56.64845 205.994343,0 56.64845,-56.64844 56.64845,-149.345898 0,-205.994344 -56.64844,-56.648445 -149.346605,-56.647738 -205.994343,0 z M 229.34467,229.34467 c -46.34872,46.34873 -121.02132,46.34802 -167.369343,0 C 15.627306,182.99665 15.625892,108.32335 61.97462,61.97462 c 46.34873,-46.348728 121.02133,-46.348021 167.37005,7.07e-4 46.34873,46.348723 46.34802,121.021323 0,167.369343 z" style="fill-opacity:1" /><g ><path style="fill:#ff0000;fill-opacity:1" d="m 145.66,29.426323 51.64318,108.828047 -103.286352,0 C 94.017828,138.25365 145.66,29.426323 145.66,29.426323 Z" /><path style="fill:#999999;fill-opacity:1" d="m 145.66,263.12809 51.64318,-106.35923 -103.286352,0 c 10e-4,7e-4 51.643172,106.35923 51.643172,106.35923 z" /></g></svg>';
        arrowDownSVG = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 204.55612 510.99498"style="enable-background:new 0 0 204.55612 510.99498;" y="0px" x="0px"><path d="m 127.635,441.369 69.626,69.626 -185.685,0 0,-185.685 69.648,69.648 c 76.847,-76.825 76.847,-201.659 0,-278.484 C 57.811,93.017 29.715,76.497 -2.0158342e-7,67.788 l 0,-67.788 C 46.695,10.437 91.201,33.588 127.656,70.02 230.193,172.666 230.193,338.746 127.635,441.369 Z" /> </svg>';
        arrowDownFlipSVG = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 204.55612 510.99498" xml:space="preserve" > <path d="m 76.921125,441.369 -69.6259998,69.626 185.6850048,0 0,-185.685 -69.648,69.648 c -76.847005,-76.825 -76.847005,-201.659 0,-278.484 23.413,-23.457 51.509,-39.977 81.224,-48.686 l 0,-67.788 c -46.695,10.437 -91.201,33.588 -127.656005,70.02 -102.537,102.646 -102.537,268.726 0.021,371.349 z" /> </svg>';
        poweredByTerraFlySVGForMap = '<svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" enable-background="new 0 0.5 61 53" viewBox="0 0.5 61 53" height="100%" width="100%" y="0" x="0" version="1.1"><g transform="translate(-2.3621042,-1.1117523)" ><g ><path d="m 60.262,17.214 c -3.436,-2.931 -9.344,-2.097 -15.352,1.575 4.221,-1.991 8.189,-2.166 10.611,-0.042 4.215,3.7 2.146,12.954 -4.627,20.673 -6.771,7.719 -15.677,10.978 -19.894,7.278 -2.393,-2.1 -2.758,-5.987 -1.392,-10.369 -3.021,6.815 -3.053,13.151 0.52,16.2 5.237,4.471 16.229,0.186 24.552,-9.566 8.318,-9.752 10.82,-21.28 5.582,-25.749 z" style="fill:#00519e" /><g ><g ><path d="m 7.104,31.737 -2.156,0 0,-6.217 -1.948,0 0,-1.763 6.046,0 0,1.763 -1.942,0 0,6.217 z" style="fill:#00519e" /><path d="m 20.032,25.444 c 0.185,0 0.362,0.016 0.529,0.042 l 0.12,0.023 -0.19,2.014 c -0.175,-0.044 -0.416,-0.065 -0.726,-0.065 -0.466,0 -0.804,0.107 -1.015,0.319 -0.211,0.211 -0.317,0.519 -0.317,0.919 l 0,3.041 -2.133,0 0,-6.185 1.588,0 0.332,0.988 0.104,0 c 0.178,-0.327 0.426,-0.592 0.745,-0.795 0.318,-0.201 0.639,-0.301 0.963,-0.301 z" style="fill:#00519e" /><path d="m 25.276,25.444 c 0.186,0 0.362,0.016 0.529,0.042 l 0.12,0.023 -0.19,2.014 c -0.175,-0.044 -0.417,-0.065 -0.726,-0.065 -0.466,0 -0.805,0.107 -1.016,0.319 -0.21,0.211 -0.316,0.519 -0.316,0.919 l 0,3.041 -2.134,0 0,-6.185 1.588,0 0.333,0.988 0.104,0 c 0.179,-0.327 0.427,-0.592 0.745,-0.795 0.318,-0.201 0.639,-0.301 0.963,-0.301 z" style="fill:#00519e" /><path d="m 30.821,31.737 -0.41,-0.821 -0.042,0 c -0.289,0.358 -0.581,0.6 -0.879,0.732 -0.299,0.131 -0.684,0.195 -1.157,0.195 -0.582,0 -1.041,-0.173 -1.375,-0.522 -0.335,-0.35 -0.502,-0.84 -0.502,-1.473 0,-0.659 0.229,-1.15 0.688,-1.471 0.458,-0.323 1.123,-0.504 1.991,-0.544 l 1.031,-0.033 0,-0.087 c 0,-0.51 -0.25,-0.763 -0.752,-0.763 -0.451,0 -1.024,0.151 -1.719,0.457 L 27.078,26 c 0.72,-0.372 1.629,-0.556 2.729,-0.556 0.792,0 1.406,0.196 1.841,0.589 0.435,0.393 0.652,0.942 0.652,1.648 l 0,4.056 -1.479,0 z m -1.583,-1.399 c 0.259,0 0.479,-0.081 0.663,-0.246 0.184,-0.162 0.276,-0.375 0.276,-0.638 l 0,-0.481 -0.492,0.024 c -0.702,0.024 -1.053,0.282 -1.053,0.773 10e-4,0.379 0.203,0.568 0.606,0.568 z" style="fill:#00519e" /><path d="m 12.376,31.843 c -1.03,0 -1.829,-0.272 -2.398,-0.82 -0.57,-0.547 -0.854,-1.326 -0.854,-2.338 0,-1.044 0.264,-1.846 0.792,-2.404 0.528,-0.558 1.28,-0.837 2.259,-0.837 0.932,0 1.651,0.241 2.158,0.728 0.508,0.486 0.762,1.186 0.762,2.099 l 0,0.688 c 0,0 0.017,0.181 -0.056,0.234 -0.059,0.045 -0.27,0.028 -0.27,0.028 l -3.489,0 c 0.015,0.346 0.142,0.616 0.379,0.812 0.239,0.195 0.563,0.296 0.975,0.296 0.375,0 0.72,-0.038 1.034,-0.107 0.279,-0.062 0.577,-0.165 0.898,-0.308 0.014,-0.005 0.067,-0.036 0.092,-0.026 0.037,0.013 0.032,0.058 0.032,0.058 l 0,1.446 c -0.335,0.172 -0.68,0.289 -1.037,0.355 -0.357,0.065 -0.783,0.096 -1.277,0.096 z M 12.25,26.895 c -0.251,0 -0.461,0.079 -0.63,0.238 -0.168,0.157 -0.268,0.405 -0.297,0.745 l 1.834,0 C 13.149,27.58 13.064,27.34 12.902,27.161 12.741,26.984 12.523,26.895 12.25,26.895 Z" style="fill:#00519e" /></g><g ><path d="m 33.332,35.92 c -0.302,0 -0.575,-0.047 -0.82,-0.139 l 0,-0.924 c 0.28,0.096 0.524,0.145 0.734,0.145 0.332,0 0.588,-0.135 0.766,-0.406 0.178,-0.271 0.324,-0.656 0.432,-1.159 l 1.488,-7.087 -1.264,0 0.084,-0.439 1.35,-0.433 0.148,-0.654 c 0.203,-0.874 0.482,-1.491 0.838,-1.852 0.355,-0.36 0.881,-0.54 1.58,-0.54 0.176,0 0.391,0.025 0.645,0.076 0.252,0.05 0.447,0.106 0.59,0.167 L 39.62,23.52 c -0.332,-0.126 -0.631,-0.19 -0.898,-0.19 -0.379,0 -0.672,0.106 -0.875,0.318 -0.201,0.213 -0.365,0.599 -0.494,1.163 l -0.162,0.708 1.559,0 -0.164,0.832 -1.553,0 -1.52,7.191 c -0.17,0.826 -0.43,1.428 -0.785,1.809 -0.355,0.379 -0.82,0.569 -1.396,0.569 z m 6.365,-3.222 -1.102,0 2.176,-10.193 1.102,0 -2.176,10.193 z" style="fill:#00519e" /><path d="m 42.285,25.518 1.102,0 0.482,3.57 c 0.045,0.301 0.086,0.744 0.129,1.332 0.041,0.588 0.062,1.062 0.062,1.418 l 0.04,0 c 0.152,-0.379 0.342,-0.817 0.57,-1.311 0.225,-0.493 0.393,-0.832 0.504,-1.021 l 2.129,-3.989 1.166,0 -4.559,8.397 c -0.406,0.752 -0.807,1.272 -1.207,1.565 -0.395,0.294 -0.873,0.439 -1.434,0.439 -0.314,0 -0.619,-0.047 -0.918,-0.139 l 0,-0.886 c 0.275,0.081 0.561,0.119 0.859,0.119 0.357,0 0.666,-0.109 0.92,-0.331 0.254,-0.221 0.504,-0.547 0.744,-0.979 l 0.498,-0.89 -1.087,-7.294 z" style="fill:#00519e" /></g></g></g><text y="9.0472097" x="2.3282847" style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:8.5px;line-height:150%;font-family:sans-serif;text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#eeeeee;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" xml:space="preserve" ><tspan style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:8.5px;line-height:150%;font-family:sans-serif;text-align:start;writing-mode:lr-tb;text-anchor:start;fill:#eeeeee;fill-opacity:1" y="9.0472097" x="2.3282847" >powered by</tspan></text> <text xml:space="preserve" style="font-style:normal;font-weight:normal;font-size:8.50913048px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" x="1.9552906" y="8.3881102" ><tspan x="1.9552906" y="8.3881102" >powered by</tspan></text> </g></svg>';
        poweredByTerraFlySVG = '<svg xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" enable-background="new 0 0 66 58" viewBox="0 0 60.000271 49.843258" height="49.843258" width="60.000271" y="0px" x="0px" version="1.1"><filter height="1.2508659" y="-0.12543292" width="1.0420316" x="-0.021015836" style="color-interpolation-filters:sRGB"><feGaussianBlur stdDeviation="0.37666626" /></filter><path d="m 57.262,12.756918 c -3.436,-2.9310001 -9.344,-2.097 -15.352,1.575 4.221,-1.991 8.189,-2.166 10.611,-0.042 4.215,3.7 2.146,12.954 -4.627,20.673 -6.771,7.719 -15.677,10.978 -19.894,7.278 -2.393,-2.1 -2.758,-5.987 -1.392,-10.369 -3.021,6.815 -3.053,13.151 0.52,16.2 5.237,4.471 16.229,0.186 24.552,-9.566 8.318,-9.752 10.82,-21.28 5.582,-25.749 z" style="fill:#00519e" /><g transform="translate(-3,-4.4570821)" ><g ><path d="m 7.104,31.737 -2.156,0 0,-6.217 -1.948,0 0,-1.763 6.046,0 0,1.763 -1.942,0 0,6.217 z" style="fill:#00519e" /><path d="m 20.032,25.444 c 0.185,0 0.362,0.016 0.529,0.042 l 0.12,0.023 -0.19,2.014 c -0.175,-0.044 -0.416,-0.065 -0.726,-0.065 -0.466,0 -0.804,0.107 -1.015,0.319 -0.211,0.211 -0.317,0.519 -0.317,0.919 l 0,3.041 -2.133,0 0,-6.185 1.588,0 0.332,0.988 0.104,0 c 0.178,-0.327 0.426,-0.592 0.745,-0.795 0.318,-0.201 0.639,-0.301 0.963,-0.301 z" style="fill:#00519e" /><path d="m 25.276,25.444 c 0.186,0 0.362,0.016 0.529,0.042 l 0.12,0.023 -0.19,2.014 c -0.175,-0.044 -0.417,-0.065 -0.726,-0.065 -0.466,0 -0.805,0.107 -1.016,0.319 -0.21,0.211 -0.316,0.519 -0.316,0.919 l 0,3.041 -2.134,0 0,-6.185 1.588,0 0.333,0.988 0.104,0 c 0.179,-0.327 0.427,-0.592 0.745,-0.795 0.318,-0.201 0.639,-0.301 0.963,-0.301 z" style="fill:#00519e" /><path d="m 30.821,31.737 -0.41,-0.821 -0.042,0 c -0.289,0.358 -0.581,0.6 -0.879,0.732 -0.299,0.131 -0.684,0.195 -1.157,0.195 -0.582,0 -1.041,-0.173 -1.375,-0.522 -0.335,-0.35 -0.502,-0.84 -0.502,-1.473 0,-0.659 0.229,-1.15 0.688,-1.471 0.458,-0.323 1.123,-0.504 1.991,-0.544 l 1.031,-0.033 0,-0.087 c 0,-0.51 -0.25,-0.763 -0.752,-0.763 -0.451,0 -1.024,0.151 -1.719,0.457 L 27.078,26 c 0.72,-0.372 1.629,-0.556 2.729,-0.556 0.792,0 1.406,0.196 1.841,0.589 0.435,0.393 0.652,0.942 0.652,1.648 l 0,4.056 -1.479,0 z m -1.583,-1.399 c 0.259,0 0.479,-0.081 0.663,-0.246 0.184,-0.162 0.276,-0.375 0.276,-0.638 l 0,-0.481 -0.492,0.024 c -0.702,0.024 -1.053,0.282 -1.053,0.773 10e-4,0.379 0.203,0.568 0.606,0.568 z" style="fill:#00519e" /><path d="m 12.376,31.843 c -1.03,0 -1.829,-0.272 -2.398,-0.82 -0.57,-0.547 -0.854,-1.326 -0.854,-2.338 0,-1.044 0.264,-1.846 0.792,-2.404 0.528,-0.558 1.28,-0.837 2.259,-0.837 0.932,0 1.651,0.241 2.158,0.728 0.508,0.486 0.762,1.186 0.762,2.099 l 0,0.688 c 0,0 0.017,0.181 -0.056,0.234 -0.059,0.045 -0.27,0.028 -0.27,0.028 l -3.489,0 c 0.015,0.346 0.142,0.616 0.379,0.812 0.239,0.195 0.563,0.296 0.975,0.296 0.375,0 0.72,-0.038 1.034,-0.107 0.279,-0.062 0.577,-0.165 0.898,-0.308 0.014,-0.005 0.067,-0.036 0.092,-0.026 0.037,0.013 0.032,0.058 0.032,0.058 l 0,1.446 c -0.335,0.172 -0.68,0.289 -1.037,0.355 -0.357,0.065 -0.783,0.096 -1.277,0.096 z M 12.25,26.895 c -0.251,0 -0.461,0.079 -0.63,0.238 -0.168,0.157 -0.268,0.405 -0.297,0.745 l 1.834,0 C 13.149,27.58 13.064,27.34 12.902,27.161 12.741,26.984 12.523,26.895 12.25,26.895 Z" style="fill:#00519e" /></g><g ><path d="m 33.332,35.92 c -0.302,0 -0.575,-0.047 -0.82,-0.139 l 0,-0.924 c 0.28,0.096 0.524,0.145 0.734,0.145 0.332,0 0.588,-0.135 0.766,-0.406 0.178,-0.271 0.324,-0.656 0.432,-1.159 l 1.488,-7.087 -1.264,0 0.084,-0.439 1.35,-0.433 0.148,-0.654 c 0.203,-0.874 0.482,-1.491 0.838,-1.852 0.355,-0.36 0.881,-0.54 1.58,-0.54 0.176,0 0.391,0.025 0.645,0.076 0.252,0.05 0.447,0.106 0.59,0.167 L 39.62,23.52 c -0.332,-0.126 -0.631,-0.19 -0.898,-0.19 -0.379,0 -0.672,0.106 -0.875,0.318 -0.201,0.213 -0.365,0.599 -0.494,1.163 l -0.162,0.708 1.559,0 -0.164,0.832 -1.553,0 -1.52,7.191 c -0.17,0.826 -0.43,1.428 -0.785,1.809 -0.355,0.379 -0.82,0.569 -1.396,0.569 z m 6.365,-3.222 -1.102,0 2.176,-10.193 1.102,0 -2.176,10.193 z" style="fill:#00519e" /><path d="m 42.285,25.518 1.102,0 0.482,3.57 c 0.045,0.301 0.086,0.744 0.129,1.332 0.041,0.588 0.062,1.062 0.062,1.418 l 0.04,0 c 0.152,-0.379 0.342,-0.817 0.57,-1.311 0.225,-0.493 0.393,-0.832 0.504,-1.021 l 2.129,-3.989 1.166,0 -4.559,8.397 c -0.406,0.752 -0.807,1.272 -1.207,1.565 -0.395,0.294 -0.873,0.439 -1.434,0.439 -0.314,0 -0.619,-0.047 -0.918,-0.139 l 0,-0.886 c 0.275,0.081 0.561,0.119 0.859,0.119 0.357,0 0.666,-0.109 0.92,-0.331 0.254,-0.221 0.504,-0.547 0.744,-0.979 l 0.498,-0.89 -1.087,-7.294 z" style="fill:#00519e" /></g></g><text xml:space="preserve" style="font-style:normal;font-weight:normal;font-size:7.5px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#bfbfbf;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;filter:url(#filter5967)" x="2.4067798" y="6.602241" ><tspan x="2.4067798" y="6.602241">powered by</tspan></text> <text y="5.8649526" x="1.9152541" style="font-style:normal;font-weight:normal;font-size:7.5px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" xml:space="preserve"><tspan y="5.8649526" x="1.9152541" >powered by</tspan></text> </svg>';
        var noClusterSVG = '<svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="enable-background:new 0 0 31.999 31.999;" viewBox="0 0 31.999 31.999" y="0px" x="0px" version="1.1"><circle r="9.4899912" cy="15.9995" cx="10.059023" style="fill:#ff6666;fill-opacity:1;stroke:#000000;stroke-width:1.13806307;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" /><circle style="fill:#6666ff;fill-opacity:1;stroke:#000000;stroke-width:1.13806307;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" cx="21.939978" cy="15.9995" r="9.4899912" /></svg>';
        noClusterData = makeDataFromSVG(noClusterSVG);
        var clusterSVG = '<svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" height="31.778698" width="31.778698" xml:space="preserve" viewBox="0 0 31.778697 31.778697" y="0px" x="0px" version="1.1"><path d="M 30.879849,15.889349 C 31.248959,25.610589 20.628413,33.423964 11.459353,30.210321 2.0694281,27.688286 -2.2730851,15.237833 3.5171547,7.4250759 8.7016043,-0.80340189 21.878289,-1.2700274 27.631811,6.5711043 c 2.092274,2.6227336 3.256385,5.9636747 3.248038,9.3182447 z" style="fill:#003377;fill-opacity:1;stroke:#000000;stroke-width:2px;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" /><path d="M 14.459033,6.2168921 C 13.000214,12.484411 11.541394,18.751931 10.082575,25.01945" style="fill:none;fill-rule:evenodd;stroke:#ffffff;stroke-width:2px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" /><path d="m 21.916427,6.759248 c -1.458819,6.267519 -2.917639,12.535039 -4.376458,18.802558" style="fill:none;fill-rule:evenodd;stroke:#ffffff;stroke-width:2px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" /><path d="m 25.987361,13.011697 c -6.435037,0.01609 -12.870073,0.03218 -19.3051097,0.04827" style="fill:none;fill-rule:evenodd;stroke:#ffffff;stroke-width:2px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" /><path d="M 25.3157,18.767 C 18.880645,18.7628 12.445589,18.7586 6.0105342,18.75446" style="fill:none;fill-rule:evenodd;stroke:#ffffff;stroke-width:2px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" /></svg>';
        clusterData = makeDataFromSVG(clusterSVG);
        refreshSVG = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="512px" height="512px" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve">  <path d="M92.07,256.41H50l78.344,78.019l77.536-78.019h-39.825c-0.104-61.079,49.192-111.032,110.329-111.387  c61.293-0.358,111.27,49.039,111.626,110.331c0.58,98.964-119.057,148.511-188.892,79.686l-51.929,52.687  c116.154,114.483,315.773,32.415,314.809-132.804C461.4,152.769,378.105,70.441,275.952,71.037 C173.955,71.632,91.725,154.47,92.07,256.41z"/> </svg>';
        playerSVGs = {
            play: '<svg viewBox="0 0 512 512" width="512" height="512" xmlns="http://www.w3.org/2000/svg"> <g> <path d="m85.887123,463.210999c5.776329,3.336304 12.226295,5.005554 18.674049,5.005554c6.447754,0 12.894409,-1.66925 18.674057,-5.005554l302.88092,-174.869049c11.554871,-6.670441 18.674042,-19.000458 18.674042,-32.343613c0,-13.33873 -7.119171,-25.669861 -18.674042,-32.339203l-302.885284,-174.871197c-5.778549,-3.334137 -12.221939,-5.004486 -18.674042,-5.004486c-6.446655,0 -12.893372,1.670349 -18.674057,5.004486c-11.554886,6.670479 -18.672958,18.999386 -18.672958,32.339245l0,349.741257c0.007652,13.34317 7.126823,25.674225 18.677315,32.34256z" /> </g> </svg>',
            pause: '<svg viewBox="0 0 512 512" width="512" height="512" xmlns="http://www.w3.org/2000/svg"> <g> <g> <path d="m162.590088,58.444733c-30.713196,0 -55.60907,24.895859 -55.60907,55.60907l0,283.892426c0,30.709412 24.895874,55.60907 55.60907,55.60907c30.709473,0 55.605377,-24.895935 55.605377,-55.60907l0,-283.896179c0,-30.709465 -24.895874,-55.605331 -55.605377,-55.605331l0,0l0,0.000015z" /> <path d="m349.409882,58.444733c-30.709473,0 -55.609039,24.895859 -55.609039,55.60907l0,283.892426c0,30.709412 24.895874,55.60907 55.609039,55.60907c30.713287,0 55.6091,-24.895874 55.6091,-55.60907l0,-283.896179c0,-30.709473 -24.895813,-55.605316 -55.6091,-55.605316l0,-0.000015l0,0.000015z" /> </g> </g> </svg>',
            stop: '<svg viewBox="0 0 512 512" width="512" height="512" xmlns="http://www.w3.org/2000/svg"> <g> <path d="m144.763687,462.881165l222.472702,0c48.978027,0 88.682129,-41.165588 88.682129,-91.946259l0,-229.869736c0,-50.780762 -39.704102,-91.946339 -88.682129,-91.946339l-222.472702,0c-48.978035,0 -88.682213,41.165577 -88.682213,91.946339l0,229.869736c-0.003708,50.78067 39.704178,91.946259 88.682213,91.946259z" /> </g> </svg>',
            autoRepeat: '<svg xmlns:svg="http://www.w3.org/2000/svg" viewBox="0, 0, 140.171, 140.171" version="1.1" height="140.171" width="140.171"> <g transform="matrix(1.1513325,0,0,1.4659322,-10.546327,-32.595694)" > <path d="M 42.943993,84.644196 C 35.08844,81.003685 30.166628,75.801018 30.166628,70.022408 c 0,-9.282604 12.714792,-17.06208 29.899881,-19.276253 l 0,-10.0228 c -22.74612,2.771629 -39.866505,14.835823 -39.866505,29.299053 0,8.339775 5.703241,15.858292 14.878479,21.274269 10.038441,6.136261 15.021397,-3.829651 7.865509,-6.652481 z M 102.79067,47.526574 c -5.347714,-4.910431 -12.823575,2.564716 -7.725423,6.983818 9.047253,3.654736 14.835813,9.246349 14.835813,15.512016 0,9.287582 -12.716924,17.067764 -29.900586,19.281227 l 0,10.018532 C 102.74659,96.55481 119.86697,84.491326 119.86697,70.022408 c 0,-8.981129 -6.62546,-17.020836 -17.0763,-22.495834 z m -38.320699,9.986534 16.221626,-9.713497 c 2.359932,-1.413544 2.364914,-3.715885 0.01279,-5.139381 L 64.332733,32.751909 c -2.354954,-1.421368 -4.255566,-0.347702 -4.244179,2.404018 l 0.08816,19.93325 c 0.0071,2.75243 1.930466,3.837479 4.293251,2.423931 z M 75.734948,82.58574 59.364007,92.493356 c -2.354252,1.423492 -2.349274,3.725838 0.0135,5.140099 l 16.219498,9.713485 c 2.35994,1.41071 4.28756,0.32851 4.299652,-2.42606 l 0.08533,-19.933253 c 0.0085,-2.75029 -1.894211,-3.82254 -4.24704,-2.401886 z" /> </g> </svg>',
            noAutoRepeat: '<svg xmlns:svg="http://www.w3.org/2000/svg" viewBox="0, 0, 140.171, 140.171" version="1.1" height="140.171" width="140.171"> <g transform="matrix(1.1513325,0,0,1.4659322,-10.546327,-32.595694)" > <path d="M 42.943993,84.644196 C 35.08844,81.003685 30.166628,75.801018 30.166628,70.022408 c 0,-9.282604 12.714792,-17.06208 29.899881,-19.276253 l 0,-10.0228 c -22.74612,2.771629 -39.866505,14.835823 -39.866505,29.299053 0,8.339775 5.703241,15.858292 14.878479,21.274269 10.038441,6.136261 15.021397,-3.829651 7.865509,-6.652481 z M 102.79067,47.526574 c -5.347714,-4.910431 -12.823575,2.564716 -7.725423,6.983818 9.047253,3.654736 14.835813,9.246349 14.835813,15.512016 0,9.287582 -12.716924,17.067764 -29.900586,19.281227 l 0,10.018532 C 102.74659,96.55481 119.86697,84.491326 119.86697,70.022408 c 0,-8.981129 -6.62546,-17.020836 -17.0763,-22.495834 z m -38.320699,9.986534 16.221626,-9.713497 c 2.359932,-1.413544 2.364914,-3.715885 0.01279,-5.139381 L 64.332733,32.751909 c -2.354954,-1.421368 -4.255566,-0.347702 -4.244179,2.404018 l 0.08816,19.93325 c 0.0071,2.75243 1.930466,3.837479 4.293251,2.423931 z M 75.734948,82.58574 59.364007,92.493356 c -2.354252,1.423492 -2.349274,3.725838 0.0135,5.140099 l 16.219498,9.713485 c 2.35994,1.41071 4.28756,0.32851 4.299652,-2.42606 l 0.08533,-19.933253 c 0.0085,-2.75029 -1.894211,-3.82254 -4.24704,-2.401886 z" /> </g> <path d="M 103.20978,17.999925 36.845247,122.07159" style="fill:none;fill-rule:evenodd;stroke:#ff0000;stroke-width:10;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" /> </svg>',
            noAutoRepeat3: '<svg xmlns:svg="http://www.w3.org/2000/svg" viewBox="0, 0, 140.171, 140.171" version="1.1" height="140.171" width="140.171"> <g transform="matrix(1.1513325,0,0,1.4659322,-10.546327,-32.595694)" > <path d="M 42.943993,84.644196 C 35.08844,81.003685 30.166628,75.801018 30.166628,70.022408 c 0,-9.282604 12.714792,-17.06208 29.899881,-19.276253 l 0,-10.0228 c -22.74612,2.771629 -39.866505,14.835823 -39.866505,29.299053 0,8.339775 5.703241,15.858292 14.878479,21.274269 10.038441,6.136261 15.021397,-3.829651 7.865509,-6.652481 z M 102.79067,47.526574 c -5.347714,-4.910431 -12.823575,2.564716 -7.725423,6.983818 9.047253,3.654736 14.835813,9.246349 14.835813,15.512016 0,9.287582 -12.716924,17.067764 -29.900586,19.281227 l 0,10.018532 C 102.74659,96.55481 119.86697,84.491326 119.86697,70.022408 c 0,-8.981129 -6.62546,-17.020836 -17.0763,-22.495834 z m -38.320699,9.986534 16.221626,-9.713497 c 2.359932,-1.413544 2.364914,-3.715885 0.01279,-5.139381 L 64.332733,32.751909 c -2.354954,-1.421368 -4.255566,-0.347702 -4.244179,2.404018 l 0.08816,19.93325 c 0.0071,2.75243 1.930466,3.837479 4.293251,2.423931 z M 75.734948,82.58574 59.364007,92.493356 c -2.354252,1.423492 -2.349274,3.725838 0.0135,5.140099 l 16.219498,9.713485 c 2.35994,1.41071 4.28756,0.32851 4.299652,-2.42606 l 0.08533,-19.933253 c 0.0085,-2.75029 -1.894211,-3.82254 -4.24704,-2.401886 z" /> </g> <path d="M 14.651911,18.861802 125.61859,121.20971" style="fill:none;fill-rule:evenodd;stroke:#ff0000;stroke-width:10;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" /> </svg>',
            noAutoRepeat2: '<svg viewBox="0 0 140.171 140.171" width="140.171" height="140.171" xmlns="http://www.w3.org/2000/svg"> <g> <path d="m42.943989,84.644203c-7.855549,-3.640526 -12.777359,-8.843185 -12.777359,-14.621796c0,-9.282608 12.71479,-17.062077 29.899879,-19.276257l0,-10.0228c-22.74612,2.771629 -39.866508,14.835831 -39.866508,29.299057c0,8.339775 5.703249,15.858292 14.878479,21.274269c10.038441,6.136261 15.0214,-3.829643 7.865509,-6.652473zm59.846684,-37.117634c-5.34771,-4.910431 -12.823586,2.56472 -7.725426,6.983822c9.047241,3.654739 14.8358,9.246349 14.8358,15.512016c0,9.287582 -12.716919,17.067764 -29.900574,19.281219l0,10.018539c22.746117,-2.767357 39.866493,-14.830833 39.866493,-29.299759c0,-8.981129 -6.625458,-17.020836 -17.076294,-22.495838zm-38.320702,9.986542l16.221626,-9.713501c2.359932,-1.41354 2.364914,-3.715881 0.012794,-5.139381l-16.371658,-9.908318c-2.354954,-1.421371 -4.255562,-0.347702 -4.244183,2.404018l0.088169,19.93325c0.007111,2.75243 1.93047,3.837479 4.293251,2.423931zm11.264977,25.072628l-16.370937,9.907608c-2.354259,1.4235 -2.349281,3.725845 0.0135,5.140106l16.219498,9.713486c2.35994,1.410713 4.28756,0.328514 4.299652,-2.426056l0.085327,-19.93325c0.008522,-2.75029 -1.894203,-3.82254 -4.24704,-2.401894z" /> <path d="m20.722425,51.273846c0,0 2.217535,-4.027969 2.217535,-4.027969c0,0 96.508617,41.474796 96.508617,41.474796c0,0 -1.80687,4.204453 -1.80687,4.204453c0,0 -96.919283,-41.651279 -96.919283,-41.651279z" fill="#FF0000"/> </g> </svg>'
        };
        mapCenterSVG = '<svg viewBox="0 0 390 390" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg"> <g> <path d="m340.384766,173.735092l31.219025,0c-4.673218,-39.459625 -22.307343,-75.974045 -50.835632,-104.503242c-28.529175,-28.528301 -65.04274,-46.162409 -104.50325,-50.83563l0,31.21903c64.030197,9.325581 114.794266,60.089661 124.119858,124.119843z" /> <path d="m173.735092,49.61525l0,-31.21903c-39.459625,4.673222 -75.974045,22.307329 -104.503242,50.83563c-28.528301,28.529198 -46.162409,65.042717 -50.83563,104.503242l31.21903,0c9.325581,-64.030182 60.089661,-114.794262 124.119843,-124.119843z" /> <path d="m216.264908,340.384766l0,31.219025c39.45871,-4.673218 75.974075,-22.307343 104.50325,-50.835632c28.52829,-28.529175 46.162415,-65.04274 50.835632,-104.50325l-31.219025,0c-9.325592,64.030197 -60.089661,114.794266 -124.119858,124.119858z" /> <path d="m49.61525,216.264908l-31.21903,0c4.673222,39.45871 22.307329,75.974075 50.83563,104.50325c28.529198,28.52829 65.042717,46.162415 104.503242,50.835632l0,-31.219025c-64.030182,-9.325592 -114.794262,-60.089661 -124.119843,-124.119858z" /> <path d="m116.634109,173.735092c7.527847,-27.709595 29.391388,-49.573135 57.100983,-57.100983l0,-31.732529c-44.80574,8.638191 -80.19532,44.027771 -88.833511,88.833511l31.732529,0z" /> <path d="m116.634109,216.264908l-31.732529,0c8.638191,44.80574 44.027771,80.195328 88.833511,88.832596l0,-31.731598c-27.709595,-7.526947 -49.574036,-29.391403 -57.100983,-57.100998z"/> <path d="m273.365906,216.264908c-7.527863,27.709595 -29.391434,49.57225 -57.100998,57.100998l0,31.731598c44.80574,-8.637268 80.195328,-44.026855 88.833511,-88.832596l-31.732513,0z" /> <path d="m273.365906,173.735092l31.732513,0c-8.638184,-44.80574 -44.027771,-80.19532 -88.833511,-88.833488l0,31.732506c27.709595,7.526947 49.574051,29.391388 57.100998,57.100983z" /> </g> </svg>';
        fenceSVG = '<svg  xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="enable-background:new 0 0 512 512;" viewBox="0 0 512 512" width="512px" height="512px" y="0px" x="0px" version="1.1"><g ><g ><path d="M471.469,84.155l-47.75-79.22C421.874,1.873,418.56,0,414.985,0s-6.89,1.873-8.735,4.934l-47.75,79.22 c-0.958,1.589-1.465,3.41-1.465,5.265v42.977H314.13V89.419c0-1.875-0.516-3.713-1.492-5.312l-48.329-79.22 C262.457,1.851,259.157,0,255.602,0c-0.008,0-0.016,0-0.023,0c-3.565,0.008-6.865,1.877-8.708,4.928l-47.821,79.22 c-0.96,1.591-1.468,3.414-1.468,5.271v42.977h-42.616V89.419c0-1.855-0.506-3.676-1.465-5.265l-47.749-79.22 C103.906,1.873,100.592,0,97.017,0s-6.89,1.873-8.735,4.934l-47.751,79.22c-0.958,1.589-1.465,3.41-1.465,5.265v412.381 c0,5.632,4.566,10.199,10.199,10.199h95.499c5.633,0,10.199-4.567,10.199-10.199v-61.426h42.616v61.426 c0,5.632,4.566,10.199,10.199,10.199h96.15c5.633,0,10.199-4.567,10.199-10.199v-61.426h42.906v61.426 c0,5.632,4.566,10.199,10.199,10.199h95.498c5.633,0,10.199-4.567,10.199-10.199V89.419 C472.932,87.564,472.427,85.743,471.469,84.155z M134.568,491.602L134.568,491.602H59.467V92.256l37.55-62.3l37.55,62.3V491.602z M197.581,419.977h-42.616v-52.311h42.616V419.977z M197.581,347.269h-42.616V225.504h42.616V347.269z M197.581,205.106h-42.616 v-52.311h42.616V205.106z M293.731,491.602H217.98V92.259l37.668-62.401l38.084,62.426V491.602z M357.036,419.977H314.13v-52.311 h42.906V419.977z M357.036,347.269H314.13V225.504h42.906V347.269z M357.036,205.106H314.13v-52.311h42.906V205.106z M452.534,491.602h-75.1V92.256l37.55-62.3l37.549,62.299V491.602z" /></g></g></svg>';
        createAltaMarkers();
        createCSSClasses();
        if (tf.js.GetFunctionOrNull(settings.onLoaded)) { setTimeout(function reportOnLoaded() { settings.onLoaded(theThis); }, 0); }
    }
    function createAltaMarkers() {
        var ls = tf.TFMap.LayoutSettings;
        var altaLargeImageNamePrefix = "Alta.Icon.Square.18px.";
        var altaSmallImageNamePrefix = "ALTA-Balloon.tiny.";
        var altaDirections = ["N", "NE", "E", "SE", "S", "SW", "W", "NW"], nAltaDirections = altaDirections.length;
        var altaAngles = [-90, -45, 0, 45, 90, 135, 180, 225];
        var altaImageNameSuffix = ".png";
        var toRad = Math.PI / 180;
        var baseStyleSettings = { iconShadow: true, iconAnchor: [0.5, 0.5], bottomMargin: 0, circleRadius: undefined, circleFill: undefined };
        var smallCanvasDim = ls.altaSmallCanvasDim, largeCanvasDim = ls.altaLargeCanvasDim;
        var hoverAdd = 4;
        var touchAdd = 6;
        var baseSmallStyleSettings = {
            circleRadius: (smallCanvasDim + touchAdd) / 2,
            circleFill: "rgba(255,255,255,0.1)",
            sizeCanvas: [smallCanvasDim + touchAdd, smallCanvasDim + touchAdd],
            sizeImage: [smallCanvasDim - 1, smallCanvasDim - 1],
            imageToPaint: arrowSmallRightImage
        };
        var baseLargeStyleSettings = {
            circleRadius: (largeCanvasDim + touchAdd) / 2,
            circleFill: "rgba(255,255,255,0.1)",
            sizeCanvas: [largeCanvasDim + touchAdd, largeCanvasDim + touchAdd],
            sizeImage: [largeCanvasDim - 1, largeCanvasDim - 1],
            imageToPaint: arrowSquareRightImage
        };
        altaMarkerStyles = {};
        for (var i = 0; i < nAltaDirections; ++i) {
            var altaDirection = altaDirections[i];
            var angleDeg = altaAngles[i], angle = angleDeg * toRad;
            var largeImageName = altaLargeImageNamePrefix + altaDirection + altaImageNameSuffix;
            var smallImageName = altaSmallImageNamePrefix + altaDirection + altaImageNameSuffix;
            var smallStyleSettings = tf.js.ShallowMerge(baseStyleSettings, baseSmallStyleSettings);
            var largeStyleSettings = tf.js.ShallowMerge(baseStyleSettings, baseLargeStyleSettings);
            var smallStyleSettingsHover = tf.js.ShallowMerge(smallStyleSettings);
            var largeStyleSettingsHover = tf.js.ShallowMerge(largeStyleSettings);
            smallStyleSettingsHover.sizeCanvas = [smallStyleSettingsHover.sizeCanvas[0] + hoverAdd, smallStyleSettingsHover.sizeCanvas[1] + hoverAdd];
            smallStyleSettingsHover.sizeImage = [smallStyleSettingsHover.sizeImage[0] + hoverAdd, smallStyleSettingsHover.sizeImage[1] + hoverAdd];
            largeStyleSettingsHover.sizeCanvas = [largeStyleSettingsHover.sizeCanvas[0] + hoverAdd, largeStyleSettingsHover.sizeCanvas[1] + hoverAdd];
            largeStyleSettingsHover.sizeImage = [largeStyleSettingsHover.sizeImage[0] + hoverAdd, largeStyleSettingsHover.sizeImage[1] + hoverAdd];
            altaMarkerStyles[smallImageName] = { name: smallImageName, angle: angle, angleDeg: angleDeg, styleSettings: smallStyleSettings, hoverSettings: smallStyleSettingsHover };
            altaMarkerStyles[largeImageName] = { name: largeImageName, angle: angle, angleDeg: angleDeg, styleSettings: largeStyleSettings, hoverSettings: largeStyleSettingsHover };
        }
    }
    function createDirectionStepsSVGs() {
        var aheadDirectionSVG = '<svg xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="enable-background:new 0 0 493.353 493.352;" viewBox="0 0 493.353 493.352" height="493.352px" width="493.353px" y="0px" x="0px" version="1.1"><path d="m 280.67541,490.7864 c 5.18209,-15.93359 1.64794,-33.17014 2.568,-49.75618 0,-104.37428 0,-208.74855 0,-313.12282 23.31063,-3.60326 53.14368,7.39213 72.44513,-5.85076 C 355.9896,108.75392 341.96497,101.66876 334.73763,91.849905 307.39022,62.184403 280.04282,32.518901 252.69541,2.8533988 238.55186,-5.5406649 230.55338,14.818517 221.09328,22.801927 193.84466,52.697751 166.59603,82.593576 139.34741,112.4894 c -8.49444,17.99737 16.96577,15.99433 28.44383,15.419 14.12005,0 28.24011,0 42.36017,0 0,118.77167 0,237.54333 0,356.315 9.35248,18.04925 37.08404,5.34374 54.42902,9.19141 5.27061,-0.72455 11.76942,1.12842 16.09498,-2.62841 z" /><g id="g7727" /></svg>';
        var turnRightDirectionSVG = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="502.049px" height="502.049px" viewBox="0 0 502.049 502.049" style="enable-background:new 0 0 502.049 502.049;" xml:space="preserve"> <g> <polygon points="420.692,74.923 290.938,0 290.938,37.359 81.356,37.359 81.356,502.049 156.486,502.049 156.486,112.49  290.938,112.49 290.938,149.849 "/> </g> </svg>';
        var turnRightSlightDirectionSVG = '<svg xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="enable-background:new 0 0 494.221 494.221;" viewBox="0 0 494.221 494.221" height="494.221px" width="494.221px" y="0px" x="0px" version="1.1"><path d="m 175.84853,495.02314 c 0,-90.893 0,-181.786 0,-272.679 37.34575,-35.00175 74.6915,-70.00351 112.03725,-105.00526 17.77104,16.33281 35.54208,32.66563 53.31312,48.99844 C 350.42727,110.19349 359.65565,54.049669 368.88402,-2.0941565 309.40113,8.8662707 249.91824,19.826698 190.43535,30.787125 204.7165,42.233902 218.99766,53.680679 233.27881,65.127456 185.43132,107.43969 137.58383,149.75193 89.73634,192.06416 c 0,101.417 0,202.834 0,304.251 28.70406,-0.43067 57.40813,-0.86135 86.11219,-1.29202 z" /><g id="g5976" /></svg>';
        var turnRightSharpDirectionSVG = '<svg xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="enable-background:new 0 0 494.221 494.221;" viewBox="0 0 494.221 494.221" height="494.221px" width="494.221px" y="0px" x="0px" version="1.1"><path d="m 172.61536,491.93915 -88.981338,0 L 85.114594,4.4108408 358.39118,216.25447 l 49.2229,-43.50647 2.96158,148.93 -161.40175,-0.96438 46.16514,-44.3922 -120.73678,-97.52933 z" style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.31939518px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" /></svg>';
        var turnLeftDirectionSVG = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="502.049px" height="502.049px" viewBox="0 0 502.049 502.049" style="enable-background:new 0 0 502.049 502.049;" xml:space="preserve"> <g> <polygon points="81.356,74.923 211.11,0 211.11,37.359 420.692,37.359 420.692,502.049 345.562,502.049 345.562,112.49  211.11,112.49 211.11,149.849"/> </g> </svg>';
        var turnLeftSlightDirectionSVG = '<svg xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="enable-background:new 0 0 494.221 494.221;" viewBox="0 0 494.221 494.221" height="494.221px" width="494.221px" y="0px" x="0px" version="1.1"><path d="m 293.754,494.221 0,-272.679 L 196.00525,118.21774 149.49134,168.01609 125.337,0 281.02749,30.203849 243.648,65.187 368.884,189.97 l 0,304.251 z" transform="matrix(1.1461758,0.01719715,0,1,-53.921896,-4.2495957)" /></svg>';
        var turnLeftSharpDirectionSVG = '<svg xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="enable-background:new 0 0 494.221 494.221;" viewBox="0 0 494.221 494.221" height="494.221px" width="494.221px" y="0px" x="0px" version="1.1"><path d="m 321.60564,491.93915 88.98134,0 L 409.10641,4.4108408 135.82982,216.25447 86.606925,172.748 l -2.96158,148.93 161.401745,-0.96438 -46.16514,-44.3922 120.73678,-97.52933 z" style="fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1.31939518px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" /></svg>';
        var uTurnDirectionSVG = '<svg xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="enable-background:new 0 0 495.002 495.002;" viewBox="0 0 495.002 495.002" y="0px" x="0px" version="1.1"><path d="m 467.73329,207.77586 c -19.04538,-0.77757 -54.63394,0.0643 -77.80829,-0.50786 l 0,-43.182 C 389.925,73.605 316.319,0 225.838,0 135.357,0 61.751,73.605 61.751,164.087 l 0,330.915 83.319,0 0,-330.915 c 0,-44.532 36.226,-80.767 80.768,-80.767 44.54,0 80.765,36.234 80.765,80.767 l 0,43.182 c -8.76231,0.65024 -56.72081,0.95691 -75.17046,1.03223 C 265.79536,250.5871 331.3256,330.71396 348.264,354.237 387.14667,306.35389 429.74251,252.29518 467.73329,207.77586 Z" /></svg>';
        var circularArrowsDirectionSVG = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 297.249 297.249" style="enable-background:new 0 0 297.249 297.249;" xml:space="preserve"> <g> <path d="M67.851,120.957H53.267c8.152-28,28.685-51.807,55.359-63.768L95.645,27.605c-38.193,16.976-66.903,51.352-75.728,93.352H0 l33.435,55.413L67.851,120.957z"/> <path d="M175.624,53.268c28,8.152,52.14,28.685,64.101,55.359l29.418-12.981c-16.976-38.193-51.519-66.903-93.519-75.728V0 l-55.413,33.436l55.413,34.414V53.268z"/> <path d="M263.813,120.544l-34.414,55.413h14.582c-8.152,28-28.685,51.973-55.359,63.934l12.982,29.502 c38.193-16.975,66.903-51.435,75.727-93.435h19.918L263.813,120.544z"/> <path d="M120.624,243.981c-28-8.152-51.639-28.685-63.6-55.358l-29.668,12.98c16.976,38.193,51.268,66.903,93.268,75.727v19.918 l55.414-33.436l-55.414-34.415V243.981z"/> </g> </svg>';
        directionStepsSVGs = [
            aheadDirectionSVG,      // no turn
            aheadDirectionSVG,      // straight
            turnRightSlightDirectionSVG,    // slight right turn
            turnRightDirectionSVG,  // right turn
            turnRightSharpDirectionSVG, // sharp right turn
            uTurnDirectionSVG,  // uturn
            turnLeftSharpDirectionSVG,  // sharp left turn
            turnLeftDirectionSVG,   // left turn
            turnLeftSlightDirectionSVG, // slight left turn
            aheadDirectionSVG,  // reach via location
            aheadDirectionSVG,  // head on
            circularArrowsDirectionSVG, // enter round about
            circularArrowsDirectionSVG, // leave round about
            circularArrowsDirectionSVG, // stay in round about
            aheadDirectionSVG,  // start at end of street
            aheadDirectionSVG,  // leave against allowed direction
            aheadDirectionSVG   // enter against allowed direction
        ];
    }
    function createImages() {
        createDirectionStepsSVGs();
        var redMarkerData = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIgogICB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgdmVyc2lvbj0iMS4xIgogICBpZD0ic3ZnNTI5MSIKICAgdmlld0JveD0iMCAwIDY4MS40Mjg1NyA2ODEuNDI4NTciCiAgIGhlaWdodD0iMTkyLjMxNDI5bW0iCiAgIHdpZHRoPSIxOTIuMzE0MjltbSI+CiAgPGRlZnMKICAgICBpZD0iZGVmczUyOTMiIC8+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNTI5NiI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgICA8ZGM6dGl0bGU+PC9kYzp0aXRsZT4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNTcuODU3MTQ3LC0yMTMuMDc2NDgpIgogICAgIGlkPSJsYXllcjEiPgogICAgPGNpcmNsZQogICAgICAgcj0iMzE1LjcxNDI5IgogICAgICAgY3k9IjU1My43OTA3NyIKICAgICAgIGN4PSIzOTguNTcxNDQiCiAgICAgICBpZD0icGF0aDU4MzkiCiAgICAgICBzdHlsZT0iZmlsbDojZmYwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojODg4ODg4O3N0cm9rZS13aWR0aDo1MDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIiAvPgogICAgPHJlY3QKICAgICAgIHk9IjQxMy43OTA3NyIKICAgICAgIHg9IjI1OC41NzE0NCIKICAgICAgIGhlaWdodD0iMjgwIgogICAgICAgd2lkdGg9IjI4MCIKICAgICAgIGlkPSJyZWN0NTg0MyIKICAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjUwO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiIC8+CiAgPC9nPgo8L3N2Zz4K';
        loadingData = 'data:image/gif;base64,R0lGODlhlgCWAOZqAJWVlZ2dnaampq6urre3t7+/v8jIyNDQ0OHh4dnZ2erq6vLy8v39/enp6f7+/vz8/Pj4+NjY2M7OzrOzs7y8vPr6+vX19fPz8/v7+/b29qmpqdfX1/Hx8d/f38bGxsXFxeDg4MTExO7u7uvr6/Dw8LW1tdbW1peXl6SkpMfHx6GhofT09OTk5M/Pz+bm5qurq/f39/n5+bS0tL6+vqysrL29ve/v79ra2qCgoOjo6JycnJqamtPT0+zs7KqqqpiYmKOjo62traWlpe3t7Zubm7a2ttzc3KKiouXl5dXV1c3NzePj45mZmcnJybKysufn57u7u8vLy97e3sHBwdTU1NLS0uLi4tvb29HR0crKyt3d3bq6uri4uMDAwMPDw8zMzLCwsMLCwpaWlrm5uZ6enrGxsZ+fn6+vr6enp6ioqP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQJAABqACwAAAAAlgCWAEAH/4BqgoOEhYaHiImKi4UPORsSEhs5D4yWl5iZmpucixc7AKGio6SiOxedqaqrnkdEAbCxsrMnIYwspbmkLJsZHAvAHBcYrMWsMyezyrE6RE/GxTErFxcZldDY2drb3KoZLygC4uPk5EJoJN3q2DYNCu/wORzGGAQq5fgCR2AQ6/7QGC6QIDHsn8GDCBMqXHjQBZgBECNKnDhABMOLqhiwAIGgo0cEIFxcO0RFA8WJGlpgXLkKQg8XLFwMicGyps2bOHNmusClCIGfQIMCLTFCJ0IICSIkWMp0aYQrxIqJ2DJBKFAZBBoYZWiBxZWlV5DA2Eq2rLYbFAqoXct2bRcLK/8hVDlAt67dAxKQmMXkIgQUCjVm1AB8YKwmDh4MKF7MWLGHeZwsWIlgIoKWHgz21nSRJYSHzx5CZHGhubQlDBN0lZoQ1fQ/BEBO6FhG5AQUmowkqN4NQILrbluYLBsOawdpSwyUkNFFRknmTQ+ASZ+e4bciF2WY/NhBpNmOEziaVLC+UomKcPlQ4PDwnLxpKUfyyRegIol7YzDcwdvfoF+2CzekMJgHCaRz34EI3ueABD7QcBINGmQxUoILOcCAA4xQ8cJJHGogBYUGWcDRRx+BsAImDMTQHogstpggA1hMUIJVJTiRxXguqrJCA0ss0UB10PQwo1VETqBXjpisoFT/U01FEAGQSEZ5kBQUzNCWWhR4cKJNDiCBVwt0RRIBXAmOkNaVbdUQxYqXsGCAZ6CFYAAvnFwhwV13tYCKlKks4EEKjTWWggcL8Gnoof8kgYIuKNiHKEtP8JbLM49qokAWRUAIRg0RGHZJC5LqolKlilwgxA7EySJGFowsAEqoo+xQKCcYshjCD6kqowMZNjASwwCwDoAbJg5cMJ10HAzrXhLJ5CoLEWkoi0kFMMCAY0u/HHsBm+7dwF2uJ5zhH6k1MZDBCtKSa8wKWJSggTgaTCABZOoyZAMa6M0ngBAo5FCvIQwsMII7PWxrTALx6VsODlj8K4gF+u33zo+sPCAD/xAKj4OCsA4/3EDECnzsaTE9lIFDvuMIgUMQx3Xs8sswxxwzBDd4wQVWU4wps0ENOMihRC/QuTMjHCDQgUdH73lIFD78TJEPjg6NCAlHk+gRCL0aUkEITTsN0QsF1Co1IheMaDWZihjh7gs0BEHDC/EmMPbcdNdtN4gVsGCCBFFUgcC4d0PTgAw+EQnUBAi8jEEHlTVpAgLccgJCVYYLNcEGHSuwAZNMbmARKwk4UfnhB7x8gZOcO4m2MQ904MEYPm0RwhXpBm47uRAgIEEKH6SQxBBlOfDAhBQ+YEANaLIFhRU1kXAnnmEaIbZ7PJyZ/FozfE5rBRVMv8kFYEJfl/8EHSSoAPLXU/BF5IqM0HugivFe1CZIKAG9BFQAziIDF6qyxAfwa8wHlnA7VojgTwEclPYKWIwHcGAEI+AA8RjICppBQQMoQIEGoHAD/VFwExUYg6TGcK0PYsILsAqFF0yICS6kUBRcsBsGKsC+RXTghaMo385IAAUdnIAJ3NnBD34gAB54LxFZwKEoWBUzKwQAVakSAxcmaAgtKDEUWohZCJrlLB2YYYGIkIESZcCJCljgAiuAQQ1dkwBcOSsWO/BBCRFRgxfWYBMQyNZ0LnDE3wTnjbIwjiUykBreTABKmIjOsaSDSPKEwY2AnA3wMGGBJBQBCDvYARCKkITVaaL/WItcAAc8+BsS4GA2gDxBF2riAAvo8RetOZANVPAKZ4khDDrpY4I2EADhLMOHZVAaCzXBgA4U4AX8EoATJGCgYTpTG8UagQI4sMZnLuIGL8ABEITATSEAAQcaoIIurWkIE6hACArDgRJ2xgAMYKCam/DAPTJGnxqM81EPGMLHJpYDEcDTEi7AGD3FcYQsOqwCIIOHO2LZiQ0kbKA4GNW/diQxhXqSE0NA50AFgIIj/YsBA6toAzBTjAjgAKKle9kKQvYxdzRyFSKgwUPzcYQ0aIWcg8yCD1SggiMcgaca8IAwcUrUohr1qEhNqlI3kaJ/KlVtGmCb2+A2AbkttRAl//FaSkzoEpjIpHaD2FrXvAa2e0ptBWYj0UsFoSGvScRDtxOR1a62pUIwza0RgdrtqDbXjmDtEEh4CF4hAsa6aaSvIaGiGnqGVx8I7XZFq5rRrDBUQyyoQQ+KkGJtZyGzGgIpNsPZBi561dKa9rSoTa1qVxs4BBRABhOQAWwnQIErOBWnSRBd5ZygBM8iqgJLoMwGNlAZJGx2Ewag3OhKMIXjIsoFJuDcUkxw01W4QLmjI8AEDPovEWxOukvZQGU3YQXsjm4CN+hYD74LXhNkTRUVKMCQRleEMZC2UgyQAns7hwDf+qoLWKlcCaBwX3KJIAIbcJKTNkcvY5DAC7EtXPoRYFsABUgNAzDIAEO3kQEbkAAG/mWtiEfMjaaSmAVeAMwMVgyYFhT4IitAQAKoQAUjkBREDbAemigQBecehAX2wxP+RuYeBeg4eWq6bTfsJD66tGBW96nCkZOXvZWAr8lh+tCBrjBlNL0lMlLAghKUgAUpvFgRcsEyXjzqngc0AX3Xg8JjL9GBEABKUCHQoSac12QJGAFEIKgSmqCQgjMDDAuJCaABPIAFJQ8iB19qQQsikQAiJyh3B2jCB5pggvltwgUAVLRiPtAyWj3A0f96gpxE/SZKXZUBPAh1AD/AA1QP0wqeCVRomLfaDCyBCpKmwhLWSuJiuygQACH5BAkAAGoALAAAAACWAJYAQAf/gGqCg4SFhoeIiYqLjI2Oj5CRkpOUhUonAZmam5wBJ1+VoaKjiQc4AqipqqooPheNBZidsycFjEMnALq7vL27tqTBjyRpKKvHqCofwpJlvs+9LMzT1NXW14smGgPc3d7eGhLY48IPC+foCxcMwg0DQd/fQS8g5PbCDg8PDvf9/v8AAwq8RsLEBAIIEypMOKHFwIehYDRQQLGiggYQ+CGKEeLgQoZdMkAcGQpDhhUwHpBcybKly5eMNlAoQLOmTZoUsMD8J6IDgp9Af3YgwQxBjRo3CxyVsnNgDBsjRpCo0LSqVWYwsqQwwLWrVwMftJBsYCKB2bNnI9ygerWRAxcS/zx8mNtkwwpKUiQc2Mu3r4QOoSpcEGEDRtuVDFxQaSFBQgsqT9gdnrxoiIAfszT9EDCEsj8TaVQYUwUEBwEbjmJoIJI5MxENMRo1gdZLiAjPgxoIEIKs9xEKkCrwCEKEyY8fTIgEocK2kTPa0F3gJvSkBpojOLIDGSDB8MoWTKAPuD0SghcNNOIF0TDj7nTPDii8iEd/AA0Czd+PWpEunQVrDJCQQw42qKTfgQgiCEMKE5SwUAlOePFKgm2B4IEMH2VYwhSSUWiPCBNZRFEDNsTm4YkopghJBkpAgVRNNUCRxYQqhvIABBAYyAwWMyV1Uw1R1BhJAyAEFRQIIwippP8/GGwQggdepRCCAUm2xEAON2yg5QYd0JggFR98JeYHnUmSGA+NNcYDEh1GYkEEEaCF1gbSLBlKB3r1pedfdvbp5zgM3OCEGccdZ4YTN7T550BeyNKaJid4segkEDxxRQJIkKCjIxW8sMOjnRDhQ36LWGCAEL3oUIIVFN6gAm+9JVOGd4tE4SiomZyQBSMN/ACdLzNMx4EGsMaqigopOJIDEJi19sMROTQCxa/QnEDeZAw4MZqxqagQQUBfUPsMEBBM50AIOBR7zBFoSPeQB+LqogIHk5IEQwdYGPBFBD1o5FIFSFSRRRZYWFFuvSPxsE193WgACsKIMABBBhnE4O//KA9skR7D3gRRwsEQq+HABf2h494oVvjAMTg3hFyIBRykw4FI07BQAnrwcEODBhOI5fLPQAct9NCIYDDEEld0MAKpRI9ThRMZKjRBkE07MvJFDTQwwsmHRDCFg1ErVAQFIFd9CAMjhChiAz38dwgJBBQRdkIlNGA2IwJa1EAO9DLCQAddlCDDBA0WcAUGdyeu+OKMn8iABSKIYIGijQtTBRQ+1kSBEhe7nIEVPgHVwRJlh8KABzNkbtMMIZRe7wMsGGkkC5RPEsMHL2Y+QxhuA91D6EF1cC0zaN/AAxVGKLBp5cy7jIEILrDQANfNkzLCB1uJydUHWNQeEAtlyZkA/5y967eAB9lrv70JJLGwgfhpJUAzgjdMqT2UfUcihRJ68qUEU5N4AAJMECezROB9REkcBpLQPz21IAmIq54oOsC/BioBMBLM4GEcIAItJCEJWhBB5zQ4CQ6UADk62IQOjFOC/JHwERl4wQ/I8Cgy/OAF83vhIkRghhTiKgA6MEOZdKiIEjDhh5pgggwk8YAcbOAAPOhA+TxEgigMAAhHOAIQBFCEBESwETBAA2uQGAAioCGHioiAGaDDBepNRwI42NYxVECDIS5CBkckIxMm0AgJxAsAZ3zPBV4gx1jhgGqLGAEQkZjCKimiCH/UhRii5RkGyGCL3OrWFRpxATTk8f9RTECDlxBxgEjuQghMs4oCdpPJVPzmEUM4wwk+xYkdnOAMPXCEE0y5iyd4Zljq4pYymNiADXzhCxtowPIYsQVeAkAMdjxMFE7RSiGgATUAaYAzgTOdKlDTWEAIwij9sQRTEuBADPgCEF61ChTgAAyUhEgBxGWGeCLIASS4AhYeyALXjUQEFAhAL07ggwh4j4gITRwDElCEF2jABz7QwAtkAMGEPoIB5+GYBqDgT4sSYgFlyNnKxiM0wcSMAxy4wDIrEYb5jHQAL6DAQf+UgZj1hwO0CgwXNjbSIEwgpwgbWcnOsYIRTqIJKnvpCyQFtBjYVGapDCAUXMoxGhSho/X/cgAESKYOrFbCCDTg6Td2lgSPPgICSdgCGMJ6Bi5gYYpmjatc50rXutr1rngdxd8CN7jC3eCLeVUDRzySoQkUAI3VewAMLJASvBVBbnMjQN0yKCC17c2FhQBBCjAUWcl2YaZmA5GIRlSirn2ts3EjW/PQpja9te1tBkHtBHRSPYmM9iIwMKognhbZqWnwalmbyAV0SwgYGKBBD3JCCMYZ2AcMAQFJGwFgA0vd6lr3utjNrnaDxoAlRKELM5hBF7KAgOnmFQIG6FFSKBACN7qsAiNYwk+WsDRmDCF3qqOAPUOGgSUUyUggYMFKJeGAKOBXdx4Y8J/eIjuggMCXejVA/+pUR5MZfMBEIWNA7Br8EyQQFxJLwByFCwAFn/3MAv+VHQiAGoonUGDCPoLCEobGQQSA4MZFwuY0RpAFCvj4x1TarpCHTOQiB4QBSFCCB0LAZAOYgLkkqQAJRiCCFYAWNxGwn5jQl0CSYAAEBJxTBIZ3IDCprytkIskK4AS/BGxgxgg635nRzL6RLOF9bSafgrQyZ7CYWBJS3psNouoIsrR5fH9NUA+wd+YPVOHKhsDADZTQgr60QAmJngQSwienOCH2PQ/IMvq6IqUmOBISJMhTAw8ggS5HggENyNIGCIgAuFLoASR4ggtG8GlHMMAElV71AVpgAkgn9NfBXnULNiLw4bimWtisxixeMXAFSltaCUZQ8LRJoIARcMC8Rg43ggIBACH5BAkAAGoALAAAAACWAJYAQAf/gGqCg4SFhoeIiYqLjI2Oj5CRkpOUhRBBKAKam5ycKEEQlaKjpIkQJTQDqqusqxpJjhc+mZ21KD4LjR8nAb2+v8A6KhylxZFJGq3KAzROF8aSCjo6wNW+JzXQ2tvc3YsVIjk5IhjQFTUlBOrr7OpFYxbe8qMjYgD3+Pn6+EzElVRO2rVzIsHBvIOVhjDZxxCfjmcII0qcSLGixW4ZvMwowLGjR45T4l0cScoChwUoUXIQqWhEFwofOdYo0ICkTWMGb+rcybOnz0kQmqQwQLSo0RQecv2kyGBEAwVQozbowQAaAyMfPqTYmuJDiAgVltpkUKFCVbFo03ZDIuGA27dw/w9UCXXzwRIEePPmBWFDbSQGPbRsMBFhCUtJMCJESMC4MWPFMEgxyOmXJwMRVrR0WCLibOXPjowIUFFLE2kjoCs+qAJGwwsaNF748EGh5qMIpEvrVhHBUYwtJ3ZY03FChZTUhlK8WMY8iO1HD0B4kaFKhhcQDyA9EW6tewAmXJAfIlGFQokJXEJcobvzgZIjJ5gQmb8j+IQcPEl4mSCjiLvzBYwgnjYkqNDQPiisIAoLEwjkIAETHDegKBIcaCEAsEyYGhIT2KPPCQQ8p+GI0JAQBQUU1DBDDSg2IQKJyOUAU0wxUeACjBRhkNKOKGWH449ABinKAjx4EEJWWR3wov+Qai3gwVBGRWnABwIyGUkFT0UllQLlWOllRRkkIIEELRzQQlsuUMbTAyK4wAISDRwG4wVlxgWXBFdUgsEIHRhhBAgjdEkJn3oVGsOXpECQwGKONbYYe4hGKulBDrBgQBFnnFFEEyyoOalNF9AAhG6cAEGDgp9W8kBYlOBGamm8RQLBDTOckcYLJUShwI8PhJEMcwME8cISjsCAyaue0BAZI1nw4p0vO6CglHgH/ArsKkGA4U8jEaBwhG5HoNBbIzaYQc2zwPzgxYAg+HAtKzRw4SNFFWjAHbrXZDjgChRY2woNPug7UgUTOOsdETtokapPD2QQg6c+OZABCTZY4Nn/wolcMMaBJxSQQSkQFCDDg+qUsAWqGKsRwYUMdVAJAg2SzM4EN6ScBcsNVUGJAymMLDMBJUwxb6oZ6ICzPjgcOgoCM8jAn9MTUGAExCl3cXQKKWet9dZcM7Lq0F2DGcJMNBZQwxQoh/0XBCu0DQHVhIAwY9kdUeCy2o9AcBKPC3DAKiJJzF02BTzg/dcFe/e9wsWKYMDCASmEkMIBS/xt+OWYZ6755pxvk0EWHkhJlAcekGC4BQo0oPpTHxvjwgeiRxkCAmGvkKWWUMVpTAMhxE5UCFbg/cAQquc+DuPQxLDCAst27jznDDwA9/PFGNGWnW5JYPpOFSwBQqEIdLAk/4wdXI999hDZBAH4eoGwK44QUGE+XEqwQMmsGzSawAY3QCorCx34HgJAAIIhTE9tPTCB/hxjgh5QzxxGyF+jNnAFpT3wghOCgAJYwAIF+A+DpFDAGICgAiCgAAUkBAIXRATCSSDghK86Ie1aKIks4ABZm8BBFGgICReMCoebAAISKEEWywlpARsIwxa4UIMssAB5i+BBboA4msI5wgFUQMMPfrADhDHhBDqAwvhGBIEpaCAIy3hBEFDjCBZ8i4oCOIL9vMYFMaBrBzqY4YQi4C/m0EAGrWNEE24IRBw0oREiMBe+enGCKUzICst5lypesAUoHkIKJozhEdi4CAy84P9eizzBBgakHElii4WLcEEJVFDCE5JQBSW4kSNyAMpFgmdA1TKlKsCwPUkwAAYZsOQiRECGcy0yAD9wpHhgIAM0SlIDWBhJGAyGLx2YoS8DwsAM+tiKIPhAYSTZxSJ3oIIxDggCURiAa4IQhNhooAh6tIkFSnACInTnB2RIgJAYAAEYGLEnC6hCEdIgBAEEwQvx5KFCheSCGaDAQycQwBRQSYoHdOADYyhCEbjghQqqTQFAYFkazEkJEWzBZwKRARfwozUGnOFo9yjBKDYQkJ9N4ABZc4APYIoPJ1RiBOn4mTomMESMJYGn+eBkJDoQM6FOYFwL8wBS8dECSiyAC/7/EWoJHIixDkz1HkWdRA5QSrIJJDRVNZjqB0bBgCpMIKjsKIETlPDPhVUIpiYwRgVYQIUoRIEHVvjg1gzgoYb8QAIL/akEoOCEqB1gCImNrGQnS9nKWlZDDHgCD5rggSZgAQmCuqwihjAFwdWtAO9b6AELsQEo0I0jUKACDRmAuJRwYHGKaIBpB/cEEOqIbz1KhNxe2xEo3O2CegOu3xJhgTBshLhdkBP1TMKjlSwiI2Sj0QymkD4Q/nIFF1jB2xwhgiagaAboRVEKuCpaR2AgBqFtr3znS9/62ve++M0vI0gghQ1EQApU0e8ghjAlKBWFdCw1HAZWQAISrABspbhB/+989wEerPZTFiieVBrQPFL0IHS++50suQaD2+GuAYIVK+xCbIAQEKtrGcadVALJ1gOAOHYeiEJdU2YDE0MlB9sqhQMkbGCjhIAKwkwZAxbglAaM4AJJFsUQkhAFA3ggCzygqIC3zOUuezktgDGCCagQAStIl2EXPqf8sFc/n0AAgHsBQQ/SXBk6nS97NdsJodiHgBQjp3x3dksLujuS9fF5gKkdkQvmh725jAID8Z2EXQ7Nlx9pgdF36mUkLCBmxSjGBEY4syO6J0C9iC9IMLjBmFrAajRVwgoS1N8GXkyJB9jgCW9SAI2ZFD06J0IEClwgY0yAzfvaINjC3kCx7yLLAmQ3ygRz1C8EOmAC/0ZgMFLosIAhMIQnjMPPXw53kAIBACH5BAkAAGoALAAAAACWAJYAQAf/gGqCg4SFhoeIiYqLjI2Oj5CRkpOUhjcaA5mam5saCZWgoaKLUhMEp6ippyUFFY8RmJyyGhGOFy8oArq7vLw4LaPBkjEFMqrHE0bClB44vc+6KGg2y9XW19jZjSwUBd7f4N5QytrloF0nAerr7O0BJ02hEAbd4d4UISvm+5VZ6e4AT2DhR7CgwYMIEya6IOVAFCwgLCzCYCWEgYsYMxoI0UGhR0lFAIgcSbIkyS1PDFnx4CFFRg8fOn6cCamFyZskqdDcybOnz5+GWEg4QLSoUQkIgCKMwWGB06ccXFWDYKSFhKtXr2RQyrWr16+VKtyIkKCsWbMmGvC80ECB27cK/xqMYAAWkoMMNkQskFqpBwgEgAMD7tCjrmFID1bYsLHiweHHixzwoOFDlg8aVehCJhgjQoESEyaUGGNAQaQHBGjIWj2ABgHHjhaMwQGkFwoVAjZsJiSiyLHfBGREmeTARgcTSTrYcCBpxhFo0AUIybG7kAUXRiJIGQK7JwQsZ1DgGK8CTQ3qPUVEqUGhfXsDaqsLi7BjB8B19mWCWm/P3gwPGMhHSQVoEHHffTsM0J2AXzUwhQYB1EfGCx8MweCFwojAQwoffBCCB1UUhiE/DJSA001bGGIDDx5o5KIHWDA34jUVAHHijRqYMCNXLJSwQ0lEcJHSjkRCsoARPLRwAP8PV5BQ5FdSDGXUlBLc8KQkGTT1lFMcwHDllwat0EEEG5R5Qw4L9sQABCtYwNeILGxw1lkRRCBRJQxkQAIHGWhWCQZxweVWAwuAKYpfgglGmKGMNlpOBS5Q8cUXPLjwpqMfGRELa5loYCWmCDHAhWqcbuJamo0wIEIHG9zgwlYjkrCFMb8V4UQVkMBSaie1NAKBE7hFJ50Kn25mARe+AZfKBDo98oAEL7wgS7QSoJqIAcEKu4sQGnCwGQNelKDsslYoFEG22gqAghPWGpbDFhMkiwpoElya0BMaPAedEDh8AOq/ABdEQgE4nPADE0z88MMRIVwgTAM1zNCfOEkF7ID/Ez8cyA4ZJ4wBCgNN1DAxODOEEMO/MAhhoMbtEOGDvY8MIfHI9wz5rwT/sLzOD7qJwgALSkwxwwxdZAFCgAETsgIYJ+hwnw5iEHBy0lRXbfXVWE9SQRdinChGCEgf4kIILrmYQggsZL1IBmbceJMQUwvSgAQtuvjSFzCrDQMRbuN0xHCDZNBE3Xa7dKfah1TR900RhF0IAws8sQShfiK+9gCLT5C35Zx37vnnoOYg5ZQHKJF21g5AcIFTF0BQzQMmKEm6UTxs7qgDq2/51AUyjsLADaNTuUG7AFdwgZYcXOA46Mw37/xjGdQ5Z1kmIOGTBQ209VYDQ1QunwXST1/W/wZL8ESC9oLGZftjJJBJVlkRmIAA8YxcAMJfgd1fKCgZ9JB9WyTwnuV+lqhEsUCAz6vEAu4nmL84LIEQjKDaFPABMLzABz54ARhCYBoJgkIJm1qNBr7gQSzJgFSlosEEDldCRoRAWrvKxAu88LkK9GAJCGjAAyNRgRIEIYaZCEIJ4taIBySgBAI4ghKBQIMPiGBENuiCE8SFiiKIJgkITIQXYBjDF4QhZgNAl21UIAEBYcALphjXBCrWCAtM4Ie7CoIT9NGILzgjXSjwwQ4f44AP0GpcwbGeIxzQhBDOogm9W8QVxCgsIMggi14ZgrwAKQMSRgIJXRiABjCIiS64IP8SzknXtoQQn8cca5LKmgAPFOIBRkaHW07azBXSOK4SUICIBiFBGoQgSgHgAHC7UQABqPgbJ0QBkvy4QBD0JSwcrJJBKzjAGEITmhJMwQqJ/MgIyoCDXPBCCCoAghKQ2cJFQCoJSjjAFTiQzXK6U0Ac2IAXtrCFECRgj8tgQA+MQAUq3EAB9AOVEVTQNHfo4ARCKFcwWDCDeoCDPVqoWg7IsDKN7UAFTwRFBTwgspHNYAosxBQI7KMzdehAB6WcRBUcOrIaABNTDHgBSUsaACaUAE8emBnNSuYlUFkABRUtKRHSgMtcsXRiFDhAwCbABJqq4wcUCAUPoEAzCnyBnFf/IgEOnCZUAfSUf0qAQke9UQMoNGF/SatAGXJ2oBNsAat2wYsILABXR0EgDAclAld1sIMTkKEJAX0nImIgAhc8wQbrE6xiF8vYxjr2sY5wQRF+RBIdjAE9jMDdCJBAOQnC4AyZ29xKPlA2A3DoAyBIoAQWR5IkGCIDWSDci5oQ0s7xgLUluUF3SMAiu70kRqCrAApwS5IcDWJusrWbB/AGOhhQlrgA+NsgKoAAi/j2IhxpnomgC4AxfJIQSCBb4UJQvuaxDboocN0hRIAFD4SgQzAaAQQZMAHcegyyhKhADW4kBi8sD7+EOFILmtCCDtARwAhOsIIXzGDFxqBNRW2w/wuschQJLKGdVnPAAxiAYVHAAAuzK0oL8Ek1C2iJS7ASxg1kF+IWmKCuYFqB7p5SWzxtgMUh5kFgDYW7GTvlwKMYQvBIp4SUUu0BPr4AjB0BgyQM+QAS4AGQr7amDGQgBkuOhAMW4IIOSIEF7GywmMdM5jILiAEWEEEPSJBY/NqATHQywdF+koER/K8BJNixYeIkvgTUqcYJART6todWAYHvfeLbwOlocr70DarNXxELoqeXFp6sYNDbmwuGMuBn8Zlg0ZOwABJA0IEOgAAJgH4E9gbNvSx/ZQUgIJOZGuDqQcSggIJRL54gYIEM/JdzDnABrgPjgg4/NtjDBkyxGxYMgWRbIcIJvg4C7geCV5n52tgOWCAAACH5BAkAAGoALAAAAACWAJYAQAf/gGqCg4SFhoeIiYqLjI2Oj5CRkpOUhhhdJQSam5yaJV0YlaKjpIsMTTUFqqusBVBIkBghE52dEx8Pj0kaA72+v740JRClxZNPFK2tFFm5xpMXTjTA1AMaVM/Z2tvc3Y4MBx4G4+TlHl8V3uqjJGhCAvDx8vIoLxmkPQYf5eMeHg3rAoqCAObIvIMCVHAJJbChw4cQI0pUVCFDukYYqLQ4wLGjRx4XJ4qEpEBHgJMoU6oMoMPMkEMPOrSQ0KKmBAkdGI7c+QhDmR8rg/6QwYCn0aNIk44a0gJKGScUsNjIhuFKhARYs2K9SkxpwA4AwoodS5Ysi1IwXFzBeoOFBa8P/xmcKUtXrAy4ePMaswECgd+/f63o3OngwoLDiBdw6Kp3koOipB4omEy5srPGmCfFyGAxs+dIEA4UmSCjRAkZE4ocYPz5YYwlWAx4iBJBxCQptGrpntAhUoMZPny8oEHjhYYyPC63JlQlmTJlM6ZSclBhsO8g1bK/8LBcUQwIypPG0PJhjIwiMw7YVjpkQ5RxUZKM6L6NgQccKBAKQKHiS6kR+/AjYAhP0EeKCSrop98RWhjYHQc3fNHFDE1owZqDGGZDQgcbJLFBByRkGFEPQDARVEo/CBCiISRs5NGLB0ggnYjeRGDiiSf+YASNmI0QxQQ+COCDDF+8xOORosAwAv8SLCjwFpKUKFFXXTyQAkMEV2ml1QYXQOnIBlOGCcCOXir1RAFC/BAWE2iEoYBXFijA5BM2WKeUA2XGANieHcxHCgOQkQIBB4kddkGgZUamQAOVTcZoeIlGKqlDIiAQgQkdzDgpUg94kJtuBEyQAqKbStTBp6BuMgEIlVBnp4gIUDDDc1A0AQMkFcyQSaqeFPAqIku8gF121oRAams3OPccK1PcCkkGX5QwgWmmTSvBhYtwAMawxPqiQQsGNqDssgXUEMWxDT0wxjTd+uJDbxgiMAUUNcxgLwUUKLHCURu88EJ2GlDwZKkEF7wTCUo4oQE8GshwQJfGOHBDCCkImEL/CBugS3AOKLyjIDz5rVdJDgEKWE4IZxksSBU4fHzQERGMEkEIJpPzARV4qqxGDGfk5zI8QMgAKSUMiCDFBiYYMcLQOqvxRBD4HYQCDk700PTVWGet9dbPXNBFACcwQcTYTJxAxhT3JMKAEUrAeIASN2jMdSFUnIDjSickYIgCErjtkQQ5zK2IBEDdvdIPVRaSQ9t+KwGL4Ik8MMAOhqe0AxhyC+IA05Ar0kAaJ5i0kg4n+GB156inrvrqcEUhRpg/HGAMA1aYkOVWmHK+KQVi0uXFKCJsoKWWJgCkcwq91yXBKBZgOXwEGyxwtQM+JE8WGKyXogAQvWsgcvbgh0+J/wgd7IkACEuEZJQDGRB6GAcXqJ/hCH2Z/5ezPD1QaGID0zgECPUDQQdYgD/HkKABCEwgCXImigpYYAUrgEHm5rYCRjXKUf0TXykWkMAESk+DIAxh50RABQNMoQseSIKmREgJC4QBVZsoghO8kDYWRkILMNyNFGwIiR7sileeMNLqACWKG+QQVBO4giQYsIQmUIALW5iCCT7Ioyd8AAqymkENZMUDbC1CAT8EYgn85AgtDMAH1QiCBsLgxdaMoF7kgoIEJliIKzgBiARwApkaAYMSsKtbGoiZgUYwrmXV4AsMbMQKunDEUE0hg4pgwBb+2C4fIMBAzSEXK6IzCQVUIf8MsvpAFcj4CAVwq10DeEEKDJSAQi6rC5BsCAnAgEpvLY8+GEhBKjQJBSuMBAu8QGUQJlBD+lwBCrNSBgVCALGRSMEHp6SGBnxFoxUYIQsfCIEHqpCDRPLECgQQDg2CEATjDCAKbeRhLCAQA2+q8500esABG8ABd2YjBiu4QDqb5gAeaAAHQBCCQIUABBy8QG+zM8IHPuCBFDh0oRH4VcEk0LKPCQEH2CBFA2hWMwOgDGszSNDPEvKBUXCgoR01QAo+cDqVacEgIwXa4yjhgpJ1NASX1NkBKhrTI2wgSU2oWEcd2kyDucBnMRVCS1vYBHGYrKEcwNpOY4qDn5aCA1X/WKhWQ6CerX0OpvpRAQ1WCE9FXCAFGlCBCo5wBLUOQAn7LKtc50rXutr1rnj1ho+cEKQhFUkSugNfA9AQuqCQznSKiMlNajITCUhBfqzDABgKdzcy/KAE6HoC49zmuPBhIAiUq9xJmFAGb7bIbx2REfhsJFoU7VEQfEMtRwAHPsK1FiWIK0RGXOS2FoAEfCMQXWt1QIalCmJtm/WIEq5Ax7klwW6tPYEgEcEBDiUhAiAS4RBQcCMcMUEIK8rrIBYJNrERYQdlM0MYiineQ1QEsu2Nr3znS9/6YugJJThBWX7AhTfNtwDW404xGOCCS20AaRFIX9aGoCbrAYAIUR2F/wJMMDysmMAFV7OADhwsFhzEQBQXEF6FsbKB702Uw2NJgihIIOIRb4CUBcsCisUiu1YhoMVa2oAWmuulEbwOxT8IbyU4kADbYQl6ERBi08CE4gYZAwOckajKbIAD66GgqHm9ABR+XJYTFKCA9MXAARVAgsDa98wYIiKaB+GAHgDwLwME81FiYIELXCADZm6Nnux3Pv8eZVD7OxSP6Mdnv8h5Ivrb32HY6yC+FHoJUn5IYRS9mCPZoHx7Qh98IQEDG4xgBCJg9CTahxj4RZo+GVgSC+iUZ7Pm4II5wHKrNJgBC16wAaIWb60v6KhDt/cCr25UrNesBgiQYAhDIEFciQbN7GZHKhAAIfkECQAAagAsAAAAAJYAlgBAB/+AaoKDhIWGh4iJiouMjY6PkJGSk5SHSBQFmZqbmRQulaChoo09HykGqKmpH1UOkUMFM5yaNQUikBU1JQS8vb68Ex2jw5URIaqqHh63xJVaTr/RMl0VzdbX2Nnaj0MSB9/g4RIK2+WjEhoD6uvs7Bobwy4t3uASEkuu5vqgCC9B7e2CBMmxr6DBgwgTKrQGYYiJBBAjRjQxYqFFSl5UCNjIsaNHFSlgIIrBIsEGExsSsIBwseWkJ0JQeJwps4HLmzhz6hwFoQcLFiKqXSPRAYHRo0Y7MNu5TwaTAFCjSp0a4AcFYhVIjBhhIwbThDnMEKFKdQcQEl+/iuhiBoBbtyf/gtzIl/YRgxENFOjdq6DBhYtb3goeTBiAmKV1D0LgsKCxYw4sI0UpTFmIhcSYM2tmZMFEGAqgKYTZkGHzRQYccjwREVkShhSyZnGaYeCBpAYGuEzYXWJGAq+mES3wgKy4gQ8mLkaREa05gSKIg0sX9GAIiBtaXJT+esFFhw5IFtCdbu1CDQ3/2tHQEKZ1qBstwsk/0MIEA/KiKnChAbD/gBdX4UceAyuMoMAC9wmo4DYQkDAECe4teFAEQMg000YVGoFID1akJJFEEYAgoT4MTADEhSgCUYRNI2YGgQsJJHGDCxG2aCMlDEAAgW03VoKBDCeQNdUJYyQYygggIIUU/wgs9tgIAzTsIKSQTJTgZFoXJOBBDbQZsUJaFViwAgxGtoSEGJRRtsWCF+TAl1558biQBGnWKQQGV4KymGOP1RgJBEvwEN8NJIyX56GIJiqhDV3UIlsNXaClaEsPGBCbbJrQJuekjjBwxQcenGJACimE0MQQkrCACaaaUMBCJAdA45wMW9igIARZiGocKiFIMckFPDRKARQUTEHFl5HwMIFzvxQxxnbk8fDBrqtUZBECyzLbiwwhGDodA0t88UEI5KZABQc5YdDCBLv4UsQEFFjL6bz0XgRDBxKkkAUPCPgZCgRJ0CMOD8jWS0gW6fi3jgZViMJABPHNFw4Pm84LQf8J6Sm8Dg1bVCxJBlhIHM5fBgtyhQ8as+PDq83EsMIF/pYsiBQTaEBDekG8oEEJLMvs889ABy00KBc0EQQKKiQNBBgtFJxIBleYEEFEEZhww2VDM/JACUeg+NEY3rqgxdQfUm2Ex1kPksEAFnrdEQpnWGEIA1J4+OEGWuCZdiIIaOR2R0DIvTc2HbyAQ9sboYADDQgM7vjjkEeuEwReBHACETpApcMOJ5jRhN7DAFrUUSBYAW3JJOCQ+ZRSEYHC6ZM4gISSSrKAtqIWoDAW61MRkYZQoIgwOlIdyFsyCFLyHpUOOjQpOSgdHHHC6q2fIAASz2efUBh1vqWC8fgxMET/Xns10ADWFimAZveEzSBgBeS/2ZekC03APmVPKMgACX2Z34NIoWCABRbAAcZYoEyOKMH9BCMGgqTNARfgE58u4K1G8GAHdZrAAiInQAIaEIHaC6EI95aBESwBAQ2A3QhB0QMvQOFSsYCCF1C1Qko8oAmrwhQFsnC7GioCCzlkFQWw4ENcfACGmJqBB4AXiQsgQQoI6AHobNSAFnjgA6BqQgLQB4kDBFGHRIQEA5IggwkUwRclcEKkRnSFEOgqGQZAFyRe4ygdGmCKjOhAtpglAy/gUTpJmBa1jhOdRjRgCl8sABTCQA5IsGCP2pKBBwQ0nEGi4gPwoIQFGoCADjyB/4uQWI623GUr8sAgV5b8gBYuUgVIMstZoAyOAtxILQ8cAISKoUC7tOUEDSmoAkkIAXFSkQJTOM8iDlCCrJojAy7QcEQVGIILrOACCu7EASwIQwl2s5st8CCWRQynOMdJTkNUgAoT8IEGXqDOF5QgAj2kRAykMA97SKAFRgDgz2AAhYT5RwNTiKddbiAw+UhgA7jkVA8yprEggGGDoZBCQecjgRvIjAE1eEHK1vGCMITiASaImMgOwAMmzgsGE2CoxmgwBpOmaqIGFZHMQqDRjQ7AB1kYRQ5g+g0l9KxkECgCf1IGIIFCYgFGEFQLqnAF+gHNBD4YKkBoQINVltMRK//gwRicMACHQsEE+ryqWMdK1rKa9axoJQYEnqAFKiTABS5N68wMhzgBKI5xjIBASU6SkiXE7HEuQEFdaSKAYw6CbnaTyAaM8MfHdcBvf8PQEgzBocR+KETZY4AMThRZDK2oEGIjW9kSEIGzPW9tg/Ua3AQ3CAiI4CGjTQBFtBcCyEZWBR4I6yBgEDXRVu1qIWRAEbp2Wy5UkBANetBfI3eDCnktQ3IlRNEGAISkqQAIA4iC06LL3e5697vgDS95FNCFNGxOShoIQSHRugIwiIF6U9GBGEqw3EhUwCdGWcII4lqvJgRJeZYLYwCRkCQlgYAFjeWUBP4L4KokJxRPKDD/7RDgguMmqgJo2F2DdzAAoy7CBRM+CgsSmigYCEHDAN7BC/j7CBiEGAEg2C69psBgAJ+gCcMgAYxBwGMEiMDCk3JAGX5ABhuvKa03IELyhCQl1sqVA2FQwQ9+wAQmTBkIHgCneMMJASvwIAtKuMEzvXsAJtSpDHJMaxYWCAAUyHg6D7CB+cw3AhUqxAlsdosY8kfJ+JVPAQkuiBLy/BYUsBgz8JMfnJyaEPsR2i18/hZeFN2ANxskMI8+QSkHJAI/m8/OrolBDAKtiBGsL88FGBEGMmABCJDYLhdgzGNWAORDPOEEeQ7Q3lYgQcdYehEhuN8RevA4Xvd6Ab9mBJRxITCYE5zBCLUGmgNWIOvGcIDWW1bDAypQAQ9n+9vg7lEgAAAh+QQJAABqACwAAAAAlgCWAEAH/4BqgoOEhYaHiImKi4yNjo+QkZKTlIcMVR8GmpucH1UOlaGio40OWhIHqaqqLQuTHSEpnJoeISCSSFAFu7y9BRRZDKTDlRk8qKupSlbEog9RFL6+FDnN1tfY2dqQDiAbCeDh4BsdwtvnoxlbRQTt7u/tJTUVww8uESYbGyYRLBjoAElJcAIPnhMqARMqXMiwoUNs9kAgmEgRAQgW5h5qlETizICPIEOKBINEUYUhLli4GBJjo8tKLTSInKmhysubOHPq3JmIQY8GCoIKbTAiI090SFAIWMq0qdOlIpoxqFDB6FGFEnA8dSpExYarVy/w4KJBCBowH1iAnRSDw4K3cP8XXABFKUOSEkJ06BBAIEkGSCIC6AhAuLDhwwF+fFgbUAuAx5AjS5YshVGFCScQH96h4xZjhVMmi4bs5bNpRxkQHGtBBcHf0y8ZPBD1JNOs2yGqTRqS4EuKJlVY0IOtSAqyZKtaXNgoYoa05xRsEp+O6EGM4WAxZMjwj/q2EQUmlGBHoIiMCWFsEFvwTZz7Deq9k+owoaB9AhNKyt/Pv39ABwzQ5V9DDzShQRAzDRCEBlFYRcgFElVUEQgWDAgQCD4kqOELPFgIGwMxOOjhiCQ+NIIGR2zFlAoDuEIKBgoAJdRQ2JXIiBEpqrgVEC7YeNUDHCgwwgICXlXkTSGIoRn/YjsA4eJ+DFwQ11scQCBJAaONNoVlGhCx5JI/JOAjJI5laWYHk2AAQQxHjjkKDBFwkYYKKmgwRgRWuqnnnuggEIIHt9XCDJ8vPRHCbbg9QagkENwggQQtRCoBFrpFwgAWgCKqyQdYiKhIBinoIk0NFCDgHxLHIZcKDy1NYkEHVXwhAQ8dvBaJBV08Jw0FN/DHQarISdDrRgw0UYOuvVDQwIAPNHBFEjyYAMKTOFkgAQUUzKBtDVCEscSi4IbrEgMWiEACDNpwcMMGEbQbAbtRiVuIBVCUcF87MhSQpygktOdeOBv0IK8gV9R37zsTmDpKAyb8C44Jig6sxgNh2Hsw/34ptCnxOaZQMMEEMpwnwwyebWzyySinrDIjFkQQwhb2epFAhY1cYEWEFiFA7cqJuPCChiK9UGkhIuAsIQIdkMBzIhtkCLRIPmSBiAVGU0Th0ok4MMXPT3/kQwg1Yj2MAwk4ocELNARBwwsayHCF2HDHLffcD1lgIJ1HHEHnCy202kwGIzQgOFA0b9yCVjo2hYOYo1gg44xBNbCCxIcn/tQREZDCwBA5yCj4ELNJ7AAFKli+4mJ0j8KDBjgAIcTrQgCBwwvDpm57QBaUcIKXmv1ghhEWYrCAW1RmoDFDU2T25WE6qLDzdBlMGVfokEBQgpmPFbGvIi7ssLxmTEDhH/8DMKxwgQV+Q3I99pMVwUgDen1f2AlhoNwE+6NF4cgDEgBxwg87IAIRdrC7IghsZQTAn2S4cLtJVCCB2BtD2BpIQZ5ggARE4UB3KjgKFzThTx4IYQia0CMOUmIIH5AFolLggXiZ8BEL8IAKNcXC570wEUuwjaY2pZZQBMhHDrBBB/BxAxagaxIcyNQOa8ioKnCrBjMgFRQ+EDH/xCAJwFJGCSMxghTS8AMHfAQDlBANXUVxBP25QAtUpQoJAG8SSzAACEXYhB5CggFROBaydkEBNO6nA1lMhnJC4YAKbHASzdkjL6LDHxYEchVV2F5DVpArRf6CcfJxgKPYeAAJxGf/IwgQFbJqkIJDymcFG1ACpA7QAkgtwVMNuUAIyuiLGVBACyViAAZg+ZIcYCEFH/BAFIxgqxsa85jITKYaYnCFEHCBHVvwgBRMOQwYIOEK4LgCCwpnsgYQQAb3kcEWXNi4dv2rXcvZGBYMdrAJmIAUGTCnwxKwgXTKCwnsvFgJFDAKEfjLYRvg58ASkM92okkUFbhCBOa50PSFawgWu1gRuGBDSTAAAfwQBz46QL2BLaGgBTHPspphAQWwgAWSUxkGlOCEiLqjBBM4AC+VSYgYLCEJSvgCFYRD05769KdADapQhxoJB8Sgo0QlhAMiYDa0qY1tE6jdIk6SkpU4NHUx/+maBrDwqaNNBASTS53WuNY1H3hhgmpYQdUmxM24YahrIeHQIYrm1YkkLXVNgytIonaIiHj1IjNVWUf0+hEwbNEQNsOZRCoKN5/plQYjXQSAjkc3BmThQAmiAYMCS9OWeYEAJeCCF25QzKSa9rSoTa1qV3uaBVwhBVBsghTaStQGnAEHSnEKCnAgg08S4wErIAEJLkBNeUGgDDlKnArGUNxJwEBwMxIcbcEVgzPk1nRAKAFnFwGBx0GuAUeUVxJKZzqmHOGgociAd6M7XUJhAXHlFcARpFoJEuQAcjHyrbhIgAYhxBcFLyhtJaIUuAxu100ucJ3plELOnzLgA7hVEf8KVCAB1JJACRPQwFI0UAQstJe1NyQfWpP6ACUc4QRMCOAAC+jHocbACcr7kgArMyDymQ99OIHfYOQXgBNsiT9Rkl6VXgQBCDR3ETHoEo8L84PM7Sd60nsLUh3BgMONBgcHoGwhurfkwjBhC/xpS5TnEokKnEGBYDjyIAKz4yX/IAT9wcAFiDc840UCCQqMzGEREYYYy6959vSPlhVxgR3kGTI7CDQiPODnL+0ABYwFlwQOHZkWNCIDRdgdmHDwRpRNmtKP4eojLMCDMbxAAGgogwf0s7ILEAHUOvjwDV1AaTEMracYcIICnaBmZfLgCKNBAUJSiwEXUCELWUjCE6YETJxAAAAh+QQJAABqACwAAAAAlgCWAEAH/4BqgoOEhYaHiImKi4yNjo+QkZKTlIgcEgeZmpsSHJWfoKGPEDcRCaeoCSZIlBg3SpuZSjcYkgxVHwa6u7spHyKiwaAiERupESZStcKgNikevLwhCczV1tfY2ZIQCN3e3iAr2uPCRlAF6Onq6FBLzBU9S91LCjHk98ErIRTr6RRNEPAJHEiwoMGD1xxAaKCgoUMFOTIgnPiJxwQCGDNqzDghCTBFD2BYgPGAoslPMKZc3MgxTMCTMGPKnEkzUQUOC3Lq5PCypsAQLwYIHUqUqI8mPpNSgkBBQ9GiGqaUNMngxgAmALJmxVHgo0wMDW7wSILgglJHNk5oXcu2LYAtkf8ejIggQUKEEQwkpVAhoK/fv4CFaCBxFpEFAW4TR2kkg0mAx5AjSw7AZIKjES/4AvYrBIeBwgUz+HA8OTIZJmnEgV7tCAOHEQpILGNNWxEDEy1ixWphIi8lGD1cNOAwtXaiDAlMpUq1wcpJE7miRUuRYoHx69izD8yRgoL371l6VMsB4pt5JA60h3rgYUa/fjW+qJ9Pv779+4MseJhQYmOJCVHAoEgMNjD0UEMNeIUfNg6E0R9LLMnwgRQLVmjhhRiKEsELNDwlFIcdMAMDTjrlxIEFGTLCQA1BefjUC1OkKGMwWySWmBisHJQBGEdsthkOSVyHgRA2FikBIyukQVr/aZChhiIjN2jm42ZATOCbehwYgYUSSbBQgSSNMclkZTPC5EAPV1SBxRU9pFfmm3CK8oARSuSmSQtKGFFcnAY5sIGdumXC25V8MmIBAshssMEVDRAKCQmYBJqJBIRJ0kMTIaTQiwch3OAodhhcodxyp5jQwCcVkNBADiJ8SYkUIUg3XRQ9ZceCMaSesoFZJo0Qnay6fEDFfQysMMQIItQqEwdUGBDCsx58scSnhVZrbXYkIADCtuWJ4Oa1aiBwznsFzEBBDsK4YJ55LOwZZwwfuEduOjU0Qa0tSJS37hKuWpsDP/OiM4OC4N6DAQJZdDHDDFN8gcS9BUcs8cQUF4xB/w8gGIHAEO4q4sAFCjQgsgIXfFuxIhI4AaFGThyQiAU9GHhgA3idjEgFFDy4ckYlFBCkJTnIvGqlNiMygs47E1AEwUUHE2oB/zkhQ896Nm311VhnTVAGVGxRhlBl1BCBssJAcEFOF0BgcrUQFNGiix9SADEkDqxQYokXzJ0iDBMEAXdRNIzRLygYXEAiBxcMXu0Ifv8tVBBgEK11JRgkMYEPGrzwggY+lJBAx5NfOIIKRWoVo0k9yIADEIGpgMIBa9NWQOluiTGCQRdogMKUP8pXWw60J+aEIyKUccIOOkSmww4nlMF0IjP0yPtmKDxh3BNiBL+WDIyMEEDyYipPhv94jGSBw/R+oaCBJ9mtIEORRAzbCAxoEBH+ZESgIZEjFSThBApHUMERjhAVBZxsCGYA3/2+R4bbhW4SNpjACZigwO8x4QQTsMEDN8jBajHgCVRoQV1aQIUn6K2Di+gALAKlhBChUBIdiJSkJODCF7YmCYCSVBJmYzMHwIAEIkjcJ2IoqUlRaBIWSEATPPCBD3igBQ2InXY4kIANjAoZCABdI6SwQt0o4YiR4IABoCGrEBihPi4wQa6SE4En4YsHdakLD5CgxUWI4FfA+sDPtIOcUZFqA+4wCXSA1YsU8Co7rvDjcjaALpMYAY+ySkEWBKQeC0RAkaViAUwYcABI8sL/Fw6kzwWkoChFJcAFPDxJA3yhKV08IwQ7tCEl6paDJSBhCKmUpS53yUtZgiUBVeDBDWqGjVSNYAQ2sMfEjECBGsCnBs5hhg06sK4OhNJaFpiCvMhVAw8orhIj0Ne6QNBIa0XBmQErAAWqIAoHIGFd31hCLt8EgRBsc14z8MAJG0ECasKzA0MA1wEAFjAKRKBsLPBnN0Bghf1dywFKIOh7oMCDazwAAhCY57UukAUooBMdNYCCEhzay0YwwAJDEEEG9lnSlrr0pTCNqUxnStO4GKEL/5kAf7rQAZaqISQjqePVIKCSnTnBC8pMBAeC5pChPfBoScvI0hBBIJk9JEGT/3OAF5C2MwmBkRAws2pTiYm1GOQsqhjp2R4JoRCxIoikWKvCSqI6ASo8bxArGIHIGFKyDSpBZUlzQgtqqgZ9OIGrJXCCB9xIWDVUYARSuIEVevDNxlr2spjNrGY3exIGXGAEPegrZhEgAw3QoHFB2FwRXMAgBjxAitVawmn/1iEDCiMDJDIRY6t1BR84bigvCGQoLHA3naimWhXgQod+O4AXUCAfxUUbbGcEgRI07rc02IJQH+HZ6G5XRhJwCnM1sNZQOCAGGbAABHyaoiyI928acBlNVzADDVx3KDTQgBfINtMMaEECTpQACPjL2ZqQIAFfyMIBlpBUwnKgDEVigv98T9K//6kAByoAQgHnswIUaA8ASJlIA3wgPR915jPYccGHtWKZgzThfOgTgPokt5oKEGnFWTlSQaIU4/Q54bszeQKOtVKGR2DABAPQARN+8AMKDsAEQB5E9HrcFyEIoZyrEYFahgyFRjQABT8I3w9QYFtGGEBKMRYMjUEzOxyf4JqI6MIJFviYE5xuEQvwwe56jAPfGYcCKz4BaxfxhTnTuc6LYcSOSsw7IGlnCB6mXQgaUQEf7ODQjyGCBhqsiCGUYHWtE8IB2KsUKYABK2tRQRgOyYhKXxrTRPABpxkBlhskwQRWOG7FCo3pAJwgCzENg6EXeIIuzHQEQgizmH4XIIQyz/QBEQADGU7A5BOQAQyfK3B9AgEAIfkECQAAagAsAAAAAJYAlgBAB/+AaoKDhIWGh4iJiouMjY6PkJGSk5SJLCYJmZqZJiyVn6ChkSQdCKanICwVlRZGJhGwESZGFpQcLQe5uroSWqK/oQ49ICCnHVa1wKJWSru8PBnK0tPU1daTHDkK29wNNtfgyhVfHgbm5+geLQ/SDyskJBcY4fTKDR4f6AYp+T31/wADChxI8JoFDgsSJuSQrKDDShmmFJhIseLEGWEaLnLwsKOoBgVqWJxIocsIjyhTVrLBY4aMCRRanFRJU9oTADhz6ty501dNcENKEBhKtCjRIlw4fCLAs2nOIOx+0hvBRYZRojK2fEu5JMQZAUI0cKmyQqqaBxBWmY0U5keAt3D/48oNoIOMiEkMMmSIKokDmAGAAwserKHF2kUIiOyYK1cMAb6KXAARQLmy5csCjix5dIPGi8GAg2iYEe3wQCsoUGC2jAIICNOwJUEQkePJEAixcz+ygWmTbxN3QTHgqNvRiGKnkpuC4fECLmfOJEgpTr26dYcKeGTxkCJKkpnKIDTgRl5Bg9LXRT0Joa+9gQ/g08ufT7++/UMimlCgMGNGjf1NbKXIAwoVmNA894XjAgUjNUjBEwlGKOGECTjllBITOoKBEk4IZVQJE2DBwCdSWGgiADxkmIgLE1zlIgElxPcJSEKIkdMRFHii4n0kqLAYY4158BAILwQBmmAaFACZ/24mnAAkkDv4oNYiUgCh2mqUoXCEEY4wsAUNRx7pAwL3VRDDko88cSWWmAGh444qQaAACywogBuceOYZDgwdmLABLBuY0MGdenpkwwa+/SZgoZFA0IMLSOTAwYiVLIFooglsYEUlOWAhgQQttPDpFYTORwJyypmyBJqSYIBgJTFUAV10SNAXQ6qoKJDSDRLMqksLSiXIwAPESXUBCBvwQMUNDVDK6LPQ7sjABSM00MAICzgbLSEMJMFeeymEEEGxocAwXnnbNFDWtoKw8K1753wA4S/inZtuAxpt60AS+cBrQAgJsFsQAz10EMEGUpAg8MIMN+zww5M8UIG2jjgAwf8KF6wAAcUQK7JCGCI1GJIX6B0SA0IGLsBBqR0f0gGDIldEQQeKMLACyipfwHHLhvAAc8wUJMHzNRiwcEC4KRzAwqtDN+300wFhsYOJYhjgMARWaJcFD6r80sSJTVEQrRUtvohVDpVUAbZTITwbQdlmEzUBzZRMsPZOaewMJxZwm+3EBqHYkAbYKswrcAVahDDGUGN80AGrUOOZgBluMUbECSWU7BASY/jgAw1BeKbBABLEkB4JOOjw5FwntE0QD6OHKVgQMrAcGxdMrM7YDmg78kQJKqhgZWvBy1DrIwoYKftgL6RgXRcnkKH7W6r7w0gWOLB5GQ7ON5KBDGAuP4D/BoDL1wMXlzOxg2I/nCDEAXofkoQK2mOmQhWRYIBACltwwUUBPFgUxJSQvfpRBgdZiJwoFLAFIAgvNQ4Ewhh0pcAKWrBlDBDBEjqgBSuIIH4XjEQMjHCpTWzACKYLYSUgkIAIYKqFCbCdCh3Rg9680ATWgxq5KAEDWLwQFszhIRJu8KcOiGCH9LEBApADgg4gQYaOgAARE7WBGwRREi5oBnQkYIIUzqcCVsDVEmWUvxF0wAhG6MAImBYJI/TKVwdowQXocxwxLqc5z4GjBOgmHxugKlVWYCNBICArOB5AAm+SjwhKAUgvdoQEb5yVBIyAxPRYoAFIYIELRDCllDiA/wWies6nNpCvGVZiWJAzpSpXycpWMgIGC7iAI6vBgApMrGMYiEAIPpCCXvLjAzdIJSUymINzWasHwiyUu/z1L8OFAgPmQZd5ZgmtIfCSmSnwQLBCkQF7lacBcxSYFd7lrw8cLxg98Ga6RpBMPF2gl9hswhVFkYFqWWs8pdzWArIJLw80IZ+uRIQIDvCBgn4gBB7gwTYDytCGOvShEI2oRCdKUdhgAAlYMIAHolAFF7TTEJW0oAIK8DOZdSGHibAZzjigsxBSAQoxmwgUTDCglClEkE57QkmB1juT4axAK7Pgy2JKkZkp4iAGYsgFLdAFok5kCgAdhMUwpjEQNm0FU/+YQcxqkJGKDmIIKdhPf2YAoOB41RAYiAFOz8rWtrr1rXDN0wjGwASenEAGLjjr19ZWgIU5wAgUmMAEZPCSCdSAj5+wgBnuhpMfoLRQDmiBE+LmBCp8AgMoYGxOdBDVDD0gDB6Kmww8EFJGRECzOvnCszrQt7hNIJGQoAJqcyIkRl2htWabAJkmsYC6olYMDXhWBrZQhLgNpQQ16GQkQDBboUHLAhQIrYtk0AUoPsICQribGcwarRFMYbDFJUARXuIFAX4iAzU4gYUIoDCHOSAD8MhAaUVRARFAqgfWjaskYgCDj0JUAQS43PqIQAQmnAAFB/BvPSrQAQ9AoQT/q4L/ea1jhPXp7gQTUO5AEuCZMGmgBp01TQGcND26BICM/7DABMK3PA3QtDpJIHGJAxAlDdPDSywWnw9eQx3czRguO3AmIx4AgjBMADATCMPjItEA5YkPMC+obXHa8mO6kGHCh4iAlrB0BBSUrxF+cbL4ClMdDqTux61rxAVesCY2oUADC3AEFWInPhrUzjokAMKPLtyERkAgCG3WHgpoME9FIKBILZ6CgqWiBRVUbi6X20J+CXED+hmwMip4sSNcsAXP0eDTL9DAGSRg4+u4wAATeEEaBgCFJITYEJW+NKa/HAkGxKDUDovBAALt5iBMepUWCMJk6geEF4RzoloQgKXtFieAK7T1k00gABjAQIAmsGC++q1OIAAAIfkECQAAagAsAAAAAJYAlgBAB/+AaoKDhIWGh4iJiouMjY6PkJGSk5SJFVYImZqaMZWen6CRDCI5DQqnDQ0WnyssIB0dICwXni4mCbi5CREJEKG/oQ8kqakjGcDAFR0mvLkbESLI0tPU1daUDBcL29wLD9fg0goSB+Xm5xLR0w4PDw7h8NIMCBLk5hItSPH7/P2PKx0ONGlhhJa/gwgLuRgDoKHDhxAflkhIUVKHEAYyatxoIASCCoVMRBz5sEXFk5FAfPiQQmOKDx4QoJxJ8xMGGzme2ABZsye1GT8CCB1KtGiAHRN8xqtCoYDTp1CdUojwyYaKHUaNEtGhT+k+IxRqRC1Qo4YVnxdAUKkSIQdPr3D/K5HQIESA3bt486rwkLDKBAKAAwsOXGTMqriLouBAkRevihcjHnl5MaCy5cuXX0yB9ADLBBlFBJdwUqMHYopfNGDGrOHL6dewY/Nz4GKTbQRI3snmV8HUqd+obNBcskGXcV7HditfzjyhgwVIOiB4cniahW7dVjRHxsBEi3PgD7RIsL28+fPTGJKMKIMB+n0jsHhYGSIFD3UhNazfj+Lte2kOVOEBRwR6wINwiDSwhQ4QEUGAC/9FKKFsUIiRVVEnlOHfhIxYEAUUTT1FAQUt+PJJCUxceOEOPrjHoSJRiDVWVBQcgMwFEXixxRhhJIHgixImgUNdjeF1xBnVIeSA/xJODCaYDFwM0RwDEwBR5JUq3OCIA02otpplGjShWyNL/OWkkzJ8MCaQj4RA2ZerveAFm3TWaeedjGRQGwh8upAknhXRdtsmLqwJKCQYwGABBC5WEsOgmpg4CQMKXLHBpREg8Gd5DIzgG3AKNGAQSg3cYlwuEVyBAXoLfPqbKRtStEIEzZy6AQuH0hSDDSMMsUKjuQYrrIQOxJBBBjEAO+wgFlBhDzpJSPrLCthxc4GhuWJARXjgtRCBsp9kwEE3HGwq7ALfcWtOcsse5AAEC6zQSbv01mvvixh4IcZ+BcR67y8QoLDfSGaY+68gS9RHoAEphAAhIVEcMTBJO8BwcP8hFSgx4MIaeSBBA4MwcMPEI/FwsSEWNNESxx40wS4hGMhAMhjSnnwIAwvkwIIC19rs889AJ/RAFGacsIMOQulAxAk6hFDzsg5kYIMNMGBbCQwCYKUiUTrg8COgDkgQ4owFQGFyJRX4QMTWRukAxKh3QhDCDGRDNYMH4D7SgA5Isz0UE1IEa8EUdNddwwf+SmKFEEy3fQIOWtaLgQIRYIHFDT18E3SwAQqhApF3oYCDDFLSxEIIJUygugxQUGFxeUrgcGVjKGiwQEIxUFDCmYNNoAVzDQgB+ux3HTFDJC5McYYGPvigWhcPQxKFDLw7WcTXsnGgAWPE24VDE45YMEH/EHBeFoQT2jkihZnVyzBF4rsNEcYLR9R/hBATmAD/IRWUQH755ivBvCDBABK4ABYN2F+7MiADGgCwMjSYwMs25wkFhAAML2geDcrQhMhQ8IMgtBkDLEACG6xAcyH8xQUQAIJN8AluKaTEEKQzqA6YJobYYAGkMrGEvOGwET1o4aBA4MFKYOACIiDB6yTEAA6EKhU9mKAkFiBEF5KgEg9AADNQ9QwO/OcCOQBVqBSwKk+MkAQksIAPw0erU+HCBF0xT2/EiIorzoQ4bsQFcs7TKVe9CoYUyUFx8hiBGygwNgwYQhhf1YD0DcdUx4mAFOWYgRXAYI0VeYALEnCpS3UA/5A/DKUoR0nKUpryNRAwQgvqUY8DdGCAyDgiB8bFgQuUkV4M2MCzwCOBK1jtauPCDgcmmasb7DI8EgjcLxxArWot4AKYtFMFeKAuc7TABCgERQWCSa6nBasDx+QlrqQBAW08s2r3WoIS1KWEJ5zyESK4QRXIwQMtePGd+MynPvfJz376ExxP4AIRILKDEozznxWYAMkGsMQPNjEHS8hBzxJBBZKV5IMdgMlGXvIBmRQCAxGwKESqELSUrWxhLXuZCfQjUocA4ZBQExDHOnagQUSspQ4hQkMvVoEvbGymHgOZIJ6wBZw2pAhBu8hMM+IR/8RACDg1AzEPdrqTbjQEcf8sBBREWoJoHqwH8gnBSjxQBfwgAgMh2BdJxDCFW/5TEBYAARa+cAApgPKteM2rXvfKV+aIwAMvIMMOdkAGDYRBAXmNARcalxUdiAEMjhzWA5YQBcIVYAoSKNQveHACvwnlBAYY1go+MLaoQKEJsJzEBoLi2c8qIVg5KC3ZalC6SYFBa60lggBSW6cHeKBwdSNLFH7JCAzQALeeJQIKDAakGHwAuHWbgQG8mogsdLa1AfjB8XJlBCgE1ylQOIsntnBdvzEBDNTlEAK8S7YZUCAHoejAUbZGhB2YgF45SMGI9kuBDkrjAiFQwQ9+wAQm/OAEZqCAWfvK4AZXowdT0AD/EHCAAxWgoAxJgGk/GGADK9xACw3wZnMM8LnZHcEHQq0IBg7wmcEUgTRFZM5cuNc9HISWIuurHmDcp2GfUMlK3btLlhJiBfbpOE3EjUsOhBfk4m0XEg4gwTJM0AESJLm61NMxYRYMm7kMr3sqSMEjHiCBF7wpMy+QQDYZwQMjV68wzEWMBGTX5Nrd1RAR8BIANbCBR8SgBrvT8gSUyZwNlJh4RyjDVAuR5weCiSpbkkCTeCeDMXB5OTzwHI3tMuESXBoRDOCCAx09ABoQYM2McMEHCKC6zxQgAjs9jwWWEIEkGGEEqGZEqEftaFPn2pQ30PMDNUCefl5B2HDSQOT8HsmAKtDAB5gJgg9oUIX0nrICLqBCFCTQll87uDmBAAAh+QQJAABqACwAAAAAlgCWAEAH/4BqgoOEhYaHiImKi4yNjo+QkZKTlIorOQqZmjkXlZ6foJMYFxwLphwZoRkiIyMiqZ4VSyAItbYdNqG6uw8ZFxcrMbvDajAsHbYgID0OxLoVJA0NNsLO1tfYiQtMAN3e3+DfOdnknwxSGwnq6+obCM2eKwHh9N4/I+X5sSwRJhsbJiK4eKCvoMGDkSpAqICwocNEIszoCECxosWLAYg0eMhRUgUeLQ6IHDmyBRUMhh7I+EEGI8YfZxh2nAmpghQJEkK2wNkBJc2fQIMKHWpIhICjSJMqPQqEBdF8F1KkMEC1qtUUTWCASoJDyFKlOL48NYghQogPU6V++HCFwVOFPv/HyvV0QMOAu3jz6gVD4qGFLgUCCx4smMKNuYxgFNAQRO/dF0GuQOpRgoDly5gxl1AQKcOBGhRqzJhBAUoIF4g5wvgwoUhmy068wEpNu7ZtchkaaNqtoMHs2wUzmBpOnOBPCLaSJ+MMvLntFULqhSMjwrk1DDBgGA+1Qbp3AGKtexKRjp35DQt2jdjyI5wYGajFy59fewGaHy4tMkExhD5CEh1EkMQGHXCQiBH45ZcfE0n4R44NEpAkoUgt9KVID19MoIEQGjjRBHMOhigicCQEocJXSB2RxkYjSmIDFmutdRYPnYDiAhAooqiCZC0y0sMHVgVJVQoeWLgLAyuMkAP/Cdv12CIGizmWVxA+SEHTCh9QQFhgpHUgnxUvSCklDVs0ucgKXUzwmmUTFFCjIwxEUcOWW1KAj5OTULbmmiXcieefgAYqKCQQkDDEECRAMOhQMOjGWya+LQoKPKAsgAlvOaTnyQMkPMECEiP85l8MpRBnygWUzvTAEsolB0Iu/jFwgakLcKBoUCMg02ott0oa1ANu+SrsJxB0cYJ0Yxg4rEEdfEcPFcsKIkIEG0RgbT8JKOsJD87Wk8KwI5Rn3jomwEpJBUd0Cw4RKyzrggnjqmMCiJ8YoG4NqUar77789jssBCGYcQITOxCxAxMnkDGFBf6Sc0WCClp0QoMNK8LA/xVKTHiAEkYESwgPEEds0Q9RVIxIDhFqPJIE9KrBABhMiGzRDi/EZXIhSGSsshLxHdKDDydMhJEOJwgwzs2OOICBx0g37fTTNEGgxAsqqHDEEVVrkEK7UOtyw4k5JoXDAdEuYIAHQlLlQRYMe7LBEWEvhUMLwyIQQtpBftAzJSGAHbcAKlCQ76JW3I23ASE8sUsEPuAABApeCQGECmlgMbi+MJjSa9fLQvDFABq8QEMQNPjgAwFLDDUCFQZ84IESHWg1HwQl0CCmXhpg0ZEVUNA5WA1NmGmbAT7c7hgNR0OiABZTUEDBFFiwGIkIM/hOGAVViHeDXcYPQMMEbTdihP8Te2LmxGGPMPCFltbX0LJ4JJgwxRZcUNCEFTY7YoSa5WM2AfqUYADTmtYB/vXPCVrg3DAWEAEPTGEKHiiXAidIQahVIAMZqEYFFyiNDjZAUxv8xAN68yjdCC+EkFiBo0rINRROYoSP0kT+AvgnBsBgBSuwgEw84YBoeHBJl3sEBI5BCwQoozohkhWtbKULAYaiB7ralQbnIxxameKEDkHOrmoBgvdZBwKlMhWqgLKqLSKgA0j0TwVIMRwOWCCID5FFEZODRifB8ScYEIELPtWA8Lnwj4AMJCgUUAAhcAMAJwACBZAgyEeQ4AXOUoHiGpmIIqirGzTA4qIswIIrqOP/Ci6QHSiccElvoGGAi1pAtcYVgQSIShJSKOU3eDCsC4iLlRF4JSQOIEtvhGBYCrjluDaQxkk8oZfdSKCwIJCAVsYrAleYYSQ80MstRAsDHQgIO/qBAFROojuXLBm/LKCATylAl5/gwSHrIYZvUdIRIsACBSbgBAoowYvvzKc+98nPfipQBBKQwQtCJwMl9MCfhxABDYLmEqJpAJ8KfMAdBcGAIiRMZj8ogzSbhk2ctOCjOenACR0wgZjJjCI7oMFGTeYCnWlMCZMkhBZCdlImmKBrEFJZSYwkCJCddGTifBrKdCoSlhWiB2QQ2k810rWPENUkM0zACX4agBNkj3MM/7iBS0nCMW+qgQQCoClGmHAEP03QBuigggmkwNNEWGAKZBgYEea6g6nOAIQIPUQMLDDFvPr1r4ANrGAFtQItNKEAU/jCDbQFWBFMAAcoWAoKcBCEmO6LASKQgj9wMVFIPGAMfsvREcCwOWEpIAVAylsTihnAIuDobwJAwQBKOygHUCG1eAtBAj7RAbjB9igqoJivnmC4w7XOrJK4gW9/iwPdCYsFxT3cB5I3iQy8ILKw9Yq5JFWBL6DtcB5ogSbhGdu/Sc6yvmJAEkIwlSClIAQ36KwjvqAC7EoWByHwqq8UQIUseMADUUhCf5xxgYC+QABCSIMTDsDYwTr4wQYRQf8VCkCAEmzBA1roa1AYEIMdOsgCFOCeY0QXAaBYoAXOE80MagAFLzhlPhEQ8e2+10KHPCAK7PMdBaTXHAQUr3t3oQEXxkuOOM3JeoGxk3UMECYgB5m6kHAABCCgX0ZQD8mFoaVz6uLku/AFEjD4QgkmUIIiFGHMJYgCOt0KGCwXwDBfLILtgKwBLTcCAyEw4Jom4AUPM2IJvUMy8Ig8lwdMQcaOCcILEPAIDHShMv2r8Az8vAgLeCDQhCENCPyDgQOAIXQ0oMELTLcF9DKigJG+zASsJIkRmMC74QUBbR30gArIFxEg0HP/JuAlfxoa0v0rQRdWSkkGGIB85ZuABwgeTUkMUIEAE5BBCUogg9ZgYdZ+5UCAItCBtkLYQYEAACH5BAUAAGoALAAAAACWAJYAQAf/gGqCg4SFhoeIiYqLjI2Oj5CRkpOUig4rHAuaCxwrDpWgoaKNBQCmp6ippz9Dkw8QEBijFg0NCrcNOSIMo72USKrBqTK+oRYjtbUkD8XNzs/Q0ZBZJwHW19jZAT8F0t6jKyAI4+TkMKM81drrJ03f76IVI0vjLD2y8Pn6+/z9/s0QDKgQQLCgwYMqpvxbSKmHiQQQI0Y0MQTCoQYCUBzciAIFC4YgJ0GwEsGEyQQsLIZcybKly5eIovgYQLOmTZsvvMDMB0LCgZ9Ag0r4KApDFw03b/rYkmHnvgxXWkiYKqGFFpVOs2o1xqUIga9gw4KdwIOhkQ8G0qpdayBFFqxb/xONqDGhRNgiMiZgYQYJC4UCgAMLBkzhwKQLGwx8WOxBggtecf/18AJlxmAKYUZE3sy5swggwlJ5mLRik+kFKzq/cxG6NYAJDEnYukUbVwXVh0iAac2kBe5/HXTsWHeNyI4kvzczADOc+DoiAmIkD+XARbnrIJ40s5GCBpkdw31knk6+vGotKIBsLJg+gnl/EEiIIAHXUIMS6tevRzGB73tpIEQg0YAbINADIxAgEQEWG7DQ1H8QRpicFDS8kBRNNPiwgYSVkHAFDy0cwIMWF/jihYUXJkUDBZBxyMgNPgUlowRSuGgjPCKMIYNYYTnh20ojNBFCCmt5EMIG/v3mQP8IO/LI4wRLRKJAGFAMVgAFUzQgyRBoscXWB8jdSIlfVlpZmJhopqnmmo88UEEFSbIpiQNSlPFDKiqEUCIlpZ2mSWpyOkKBa6n8oCUkl2SyCQcXtFiJAxBYAAM+5IlwAqHBUMDQBbPVpkADIzjaWQUoYKqKBAxh8Kmnny5Q3gJHmApAFoEy5MAIEUSRRQsgPFirKBd8cMQPPzDBBLE4FEDCr/1soY5z1zABhqiBOiACAiBkK86yRdHQHLTYEIGCBb8ywMJ117kgSgQ/gJvNCUowqwYGLIiDHRJxVhIDF2LoQJwOYoABqLwEF2zwwQVbIMEZKKjgMBADZLEnwtI4MMb/QPoZdEQJ+VJsSAY3mCAgRCVdcY4hVjCcMUcD+OpxIQ8YMfKAJBuhbiFL5LdyQSrU+DIiGGixAc0JbKAFtYSA8AIOGhmEAg4aGPHz1FRXbXV5MJhAQRk0gbEFD+Re7QsDNcyUYk00FFFfoCwoISNQEhwKCgZj0HD2TUE4cXKgFfDwtowtmNAxJAuAEcTdaGvG7AMmxPi2BDcgTckDEZTggwY+vIC5E1XcJvbnv2ZABQV5TTBBESHc/BItSyAhwuC4GeGEk2KVUIN0CzFwQJdetvWB4r+J4BXtYsnwBSW0INDBE2FPYgLvvbeVwsS4VTBFk8RP0AEkGBjwV5mA1ZAC/6WOcOdB9CHcECEEDYCgBQs2SL5IBR5YBn5gM4SAO+iTZ/E9+BQwAPn4F4oMKEB5OWgeARfIwAY68BEMsAAnMmEB+b2MA1qoQguS4IL9UQICijINB9ZGsQtMoDU6CFMkHHABP2niAp94mQUEICtURQKEfhrhz1gjK1MQQBIRnOACKigKGPQgGQrggAXjQqoengILqVqVp3JAPdU8wYmnIMZCZMMq2yRHBGLAIgCgsKlO1QZUS9RKDbB4AuD9gxZmzMEQ0rgVLvRQDKoDCQNgsAILeO49DcABphTywEgwIAIvuBQqAjADERTykcVYwQ0+AIUtHIkDkJQEAlBwAiJoQ/8HJ8BBAjLJCBsc4VvOIYIOkHCwGNhgBCMgwR9F0QAd+Mtd1mDC9uQ1gg6gqwM2GEURmIDLa+zgBXR0UfvQNQ4QuHESFfCBJ4sZAB0AoYpresC5mDkOJMSwEjNoFzWZABtmDcGXzOwAt0ABAwFM0106wEEw5ZUBK9hrHB1ISS8cAAUxuOsEZZglwV4BAdiB4gFRwMEJdnBL4VTDCyQkpSIwYAMXuE6gEs2oRjfK0Y5CMgZPCNkNXBBRjwpiCQNg2kGe9oJdmlQQGGlaxjqSx89BgAVFM8EGbsACDxaCBTrbmQBU4NKrPUBoRNuAFKilgCIEdWf8MSjFQDA0ohXNQIX/QMAAZCpUFLRMbDGbGc0iYLNCwCAFGBPqUAkpNodYNQEUWRsDuJDWlR1BBgO0mgVusIGZlcxlhrgCEJ7qtCOYwIEwEMEIRFBSQ1ygCUEAgsNUcAQapACTL82sZjfL2c56dmoMuMAIFLCAZG4UCUXQwAsON4Ag0EADEwDBy2JwgRX4dBQNaO3dgvACKxTMASyYilBaoJ1RsABFiBuAD64grwv8LShY2FslaoBcxNGAABhVEwNMEKLnHqAF6gMFA7Zgt+S2VgaNvdED/Obd70bAtIjYAFLMqwEb/qoBjvubBFohCizM924acAfBVsCD/P5EAklILyQgEAYNlNcmQdAA/wWwySwHcIAFUugAEijcCwgggAdNaIwUAPvZEpt4H+zrgBGWQAL4SrQHdBkeWPJSBanuYwUmMEAIdtyYx5inAl3AHu0m4DOG2MAD5+tdCEY5HQaEwC7EG0uUFtID6PUOTNMRXpTDIoMoMOR50VNLCqaXHAt0ZctfIYskLECFKdSAAlDAEg8GBgktWNlLblFwVowwATTb7raKEEEBagA+y/AXgrsLcwo+cKBK6Yh4TjAMJJDwv/tRgCiQUICOiZSWFBgpAjbeDAySQDrTne4DxYXEAwxgv/sVYAbjQ14DkOACG4R6cax2NWBgndeNuqDSAMT0S23QBUKXidCO7GwGTA8QBgo4G0tJUOCJp22jQAAAOw==';
        var busPNGData = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACUAAAAoCAYAAAB5ADPdAAAABmJLR0QA/wD/AP+gvaeTAAAEW0lEQVRYhc2Ya0wcVRTHfzOzu7zfXVhetiBCCiJQSjWR+kATRYqpwZgoVtOg0TRSi02Mpg0mxhh8favWpnGDmpoUFQumSVtIxUZRKVaxUAgqYkMFypuFZXnt+AEYdnd2eS3t8v809+Tcub85995z5x5BlmUZF5qYnKb1n+u0dfbR0tFLW2cfvQMmRsYsDJssjIxZMJkn0Wok/H11APh56wjy9yZKH4ghLIDITQHEGoLISIomPTESPx+dq+EWlCk4QpnMkxirGjlZ00RDcxezVutyL1mxJFFka5yeezPjeSZvGztSYpeHunili0dLPqVnwLRuIEvpkbuTOH64gCh9oHOowVEzCbvfY2h0wq6jViOx+75ktwFmrTKV55tV9vjoUNq+PohWIylQmoWnM/XtKiAAPx8dFWWFbkOZLdNOoTquDVJR8weFuRmKTVx4+PnyVbcHXquqL7TatZVINbZ2Oe1gtkzxwtuVbg88M+N6w/zY1OkcquXv3kWjJBLg56W0v6y97DYUQEigj/I8MmbBap3bY//1mRifmFLShQZgaHSC0fFJpUNWSgz1xn3rAuJKW/Lf4d/uIQBkWabj2iCpCQYARFmWOf1D2w0FWIm+vdDK9MwsAOIbx2rZU3rSw0hw6KOz5L1cDoB4/JsGz9LYqOaXPymvvhQuDo6aPc1ip7bO68Hiwg7YKJIkwSpaXf8keERW2SqIQf7enuawU4w+eFwsyLnd0xyK0hIj2Zu/vUc8+vpjxEWFepqHhNgwzh0pwtdXaxU1ksgdtxk8zURYkC/hof7A/F/C7AbYgbZZQANzh6OtBobN63YIu5LZMmUPJTtASaJg59B+tZ8nXjtxQ6EcZRspEUB0gPKEbCM1ByVsACjHSEmS6NL5Zkk9fRsgUrYIy66pzZEhJMeHI7gBLooCqQkGosMDl/BZnC3NUlAflORR8lQ2giDQ1N5N7n4j3f2ru6iGBvpSe/Q5MpKikGWZY5UN7Cs7hWO1wDYDiABeWg2Ouiv1Fl4p3KlEKC0xktLnH1wVEMChovvJSIoCQBAEXiy4k5ysW1V+oiOUs6JDTHiQymYI8181VGxEsJP3BKhsks30uYSq+7VDlenXcsE4Vddi156YnOb8xb/UUNJipDQAIQE+Kqf+4XF2HSinrDgXPx8tn5/+jU+qGlcN9cWZ34nSB7I3fzs9AyZKPz7ndF3aZgBBlmX5SEU9xe9Wr3rA9VRWcgwNn70EkCkCRISq5/hma2r+zgfzayo7fQvJ8eEeA/L31XG4KEdpqyp5Z39q5+Fio12ng0/v5P0DeW4PXvTmVxir7dflpRP7lZQxr0zVoafTSo4m24KWW5qZXVmp0gmUOpF66dS2tci2krM4nvqDVVA7UmKU6gfMzfeTD6WtC9TjD6TaJcnMrdEkbdar/ARZlt9yNPYMmnRlxu9Txi2Tumd3bWvPTo8bWhcqoPK7ZkNV3ZX4iLCAsVf33NO6KcRv2sHlw/8BQH5xEOi41Y4AAAAASUVORK5CYII=';
        mapMarker1SVG = '<svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" version="1.1" x="0px" y="0px" viewBox="0 0 38.870663 65.01535" xml:space="preserve" width="38.870663" height="65.01535"><path d="m 19.614341,12.25 c -3.859,0 -7,3.141 -7,7 0,3.859 3.141,7 7,7 3.859,0 7,-3.141 7,-7 0,-3.859 -3.141,-7 -7,-7 z m 0,12 c -2.757,0 -5,-2.243 -5,-5 0,-2.757 2.243,-5 5,-5 2.757,0 5,2.243 5,5 0,2.757 -2.243,5 -5,5 z" style="fill:#000000;fill-opacity:1;stroke:#000000;stroke-width:13.9;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" /><path d="m 32.997341,5.867 c -3.622,-3.622 -8.438,-5.617 -13.56,-5.617 -5.123,0 -9.9380005,1.995 -13.5600001,5.617 -6.70300004,6.702 -7.536,19.312 -1.804,26.952 l 15.3640001,22.188 15.341,-22.157 c 5.755,-7.671 4.922,-20.281 -1.781,-26.983 z m 0.159,25.814 -13.719,19.812 L 5.6963409,31.65 C 0.49734086,24.718 1.2423409,13.33 7.2923405,7.281 10.536341,4.037 14.849341,2.25 19.437341,2.25 c 4.588,0 8.901,1.787 12.146,5.031 6.05,6.049 6.795,17.437 1.573,24.4 z" style="fill:#949494;fill-opacity:1;stroke:#949494;stroke-width:0.5;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" /><path style="fill:#ff0000;fill-opacity:1;stroke:none;stroke-width:50;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" d="M 12.032534,40.635204 C 7.9812495,34.777493 4.3642549,29.318095 3.9947689,28.503211 c -1.254422,-2.76657 -1.506747,-4.12908 -1.494007,-8.067368 0.01047,-3.235933 0.07525,-3.80559 0.646467,-5.684519 C 4.0157469,11.894463 5.2025649,9.7783 7.0510435,7.790604 12.155492,2.301719 20.002618,0.817712 26.837317,4.048731 c 4.27931,2.02299 7.551287,6.012562 8.978598,10.947744 0.454103,1.570137 0.53289,2.375556 0.532083,5.439368 -0.0012,4.038252 -0.276447,5.456681 -1.606009,8.272173 -0.588137,1.245438 -14.275211,21.444897 -15.183639,22.408095 -0.08791,0.09322 -3.474532,-4.623193 -7.525816,-10.480907 z M 22.898806,25.537479 c 1.229847,-0.59536 2.545801,-2.009926 3.208644,-3.449087 0.744969,-1.617466 0.683254,-4.381381 -0.132739,-5.944941 -2.315334,-4.436504 -8.061833,-5.307308 -11.51848,-1.745469 -1.721222,1.773601 -2.357875,4.80885 -1.52276,7.259775 0.442483,1.298618 1.882222,2.988447 3.208268,3.765563 1.836753,1.076409 4.670428,1.124281 6.757067,0.114159 z" /><circle style="fill:#ff0000;fill-opacity:1;stroke:#000000;stroke-width:0.81510067;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" cx="19.435331" cy="60.352589" r="4.2552137" /></svg>';
        mapMarker1Data = makeDataFromSVG(mapMarker1SVG);
        var mapMarkerSearchData = makeDataFromSVG(makeSearchSVG("#000"));
        var tapSVG = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="32px" height="32px" viewBox="0 0 42.585 42.585" style="enable-background:new 0 0 42.585 42.585;" xml:space="preserve"> <g> <g> <path d="M14.934,32.494c-0.276,0-0.5-0.224-0.5-0.5V15.632c0-1.93,1.481-3.5,3.303-3.5s3.303,1.57,3.303,3.5v10.637 c0,0.276-0.224,0.5-0.5,0.5s-0.5-0.224-0.5-0.5V15.632c0-1.378-1.033-2.5-2.303-2.5s-2.303,1.122-2.303,2.5v16.361 C15.434,32.27,15.21,32.494,14.934,32.494z"/> <path d="M17.099,42.585c-0.128,0-0.256-0.049-0.354-0.146l-7.413-7.412c-0.824-0.824-1.376-1.835-1.555-2.846 c-0.189-1.076,0.062-2.025,0.708-2.67c1.287-1.288,3.415-1.255,4.745,0.074l2.056,2.056c0.195,0.195,0.195,0.512,0,0.707 s-0.512,0.195-0.707,0l-2.056-2.056c-0.94-0.939-2.435-0.972-3.331-0.074c-0.409,0.409-0.562,1.044-0.43,1.79 c0.143,0.811,0.596,1.632,1.277,2.313l7.413,7.412c0.195,0.195,0.195,0.512,0,0.707C17.355,42.537,17.227,42.585,17.099,42.585z" /> <path d="M26.146,27.341c-0.276,0-0.5-0.224-0.5-0.5V24.32c0-1.115-1.033-2.021-2.303-2.021s-2.303,0.907-2.303,2.021v2.521 c0,0.276-0.224,0.5-0.5,0.5s-0.5-0.224-0.5-0.5V24.32c0-1.666,1.482-3.021,3.303-3.021s3.303,1.355,3.303,3.021v2.521 C26.646,27.118,26.422,27.341,26.146,27.341z"/> <path d="M31.75,27.341c-0.276,0-0.5-0.224-0.5-0.5v-2.104c0-0.87-1.054-1.604-2.302-1.604s-2.302,0.735-2.302,1.604v2.104 c0,0.276-0.224,0.5-0.5,0.5s-0.5-0.224-0.5-0.5v-2.104c0-1.436,1.481-2.604,3.302-2.604s3.302,1.168,3.302,2.604v2.104 C32.25,27.118,32.027,27.341,31.75,27.341z"/> <path d="M37.356,33.759c-0.276,0-0.5-0.224-0.5-0.5v-6.877c0-1.378-1.033-2.5-2.303-2.5c-1.357,0-2.303,0.648-2.303,1.229v1.729 c0,0.276-0.224,0.5-0.5,0.5s-0.5-0.224-0.5-0.5v-1.729c0-1.25,1.451-2.229,3.303-2.229c1.821,0,3.303,1.57,3.303,3.5v6.877 C37.856,33.536,37.632,33.759,37.356,33.759z"/> <path d="M33.356,42.582H17.138c-0.276,0-0.518-0.224-0.518-0.5s0.206-0.5,0.482-0.5h16.254c1.93,0,3.5-1.57,3.5-3.5v-5.396 c0-0.276,0.224-0.5,0.5-0.5s0.5,0.224,0.5,0.5v5.396C37.856,40.563,35.837,42.582,33.356,42.582z"/> </g> <path d="M17.737,7.197c-0.276,0-0.5-0.224-0.5-0.5V0.5c0-0.276,0.224-0.5,0.5-0.5s0.5,0.224,0.5,0.5v6.197 C18.237,6.973,18.013,7.197,17.737,7.197z"/> <path d="M21.857,8.916c-0.128,0-0.256-0.049-0.354-0.146c-0.195-0.195-0.195-0.512,0-0.707l4.381-4.382 c0.195-0.195,0.512-0.195,0.707,0s0.195,0.512,0,0.707L22.21,8.769C22.113,8.867,21.985,8.916,21.857,8.916z"/> <path d="M30.244,12.408h-6.197c-0.276,0-0.5-0.224-0.5-0.5s0.224-0.5,0.5-0.5h6.197c0.276,0,0.5,0.224,0.5,0.5 S30.521,12.408,30.244,12.408z"/> <g> <path d="M13.617,8.916c-0.128,0-0.256-0.049-0.354-0.146L8.881,4.387c-0.195-0.195-0.195-0.512,0-0.707s0.512-0.195,0.707,0 l4.382,4.382c0.195,0.195,0.195,0.512,0,0.707C13.873,8.867,13.745,8.916,13.617,8.916z"/> <path d="M11.426,12.408H5.229c-0.276,0-0.5-0.224-0.5-0.5s0.224-0.5,0.5-0.5h6.196c0.276,0,0.5,0.224,0.5,0.5 S11.702,12.408,11.426,12.408z"/> </g> </g> </svg>';
        var tapData = makeDataFromSVG(tapSVG);
        var geolocationMapSVG = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="32px" height="32px" viewBox="0 0 512 512" style="enable-background:new 0 0 512 512;" xml:space="preserve"> <g> <g> <path d="M256,0C114.84,0,0,114.842,0,256s114.84,256,256,256s256-114.842,256-256S397.16,0,256,0z M256,462.452 c-113.837,0-206.452-92.614-206.452-206.452S142.163,49.548,256,49.548S462.452,142.163,462.452,256S369.837,462.452,256,462.452z "/> </g> </g> <g> <g> <path d="M256,132.129c-68.302,0-123.871,55.569-123.871,123.871S187.698,379.871,256,379.871S379.871,324.302,379.871,256 S324.302,132.129,256,132.129z M256,330.323c-40.983,0-74.323-33.341-74.323-74.323c0-40.982,33.339-74.323,74.323-74.323 s74.323,33.341,74.323,74.323C330.323,296.981,296.983,330.323,256,330.323z"/> </g> </g> </svg>';
        var geolocationMapData = makeDataFromSVG(geolocationMapSVG);
        var fromSVG = '<svg xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" version="1.1" x="0px" y="0px" viewBox="0 0 37.541998 52.066015" xml:space="preserve" width="37.542" height="52.066017"><path style="fill:#33cd5f;fill-opacity:1;stroke:#000000;stroke-linecap:butt;stroke-opacity:1;stroke-linejoin:round;stroke-width:1.1;stroke-miterlimit:4;stroke-dasharray:none" d="M 18.771,0.49999809 C 8.695,0.49999809 0.5,8.6989981 0.5,18.770998 c 0,9.461 13.676,19.698 17.63,32.338 0.085,0.273 0.34,0.459 0.626,0.457 0.287,-0.004 0.538,-0.192 0.619,-0.467 3.836,-12.951 17.666,-22.856 17.667,-32.33 C 37.041,8.6989981 28.845,0.49999809 18.771,0.49999809 Z m 0,32.13099991 c -7.9,0 -14.328,-6.429 -14.328,-14.328 0,-7.9 6.428,-14.3279999 14.328,-14.3279999 7.898,0 14.327,6.4279999 14.327,14.3279999 0,7.899 -6.429,14.328 -14.327,14.328 z" /><path d="M 17.491987,32.053536 C 14.72134,31.72142 12.547927,30.865333 10.4178,29.267079 9.6776719,28.711755 8.5836331,27.649072 8.0205177,26.938505 6.3421849,24.820701 5.3150402,22.309714 5.0369017,19.644675 4.9078899,18.408524 5.0175369,16.595491 5.2991384,15.308541 6.3906811,10.320071 10.357268,6.2177124 15.313137,4.9517748 16.66082,4.6075198 17.124594,4.555504 18.821934,4.5582359 c 1.659792,0.00267 2.040614,0.044746 3.313399,0.3660747 1.747467,0.4411677 3.437805,1.2498595 4.920955,2.3542846 0.737616,0.5492649 2.161188,1.965297 2.696138,2.6818603 1.379868,1.8483245 2.2095,3.7634445 2.635509,6.0838005 0.171856,0.936055 0.186303,3.396013 0.02559,4.3577 -0.660389,3.95175 -2.829084,7.293935 -6.149548,9.4771 -1.117319,0.734624 -2.960835,1.533582 -4.244512,1.839523 -1.042011,0.248343 -1.718768,0.324734 -3.027752,0.341764 -0.715908,0.0093 -1.390786,0.0063 -1.499728,-0.0068 z" style="fill:#ff0000;fill-opacity:1;stroke:none;stroke-width:1.69799995;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" /></svg>';
        var fromData = makeDataFromSVG(fromSVG);
        var toSVG = '<svg xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" version="1.1" x="0px" y="0px" viewBox="0 0 37.541998 52.066015" xml:space="preserve" width="37.542" height="52.066017"><path style="fill:#387ef5;fill-opacity:1;stroke:#000000;stroke-linejoin:round;stroke-opacity:1;stroke-width:1.1;stroke-miterlimit:4;stroke-dasharray:none" d="M 18.771,0.49999809 C 8.695,0.49999809 0.5,8.6989981 0.5,18.770998 c 0,9.461 13.676,19.698 17.63,32.338 0.085,0.273 0.34,0.459 0.626,0.457 0.287,-0.004 0.538,-0.192 0.619,-0.467 3.836,-12.951 17.666,-22.856 17.667,-32.33 C 37.041,8.6989981 28.845,0.49999809 18.771,0.49999809 Z m 0,32.13099991 c -7.9,0 -14.328,-6.429 -14.328,-14.328 0,-7.9 6.428,-14.3279999 14.328,-14.3279999 7.898,0 14.327,6.4279999 14.327,14.3279999 0,7.899 -6.429,14.328 -14.327,14.328 z" /><path d="M 16.932297,31.971499 C 12.339831,31.3131 8.4926786,28.534608 6.4065867,24.369617 4.4054277,20.374199 4.5435059,15.479076 6.7684711,11.540162 7.6961091,9.8979402 9.2861721,8.1406588 10.851745,7.0274723 c 1.41916,-1.0090817 3.385681,-1.8583995 5.223796,-2.2560971 0.722092,-0.1562331 1.040522,-0.1773919 2.691017,-0.178811 1.665176,-0.00143 1.962502,0.018147 2.691017,0.1772014 5.586243,1.2196281 9.734526,5.4019344 10.857963,10.9470174 0.156108,0.770521 0.178715,1.109403 0.176059,2.639052 -0.0026,1.522894 -0.02641,1.863332 -0.179715,2.574017 -0.642478,2.978462 -2.08033,5.530868 -4.232971,7.514164 -1.88734,1.738867 -4.412284,2.992994 -6.933338,3.443754 -0.999688,0.178743 -3.239992,0.223263 -4.213276,0.08373 z" style="fill:#ff0000;fill-opacity:1;stroke:none;stroke-width:1.10000002;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" /></svg>';
        var toData = makeDataFromSVG(toSVG);
        var directionsMapArrowSVG = '<svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" height="575.54266" width="459.91489" id="svg4185" xml:space="preserve" viewBox="0 0 459.91486 575.54263" y="0px" x="0px" version="1.1"><metadata id="metadata4197"><rdf:RDF><cc:Work rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage" /><dc:title></dc:title></cc:Work></rdf:RDF></metadata><defs id="defs4195" /><path id="path4742" d="M 23.692352,544.60861 229.15147,32.877744 434.65268,544.71349 224.22287,421.61601 Z" style="fill:#efefef;fill-opacity:1;fill-rule:evenodd;stroke:#ffffff;stroke-width:1.22280085px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" /><path id="path4744" d="m 229.16083,174.26046 -82.44132,201.7643 164.88265,0 z" style="fill:#ff0000;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" /><path id="path4752" d="M 228.58218,32.311096 24.550304,546.22596 223.97996,422.73299 435.6822,546.22596 Z" style="fill:none;fill-rule:evenodd;stroke:#037;stroke-width:24;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" /></svg>';
        var directionsMapArrowData = makeDataFromSVG(directionsMapArrowSVG);
        arrowSquareRightSVG = '<svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" version="1.1" x="0px" y="0px" width="294" height="322.97055" viewBox="0 0 293.99999 322.97055" xml:space="preserve"><rect y="-1.3685193" x="0" height="325.70758" width="353.07797" style="fill:#ffffff;fill-opacity:0.00392157;stroke:none;stroke-width:3;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" /><path d="m 70.387038,44.185123 c 39.100002,39.100052 78.200002,78.200107 117.300002,117.300157 -39.1,39.1 -78.2,78.2 -117.300002,117.3 11.899997,11.9 23.799997,23.8 35.700002,35.7 51,-51 102,-102 153,-153 -51,-51.00003 -102,-102.000052 -153,-153.0000776 C 94.187035,20.385176 82.287035,32.285149 70.387038,44.185123 Z" style="fill:#45f7f7;fill-opacity:1;stroke:none;stroke-width:12;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" /></svg>';
        arrowSquareRightData = makeDataFromSVG(arrowSquareRightSVG);
        arrowSmallRightSVG = '<svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" version="1.1" x="0px" y="0px" width="320" height="322.97055" viewBox="0 0 320 322.97055" xml:space="preserve"><rect style="fill:#ffffff;fill-opacity:0.00392157;stroke:none;stroke-width:3;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" width="314.75943" height="325.70758" x="0" y="-1.3685194" /><path d="M 160.31665,162.8538 60.925903,283.00934 309.72225,161.48528 62.294422,46.803742 Z" style="fill:#45f7f7;fill-opacity:1;stroke:none;stroke-width:12;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" /></svg>';
        arrowSmallRightData = makeDataFromSVG(arrowSmallRightSVG);
        measuringSVG = '<svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 80.853 80.854" style="enable-background:new 0 0 80.853 80.854;" xml:space="preserve"> <g> <path stroke="null" d="m76.442612,40.437309c0,-0.127323 -0.054695,-0.231339 -0.068146,-0.353287c-0.024208,-2.757259 -0.234032,-5.544113 -0.716438,-8.319305c-2.197739,-12.695959 -8.09066,-22.629272 -16.184906,-27.25609c-0.36853,-0.216098 -0.800728,-0.330872 -1.248165,-0.330872l-29.184824,0c-1.140566,0 -2.136765,0.763066 -2.428185,1.868661c-0.288727,1.100215 0.197268,2.260507 1.182709,2.820925c5.40423,3.096202 9.761152,9.528916 12.250311,17.702962l-16.678967,0c-0.494961,0 -0.92626,0.179335 -1.319899,0.427713c-1.59697,-0.060974 -3.21546,0.260033 -4.764009,1.035652c-8.132799,4.052952 -12.871703,16.671795 -10.797704,28.722145c1.51896,8.798126 5.70372,15.515091 11.471105,18.440926c1.952948,0.989922 4.018875,1.479507 6.103634,1.479507c0.95047,0 1.90453,-0.106705 2.853205,-0.31205l31.595972,-0.94957c0.364048,-0.009865 0.720924,-0.102219 1.043724,-0.264519c10.163761,-5.087708 16.754292,-19.223713 16.817059,-34.381027c0.026894,-0.111191 0.073524,-0.214306 0.073524,-0.331772zm-48.30722,30.224968c-0.617805,0.308456 -1.232922,0.540688 -1.839968,0.716446l-2.054272,0.058273c-0.326387,0.009865 -0.642015,0.088776 -0.928949,0.210724c-1.040138,-0.102219 -2.066826,-0.407089 -3.081858,-0.921776c-4.274427,-2.164566 -7.560724,-7.698814 -8.793646,-14.808514c-1.659736,-9.651764 2.0471,-20.357109 8.093348,-23.372612c1.446329,-0.719131 2.872932,-0.728096 4.233179,-0.041248c2.482882,1.260719 4.406239,4.563156 5.140612,8.835793c1.105595,6.408501 -1.526133,12.404537 -4.686895,13.979088c-0.674297,0.33894 -1.277756,0.348804 -1.896458,0.034073c-1.027584,-0.520065 -2.30534,-2.105381 -2.806578,-4.994453c-0.612427,-3.551708 0.817762,-7.133907 2.50709,-7.97678c1.245476,-0.618702 1.752094,-2.125107 1.134287,-3.366993c-0.618702,-1.243683 -2.130487,-1.752098 -3.3661,-1.133392c-3.883478,1.928734 -6.179852,7.787579 -5.224897,13.330795c0.703886,4.078056 2.707047,7.222679 5.497484,8.635834c2.034546,1.030273 4.310295,1.020409 6.401333,-0.028698c5.541418,-2.758156 8.792746,-11.252316 7.395735,-19.336693c-0.616909,-3.577717 -1.965502,-6.554661 -3.763327,-8.871658l11.199411,0c0.062767,0.346115 0.154228,0.672504 0.215199,1.025791c2.754574,15.901554 -3.250427,32.961609 -13.374729,38.026001zm29.647507,-0.251076l-21.750534,0.661743c8.598171,-8.36055 13.065388,-24.115047 10.436348,-39.308228c-1.612213,-9.363928 -5.245522,-17.226831 -10.288395,-22.562917l21.353306,0c3.383137,2.104486 6.327801,5.546803 8.645699,9.882203l-14.234642,0c-1.379978,0 -2.511574,1.126219 -2.511574,2.511574c0,1.387148 1.131596,2.51247 2.511574,2.51247l16.47094,0c0.971092,2.642488 1.770927,5.481346 2.286507,8.511196c0.313835,1.758369 0.467171,3.531982 0.564003,5.306496l-14.928665,0c-1.380871,0 -2.51247,1.126217 -2.51247,2.51157c0,1.383568 1.131599,2.511578 2.51247,2.511578l14.899979,0c-0.263618,4.917336 -1.256241,9.627548 -2.875626,13.817688l-16.427002,0c-1.379078,0 -2.51247,1.128014 -2.51247,2.51247c0,1.38356 1.133392,2.512466 2.51247,2.512466l14.014961,0c-2.190563,3.787537 -4.928104,6.862221 -8.166878,8.61969z"/> </g> </svg>';
        dustBinSVG = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="729.837px" height="729.838px" viewBox="0 0 729.837 729.838" style="enable-background:new 0 0 729.837 729.838;" xml:space="preserve"> <g> <path d="M589.193,222.04c0-6.296,5.106-11.404,11.402-11.404S612,215.767,612,222.04v437.476c0,19.314-7.936,36.896-20.67,49.653 c-12.733,12.734-30.339,20.669-49.653,20.669H188.162c-19.315,0-36.943-7.935-49.654-20.669 c-12.734-12.734-20.669-30.313-20.669-49.653V222.04c0-6.296,5.108-11.404,11.403-11.404c6.296,0,11.404,5.131,11.404,11.404 v437.476c0,13.02,5.37,24.922,13.97,33.521c8.6,8.601,20.503,13.993,33.522,13.993h353.517c13.019,0,24.896-5.394,33.498-13.993 c8.624-8.624,13.992-20.503,13.992-33.498V222.04H589.193z"/> <path d="M279.866,630.056c0,6.296-5.108,11.403-11.404,11.403s-11.404-5.107-11.404-11.403v-405.07 c0-6.296,5.108-11.404,11.404-11.404s11.404,5.108,11.404,11.404V630.056z"/> <path d="M376.323,630.056c0,6.296-5.107,11.403-11.403,11.403s-11.404-5.107-11.404-11.403v-405.07 c0-6.296,5.108-11.404,11.404-11.404s11.403,5.108,11.403,11.404V630.056z"/> <path d="M472.803,630.056c0,6.296-5.106,11.403-11.402,11.403c-6.297,0-11.404-5.107-11.404-11.403v-405.07 c0-6.296,5.107-11.404,11.404-11.404c6.296,0,11.402,5.108,11.402,11.404V630.056L472.803,630.056z"/> <path d="M273.214,70.323c0,6.296-5.108,11.404-11.404,11.404c-6.295,0-11.403-5.108-11.403-11.404 c0-19.363,7.911-36.943,20.646-49.677C283.787,7.911,301.368,0,320.73,0h88.379c19.339,0,36.92,7.935,49.652,20.669 c12.734,12.734,20.67,30.362,20.67,49.654c0,6.296-5.107,11.404-11.403,11.404s-11.403-5.108-11.403-11.404 c0-13.019-5.369-24.922-13.97-33.522c-8.602-8.601-20.503-13.994-33.522-13.994h-88.378c-13.043,0-24.922,5.369-33.546,13.97 C278.583,45.401,273.214,57.28,273.214,70.323z"/> <path d="M99.782,103.108h530.273c11.189,0,21.405,4.585,28.818,11.998l0.047,0.048c7.413,7.412,11.998,17.628,11.998,28.818 v29.46c0,6.295-5.108,11.403-11.404,11.403h-0.309H70.323c-6.296,0-11.404-5.108-11.404-11.403v-0.285v-29.175 c0-11.166,4.585-21.406,11.998-28.818l0.048-0.048C78.377,107.694,88.616,103.108,99.782,103.108L99.782,103.108z M630.056,125.916H99.782c-4.965,0-9.503,2.02-12.734,5.274L87,131.238c-3.255,3.23-5.274,7.745-5.274,12.734v18.056h566.361 v-18.056c0-4.965-2.02-9.503-5.273-12.734l-0.049-0.048C639.536,127.936,635.021,125.916,630.056,125.916z"/> </g> </svg>';
        //downloadSVG = '<svg width="29.978" height="29.978" xmlns="http://www.w3.org/2000/svg"> <g> <path stroke="null" d="m24.494501,18.724583l0,6.215084l-19.011004,0l0,-6.215084l-3.653903,0l0,8.042036c0,1.008316 0.816819,1.826044 1.829675,1.826044l22.659461,0c1.01195,0 1.829676,-0.81682 1.829676,-1.826044l0,-8.042036l-3.653904,0z"/> <path stroke="null" d="m14.654558,18.108339l-5.231272,-6.32127c0,0 -0.795944,-0.751473 0.067162,-0.751473s2.947808,0 2.947808,0s0,-0.50552 0,-1.285129c0,-2.222653 0,-6.267723 0,-7.916789c0,0 -0.117078,-0.448343 0.55816,-0.448343c0.680682,0 3.662069,0 4.149439,0c0.486462,0 0.475569,0.377552 0.475569,0.377552c0,1.59915 0,5.783985 0,7.934033c0,0.697019 0,1.148993 0,1.148993s1.671757,0 2.720915,0c1.047344,0 0.258661,0.786869 0.258661,0.786869s-4.450758,5.908321 -5.071538,6.528194c-0.446527,0.449251 -0.874904,-0.052637 -0.874904,-0.052637z"/> </g> </svg>';
        downloadSVG = '<svg xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" version="1.1" x="0px" y="0px" viewBox="0 0 29.978 29.978" > <path stroke="null" d="m 24.494501,18.724583 0,6.215084 -19.011004,0 0,-6.215084 -3.653903,0 0,8.042036 c 0,1.008316 0.816819,1.826044 1.829675,1.826044 l 22.659461,0 c 1.01195,0 1.829676,-0.81682 1.829676,-1.826044 l 0,-8.042036 -3.653904,0 z" /> <path stroke="null" d="m 14.654558,20.108339 -5.231272,-6.32127 c 0,0 -0.795944,-0.751473 0.067162,-0.751473 0.863106,0 2.947808,0 2.947808,0 0,0 0,-0.50552 0,-1.285129 0,-2.222653 0,-6.267723 0,-7.916789 0,0 -0.117078,-0.448343 0.55816,-0.448343 0.680682,0 3.662069,0 4.149439,0 0.486462,0 0.475569,0.377552 0.475569,0.377552 0,1.59915 0,5.783985 0,7.934033 0,0.697019 0,1.148993 0,1.148993 0,0 1.671757,0 2.720915,0 1.047344,0 0.258661,0.786869 0.258661,0.786869 0,0 -4.450758,5.908321 -5.071538,6.528194 -0.446527,0.449251 -0.874904,-0.05264 -0.874904,-0.05264 z" /> </svg>';
        layersSVG = '<svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" enable-background="new 0 0 12 12" viewBox="0 0 12 12" y="0px" x="0px" version="1.1"><path style="" d="M 6,6 0,3 6,0 12,3 6,6 Z M 6,7.102 2.297,5.25 0,6 6,9 12,6 9.891,5.203 6,7.102 Z m 0,3 L 2.297,8.25 0,9 6,12 12,9 9.891,8.203 6,10.102 Z" /></svg>';
        busSVG = '<svg xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" version="1.1" style="" viewBox="0 0 36.195457 39.516697" height="40px" width="36px" y="0" x="0" > <g transform="translate(-4.617,-3.543)" > <path d="M 38.959923,13.213912 C 38.650508,10.991005 38.563146,8.5764759 37.310921,6.641368 35.36833,4.8576827 32.569062,4.5648379 30.076842,4.1029589 24.055082,3.3335673 17.856288,3.2476921 11.900967,4.5459668 9.9990492,5.0084702 7.6231346,5.7758159 7.265452,8.007119 6.7944666,9.7082842 6.5885076,11.467905 6.404925,13.219128 c -1.608175,0.139478 -1.8889475,1.850618 -1.761139,3.14856 0.1052295,1.276826 -0.2817203,2.670636 0.3670487,3.833082 1.7260712,0.979844 0.5588763,3.29833 0.8614473,4.992758 0.025404,4.133446 -0.043047,8.300214 0.4620345,12.40219 0.3705824,1.317238 1.860401,0.863544 2.8778727,0.940007 0.3353234,0.318875 0.044906,1.263491 0.1421648,1.820431 -0.2835179,1.450392 0.904532,2.808452 2.400052,2.697158 1.524145,0.114802 2.690639,-1.279576 2.401791,-2.743857 0.132241,-0.530392 -0.271832,-1.597099 0.214168,-1.773732 5.878468,0 11.756935,0 17.635403,0 0.112295,1.22968 -0.30603,2.604211 0.409905,3.685926 1.294617,1.58302 4.675897,0.817738 4.391067,-1.483858 0,-0.734022 0,-1.468045 0,-2.202068 1.796426,0.455141 3.100565,-0.7801 2.566298,-2.622925 0.06559,-4.989054 0.146241,-9.97963 0.02239,-14.968479 1.486068,-0.405159 1.448867,-2.049382 1.396919,-3.284491 -0.127361,-1.372334 0.432771,-3.058416 -0.802022,-4.059576 -0.298387,-0.221692 -0.659819,-0.356985 -1.030401,-0.386342 z m -25.40613,-6.00665 c 6.008098,0 12.016196,0 18.024294,0 0,0.9089657 0,1.8179313 0,2.726897 -6.008098,0 -12.016196,0 -18.024294,0 0,-0.9089657 0,-1.8179313 0,-2.726897 z m 0.257304,28.222559 c -2.080584,0.108147 -3.383411,-2.654906 -1.976877,-4.191541 1.23379,-1.662539 4.173148,-0.933343 4.487413,1.112844 0.35746,1.536857 -0.932524,3.120253 -2.510536,3.078697 z m 17.670501,0 c -2.080337,0.108007 -3.386455,-2.654626 -1.977908,-4.191541 1.23421,-1.662026 4.173671,-0.934052 4.487618,1.112844 0.357733,1.536783 -0.931773,3.12 -2.50971,3.078697 z m 3.257156,-11.21357 c -8.115208,0 -16.230415,0 -24.345623,0 0,-4.256521 0,-8.513043 0,-12.769564 8.115208,0 16.230415,0 24.345623,0 0,4.256521 0,8.513043 0,12.769564 z" /> </g> </svg>';
        busStopSVG = '<svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" width="19.6" height="30.043739" viewBox="0 0 19.6 30.043739" version="1.1" > <path style="fill-rule:evenodd;stroke:none;stroke-width:1" d="m 8.4,29.089729 0,-0.453553 0,-7.153255 C 3.6507882,20.799928 0,16.693477 0,11.729729 0,6.7659823 3.6507882,2.6595312 8.4,1.9765376 l 0,-0.56897 C 8.4,0.6301895 9.026801,0 9.8,0 c 0.773199,0 1.4,0.6301895 1.4,1.4075676 l 0,0.56897 c 4.749212,0.6829936 8.4,4.7894447 8.4,9.7531914 0,4.963748 -3.650788,9.070199 -8.4,9.753192 l 0,7.153255 0,0.453553 2.8,0 0.466667,0 0,0.938379 -0.466667,0 -2.8,0 0,0.01563 -2.8,0 0,-0.01563 -2.8,0 -0.4666667,0 0,-0.938379 0.4666667,0 2.8,0 z" /> <ellipse style="fill:#ffffff;fill-rule:evenodd;stroke:none;stroke-width:1" ry="7.037838" rx="7" cy="11.72973" cx="9.8000002" /> </svg>';
        var busSVGFillBlue = '<svg xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" version="1.1" style="fill:#00519e" viewBox="0 0 36.195457 39.516697" height="40px" width="36px" y="0" x="0" > <g transform="translate(-4.617,-3.543)" > <path d="M 38.959923,13.213912 C 38.650508,10.991005 38.563146,8.5764759 37.310921,6.641368 35.36833,4.8576827 32.569062,4.5648379 30.076842,4.1029589 24.055082,3.3335673 17.856288,3.2476921 11.900967,4.5459668 9.9990492,5.0084702 7.6231346,5.7758159 7.265452,8.007119 6.7944666,9.7082842 6.5885076,11.467905 6.404925,13.219128 c -1.608175,0.139478 -1.8889475,1.850618 -1.761139,3.14856 0.1052295,1.276826 -0.2817203,2.670636 0.3670487,3.833082 1.7260712,0.979844 0.5588763,3.29833 0.8614473,4.992758 0.025404,4.133446 -0.043047,8.300214 0.4620345,12.40219 0.3705824,1.317238 1.860401,0.863544 2.8778727,0.940007 0.3353234,0.318875 0.044906,1.263491 0.1421648,1.820431 -0.2835179,1.450392 0.904532,2.808452 2.400052,2.697158 1.524145,0.114802 2.690639,-1.279576 2.401791,-2.743857 0.132241,-0.530392 -0.271832,-1.597099 0.214168,-1.773732 5.878468,0 11.756935,0 17.635403,0 0.112295,1.22968 -0.30603,2.604211 0.409905,3.685926 1.294617,1.58302 4.675897,0.817738 4.391067,-1.483858 0,-0.734022 0,-1.468045 0,-2.202068 1.796426,0.455141 3.100565,-0.7801 2.566298,-2.622925 0.06559,-4.989054 0.146241,-9.97963 0.02239,-14.968479 1.486068,-0.405159 1.448867,-2.049382 1.396919,-3.284491 -0.127361,-1.372334 0.432771,-3.058416 -0.802022,-4.059576 -0.298387,-0.221692 -0.659819,-0.356985 -1.030401,-0.386342 z m -25.40613,-6.00665 c 6.008098,0 12.016196,0 18.024294,0 0,0.9089657 0,1.8179313 0,2.726897 -6.008098,0 -12.016196,0 -18.024294,0 0,-0.9089657 0,-1.8179313 0,-2.726897 z m 0.257304,28.222559 c -2.080584,0.108147 -3.383411,-2.654906 -1.976877,-4.191541 1.23379,-1.662539 4.173148,-0.933343 4.487413,1.112844 0.35746,1.536857 -0.932524,3.120253 -2.510536,3.078697 z m 17.670501,0 c -2.080337,0.108007 -3.386455,-2.654626 -1.977908,-4.191541 1.23421,-1.662026 4.173671,-0.934052 4.487618,1.112844 0.357733,1.536783 -0.931773,3.12 -2.50971,3.078697 z m 3.257156,-11.21357 c -8.115208,0 -16.230415,0 -24.345623,0 0,-4.256521 0,-8.513043 0,-12.769564 8.115208,0 16.230415,0 24.345623,0 0,4.256521 0,8.513043 0,12.769564 z" /> </g> </svg>';
        var busData = makeDataFromSVG(busSVGFillBlue);
        var imgSrcs = [redMarkerData, loadingData, mapMarker1Data, mapMarkerSearchData, tapData, geolocationMapData, fromData, toData,
            directionsMapArrowData, arrowSquareRightData, arrowSmallRightData, busData, busPNGData
        ];
        new tf.dom.ImgsPreLoader({ imgSrcs: imgSrcs, onAllLoaded: onImagesCreated });
    }
    function createRippleClasses() {
        var styleCreator = new tf.dom.StyleSheet({}), cssStyles = [], rippleClasses = {};
        createRippleClass(rippleClasses, "ripple", "#000");
        createRippleClass(rippleClasses, "rippleWhite", "#fff");
        for (var i in rippleClasses) { var cssStr = rippleClasses[i], cssName = '.' + i; cssStyles.push({ styleName: cssName, inherits: cssStr }); }
        styleCreator.AddStyles(cssStyles);
        //console.log(JSON.stringify(styleCreator.GetAllRules()[".ripple:active::after"]));
    }
    function createRippleClass(addToCSSClasses, tagName, endColor) {
        addToCSSClasses[tagName] = { position: "relative", overflow: "hidden", transform: "translate3d(0, 0, 0)" };
        addToCSSClasses[tagName + ":active::after"] = { transform: "scale(0, 0)", opacity: ".2", transition: "0s" };
        addToCSSClasses[tagName + "::after"] = {
            content: "", display: "block", position: "absolute", width: "100%", height: "100%", top: "0", left: "0", pointerEvents: "none",
            backgroundImage: "radial-gradient(circle, " + endColor + " 10%,transparent 10.01%)",
            backgroundRepeat: "no-repeat", backgroundPosition: "50%",
            transform: "scale(10, 10)", opacity: "0", transition: "transform .5s,opacity 1s"
        };
    }
    function calcLayoutSettings() {
        tf.TFMap.LayoutSettings = isSmallScreen ?
            tf.js.ShallowMerge(tf.TFMap.LayoutSettings, tf.TFMap.LayoutSettingsNormal, tf.TFMap.SmallLayoutSettings) :
            tf.js.ShallowMerge(tf.TFMap.LayoutSettings, tf.TFMap.LayoutSettingsNormal);
    }
    function notify(eventName, props) { allEventDispatchers.Notify(eventName, tf.js.ShallowMerge(props, { sender: theThis, eventName: eventName })); }
    function initialize() {
        minNonSmallScreenWidthAddValue = 0;
        minNonSmallScreenWidth = 620;
        minNonSmallScreenHeight = 500;
        if (settings.sidePanelWidthInt != undefined) { minNonSmallScreenWidth += settings.sidePanelWidthInt; }
        layoutChangeEventName = "layoutChange";
        allEventDispatchers = new tf.events.MultiEventNotifier({ eventNames: [layoutChangeEventName] });
        isSmallScreen = theThis.CheckIsSmallScreen();
        calcLayoutSettings();
        createImages();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: togglebutton.js
tf.TFMap.ToggleButton = function(settings) {
    var theThis, classToggled, classNotToggled, button, autoToggle, isToggled, onClickCB, onHoverCB;
    var hoverListener;
    this.GetButton = function() { return button; }
    this.GetIsToggled = function() { return isToggled; }
    this.SetIsToggled = function(bool) { return setIsToggled(bool); }
    this.SetClassToggled = function(newClassToggled) {
        if (isToggled) { tf.dom.ReplaceCSSClassCondition(button, true, newClassToggled, classToggled); }
        classToggled = newClassToggled;
    }
    this.SetClassNotToggled = function(newClassNotToggled) {
        if (!isToggled) { tf.dom.ReplaceCSSClassCondition(button, true, newClassNotToggled, classNotToggled); }
        classNotToggled = newClassNotToggled;
    }
    function setCSSClasses() {
        tf.dom.ReplaceCSSClassCondition(button, isToggled, classToggled, classNotToggled);
    }
    function setIsToggled(bool) {
        if (isToggled != (bool = !!bool)) {
            isToggled = bool;
            setCSSClasses();
        }
    }
    function onClickToggleButton(event) { if (!!autoToggle) { setIsToggled(!isToggled); } if (!!onClickCB) { onClickCB({ sender: theThis }); } }
    function onHoverToggleButton(notification) { onHoverCB({ sender: theThis, notification: notification }); }
    function initialize() {
        onClickCB = tf.js.GetFunctionOrNull(settings.onClick);
        onHoverCB = tf.js.GetFunctionOrNull(settings.onHover);
        autoToggle = settings.autoToggle != undefined ? !!settings.autoToggle : true;
        classToggled = settings.classToggled;
        classNotToggled = settings.classNotToggled;
        button = document.createElement('button');
        button.className = settings.buttonClassName;
        if (tf.js.GetIsNonEmptyString(settings.svgHTML)) {
            button.innerHTML = settings.svgHTML;
        }
        var isToggleInit = settings.isToggled != undefined ? !!settings.isToggled : false;
        isToggled = !isToggleInit;
        setIsToggled(isToggleInit);
        button.addEventListener("click", onClickToggleButton);
        if (!!onHoverCB) { hoverListener = new tf.events.DOMHoverListener({ target: button, callBack: onHoverToggleButton, optionalScope: theThis, callBackSettings: null }); }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: iconbutton.js
tf.TFMap.IconButton = function(settings) {
    var theThis, button, onClickCB, onHoverCB;
    var hoverListener;
    this.GetSettings = function() { return settings; }
    this.GetButton = function() { return button; }
    function onClickButton(event) { onClickCB({ sender: theThis, event: event }); }
    function onHoverButton(notification) { onHoverCB({ sender: theThis, notification: notification }); }
    function initialize() {
        onClickCB = tf.js.GetFunctionOrNull(settings.onClick);
        onHoverCB = tf.js.GetFunctionOrNull(settings.onHover);
        button = document.createElement('button');
        button.className = tf.js.GetNonEmptyString(settings.cssClass, "");
        if (tf.js.GetIsNonEmptyString(settings.svgHTML)) { button.innerHTML = settings.svgHTML; }
        if (!!onClickCB) { button.addEventListener("click", onClickButton); }
        if (!!onHoverCB) { hoverListener = new tf.events.DOMHoverListener({ target: button, callBack: onHoverButton, optionalScope: theThis, callBackSettings: null }); }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: mapfeaturepropsdisplayer.js
tf.TFMap.MapFeaturePropsDisplayer = function(settings) {
    var theThis, cssTag, map, wrapper, propsContent, coordsButton, toolBar, toolBarAdditionalButtons, isVisible, lastMapFeature, closeButton, directionsButton, toast;
    var wrapperClassName, visibleClassName, hiddenClassName;
    var propsTextButtonClassName, mapFeaturePropsImageClassName, mapFeaturePropsImageWrapperClassName;
    var toolBarClassName, contentClassName;
    var allEventDispatchers, visibilityChangeEventName;
    this.AddVisibilityChangeListener = function (callBack) { allEventDispatchers.AddListener(visibilityChangeEventName, callBack); }
    this.OnPostCompose = function(notification) {
        if (!!lastMapFeature) {
            var props = lastMapFeature.GetSettings();
            if (tf.js.GetFunctionOrNull(props.onPostCompose)) {
                props.onPostCompose({ sender: theThis, pcNotification: notification, lastMapFeature: lastMapFeature, props: props });
            }
        }
    }
    this.GetCSSClasseNames = function() { return { visibleClassName: visibleClassName, hiddenClassName: hiddenClassName }; }
    this.CreateMapFeaturePropsSpan = function(spanClass, innerHTML, color) {
        var styleStr = "";
        if (color != undefined) {
            //console.log('color specified');
            styleStr = ' style="background-color:' + color + ';"';
        }
        return '<span class="' + spanClass + '" ' + styleStr + '> ' + innerHTML + '</span> ';
    };
    this.CreateMapFeatureTitleSpan = function(innerHTML, color) { return theThis.CreateMapFeaturePropsSpan(titleClassName, innerHTML, color); };
    this.CreateMapFeatureTextSpan = function(innerHTML) { return theThis.CreateMapFeaturePropsSpan(textClassName, innerHTML); };
    this.CreateMapFeatureImageDiv = function(imageSrc) {
        var urlStr = "url('" + imageSrc + "')";
        var backgroundStr = "background: " + urlStr + " center/100% no-repeat;";
        var styleStr = 'style="' + backgroundStr + 'background-size:contain;"';
        return '<div class="' + mapFeaturePropsImageWrapperClassName + '"><div class="' + mapFeaturePropsImageClassName + '" ' + styleStr + '>' + '</div></div>';
    };
    this.GetMapFeaturePropsTextButtonClass = function() { return propsTextButtonClassName; };
    this.GetWrapper = function() { return wrapper; }
    this.GetIsVisible = function() { return isVisible; }
    this.RefreshProps = function(mapFeature) { return refreshProps(mapFeature); }
    this.ShowProps = function(mapFeature) { return showProps(mapFeature); }
    this.GetLastMapFeature = function() { return lastMapFeature; }
    this.Hide = function() { return setDisplayVisible(false); }
    function createSpan(spanClass, spanText) { return '<span class="' + spanClass + '">' + spanText + '</span>' }
    function showLastMapFeatureProps() {
        var props = lastMapFeature.GetSettings();
        if (tf.js.GetFunctionOrNull(props.getDisplayProps)) {
            if (tf.js.GetFunctionOrNull(props.onPrepareForPropsDisplay)) {
                props.onPrepareForPropsDisplay(lastMapFeature);
            }
            var displayProps = props.getDisplayProps(lastMapFeature);
            var coords = lastMapFeature.GetPointCoords()
            props.coords = coords;
            propsContent.GetHTMLElement().innerHTML = displayProps.innerHTML;
            if (!!coords) {
                var coordsHTML = coords[1].toFixed(5) + ', ' + coords[0].toFixed(5);
                coordsButton.GetButton().innerHTML = coordsHTML;
                coordsButton.GetButton().style.display = 'block';
            }
            else { coordsButton.GetButton().style.display = 'none'; }
            if (!!props.addButtons) {
                var appContent = settings.appContent;
                var buttonSettings = getToolBarButtonSettings();
                var nButtonsAdd = props.addButtons.length;
                for (var i = 0; i < nButtonsAdd; ++i) {
                    var addButton = props.addButtons[i];
                    var button = appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, addButton));
                    if (tf.js.GetIsNonEmptyString(addButton.buttonText)) {
                        button.GetButton().innerHTML = addButton.buttonText;
                    }
                    toolBarAdditionalButtons.AddContent(button.GetButton());
                }
            }
        }
    }
    function refreshProps(mapFeature) { if (!!lastMapFeature && lastMapFeature == mapFeature) { showLastMapFeatureProps(); } }
    function showProps(mapFeature) {
        setDisplayVisible(false);
        if (!!(lastMapFeature = mapFeature)) {
            var props = lastMapFeature.GetSettings();
            if (tf.js.GetFunctionOrNull(props.getDisplayProps)) { showLastMapFeatureProps(); setDisplayVisible(true); }
            else { lastMapFeature = undefined; }
        }
    }
    function renderMap() { settings.appContent.GetMap().Render(); }
    function setDisplayVisible(bool) {
        var appContent = settings.appContent;
        isVisible = !!bool;
        tf.dom.ReplaceCSSClassCondition(appContent.GetRootDiv(), isVisible, visibleClassName, hiddenClassName);
        if (!isVisible) {
            toolBarAdditionalButtons.ClearContent();
            propsContent.GetHTMLElement().scrollTop = "0px";
            if (!!lastMapFeature) {
                var props = lastMapFeature.GetSettings();
                var lastMapFeatureSaved = lastMapFeature;
                if (!!props.additionalFeatures) {
                    for (var i in props.additionalFeatures) {
                        settings.additionalFeaturesLayer.DelMapFeature(props.additionalFeatures[i], true);
                    }
                    settings.additionalFeaturesLayer.DelWithheldFeatures();
                }
                if (!!props.bottomContent) {
                    appContent.SetBottomPaneUp(false);
                }
                lastMapFeature = undefined;
                if (tf.js.GetFunctionOrNull(props.onPostCompose)) { renderMap(); }
                if (tf.js.GetFunctionOrNull(props.onClose)) { props.onClose(lastMapFeatureSaved); }
                appContent.OnCloseMapFeatureProps();
            }
        }
        else {
            var props = lastMapFeature.GetSettings();
            if (!!props.additionalFeatures) {
                for (var i in props.additionalFeatures) {
                    settings.additionalFeaturesLayer.AddMapFeature(props.additionalFeatures[i], true);
                }
                settings.additionalFeaturesLayer.AddWithheldFeatures();
            }
            if (!!props.bottomContent) {
                appContent.SetBottomContent(props.bottomContentType, props.bottomContent);
            }
            if (tf.js.GetFunctionOrNull(props.onPostCompose)) { renderMap(); }
        }
        notifyVisibilityChange();
    }
    function closeLastToast() { if (!!toast) { toast.Close(); toast = undefined; } }
    function showToast(str, timeout) {
        closeLastToast();
        var toaster = settings.appContent.GetToaster();
        if (!!toaster) {
            if (timeout == undefined) { timeout = 0; }
            toast = toaster.Toast({ text: str, timeout: timeout });
        }
    }
    function onButtonClicked(notification) {
        var button = notification.sender;
        if (!tf.js.GetFunctionOrNull(notification.sender.GetSettings)) {
            button = notification.toolTipSender;
        }
        var appContent = settings.appContent;
        var map = appContent.GetMap();
        switch (button) {
            case directionsButton:
                appContent.SetDirectionsTargetToMapFeature(lastMapFeature);
                break;
            case closeButton:
                setDisplayVisible(false);
                break;
            case coordsButton:
                if (!!lastMapFeature) { appContent.AnimatedSetCenterIfDestVisible(lastMapFeature.GetPointCoords()); }
                break;
            default:
                if (!!lastMapFeature) {
                    var props = lastMapFeature.GetSettings();
                    if (!!props && tf.js.GetFunctionOrNull(props.onClick)) { props.onClick(notification); }
                }
                break;
        }
    }
    function getToolBarButtonSettings() {
        var delayMillis = tf.TFMap.toolTipDelayMillis;
        var toolTipClass = "*start";
        var toolTipArrowClass = "top";
        var buttonSettings = {
            onClick: onButtonClicked, onHover: undefined, wrapper: wrapper, delayMillis: delayMillis,
            toolTipClass: toolTipClass, toolTipArrowClass: toolTipArrowClass,
            offsetY: -9
        };
        return buttonSettings;
    }
    function createControl() {
        var appContent = settings.appContent;
        var mapDiv = appContent.GetMapDiv();
        var rootDiv = appContent.GetRootDiv();
        var customizedScrollBarClassName = tf.TFMap.LayoutSettings.customizedScrollBarClassName;
        wrapper = new tf.dom.Div({ cssClass: wrapperClassName });
        toolBar = new tf.dom.Div({ cssClass: toolBarClassName });
        propsContent = new tf.dom.Div({ cssClass: contentClassName + " " + customizedScrollBarClassName });
        var buttonSettings = getToolBarButtonSettings();
        closeButton = appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, { buttonClass: closeButtonClassName + " ripple", toolTipText: "Close" }));
        directionsButton = appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, { buttonClass: directionsButtonClassName + " ripple", toolTipText: "Get Directions" }));
        var coordsWrapper = new tf.dom.Div({ cssClass: coordsButtonWrapperClassName });
        //buttonSettings.wrapper = coordsWrapper;
        buttonSettings.toolTipClass = "*center";
        buttonSettings.toolTipArrowClass = "right";
        coordsButton = appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, { buttonClass: coordsButtonClassName + " ripple", toolTipText: "Center Map to Location" }));
        toolBarAdditionalButtons = new tf.dom.Div({ cssClass: additionalButtonsClassName })
        coordsWrapper.AddContent(coordsButton.GetButton());
        toolBar.AddContent(closeButton.GetButton(), directionsButton.GetButton(), toolBarAdditionalButtons);
        wrapper.AddContent(toolBar, propsContent, coordsWrapper);
    }
    var coordsButtonWrapperClassName, coordsButtonClassName, additionalButtonsClassName, closeButtonClassName, directionsButtonClassName, titleClassName, textClassName;
    function createCSSClassNames() {
        wrapperClassName = tf.TFMap.CreateClassName(cssTag, "Wrapper");
        visibleClassName = tf.TFMap.CreateClassName(cssTag, "WrapperVisible");
        hiddenClassName = tf.TFMap.CreateClassName(cssTag, "WrapperHidden");
        toolBarClassName = tf.TFMap.CreateClassName(cssTag, "ToolBar");
        contentClassName = tf.TFMap.CreateClassName(cssTag, "Content");
        coordsButtonWrapperClassName = tf.TFMap.CreateClassName(cssTag, "CoordsButtonWrapper");
        coordsButtonClassName = tf.TFMap.CreateClassName(cssTag, "CoordsButton");
        additionalButtonsClassName = tf.TFMap.CreateClassName(cssTag, "AdditionalButtons");
        closeButtonClassName = tf.TFMap.CreateClassName(cssTag, "CloseButton");
        directionsButtonClassName = tf.TFMap.CreateClassName(cssTag, "DirectionsButton");
        textClassName = tf.TFMap.CreateClassName(cssTag, "Text");
        titleClassName = tf.TFMap.CreateClassName(cssTag, "Title");
        propsTextButtonClassName = tf.TFMap.CreateClassName(cssTag, "TextButton");
        mapFeaturePropsImageClassName = tf.TFMap.CreateClassName(cssTag, "PropsImage");
        mapFeaturePropsImageWrapperClassName = tf.TFMap.CreateClassName(cssTag, "PropsImageWrapper");
    }
    function createCSSClasses() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var cssClasses = [];
        var ls = tf.TFMap.LayoutSettings;
        var minWidthPropsDisplayerInt = ls.minWidthPropsDisplayerInt, minWidthPropsDisplayerPx = minWidthPropsDisplayerInt + 'px';
        var maxFeaturePropsDisplayHeightInt = ls.maxFeaturePropsDisplayHeightInt, maxFeaturePropsDisplayHeightPx = maxFeaturePropsDisplayHeightInt + 'px';
        var propsToolBarButtonWidthInt = ls.propsToolBarButtonWidthInt, propsToolBarButtonWidthPx = propsToolBarButtonWidthInt + 'px';
        var lightBackground = ls.lightBackground;
        var lightBackgroundHalfOpaque = ls.lightBackgroundHalfOpaque;
        var darkTextColor = ls.darkTextColor, darkTextShadow = ls.darkTextShadow;
        cssClasses[wrapperClassName] = {
            inherits: [CSSClasses.borderRadius2px, CSSClasses.transitionPoint2s, CSSClasses.cursorDefault, CSSClasses.pointerEventsAll,
            CSSClasses.noMarginNoBorderNoPadding, CSSClasses.positionAbsolute, CSSClasses.displayFlex],
            flexFlow: "column nowrap",
            boxShadow: "rgba(0, 0, 0, 0.1) -4px 4px 10px",
            maxHeight: ls.CSSLiteralMaxHeightMapFeaturePropsDisplayer,
            //background: "rgba(0,0,0,0.2)",
            zIndex: '' + (ls.rootDivZIndex + ls.mapFeaturePropsDisplayerWrapperZIndexAdd),
            borderRadius: '2px',
            fontSize: ls.propsDisplayerWrapperFontSizeInt + "px",
            lineHeight: ls.propsDisplayerWrapperLineHeightInt + "px",
            maxWidth: ls.propsDisplayerWrapperMaxWidthInt + "px"
        };
        cssClasses[visibleClassName + " ." + wrapperClassName] = {
            inherits: [CSSClasses.overflowVisible],
            width: 'initial', minWidth: minWidthPropsDisplayerPx,
            right: ls.leftMarginInt + "px",
            top: ls.topMarginInt + "px",
            opacity: 1, transform: "translateX(0px)", "-webkit-transform": "translateX(0px)"
        };
        cssClasses[hiddenClassName + " ." + wrapperClassName] = {
            inherits: [CSSClasses.overflowHidden],
            width: '0px', minWidth: '0px',
            right: ls.leftMarginInt + "px",
            top: ls.topMarginInt + "px",
            opacity: 0, transform: "translateX(100%)", "-webkit-transform": "translateX(100%)"
        };
        cssClasses[toolBarClassName] = {
            inherits: [CSSClasses.lightBackground, CSSClasses.pointerEventsAll, CSSClasses.borderRadius2px, CSSClasses.positionRelative, CSSClasses.displayInlineBlock, CSSClasses.whiteSpaceNoWrap],
            verticalAlign: "bottom", height: propsToolBarButtonWidthPx, maxWidth: 'initial', width: "100%"
        };
        var contentCommon = {
            inherits: [CSSClasses.displayBlock, CSSClasses.overflowHidden],
            color: "white",
            //textShadow: "1px 1px 2px black",
            textShadow: "0px 0px 4px black",
            fontWeight: "600",
            background: "rgba(0, 0, 0, 0.2)"// lightBackground
        };
        cssClasses[contentClassName] = {
            inherits: [contentCommon],
            overflowY: "auto",
            maxHeight: "calc(" + maxFeaturePropsDisplayHeightPx + " - " + (propsToolBarButtonWidthInt * 2 + 12) + "px)",
            //marginTop: "2px",
            width: "calc(100% - 16px)",
            padding: "8px",
            paddingTop: "0px",
            paddingBottom: "4px"
        };
        var textShadowContentAU = "black 1px 1px 4px";
        var commonAU = {
            color: "white",
            fontSize: "120%",
            lineHeight: "120%",
            fontWeight: "600",
            textShadow: textShadowContentAU
        };
        cssClasses[contentClassName + " a"] = { inherits: [commonAU] };
        cssClasses[contentClassName + " u"] = { inherits: [commonAU] };
        cssClasses[ls.showingMapClassName + " ." + contentClassName + " img"] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding],
            boxShadow: "1px 1px 2px black",
            margin: "1px",
            marginTop: "6px",
            marginBottom: "-2px",
            borderRadius: "2px", padding: "2px"
        };
        cssClasses[ls.showingAerialClassName + " ." + contentClassName + " img"] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding],
            boxShadow: "1px 1px 2px yellow",
            margin: "1px",
            marginTop: "6px",
            marginBottom: "-2px",
            borderRadius: "2px", padding: "2px"
        };
        cssClasses[coordsButtonWrapperClassName] = { inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.overflowVisible, CSSClasses.positionRelative] };
        cssClasses[coordsButtonClassName] = {
            inherits: [CSSClasses.borderRadius2px, CSSClasses.baseTextButton, contentCommon],
            fontSize: ls.propsDisplayerCoordsButtonFontSizeInt + "px",
            lineHeight: ls.propsDisplayerCoordsButtonLineHeightInt + "px",
            fontWeight: "600",
            textShadow: darkTextShadow, color: darkTextColor,
            //background: lightBackgroundHalfOpaque,
            background: "rgba(255, 255, 255, 0.5)",
            height: (ls.propsDisplayerCoordsButtonLineHeightInt + 4) + 'px',
            border: 'none', marginTop: "2px", padding: "0px 0px", width: "calc(100% - " + (0) + "px)"
        };
        cssClasses[additionalButtonsClassName] = {
            inherits: [CSSClasses.displayInlineBlock, CSSClasses.borderRadius2px],
            marginLeft: "2px", paddingLeft: "2px", borderLeft: "1px solid " + darkTextColor,
            lineHeight: "100%", verticalAlign: "middle"
        };
        var buttonCommon = {
            inherits: [CSSClasses.baseImageButton, CSSClasses.verticalAlignMiddle, CSSClasses.displayInlineBlock, CSSClasses.borderRadius2px],
            border: "1px solid transparent", fill: darkTextColor, width: propsToolBarButtonWidthPx, height: propsToolBarButtonWidthPx, marginBottom: "2px"
        };
        cssClasses[closeButtonClassName] = { inherits: [buttonCommon, CSSClasses.closeButtonBackground] };
        cssClasses[directionsButtonClassName] = { inherits: [buttonCommon, CSSClasses.directionsButtonBackground2] };
        var textColorSearchProps = "#002255";
        var textTitle = {
            color: textColorSearchProps,
            textShadow: ls.lightTextShadow,
            overflow: "hidden", textOverflow: "ellipsis", display: "block", whiteSpace: "normal", maxWidth: "16rem",
            fontSize: ls.propsDisplayerTextFontSizeInt + "px",
            lineHeight: ls.propsDisplayerTextLineHeightInt + "px",
            //fontSize: "0.8rem",
            //lineHeight: "1rem",
            fontWeight: "400"
        };
        cssClasses[textClassName] = {
            inherits: [textTitle, contentCommon],
            backgroundColor: "transparent"
        };
        cssClasses[titleClassName] = {
            inherits: [textTitle],
            color: darkTextColor, textShadow: darkTextShadow,
            fontSize: ls.propsDisplayerTitleFontSizeInt + "px",
            lineHeight: ls.propsDisplayerTitleLineHeightInt + "px",
            //fontSize: "0.9rem",
            //lineHeight: "1.1rem",
            borderBottom: "1px solid gray", marginLeft: "-7px", marginTop: "2px", maxWidth: 'initial', width: "calc(100% + 6px)",
            borderRadius: "4px", paddingLeft: "4px", paddingRight: "4px", marginBottom: "2px", paddingTop: "2px", textAlign: "center", fontWeight: "800"
        };
        cssClasses[propsTextButtonClassName] = {
            inherits: [CSSClasses.verticalAlignMiddle, CSSClasses.baseTextButton, CSSClasses.noBorderNoPadding, CSSClasses.lightBackground, CSSClasses.darkTextColor],
            fontSize: ls.propsDisplayerTextButtonFontSizeInt + "px",
            lineHeight: ls.propsDisplayerTextButtonLineHeightInt + "px",
            //fontSize: "0.8rem",
            //lineHeight: "1.0rem",
            fontWeight: "500", marginLeft: "4px", marginRight: "4px", borderBottom: "1px solid " + lightBackground
        };
        cssClasses[mapFeaturePropsImageClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.positionAbsolute, CSSClasses.leftTopZero, CSSClasses.WHOneHundred]
        };
        cssClasses[mapFeaturePropsImageWrapperClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.positionRelative],
            textAlign: "center",
            height: ls.propsDisplayerImgHeightPxInt + "px",
            margin: "2px",
            marginBottom: "4px",
            border: "1px solid white"
        };
        return cssClasses;
    }
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function onLayoutChange(notification) { registerCSSClasses(); }
    function notify(eventName, props) { allEventDispatchers.Notify(eventName, tf.js.ShallowMerge(props, { sender: theThis, eventName: eventName, isVisible: isVisible })); }
    function notifyVisibilityChange() {
        return notify(visibilityChangeEventName, {
        });
    }
    var lcl;
    function initialize() {
        allEventDispatchers = new tf.events.MultiEventNotifier({ eventNames: [visibilityChangeEventName = "vis"] });
        cssTag = 'featurePropsDisplay';
        createCSSClassNames();
        registerCSSClasses();
        createControl();
        lcl = settings.appContent.GetAppStyles().AddOnLayoutChangeListener(onLayoutChange);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: appsizer.js
tf.TFMap.AppSizer = function(settings) {
    var theThis, onResizeCB;
    this.OnResize = function() { return onResize(); }
    function onResize() {
        //var winDims = tf.dom.GetWindowDims();
        //document.body.style.width = winDims[0] + "px";
        //document.body.style.height = winDims[1] + "px";
        if (!!onResizeCB) { onResizeCB(); }
    }
    function initialize() {
        onResizeCB = tf.js.GetFunctionOrNull(settings.onResize);
        tf.events.AddDOMEventListener(window, tf.consts.DOMEventNamesResize, onResize);
        new tf.events.DOMFullScreenChangeListener({ callBack: onResize, optionalScope: theThis });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: inputbox.js
tf.TFMap.InputBox = function(settings) {
    var theThis, inputBox, changeCB, changeVerb, goCB, goVerb, maxLength;
    this.GetInputBox = function() { return inputBox; }
    this.SetText = function(text, skipNotify) {
        inputBox.value = (tf.js.GetNonEmptyString(text, "").substring(0, maxLength)).trim();
        if (!skipNotify) { onInputChange(false); }
    }
    this.GetText = function() { return inputBox.value.trim(); }
    this.GetUnTrimText = function() { return inputBox.value; }
    function notify(cb, verb, addProps) { if (!!cb) { cb(tf.js.ShallowMerge(addProps, { sender: theThis, verb: verb })); } }
    function onInputChange(byUser) { notify(changeCB, changeVerb, { byUser: byUser }); }
    function onInputChangeEvent() { return onInputChange(true); }
    function onInputKeyPressEvent(event) { if (tf.js.GetKeyCodeFromEvent(event) == 13) { notify(goCB, goVerb); } else { onInputChangeEvent(true); } }
    function createControl(className, placeHolder) {
        inputBox = document.createElement('input');
        inputBox.type = 'text';
        if (tf.js.GetIsNonEmptyString(className)) { inputBox.className = className; }
        inputBox.maxLength = maxLength;
        inputBox.placeholder = tf.js.GetNonEmptyString(placeHolder, "");
        inputBox.addEventListener("keypress", onInputKeyPressEvent);
        inputBox.addEventListener("change", onInputChangeEvent);
        inputBox.addEventListener("paste", onInputChangeEvent);
        inputBox.addEventListener("input", onInputChangeEvent);
    }
    function initialize() {
        changeCB = tf.js.GetFunctionOrNull(settings.onChange);
        changeVerb = tf.js.GetNonEmptyString(settings.changeVerb, "change");
        goCB = tf.js.GetFunctionOrNull(settings.onGo);
        goVerb = tf.js.GetNonEmptyString(settings.goVerb, "change");
        maxLength = tf.js.GetIntNumberInRange(settings.maxLength, 1, 1000, 200);
        createControl(settings.className, settings.placeHolder);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: datasetsearch.js
tf.TFMap.DataSetSearch = function(settings) {
    var theThis, urlStart, searchAjaxRequest, searchResults, addedSearchResults, deletedSearchResults, maxRecords, isSearching;
    var dataSetTitle;
    var gen;
    var lastSearchCompletedOK;
    var searchCenter, searchRes;
    var lastSearchCenter, lastSearchRes;
    var nDLayerExtent, initialExtent;
    var startURLPart, endURLPart;
    this.GetInitialExtent = function() { return initialExtent; }
    this.GetDataSetTitle = function() { return dataSetTitle; }
    this.GetColor = function() { return settings.color; }
    this.GetTitle = function() { return settings.title; }
    this.GetUpdateVerb = function() { return settings.updateVerb; }
    this.GetCount = function() { return searchResults.GetCount(); }
    this.GetSettings = function() { return settings; }
    this.Search = function() { if (checkNeedsSearch()) { changeContext(true); doSearchQuery(); } }
    this.GetIsSearching = function() { return isSearching; }
    this.GetLastSearchCompletedOK = function() { return lastSearchCompletedOK; }
    //this.GetIsSearching = function () { return !!searchAjaxRequest; }
    this.GetAddedAndDeletedSearchResults = function() { return { addedResults: addedSearchResults, deletedResults: deletedSearchResults }; }
    this.GetSearchItems = function() { return searchResults.GetHeap(); }
    function checkNeedsSearch() {
        var needsSearch = (lastSearchCenter == undefined);
        if (!needsSearch) {
            var autoRefreshes = settings.appContent.GetAppCtx().GetCtxAttribute(settings.autoRefreshVerb);
            if (autoRefreshes) {
                var map = settings.appContent.GetMap();
                var center = map.GetCenter(), res = map.GetResolution();
                needsSearch = res != lastSearchRes || center[0] != lastSearchCenter[0] || center[1] != lastSearchCenter[1];
            }
        }
        return needsSearch;
    }
    function changeContext(isSearchingSet) {
        settings.appContent.GetAppCtx().SetCtxAttribute(settings.updateVerb, isSearching = isSearchingSet);
    }
    function getKey(result) { var props = result.properties; return props.Display_Label + '|' + props.lon + '|' + props.lat; }
    function compareSearchResults(a, b) { return a.priority - b.priority; }
    function getKeyFromResult(result) { return result.key; }
    function onEndSearch(notification) {
        //settings.appContent.GetAppCtx().SetCtxAttribute(tf.TFMap.CAN_selectedToolTipSender, undefined);
        //settings.appContent.ShowMapFeatureProps(undefined);
        searchAjaxRequest = undefined;
        addedSearchResults = [];
        deletedSearchResults = [];
        lastSearchCompletedOK = false;
        if (notification.requestProps.gen == gen) {
            if (!tf.js.GetIsValidObject(notification) || !tf.js.GetIsValidObject(notification.data)) {
                if (tf.TFMap.UseCachedDataSets) {
                    try {
                        switch (dataSetTitle) {
                            case "Hotels":
                                notification = { data: hotels };
                                break;
                            case "Sights":
                                notification = { data: geoImages };
                                break;
                            case "Restaurants":
                                notification = { data: restaurants };
                                break;
                            case "MLS":
                                notification = { data: callReal };
                                break;
                        }
                    } catch (e) { }
                }
            }
            if (tf.js.GetIsValidObject(notification) && tf.js.GetIsValidObject(notification.data)) {
                var dataSetProps = notification.data;
                var results = dataSetProps.features;
                if (lastSearchCompletedOK = tf.js.GetIsArray(results)) {
                    lastSearchCenter = searchCenter;
                    lastSearchRes = searchRes;
                    if (tf.js.GetIsNonEmptyArray(results)) {
                        //setDataSetTitle(tf.js.GetNonEmptyString(dataSetProps.title, settings.title));
                        var timeNow = new Date().getTime();
                        var nRecentResults = results.length;
                        var prefix = "http://", len_of_prefix = prefix.length;
                        for (var i = nRecentResults - 1; i >= 0; --i) {
                            var result = results[i], resultProps = result.properties;
                            var existingItem = searchResults.GetItem(result.key = getKey(result));
                            if (!!existingItem) { existingItem.priority = timeNow - nRecentResults - 2; searchResults.Update(existingItem); }
                            else {
                                var nameValue = tf.js.GetNonEmptyString(resultProps[settings.markerNameField], dataSetTitle);
                                var isImageMarker = nameValue.trim().toLowerCase().substring(0, len_of_prefix) == prefix;
                                if (isImageMarker) { result.mapFeatureImageSrc = nameValue; }
                                result.compassDirectionAngle = tf.js.CompassDirectionToAngle(resultProps.compass_direction);
                                result.mapFeatureText = nameValue;
                                result.priority = timeNow + (nRecentResults - i);
                                addedSearchResults.push(result);
                                searchResults.Insert(result);
                            }
                        }
                        if (nDLayerExtent != undefined && initialExtent == undefined) {
                            if (nDLayerExtent < nRecentResults) { nDLayerExtent = nRecentResults; }
                            for (var i = 0; i < nDLayerExtent; ++i) {
                                var coord = results[i].geometry.coordinates.slice(0);
                                initialExtent = tf.js.UpdateMapExtent(initialExtent, coord);
                            }
                            nDLayerExtent = undefined;
                        }
                        if (maxRecords != undefined) {
                            var selectedSearch = settings.appContent.GetAppCtx().GetCtxAttribute(tf.TFMap.CAN_selectedSearch);
                            if (!!selectedSearch) {
                                var searchResult = tf.TFMap.GetSearchFeature(selectedSearch);
                                if (!!searchResult) { searchResult.priority = timeNow - nRecentResults - 3; searchResults.Update(searchResult); }
                            }
                            var maxRecordsUse = maxRecords;
                            if (maxRecordsUse < nRecentResults) { maxRecordsUse = nRecentResults }
                            var count = searchResults.GetCount(), nRecordsDelete = count - maxRecordsUse;
                            if (nRecordsDelete > 0) { for (var j = 0; j < nRecordsDelete; ++j) { deletedSearchResults.push(searchResults.PopRoot()); } }
                        }
                    }
                }
            }
            changeContext(false);
        }
        //else { console.log('skipping stale search response'); }
    }
    function buildSearchURL() {
        var map = settings.appContent.GetMap();
        var center = map.GetCenter(), res = map.GetResolution();
        var locationPart = "&x1=" + center[0] + "&y1=" + center[1] + "&cres=" + res;
        var searchURL = startURLPart + locationPart + endURLPart + "&filetype=.json";
        searchCenter = center;
        searchRes = res;
        //console.log(searchURL);
        return searchURL;
    }
    function buildSearchURL2() {
        var map = settings.appContent.GetMap();
        var center = map.GetCenter(), res = map.GetResolution(), url = urlStart + "&x1=" + center[0] + "&y1=" + center[1] + "&cres=" + res;
        searchCenter = center;
        searchRes = res;
        url += "&filetype=.json";
        return url;
    }
    function doSearchQuery() {
        var serviceURL = buildSearchURL();
        if (!!searchAjaxRequest) { searchAjaxRequest.Cancel(); }
        addedSearchResults = [];
        deletedSearchResults = [];
        searchAjaxRequest = new tf.ajax.JSONGet().Request(serviceURL, function(notification) { onEndSearch(notification); }, theThis, { gen: ++gen }, false, undefined, undefined, undefined);
        changeContext(true);
    }
    function setDataSetTitle(newTitle) {
        dataSetTitle = newTitle;
    }
    function buildURLParts(fromURL) {
        var brokenURL = tf.urlapi.BreakUrlParamString(fromURL);
        var paramsPart = brokenURL.paramsPart;
        var startPart = brokenURL.urlPart + brokenURL.tag, endPart = "";
        var paramStringArray = paramsPart.split("&");
        var paramStringArrayLen = paramStringArray.length;
        if (paramStringArrayLen) {
            var numFindParamName = "numfind", arCriteriaParamName = "arcriteria", fileTypeParamName = "filetype";
            var inStartPart = true, hadPrev = false, hadStartParams = false;
            for (var i = 0; i < paramStringArrayLen; ++i) {
                var equalIndex = paramStringArray[i].indexOf("=");
                if (equalIndex != -1) {
                    var key = paramStringArray[i].substring(0, equalIndex), keyLower = key.toLowerCase();
                    var value = paramStringArray[i].substring(equalIndex + 1, paramStringArray[i].length);
                    var isArCriteria = false, skipParam = false;
                    switch (keyLower) {
                        case numFindParamName: case fileTypeParamName: skipParam = true; break;
                        case arCriteriaParamName: isArCriteria = true; break;
                    }
                    if (!skipParam) {
                        if (isArCriteria) { hadPrev = true; inStartPart = false; }
                        if (inStartPart) { if (hadPrev) { startPart += '&'; } startPart += key + '=' + value; hadStartParams = true; }
                        else { if (hadPrev) { endPart += '&'; } endPart += key + '=' + value; }
                        hadPrev = true;
                    }
                }
            }
            if (inStartPart) {
                endPart += "&" + arCriteriaParamName + "=1";
            }
            endPart += "&numfind=20";
        }
        //console.log("START: " + startPart);
        //console.log("END: " + endPart);
        return { startPart: startPart, endPart: endPart };
    }
    function initialize() {
        nDLayerExtent = settings.nDLayerExtent;
        lastSearchCompletedOK = true;
        gen = 0;
        setDataSetTitle(settings.title);
        isSearching = false;
        maxRecords = settings.maxRecords;
        searchResults = new tf.js.BinaryHeap({ compareFunction: compareSearchResults, getItemKeyFunction: getKeyFromResult });
        addedSearchResults = [];
        deletedSearchResults = [];
        var urlParts = buildURLParts(tf.js.GetNonEmptyString(settings.urlStart, "http://acorn.cs.fiu.edu/cgi-bin/arquery.cgi?category=itpall&vid=itpa&numfind=20&tfaction=shortdisplayflash"));
        startURLPart = urlParts.startPart;
        endURLPart = urlParts.endPart;
        urlStart = tf.js.GetNonEmptyString(settings.urlStart, "http://acorn.cs.fiu.edu/cgi-bin/arquery.cgi?category=itpall&vid=itpa&numfind=20&tfaction=shortdisplayflash");
        settings.searchMapFeatures.SetDataSet(theThis);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: tooltipdisplayer.js
tf.TFMap.ToolTipDisplayer = function(settings) {
    var theThis, curParent;
    var delayedShowToolTip;
    var contentToolTip, contentToolTipArrow;
    var lastSender, lastToolTipClassName, lastToolTipArrowClassName;
    var buttonsCache, spansCache;
    var hoverListener;
    var isInHover;
    this.GetIsInHover = function() { return isInHover; }
    this.GetLastSender = function() { return lastSender; }
    this.Show = function(sender) { return show(sender); }
    this.RefreshToolTip = function() { return refreshToolTip(); }
    this.Hide = function() { return showToolTip(false); }
    this.GetIsVisible = function() { return curParent != undefined; }
    function detach() {
        if (!!curParent) {
            curParent.removeChild(contentToolTip.GetHTMLElement()); curParent.removeChild(contentToolTipArrow.GetHTMLElement());
            curParent = undefined;
            /*var root = settings.appContent.GetRootDiv();
            root.RemoveContent(contentToolTip);
            root.RemoveContent(contentToolTipArrow);*/
            curParent = undefined;
            buttonsCache.Reset();
            spansCache.Reset();
        }
    }
    function attach() {
        var wrapperUse = !!lastSender.insertWrapper ? lastSender.insertWrapper : lastSender.wrapper;
        if (!!(curParent = tf.dom.GetHTMLElementFrom(wrapperUse))) {
            //isInHover = true;
            curParent.appendChild(contentToolTip.GetHTMLElement()); curParent.appendChild(contentToolTipArrow.GetHTMLElement());
            /*var root = settings.appContent.GetRootDiv();
            root.AddContent(contentToolTip);
            root.AddContent(contentToolTipArrow);*/
        }
        else {
            curParent = undefined;
        }
    }
    function resetStylePos(appContent) {
        var elem = appContent.GetHTMLElement(), display = elem.style.display;
        elem.removeAttribute("style");
        elem.style.display = display;
    }
    function doPositionToolTip(lastSender, rectToolBar, rectObj, styleContent, styleArrow, rectInsert, posStr, arrowStr, centerToObject, isInset) {
        //posStr = 'center';
        //centerToObject = true;
        var ls = tf.TFMap.LayoutSettings;
        var fontSizeToolTipInt = ls.arrowDimsToolTipInt;
        var halfToolTipDim = fontSizeToolTipInt / 2;
        var offsetX = lastSender.offsetX != undefined ? lastSender.offsetX : 0;
        var offsetY = lastSender.offsetY != undefined ? lastSender.offsetY : 0;
        var parentRect = !!rectInsert ? rectInsert : rectToolBar;
        var halfObjectWidthForCentering = centerToObject ? rectObj.width / 2 - fontSizeToolTipInt : 0;
        var halfObjectHeightForCentering = centerToObject ? rectObj.height / 2 - fontSizeToolTipInt : 0;
        var isTopBot = false;
        var leftC, topC, rightC, bottomC;
        var leftA, topA, rightA, bottomA;
        var transformC;
        //console.log(posStr + ' ' + arrowStr + ' ' + offsetX + ' ' + offsetY + ' center: ' + centerToObject + ' inset: ' + isInset);
        switch (arrowStr) {
            case 'left':
                if (isInset) {
                    leftC = rectObj.left - parentRect.left + offsetX + halfToolTipDim;
                    leftA = rectObj.left - parentRect.left + offsetX;
                }
                else {
                    leftC = rectObj.right - parentRect.left + offsetX + halfToolTipDim;
                    leftA = rectObj.right - parentRect.left + offsetX;
                }
                break;
            case 'right':
                if (isInset) {
                    rightC = parentRect.right - rectObj.right + offsetX + halfToolTipDim;
                    rightA = parentRect.right - rectObj.right + offsetX
                }
                else {
                    rightC = parentRect.right - rectObj.left + offsetX + halfToolTipDim * 2;
                    rightA = parentRect.right - rectObj.left + offsetX + halfToolTipDim
                }
                break;
            case 'top':
                if (isInset) {
                    topC = rectObj.top - parentRect.top + offsetY + halfToolTipDim;
                    topA = rectObj.top - parentRect.top + offsetY
                }
                else {
                    topC = rectObj.bottom - parentRect.top + offsetY + halfToolTipDim * 2;
                    topA = rectObj.bottom - parentRect.top + offsetY + halfToolTipDim
                }
                isTopBot = true;
                break;
            case 'bottom':
                if (isInset) {
                    bottomC = parentRect.bottom - rectObj.bottom + offsetY + halfToolTipDim;
                    bottomA = parentRect.bottom - rectObj.bottom + offsetY
                }
                else {
                    bottomC = parentRect.bottom - rectObj.top + offsetY + halfToolTipDim * 2;
                    bottomA = parentRect.bottom - rectObj.top + offsetY + halfToolTipDim
                }
                isTopBot = true;
                break;
        }
        if (isTopBot) {
            switch (posStr) {
                case 'start':
                    rightC = parentRect.right - rectObj.right + offsetX + halfObjectWidthForCentering;
                    rightA = parentRect.right - rectObj.right + offsetX + halfToolTipDim + halfObjectWidthForCentering;
                    break;
                case 'end':
                    leftC = rectObj.left - parentRect.left + offsetX + halfObjectWidthForCentering;
                    leftA = rectObj.left - parentRect.left + offsetX + halfToolTipDim + halfObjectWidthForCentering;
                    break;
                case 'center':
                    leftC = rectObj.left - parentRect.left + offsetX + rectObj.width / 2;
                    leftA = rectObj.left - parentRect.left + offsetX + rectObj.width / 2;
                    transformC = "translateX(-50%)";
                    break;
            }
        }
        else {
            switch (posStr) {
                case 'start':
                    topC = rectObj.top - parentRect.top + offsetY + halfObjectHeightForCentering;
                    topA = rectObj.top - parentRect.top + offsetY + halfObjectHeightForCentering + halfToolTipDim;
                    break;
                case 'end':
                    bottomC = parentRect.bottom - rectObj.bottom + offsetY - halfToolTipDim + halfObjectHeightForCentering;
                    bottomA = parentRect.bottom - rectObj.bottom + offsetY + halfObjectHeightForCentering;
                    break;
                case 'center':
                    topC = rectObj.top - parentRect.top + offsetY + rectObj.height / 2;
                    topA = rectObj.top - parentRect.top + offsetY + rectObj.height / 2;
                    transformC = "translateY(-50%)";
                    break;
            }
        }
        styleContent.transform = transformC != undefined ? transformC : 'initial';
        styleContent.left = leftC != undefined ? leftC + 'px' : 'initial';
        styleContent.right = rightC != undefined ? rightC + 'px' : 'initial';
        styleContent.top = topC != undefined ? (topC.length != undefined ? topC : topC + 'px') : 'initial';
        styleContent.bottom = bottomC != undefined ? bottomC + 'px' : 'initial';
        styleArrow.transform = transformC != undefined ? transformC : 'initial';
        styleArrow.left = leftA != undefined ? leftA + 'px' : 'initial';
        styleArrow.right = rightA != undefined ? rightA + 'px' : 'initial';
        styleArrow.top = topA != undefined ? topA + 'px' : 'initial';
        styleArrow.bottom = bottomA != undefined ? bottomA + 'px' : 'initial';
    }
    function positionToolTip() {
        var contentToolTipES = contentToolTip.GetHTMLElement().style, contentToolTipArrowES = contentToolTipArrow.GetHTMLElement().style;
        var rectInsert = !!lastSender.insertWrapper ? tf.dom.GetHTMLElementFrom(lastSender.insertWrapper)/*.GetHTMLElement()*/.getBoundingClientRect() : undefined;
        var rectToolBar = tf.dom.GetHTMLElementFrom(lastSender.wrapper)/*.GetHTMLElement()*/.getBoundingClientRect();
        var rectObj = !!lastSender.element ? lastSender.element.getBoundingClientRect() : undefined;
        tf.dom.RemoveCSSClass(contentToolTip, lastToolTipClassName);
        tf.dom.RemoveCSSClass(contentToolTipArrow, lastToolTipArrowClassName);
        resetStylePos(contentToolTip);
        resetStylePos(contentToolTipArrow);
        //tf.dom.AddCSSClass(contentToolTip, lastToolTipClassName = lastSender.toolTipClassName);
        var isInset = false;
        var centerToObject = false;
        var toolTipArrowClassName = tf.js.GetNonEmptyString(lastSender.toolTipArrowClassName, "left").toLowerCase();
        var toolTipArrowClassNameUse;
        if (tf.js.GetIsNonEmptyString(toolTipArrowClassName)) { if (toolTipArrowClassName.charAt(0) == '*') { isInset = true; toolTipArrowClassName = toolTipArrowClassName.substring(1); } }
        var toolTipPosName = tf.js.GetNonEmptyString(lastSender.toolTipClassName, "center").toLowerCase();
        if (tf.js.GetIsNonEmptyString(toolTipPosName)) { if (toolTipPosName.charAt(0) == '*') { centerToObject = true; toolTipPosName = toolTipPosName.substring(1); } }
        switch (toolTipPosName) { case "start": break; default: case "center": toolTipPosName = "center"; break; case "end": break; }
        switch (toolTipArrowClassName) {
            default:
            case "left": toolTipArrowClassName = "left"; toolTipArrowClassNameUse = leftArrowToolTipClassName; break;
            case "right": toolTipArrowClassNameUse = rightArrowToolTipClassName; break;
            case "top": toolTipArrowClassNameUse = topArrowToolTipClassName; break;
            case "bottom": toolTipArrowClassNameUse = botArrowToolTipClassName; break;
        }
        tf.dom.AddCSSClass(contentToolTipArrow, lastToolTipArrowClassName = toolTipArrowClassNameUse);
        if (tf.js.GetFunctionOrNull(lastSender.toolTipStyle)) {
            lastSender.toolTipStyle(lastSender, rectToolBar, rectObj, contentToolTipES, contentToolTipArrowES, rectInsert, toolTipPosName, toolTipArrowClassName, centerToObject, isInset);
        }
        else {
            doPositionToolTip(lastSender, rectToolBar, rectObj, contentToolTipES, contentToolTipArrowES, rectInsert, toolTipPosName, toolTipArrowClassName, centerToObject, isInset);
        }
    }
    function show(sender) {
        if (tf.TFMap.DontHideToolTipsDebug) {
            if (!sender) { return; }
        }
        var doShow = false;
        detach();
        if (!!sender) {
            lastSender = sender;
            contentToolTip.ClearContent();
            var toolTipText = lastSender.toolTipText;
            if (tf.js.GetFunctionOrNull(lastSender.toolTipFunction)) {
                toolTipText = lastSender.toolTipFunction(lastSender);
            }
            if (!tf.js.GetIsArray(toolTipText)) {
                toolTipText = [toolTipText];
            }
            var nToolTips = toolTipText.length, nToolTipsAdded = 0;
            var useButton = !!tf.js.GetFunctionOrNull(lastSender.onClick);
            for (var i = 0; i < nToolTips; ++i) {
                var thisToolTip = toolTipText[i], thisToolTipContent;
                if (!!tf.js.GetFunctionOrNull(thisToolTip)) { thisToolTipContent = thisToolTip(lastSender, thisToolTip); }
                else { thisToolTipContent = thisToolTip; }
                if (thisToolTipContent != undefined) {
                    if (tf.js.GetIsNonEmptyString(thisToolTipContent)) {
                        var thisToolTipContentElement = useButton ? buttonsCache.GetNext() : spansCache.GetNext();
                        thisToolTipContentElement.tfToolTipButtonOrder = i;
                        thisToolTipContentElement.innerHTML = thisToolTipContent;
                        thisToolTipContent = thisToolTipContentElement;
                    }
                    ++nToolTipsAdded;
                    contentToolTip.AddContent(thisToolTipContent);
                }
            }
            if (nToolTipsAdded > 0) {
                positionToolTip();
                isInHover = !!lastSender.startInHover;
                attach();
                doShow = true;
            }
        }
        showToolTip(doShow);
    }
    function refreshToolTip() {
        if (!!lastSender) {
            var lastSenderSaved = lastSender;
            showToolTip(false);
        }
    }
    function showToolTipImmediate(bool) {
        var displayStr = !!bool ? 'block' : 'none';
        contentToolTipArrow.GetHTMLElement().style.display = contentToolTip.GetHTMLElement().style.display = displayStr;
        if (!bool) { lastSender = undefined; }
    }
    function showToolTipOn() { showToolTipImmediate(true); }
    function showToolTip(bool) {
        if (!!lastSender) {
            delayedShowToolTip.CancelCallBack();
            if (!bool || lastSender.delayUse == undefined) { showToolTipImmediate(bool); }
            else { delayedShowToolTip.ChangeDelay(lastSender.delayUse); delayedShowToolTip.DelayCallBack(); }
        }
    }
    function createNewButtonSpan(elem, classStr) { elem.className = classStr; return elem; }
    function createNewSpan(notification) { return createNewButtonSpan(document.createElement('span'), spanClassName); }
    function deleteSpan(notification) { /*console.log('deleted span');*/ }
    function onClickToolTipButton(notification) {
        if (!!lastSender) {
            if (!!tf.js.GetFunctionOrNull(lastSender.onClick)) {
                lastSender.onClick({ sender: theThis, toolTipSender: lastSender, order: notification.target.tfToolTipButtonOrder });
            }
        }
    }
    function createNewButton(notification) {
        var button = createNewButtonSpan(document.createElement('button'), buttonClassName);
        button.addEventListener('click', onClickToolTipButton);
        return button;
    }
    function deleteButton(notification) { /*console.log('deleted button');*/ }
    function onHoverToolTipContainer(notification) {
        //console.log(notification.isInHover);
        if (!!lastSender) {
            var target = notification.event.target;
            //console.log(notification.isInHover);
            if (target == contentToolTip.GetHTMLElement() || target == contentToolTipArrow.GetHTMLElement()) {
                var needsHide = !(isInHover = notification.isInHover) ? true : !lastSender.keepOnHoverOutTarget;
                if (needsHide) { settings.appContent.GetAppCtx().SetCtxAttribute(tf.TFMap.CAN_selectedToolTipSender, undefined); }
                //console.log(needsHide + ' ' + isInHover);
            }
        }
    }
    function createControl() {
        var ls = tf.TFMap.LayoutSettings;
        var customizedScrollBarClassName = ls.customizedScrollBarClassName
        contentToolTip = new tf.dom.Div({ cssClass: wrapperClassName + " " + customizedScrollBarClassName });
        contentToolTipArrow = new tf.dom.Div({ cssClass: "" });
        hoverListener = new tf.events.DOMMouseEnterLeaveListener({ target: contentToolTip, callBack: onHoverToolTipContainer, optionalScope: theThis, callBackSettings: null });
    }
    var cssTag, wrapperClassName, buttonClassName, spanClassName, leftArrowToolTipClassName, rightArrowToolTipClassName, topArrowToolTipClassName, botArrowToolTipClassName;;
    function commonCreateToolTip(dims, color, zIndex, borderNames) {
        var halfDims = Math.floor((dims + 1) / 2);
        if (halfDims < 0) { halfDims = 1; }
        var halfDimsMinusTwo = halfDims - 3, halfDimsPx = halfDims + "px";
        var preffixStr = 'border';
        var transparentBorderStr = halfDimsPx + " solid transparent";
        var colorBorderStr = halfDimsPx + " solid " + color;
        var result = { content: '', position: 'absolute', zIndex: '' + zIndex };
        result[preffixStr + borderNames[0]] = result[preffixStr + borderNames[1]] = transparentBorderStr;
        result[preffixStr + borderNames[2]] = colorBorderStr;
        return result;
    }
    function createLeftArrowDivClass(dims, color, zIndex) { return commonCreateToolTip(dims, color, zIndex, ["Top", "Bottom", "Right"]); }
    function createRightArrowDivClass(dims, color, zIndex) { return commonCreateToolTip(dims, color, zIndex, ["Top", "Bottom", "Left"]); }
    function createTopArrowDivClass(dims, color, zIndex) { return commonCreateToolTip(dims, color, zIndex, ["Left", "Right", "Bottom"]); }
    function createBotArrowDivClass(dims, color, zIndex) { return commonCreateToolTip(dims, color, zIndex, ["Left", "Right", "Top"]); }
    function createCSSClassNames() {
        wrapperClassName = tf.TFMap.CreateClassName(cssTag, "Wrapper");
        buttonClassName = tf.TFMap.CreateClassName(cssTag, "Button");
        spanClassName = tf.TFMap.CreateClassName(cssTag, "Span");
        leftArrowToolTipClassName = tf.TFMap.CreateClassName(cssTag, "latt");
        rightArrowToolTipClassName = tf.TFMap.CreateClassName(cssTag, "ratt");
        topArrowToolTipClassName = tf.TFMap.CreateClassName(cssTag, "tatt");
        botArrowToolTipClassName = tf.TFMap.CreateClassName(cssTag, "batt");
    }
    function createCSSClasses() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var cssClasses = [];
        var layoutSettings = tf.TFMap.LayoutSettings;
        var fontSizeToolTipInt = layoutSettings.fontSizeToolTipInt;
        var arrowDimsToolTipInt = layoutSettings.arrowDimsToolTipInt;
        var zIndexToolTipInt = layoutSettings.zIndexToolTipInt;
        var toolTipContentBackground = layoutSettings.toolTipContentBackground;
        cssClasses[wrapperClassName] = {
            inherits: [CSSClasses.borderRadius2px, CSSClasses.whiteSpaceNoWrap, CSSClasses.pointerEventsAll, CSSClasses.displayBlock, CSSClasses.lightTextColor,
            CSSClasses.toolTipBackground, CSSClasses.positionAbsolute],
            fontWeight: layoutSettings.fontWeightToolTip, overflowY: 'auto', overflowX: 'hidden',
            maxHeight: "120px", zIndex: '' + zIndexToolTipInt,
            padding: "4px 8px", fontSize: fontSizeToolTipInt + "px", lineHeight: (fontSizeToolTipInt + 8) + "px",
            maxWidth: "16rem", boxShadow: "1px 1px 2px rgba(0,0,0,0.2)"
        };
        var commonSettings = {
            inherits: [CSSClasses.inheritBackgroundAndColorImageButton, CSSClasses.overflowHidden, CSSClasses.whiteSpaceNoWrap, CSSClasses.displayBlock, CSSClasses.lightTextShadow, CSSClasses.textOverflowEllipsis],
            fontWeight: 'inherit', width: "100%",
            background: "rgba(0, 0, 0, 0.1)", fontSize: 'inherit', lineHeight: 'inherit',
            borderTop: "1px solid transparent", borderBottom: "1px solid transparent",
            textAlign: 'inherit', marginBottom: "2px"
        };
        cssClasses[buttonClassName] = { inherits: [commonSettings, CSSClasses.cursorPointer] };
        cssClasses[buttonClassName + ":hover"] = { borderTop: "1px solid darkgray", borderBottom: "1px solid red", color: "#fff" };
        cssClasses[spanClassName] = { inherits: [commonSettings, CSSClasses.cursorDefault] };
        cssClasses[leftArrowToolTipClassName] = createLeftArrowDivClass(arrowDimsToolTipInt + 1, toolTipContentBackground, zIndexToolTipInt);
        cssClasses[rightArrowToolTipClassName] = createRightArrowDivClass(arrowDimsToolTipInt + 1, toolTipContentBackground, zIndexToolTipInt);
        cssClasses[topArrowToolTipClassName] = createTopArrowDivClass(arrowDimsToolTipInt + 1, toolTipContentBackground, zIndexToolTipInt);
        cssClasses[botArrowToolTipClassName] = createBotArrowDivClass(arrowDimsToolTipInt + 1, toolTipContentBackground, zIndexToolTipInt);
        return cssClasses;
    }
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function onLayoutChange(notification) { registerCSSClasses(); }
    var lcl;
    function initialize() {
        cssTag = 'ToolTip';
        createCSSClassNames();
        registerCSSClasses();
        createControl();
        isInHover = false;
        buttonsCache = new tf.js.ObjectCache({ createNew: createNewButton, onDelete: deleteButton });
        spansCache = new tf.js.ObjectCache({ createNew: createNewSpan, onDelete: deleteSpan });
        curParent = undefined;
        delayedShowToolTip = new tf.events.DelayedCallBack(tf.TFMap.toolTipDelayMillis, showToolTipOn, theThis);
        showToolTip(false);
        lcl = settings.appContent.GetAppStyles().AddOnLayoutChangeListener(onLayoutChange);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: searchbar.js
tf.TFMap.SearchBar = function(settings) {
    var theThis, divWrapper, inputBox, menuButton, searchButton, directionsButton, loadingSearchButton;
    this.CheckSearchActive = function() { return checkSearchActive(); }
    this.GetWrapper = function() { return divWrapper; }
    this.SetSearchText = function(searchText) { return setSearchText(searchText); }
    this.GetSearchText = function() { return getSearchString(); }
    function setSearchText(searchText) {
        inputBox.SetText(searchText);
        checkSearchActive();
    }
    function onSearch() {
        if (getIsActiveIsSearching().isActive) { settings.appContent.SearchAddress(getSearchString()); }
    }
    function updateFullScreenButton(useFullScreen) {
        tf.dom.ReplaceCSSClassCondition(menuButton.GetButton(), useFullScreen, goFullScreenBackgroundClassName, restoreFullScreenBackgroundClassName);
    }
    function onButtonClicked(notification) {
        var sender = notification.sender;
        switch (sender) {
            case menuButton:
                if (tf.browser.GetIsFullScreen(document)) {
                    tf.browser.ExitFullScreen(document);
                    updateFullScreenButton(true);
                }
                else {
                    tf.browser.RequestFullScreen(settings.appContent.GetRootDiv().GetHTMLElement());
                    updateFullScreenButton(false);
                }
                break;
            case searchButton: onSearch(); break;
            case directionsButton:
                settings.appContent.GetAppCtx().SetCtxAttribute(tf.TFMap.CAN_showingDirections, true);
                break;
        }
    }
    function getIsActiveIsSearching() {
        var isSearching = settings.appContent.GetAppCtx().GetCtxAttribute(tf.TFMap.CAN_isSearchingAddress);
        var isActive = getSearchString().length > 0 && !isSearching;
        return { isSearching: isSearching, isActive: isActive };
    }
    function checkSearchActive() {
        var isActiveIsSearching = getIsActiveIsSearching();
        var isSearching = isActiveIsSearching.isSearching;
        var isActive = isActiveIsSearching.isActive;
        tf.dom.ReplaceCSSClassCondition(searchButton.GetButton(), isActive, activeSearchButtonClassName, inactiveSearchButtonClassName);
        var appStyles = settings.appContent.GetAppStyles();
        var inputBoxBox = inputBox.GetInputBox();
        var visibleDisplayVerb = "inline-block";
        var ls = tf.TFMap.LayoutSettings;
        if (isSearching) {
            inputBoxBox.style.color = ls.inactiveTextColor;
            inputBoxBox.disabled = true;
            searchButton.GetButton().style.display = 'none';
            loadingSearchButton.GetButton().style.display = visibleDisplayVerb;
        }
        else {
            inputBoxBox.style.color = ls.darkTextColor;
            inputBoxBox.disabled = false;
            loadingSearchButton.GetButton().style.display = 'none';
            searchButton.GetButton().style.display = visibleDisplayVerb;
        }
    }
    function getSearchToolTip() {
        return getIsActiveIsSearching().isActive ? "Search" : "Type an address or a place to search";
    }
    function getSearchString() { return inputBox.GetText(); }
    function onInputChange() { checkSearchActive(); }
    function onInputKeyPress(event) { if (tf.js.GetKeyCodeFromEvent(event) == 13) { onSearch(); } else { onInputChange(); } }
    function getFullScreenToolTip() {
        return tf.browser.GetIsFullScreen() ? "Exit full screen" : "Display full screen";
    }
    function createControl() {
        var inputFade = new tf.dom.Div({ cssClass: inputFadeClassName });
        var searchBarInputWrapper = new tf.dom.Div({ cssClass: inputWrapperClassName });
        divWrapper = new tf.dom.Div({ cssClass: wrapperClassName });
        inputBox = new tf.TFMap.InputBox({ onChange: onInputChange, onGo: onSearch, placeHolder: settings.placeHolder, className: inputClassName, maxLength: tf.TFMap.maxCharsAddressInput });
        searchBarInputWrapper.AddContent(inputBox.GetInputBox(), inputFade);
        var appContent = settings.appContent;
        var delayMillis = 0;
        var toolTipClass = "*start";
        var toolTipArrowClass = "top";
        var ls = tf.TFMap.LayoutSettings;
        var fontSizeToolTipInt = ls.fontSizeToolTipInt;
        var buttonSettings = {
            offsetY: - (fontSizeToolTipInt / 2 + 2),
            onClick: onButtonClicked, onHover: undefined, wrapper: divWrapper, delayMillis: delayMillis, toolTipClass: toolTipClass, toolTipArrowClass: toolTipArrowClass
        };
        menuButton = appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, { buttonClass: menuButtonClassName, toolTipText: getFullScreenToolTip, toolTipClass: "*end" }));
        searchButton = appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, { buttonClass: "", toolTipText: getSearchToolTip }));
        directionsButton = appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, { buttonClass: directionsButtonClassName, toolTipText: "Get Directions" }));
        loadingSearchButton = appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, { buttonClass: searchingSearchButtonClassName, toolTipText: "Searching..." }));
        loadingSearchButton.GetButton().style.display = 'none';
        updateFullScreenButton(true);
        checkSearchActive();
        divWrapper.AddContent(menuButton.GetButton(), searchBarInputWrapper, searchButton.GetButton(), loadingSearchButton.GetButton(), directionsButton.GetButton());
    }
    var cssTag, wrapperClassName, inputFadeClassName, inputWrapperClassName, inputClassName, menuButtonClassName, activeSearchButtonClassName,
        inactiveSearchButtonClassName, searchingSearchButtonClassName, directionsButtonClassName, goFullScreenBackgroundClassName, restoreFullScreenBackgroundClassName;
    function createCSSClassNames() {
        wrapperClassName = tf.TFMap.CreateClassName(cssTag, "Wrapper");
        inputFadeClassName = tf.TFMap.CreateClassName(cssTag, "InputFade");
        inputWrapperClassName = tf.TFMap.CreateClassName(cssTag, "InputWrapper");
        inputClassName = tf.TFMap.CreateClassName(cssTag, "Input");
        menuButtonClassName = tf.TFMap.CreateClassName(cssTag, "MenuButton");
        activeSearchButtonClassName = tf.TFMap.CreateClassName(cssTag, "Active");
        inactiveSearchButtonClassName = tf.TFMap.CreateClassName(cssTag, "Inactive");
        searchingSearchButtonClassName = tf.TFMap.CreateClassName(cssTag, "Searching");
        directionsButtonClassName = tf.TFMap.CreateClassName(cssTag, "Directions");
        goFullScreenBackgroundClassName = tf.TFMap.CreateClassName(cssTag, "gfsbg");
        restoreFullScreenBackgroundClassName = tf.TFMap.CreateClassName(cssTag, "rfsbg");
    }
    function createCSSClasses() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var isSmallScreen = appStyles.GetIsSmallScreen();
        var cssClasses = [];
        var ls = tf.TFMap.LayoutSettings;
        var topMarginInt = ls.topMarginInt, topMarginPx = topMarginInt + 'px';
        var leftMarginInt = ls.leftMarginInt, leftMarginPx = leftMarginInt + 'px';
        var heightSearchBoxInt = ls.heightSearchBoxInt, heightSearchBoxPx = heightSearchBoxInt + 'px';
        var lightBackground = ls.lightBackground;
        var lightBackgroundFadeStart = ls.lightBackgroundHalfOpaque;
        var searchBarInputHeightInt = ls.searchBarInputHeightInt, searchBarInputHeightPx = searchBarInputHeightInt + 'px';
        var searchBarInputWidthInt = ls.searchBarInputWidthInt, searchBarInputWidthPx = searchBarInputWidthInt + 'px';
        var searchBarHorizPaddingInt = ls.searchBarHorizPaddingInt, searchBarHorizPaddingPx = searchBarHorizPaddingInt + 'px';
        var searchBarInputFontSizePx = ls.searchBarInputFontSizeInt + 'px';
        var searchBarInputWrapperWidthInt = searchBarInputWidthInt + 2 * searchBarHorizPaddingInt + 2, searchBarInputWrapperWidthPx = searchBarInputWrapperWidthInt + 'px';
        var searchBarInputFadeWidth = isSmallScreen ? 10: 20;
        var marginRightSearchBox = isSmallScreen ? "2px" : "6px";
        var paddingWrapperVerPx = ls.searchBarPaddingVerInt + 'px';
        var paddingWrapperHorInt = ls.searchBarPaddingHorInt, paddingWrapperHorPx = paddingWrapperHorInt + 'px';
        cssClasses[wrapperClassName] = {
            inherits: [CSSClasses.positionRelative, CSSClasses.whiteSpaceNoWrap, CSSClasses.overflowVisible, CSSClasses.pointerEventsAll,
                CSSClasses.displayBlock,
                //CSSClasses.displayFlex, CSSClasses.flexFlowRowNoWrap,
            CSSClasses.boxShadow01403, CSSClasses.noBorder, CSSClasses.lightBackground],
            marginTop: topMarginPx, marginLeft: leftMarginPx,
            //width: "calc(100% - " + (leftMarginInt + 16) + "px)",
            width: "calc(100% - " + (leftMarginInt + 2 * paddingWrapperHorInt) + "px)",
            //width: "100%",
            borderRadius: '2px',
            height: heightSearchBoxPx,
            paddingTop: paddingWrapperVerPx, paddingBottom: paddingWrapperVerPx,
            paddingLeft: paddingWrapperHorPx, paddingRight: paddingWrapperHorPx
        };
        cssClasses[inputFadeClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.pointerEventsNone, CSSClasses.positionAbsolute, CSSClasses.overflowVisible],
            top: "2px", left: (searchBarInputWrapperWidthInt - searchBarInputFadeWidth) + 'px',
            background: "linear-gradient(to right, " + lightBackgroundFadeStart + "," + lightBackground + ")",
            padding: '0',
            width: (searchBarInputFadeWidth - 3) + 'px',
            height: (searchBarInputHeightInt - 4) + 'px !important'
        };
        var searchBarInputCommon = {
            width: searchBarInputWidthPx, height: searchBarInputHeightPx + ' !important',
            padding: '0', verticalAlign: 'middle', listStyle: 'none', margin: '0 !important', overflow: 'visible'
        };
        cssClasses[inputWrapperClassName] = {
            inherits: [searchBarInputCommon, CSSClasses.cursorText, CSSClasses.noMarginNoBorderNoPadding, CSSClasses.positionRelative,
                CSSClasses.overflowVisible, CSSClasses.displayInlineBlock],
            width: searchBarInputWrapperWidthPx,
            marginRight: marginRightSearchBox
        };
        cssClasses[inputClassName] = {
            inherits: [CSSClasses.robotoFontFamily, searchBarInputCommon, CSSClasses.positionAbsolute, CSSClasses.leftTopZero],
            color: 'inherit', outline: 'none', border: 'none', fontSize: searchBarInputFontSizePx,
            paddingLeft: searchBarHorizPaddingPx, paddingRight: searchBarHorizPaddingPx,
            borderLeft: "1px solid lightgray", borderRight: "1px solid lightgray",
            lineHeight: searchBarInputHeightPx + ' !important', background: 'white'
        };
        var widthSearchBoxButton = isSmallScreen ? "32px" : "40px";
        var marginSearchBoxButton = isSmallScreen ? "-8px" : "0px";
        var baseButton = {
            inherits: [CSSClasses.baseImageButton, CSSClasses.displayInlineBlock, CSSClasses.verticalAlignMiddle],
            width: widthSearchBoxButton, height: heightSearchBoxPx, marginRight: marginSearchBoxButton
        }
        cssClasses[menuButtonClassName] = { inherits: [baseButton], marginRight: marginRightSearchBox };
        cssClasses[activeSearchButtonClassName] = { inherits: [baseButton, CSSClasses.activeSearchButtonBackground] };
        cssClasses[inactiveSearchButtonClassName] = { inherits: [baseButton, CSSClasses.inactiveSearchButtonBackground] };
        cssClasses[searchingSearchButtonClassName] = { inherits: [baseButton, CSSClasses.loadingBackground], boxShadow: 'none' };
        cssClasses[directionsButtonClassName] = { inherits: [baseButton, CSSClasses.directionsButtonBackground] };
        cssClasses[goFullScreenBackgroundClassName] = { inherits: [CSSClasses.goFullScreenBackground] };
        cssClasses[restoreFullScreenBackgroundClassName] = { inherits: [CSSClasses.restoreFullScreenBackground] };
        return cssClasses;
    }
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function onLayoutChange(notification) { registerCSSClasses(); }
    var lcl;
    function initialize() {
        cssTag = 'searchBar';
        createCSSClassNames();
        registerCSSClasses();
        createControl();
        if (tf.js.GetIsNonEmptyString(settings.initialText)) { setSearchText(settings.initialText); }
        lcl = settings.appContent.GetAppStyles().AddOnLayoutChangeListener(onLayoutChange);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: searchmapfeatures.js
tf.TFMap.SearchMapFeatures = function(settings) {
    var theThis, isVisible, dataSet;
    var searchFeaturesByKeyHB, searchFeaturesByKeyMB;
    var nDLayerExtent, dlayerPreClick;
    var lineWidthForPlaceBoundaryMeasures;
    this.SetDataSet = function(newDataSet) { dataSet = newDataSet; }
    this.GetSearchFeaturesForToolTip = function() { return searchFeaturesByKeyHB; }
    this.GetIsVisible = function() { return isVisible; }
    this.UpdateVisibility = function() {
        var wasVisible = isVisible;
        updateIsVisibleFromContext();
        if (wasVisible != isVisible) { addDelFeatures(); }
    }
    this.UpdateSearchFeatures = function(updateNotification) {
        if (tf.js.GetIsValidObject(updateNotification)) {
            updateIsVisibleFromContext();
            var layerHB = settings.layerHybridB, layerMB = settings.layerMapB;
            var toolTipProps = { toolTipText: getSearchMapFeatureToolTipText, onClick: onClickSearchFeature, keepOnHoverOutTarget: true, offsetX: 12 };
            var additionalToolTipProps = tf.js.ShallowMerge(toolTipProps);
            var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), appCtx = appContent.GetAppCtx();
            var addedResults = updateNotification.addedResults, nAddedResults = addedResults.length;
            var deletedResults = updateNotification.deletedResults, nDeletedResults = deletedResults.length;
            var selectedSearch = appCtx.GetCtxAttribute(tf.TFMap.CAN_selectedSearch);
            var doWithHold = true;
            var minZIndex = settings.minZIndex;
            //additionalToolTipProps.toolTipText = "Image boundaries";
            delete additionalToolTipProps.toolTipText;
            delete additionalToolTipProps.onClick;
            additionalToolTipProps.keepOnHoverOutTarget = false;
            if (searchFeaturesByKeyHB == undefined) { searchFeaturesByKeyHB = {}; }
            if (searchFeaturesByKeyMB == undefined) { searchFeaturesByKeyMB = {}; }
            var quadriPolyFeatureStyle = [{ line: true, line_color: "#45f7f7", line_width: 2, zindex: 2 }, { fill: true, fill_color: "#fff", fill_opacity: 25, zindex: 3 }];
            var quadriPolyVertexStyle = [{
                zindex: 5, circle: true, circle_radius: 12, fill: true, fill_color: "#fff", line: true, line_color: "#45f7f7", line_width: 2, line_opacity: 30
            }, { zindex: 6, font: "600 14px Roboto", text: true, fill: true, fill_color: "#037", line: true, line_opacity: 70, line_color: "#fffffc", line_width: 2 }];
            var placeBoundaryFeatureStyle = [{ line: true, line_color: "#000", zindex: 1, line_width: lineWidthForPlaceBoundaryMeasures + 2, line_opacity: 70, line_cap: "round" }];
            var propsDisplayer = appContent.GetMapFeaturePropsDisplayer();
            var firstRecordProcessedLastKey;
            for (var i = nAddedResults - 1; i >= 0; --i) {
                var result = addedResults[i], key = result.key;
                var buttonClasses = propsDisplayer.GetMapFeaturePropsTextButtonClass();
                if (searchFeaturesByKeyHB[key] == undefined) {
                    var onPostCompose = undefined;
                    var resultProps = result.properties;
                    var geom = result.geometry, coords = geom.coordinates;
                    var bottomContent = undefined, bottomContentType;
                    var additionalFeatures = undefined;
                    var addButtons = [];
                    var polyMapFeature = undefined, polyMeasure = undefined, polyArea = undefined;
                    //if (searchFeaturesByKeyMB[key] != undefined) { console.log('search has H but not M feature'); }
                    createAddButton(addButtons, { buttonClass: buttonClasses, toolTipText: "View Detail Report", clickVerb: "detail", buttonText: "Detail" }, resultProps.Display_Link_Detail);
                    createAddButton(addButtons, { buttonClass: buttonClasses, toolTipText: "View Nearby Report", clickVerb: "nearby", buttonText: "Nearby" }, resultProps.Display_Link_Report_Recentered);
                    createAddButton(addButtons, { buttonClass: buttonClasses, toolTipText: "View Location Report", clickVerb: "location", buttonText: "Location" }, resultProps.Display_Link_Location);
                    createAddButton(addButtons, { buttonClass: buttonClasses, toolTipText: "Professional detail report for realtors only", clickVerb: "pro", buttonText: "Pro" }, resultProps.Display_Link_Pro);
                    var photos = tf.js.GetNonEmptyString(resultProps.photo, undefined);
                    if (!!photos) {
                        bottomContentType = tf.TFMap.BottomContentTypes.photos;
                        bottomContent = {
                            photoNamesStr: photos,
                            onClick: onPhotoClicked
                        };
                        result.mapFeatureText = '* ' + result.mapFeatureText;
                    }
                    if (tf.js.GetIsNonEmptyString(resultProps.place_boundary)) {
                        var coordsStr = resultProps.place_boundary.split("coordinates: ");
                        if (coordsStr.length == 2) {
                            coordsStr = coordsStr[1];
                            if (coordsStr.length > 2) {
                                coordsStr = coordsStr.substring(0, coordsStr.length - 2);
                                //var thisPlaceStyle = tf.js.ShallowMerge(placeBoundaryFeatureStyle, { line_color: settings.color });
                                var coordinates = tf.js.JSONParse(coordsStr);
                                polyMapFeature = new tf.map.Feature({
                                    type: "polygon", coordinates: coordinates, style: placeBoundaryFeatureStyle/*thisPlaceStyle*/,
                                    originalSearchFeature: result, toolTipCoords: coords
                                });
                                polyMeasure = coordinates[0].slice(0);
                                polyMeasure = polyMeasure.slice(0, polyMeasure.length - 1);
                                polyArea = polyMapFeature.GetGeom().GetArea();
                                onPostCompose = displayPlaceBoundaryMeasures;
                                additionalFeatures = [];
                                additionalFeatures.push(polyMapFeature);
                            }
                        }
                    }
                    else if (resultProps.UC_X1 !== undefined) {
                        var UC_X1 = tf.js.GetLongitudeFrom(resultProps.UC_X1), UC_X2 = tf.js.GetLongitudeFrom(resultProps.UC_X2);
                        var UC_X3 = tf.js.GetLongitudeFrom(resultProps.UC_X3), UC_X4 = tf.js.GetLongitudeFrom(resultProps.UC_X4);
                        var UC_Y1 = tf.js.GetLatitudeFrom(resultProps.UC_Y1), UC_Y2 = tf.js.GetLatitudeFrom(resultProps.UC_Y2);
                        var UC_Y3 = tf.js.GetLatitudeFrom(resultProps.UC_Y3), UC_Y4 = tf.js.GetLatitudeFrom(resultProps.UC_Y4);
                        var v1 = [UC_X1, UC_Y1], v2 = [UC_X2, UC_Y2], v3 = [UC_X3, UC_Y3], v4 = [UC_X4, UC_Y4];
                        var polyVertices = [v1, v2, v3, v4, v1];
                        polyMapFeature = new tf.map.Feature({
                            type: "polygon", coordinates: [polyVertices], style: quadriPolyFeatureStyle,
                            originalSearchFeature: result, toolTipCoords: coords
                        });
                        additionalFeatures = [];
                        additionalFeatures.push(polyMapFeature);
                        tf.TFMap.SetMapFeatureToolTipProps(polyMapFeature, tf.js.ShallowMerge(additionalToolTipProps, { toolTipText: "Image boundaries" }));
                        for (var iV = 0; iV < polyVertices.length - 1; ++iV) {
                            var indexStr = ' #' + (iV + 1)
                            var vertexStyle = quadriPolyVertexStyle.slice(0);
                            var vertexCoords = polyVertices[iV];
                            vertexStyle[1] = tf.js.ShallowMerge(vertexStyle[1], { label: indexStr });
                            var vertexFeature = new tf.map.Feature({
                                type: "point", coordinates: vertexCoords, style: vertexStyle,
                                originalSearchFeature: result
                            });
                            additionalFeatures.push(vertexFeature);
                            var vertexCoordsStr = vertexCoords[1].toFixed(5) + ", " + vertexCoords[0].toFixed(5)
                            var toolTipText = tf.TFMap.MapTwoLineSpan("Boundary vertex " + indexStr, vertexCoordsStr);
                            tf.TFMap.SetMapFeatureToolTipProps(vertexFeature, tf.js.ShallowMerge(additionalToolTipProps, { toolTipText: toolTipText }));
                        }
                        polyMeasure = [v1, v2, v3, v4];
                        polyArea = polyMapFeature.GetGeom().GetArea();
                        onPostCompose = displayImageBoundaryMeasures;
                    }
                    var commonSettings = {
                        searchFeature: result,
                        onPrepareForPropsDisplay: prepareForPropsDisplay,
                        showToolTip: result.mapFeatureImageSrc != undefined,
                        minZIndex: minZIndex,
                        getDisplayProps: getDisplayProps,
                        additionalFeatures: additionalFeatures,
                        onPostCompose: onPostCompose,
                        polyMapFeature: polyMapFeature,
                        polyMeasure: polyMeasure,
                        polyArea: polyArea,
                        hasStaticBottomContent: bottomContent != undefined,
                        bottomContentType: bottomContentType,
                        bottomContent: bottomContent,
                        onClose: onCloseDisplayProps,
                        isInLayer: true,
                        color: settings.color,
                        text: result.mapFeatureText,
                        imageSrc: result.mapFeatureImageSrc,
                        compassDirectionAngle: result.compassDirectionAngle,
                        onClick: onClickSearchButton,
                        addButtons: addButtons
                    };
                    var searchFeatureHBSettings = tf.js.ShallowMerge(commonSettings, { isForHybrid: true });
                    settings.addStyles(geom, searchFeatureHBSettings);
                    var searchFeatureHB = new tf.map.Feature(tf.js.ShallowMerge(geom, searchFeatureHBSettings));
                    var searchFeatureMBSettings = tf.js.ShallowMerge(commonSettings, { isForHybrid: false });
                    settings.addStyles(geom, searchFeatureMBSettings);
                    var searchFeatureMB = new tf.map.Feature(tf.js.ShallowMerge(geom, searchFeatureMBSettings));
                    tf.TFMap.SetMapFeatureToolTipProps(searchFeatureHB, toolTipProps);
                    tf.TFMap.SetMapFeatureToolTipProps(searchFeatureMB, toolTipProps);
                    result.properties.coords = coords;
                    searchFeatureHB.isVisible = searchFeatureMB.isVisible = isVisible;
                    if (isVisible) {
                        layerHB.AddMapFeature(searchFeatureHB, doWithHold);
                        layerMB.AddMapFeature(searchFeatureMB, doWithHold);
                    }
                    searchFeaturesByKeyHB[key] = searchFeatureHB;
                    searchFeaturesByKeyMB[key] = searchFeatureMB;
                    if (firstRecordProcessedLastKey == undefined) {
                        firstRecordProcessedLastKey = key;
                    }
                }
            }
            var needDeselectSelectedSearch = false;
            for (var i = 0; i < nDeletedResults; ++i) {
                var result = deletedResults[i], key = result.key;
                var existingFeatureHB = searchFeaturesByKeyHB[key];
                var existingFeatureMB = searchFeaturesByKeyMB[key];
                if (!!existingFeatureHB) {
                    delete searchFeaturesByKeyHB[key];
                    if (selectedSearch == existingFeatureHB) { needDeselectSelectedSearch = true; }
                    if (isVisible) { if (existingFeatureHB.isVisible) { layerHB.DelMapFeature(existingFeatureHB, doWithHold); } }
                }
                if (!!existingFeatureMB) {
                    delete searchFeaturesByKeyMB[key];
                    if (selectedSearch == existingFeatureMB) { needDeselectSelectedSearch = true; }
                    if (isVisible) { if (existingFeatureMB.isVisible) { layerMB.DelMapFeature(existingFeatureMB, doWithHold); } }
                }
            }
            if (doWithHold) {
                layerHB.DelWithheldFeatures();
                layerMB.DelWithheldFeatures();
                layerHB.AddWithheldFeatures();
                layerMB.AddWithheldFeatures();
            }
            if (needDeselectSelectedSearch) {
                appCtx.SetCtxAttribute(tf.TFMap.CAN_selectedSearch, undefined);
                appContent.ShowMapFeatureProps(undefined);
            }
            if (dlayerPreClick) {
                dlayerPreClick = false;
                if (firstRecordProcessedLastKey != undefined) {
                    var mapFeature = getIsShowingAerial ? searchFeaturesByKeyHB[firstRecordProcessedLastKey] : searchFeaturesByKeyMB[firstRecordProcessedLastKey];
                    if (!!mapFeature) {
                        appContent.ShowMapFeatureProps(mapFeature);
                    }
                }
            }
            else if (nDLayerExtent != undefined && nDLayerExtent > 0) {
                var extent = dataSet.GetInitialExtent();
                appContent.SetMapExtent(extent);
                nDLayerExtent = undefined;
            }
        }
    }
    function displayMeasureVertices(canvas, polyMeasure, polyArea, drawSettings) {
        if (!!polyMeasure) {
            var vertexInfos = tf.js.CalcVertexInfos(polyMeasure, polyArea);
            var nPoints = vertexInfos.length;
            if (nPoints >= 2) {
                var map = settings.appContent.GetMap();
                var showingHybrid = getIsShowingAerial();
                var ctx = canvas.getContext("2d");
                var extent = map.GetVisibleExtent();
                var requiredDrawSettings = {
                    map: map, ctx: ctx, distances3Units: tf.TFMap.LayoutSettings.distances3Units, vertexInfos: vertexInfos,
                    showingHybrid: showingHybrid, extent: extent
                };
                var defaultDrawSettings = { showArea: true, showIntermediateLenghts: true };
                tf.js.DrawMeasuredVertices(tf.js.ShallowMerge(defaultDrawSettings, drawSettings, requiredDrawSettings));
            }
        }
    }
    function displayImageBoundaryMeasures(notification) {
        var props = notification.props;
        return displayMeasureVertices(notification.pcNotification.canvas, props.polyMeasure, props.polyArea, {});
    }
    function displayPlaceBoundaryMeasures(notification) {
        var props = notification.props;
        var appContent = settings.appContent;
        var level = appContent.GetMap().GetLevel();
        var area = props.polyArea;
        var isSmallScreen = appContent.GetAppStyles().GetIsSmallScreen();
        var minLevel = isSmallScreen ? 15 : 16;
        var bigArea = area >= 100000;
        var medArea = !bigArea && area > 10000;
        var smArea = !bigArea && !medArea;
        var levelForTics = bigArea ? minLevel + 1 : (medArea ? minLevel + 2 : minLevel + 3);
        var levelForScaleText = levelForTics + 0;
        var levelForIntermediateLengths = levelForScaleText + 1;
        displayMeasureVertices(notification.pcNotification.canvas, props.polyMeasure, area, {
            colorSeg: props.color, lineWidth: lineWidthForPlaceBoundaryMeasures, largerFontSize: "18px",
            showIntermediateLenghts: level >= levelForIntermediateLengths,
            skipScaleText: level < levelForScaleText,
            skipTics: level < levelForTics,
            skipMeasures: level < minLevel
        });
    }
    function createAddButton(addButtons, buttonProps, linkStr) {
        if (tf.js.GetIsNonEmptyString(linkStr)) {
            buttonProps.linkStr = linkStr;
            addButtons.push(buttonProps);
        }
    }
    function onClickSearchButton(notification) {
        var toolTipSender = notification.toolTipSender;
        var sender = !!toolTipSender ? toolTipSender : notification.sender;
        var senderSettings = sender.GetSettings();
        var buttonSettings = senderSettings.buttonSettings;
        var clickVerb = buttonSettings.clickVerb;
        var linkStr = buttonSettings.linkStr;
        if (tf.js.GetIsNonEmptyString(linkStr)) { var nextWindow = window.open(linkStr, "_top"); }
    }
    function setSelectedSearchMapFeature(mapFeature) {
        if (!!mapFeature) {
            settings.appContent.GetAppCtx().SetCtxAttribute(tf.TFMap.CAN_selectedSearch, mapFeature);
            settings.appContent.ShowMapFeatureProps(mapFeature);
        }
    }
    function onClickSearchFeature(notification) { setSelectedSearchMapFeature(notification.toolTipSender.mapFeature); }
    function getDisplayProps(mapFeature) {
        var props = mapFeature.GetSettings();
        var innerHTML = "";
        var searchProps = tf.TFMap.GetSearchProps(mapFeature);
        var appContent = settings.appContent;
        var propsDisplayer = appContent.GetMapFeaturePropsDisplayer();
        if (!!searchProps) {
            var innerHTML = propsDisplayer.CreateMapFeatureTitleSpan(searchProps.Display_Label, settings.color);
            var nextPropsText;
            var propsImage = tf.js.GetNonEmptyString(searchProps.Display_Thumbnail, undefined);
            if (tf.js.GetIsNonEmptyString(propsImage)) {
                var nextPropsText = tf.js.GetNonEmptyString(searchProps.Display_Summary_Short_Text);
                if (tf.js.GetIsNonEmptyString(nextPropsText)) { innerHTML += propsDisplayer.CreateMapFeatureTextSpan(nextPropsText); }
                innerHTML += propsDisplayer.CreateMapFeatureImageDiv(propsImage);
            }
            nextPropsText = tf.js.GetNonEmptyString(searchProps.Display_Summary_Longer_Text_HTML, tf.js.GetNonEmptyString(searchProps.Display_Summary_Midsize_Text, undefined));
            if (tf.js.GetIsNonEmptyString(nextPropsText)) { innerHTML += propsDisplayer.CreateMapFeatureTextSpan(nextPropsText); }
        }
        return { innerHTML: innerHTML };
    }
    /*function doRefreshStyles(layer, featuresByKey) {
        for (var i in featuresByKey) { var fbk = featuresByKey[i]; if (fbk.isVisible) { layer.DelMapFeature(fbk); featuresByKey[i].RefreshStyle(); } }
        for (var i in featuresByKey) { var fbk = featuresByKey[i]; if (fbk.isVisible) { layer.AddMapFeature(fbk, true); } }
        layer.AddWithheldFeatures();
    }*/
    function addDelFeatures() {
        var layerH = settings.layerHybrid, layerM = settings.layerMap, layerHB = settings.layerHybridB, layerMB = settings.layerMapB;
        addDelLayerFeatures(layerHB, searchFeaturesByKeyHB);
        addDelLayerFeatures(layerMB, searchFeaturesByKeyMB);
    }
    function addDelLayerFeatures(layer, features) {
        var doWithHold = true;
        for (var i in features) {
            var feature = features[i];
            var featureVisible = feature.isVisible;
            if (featureVisible != isVisible) {
                if (isVisible) { layer.AddMapFeature(feature, doWithHold); } else { layer.DelMapFeature(feature, doWithHold); }
                feature.isVisible = isVisible;
            }
            else { console.log('unexpected feature visibility status'); }
        }
        if (doWithHold) { if (isVisible) { layer.AddWithheldFeatures(); } else { layer.DelWithheldFeatures(); } }
    }
    function updateIsVisibleFromContext() {
        isVisible = settings.appContent.GetAppCtx().GetCtxAttribute(settings.visibilityVerb);
    }
    function getSortedNeighborResults(result) {
        var searchItems = dataSet.GetSearchItems(), nSearchItems = dataSet.GetCount();
        var sortedNeighbors = [];
        var resultCoords = result.geometry.coordinates;
        for (var i = 0; i < nSearchItems; ++i) {
            var thisItem = searchItems[i];
            //if (thisItem != result) {
            var thisItemCoords = thisItem.geometry.coordinates;
            var thisDistance = tf.units.GetHaversineDistance(thisItemCoords, resultCoords);
            var thisNeighbor = { result: thisItem, distance: thisDistance };
            sortedNeighbors.push(thisNeighbor);
            //}
        }
        sortedNeighbors.sort(function(a, b) { var da = a.distance, db = b.distance; return da == db ? 0 : (da < db ? -1 : 1); });
        return sortedNeighbors;
    }
    function prepareForPropsDisplay(mapFeature) {
        var mapFeatureSettings = mapFeature.GetSettings();
        if (!mapFeatureSettings.hasStaticBottomContent) {
            var result = tf.TFMap.GetSearchFeature(mapFeature), resultProps = result.properties;
            if (resultProps.Display_Thumbnail != undefined) {
                var sortedNeighbors = getSortedNeighborResults(result), nSortedNeighbors = sortedNeighbors.length;
                var maxNeighbors = 19;
                var photoNames = [];
                var photoTitles = [];
                var photosToMapCoords = [];
                var shownNeighbors = [];
                var addedCount = 0;
                //if (nSortedNeighbors > maxNeighbors) { nSortedNeighbors = maxNeighbors; }
                for (var i = 0; i < nSortedNeighbors && addedCount < maxNeighbors; ++i) {
                    var thisNeighbor = sortedNeighbors[i];
                    var thisNeighborResultProps = thisNeighbor.result.properties;
                    //var thisNeighborFileName = tf.js.GetNonEmptyString(thisNeighborResultProps.mainphoto, thisNeighborResultProps.Display_Thumbnail);
                    var thisNeighborFileName = thisNeighborResultProps.Display_Thumbnail;
                    if (thisNeighborFileName != undefined) {
                        photosToMapCoords.push(thisNeighborResultProps.coords);
                        photoNames.push(thisNeighborFileName);
                        photoTitles.push(thisNeighborResultProps.Display_Label);
                        shownNeighbors.push(thisNeighbor);
                        ++addedCount;
                    }
                }
                if (shownNeighbors.length > 0) {
                    mapFeatureSettings.bottomContentType = tf.TFMap.BottomContentTypes.photos;
                    mapFeatureSettings.bottomContent = {
                        photoTitles: photoTitles,
                        toolTipText: getNeighborToolTipText,
                        photosToMapCoords: photosToMapCoords,
                        photoNames: photoNames,
                        onClick: onPhotoRecordClicked,
                        shownNeighbors: shownNeighbors
                    };
                }
            }
        }
    }
    function getNeighborToolTipText(notification) {
        var photoList = notification.photoList, photoSettings = photoList.GetLastContentSettings();
        var shownNeighbors = photoSettings.shownNeighbors, thisRecord = shownNeighbors[notification.index];
        var thisResultProps = thisRecord.result.properties, recordLabel = thisResultProps.Display_Label;
        return "View " + recordLabel;
    }
    function onCloseDisplayProps(mapFeature) {
        var mapFeatureSettings = mapFeature.GetSettings();
        if (mapFeatureSettings.bottomContent != undefined && !mapFeatureSettings.hasStaticBottomContent) {
            var result = tf.TFMap.GetSearchFeature(mapFeature), resultProps = result.properties;
            if (resultProps.Display_Thumbnail != undefined) { mapFeatureSettings.bottomContent = undefined; }
        }
        var appCtx = settings.appContent.GetAppCtx();
        if (mapFeature == appCtx.GetCtxAttribute(tf.TFMap.CAN_selectedSearch)) { appCtx.SetCtxAttribute(tf.TFMap.CAN_selectedSearch, undefined); }
    }
    function onPhotoClicked(notification) {
        var photoListDisplayer = notification.sender;
        settings.appContent.ShowPhoto({ photoListDisplayer: photoListDisplayer, photoName: notification.photoName }, notification.button.GetButton());
    }
    function onPhotoRecordClicked(notification) {
        var photoListDisplayer = notification.sender;
        var photoList = photoListDisplayer.GetLastPhotoList();
        var photoSettings = photoList.GetLastContentSettings();
        var shownNeighbors = photoSettings.shownNeighbors;
        var thisRecord = shownNeighbors[notification.index];
        var thisRecordResult = thisRecord.result;
        var thisResultProps = thisRecordResult.properties;
        if (notification.isSelect) {
            var appContent = settings.appContent;
            var key = thisRecordResult.key;
            if (appContent.GetIsShowingPhoto()) { appContent.GetPhotoDisplayer().OnClose(); }
            setSelectedSearchMapFeatureAndSetCenter(getMapFeatureByKey(key));
        }
        else {
            var recordLabel = thisResultProps.Display_Label;
            var dataSetName = dataSet.GetDataSetTitle();
            var toolTipText = tf.TFMap.MapTwoLineSpan("Click to select in '" + dataSetName + "'", recordLabel);
            settings.appContent.ShowPhoto({ photoListDisplayer: photoListDisplayer, theRecord: thisRecord, photoName: notification.photoName, onClick: onFullPhotoClick, toolTipText: toolTipText }, notification.button.GetButton());
        }
    }
    function getIsShowingAerial() { return settings.appContent.GetIsShowingAerial(); }
    function getMapFeatureByKey(key) { return getIsShowingAerial() ? searchFeaturesByKeyHB[key] : searchFeaturesByKeyMB[key]; }
    function setSelectedSearchMapFeatureAndSetCenter(mapFeature) {
        if (!!mapFeature) {
            var appContent = settings.appContent;
            setSelectedSearchMapFeature(mapFeature);
            appContent.AnimatedSetCenterIfDestVisible(mapFeature.GetPointCoords());
        }
    }
    function onFullPhotoClick(notification) {
        notification.sender.OnClose();
        setSelectedSearchMapFeatureAndSetCenter(getMapFeatureByKey(notification.photoSettings.theRecord.result.key));
    }
    function getSearchMapFeatureToolTipText(toolTipProps) {
        var mapFeatureSettings = toolTipProps.mapFeature.GetSettings();
        var searchFeatureProps = mapFeatureSettings.searchFeature.properties;
        var title = tf.js.GetNonEmptyString(searchFeatureProps.Display_Label, searchFeatureProps.L);
        if (!tf.js.GetIsNonEmptyString(title)) { title = dataSet.GetDataSetTitle() + " search result"; }
        return title;
    }
    function initialize() {
        lineWidthForPlaceBoundaryMeasures = 3;
        nDLayerExtent = (dlayerPreClick = settings.dlayerPreClick) ? undefined : settings.nDLayerExtent;
        updateIsVisibleFromContext();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: sidepane.js
tf.TFMap.SidePane = function(settings) {
    var theThis, cssTag, paneWrapper, paneContent, toggleButton, isVisible;
    this.GetContentPane = function() { return paneContent; }
    this.GetWrapper = function() { return paneWrapper; }
    this.CheckIsVisible = function() { return checkIsVisible(); }
    function onToggleButtonClick(notification) { settings.appContent.GetAppCtx().SetCtxAttribute(tf.TFMap.CAN_sidePanelVisible, toggleButton.GetIsToggled()); }
    function getToggleButtonToolTipText() { var verbStr = isVisible ? "Collapse" : "Expand"; return verbStr + " side panel"; }
    function getShouldBeVisible() { return settings.appContent.GetAppCtx().GetCtxAttribute(tf.TFMap.CAN_sidePanelVisible); }
    function setVisible(isVisibleSet) {
        tf.dom.ReplaceCSSClassCondition(paneWrapper, isVisible = isVisibleSet, visibleClassName, collapsedClassName);
        toggleButton.SetIsToggled(isVisible);
    }
    function checkIsVisible() { var shouldBeVisible = getShouldBeVisible(); if (isVisible != shouldBeVisible) { setVisible(shouldBeVisible); } }
    function createControl() {
        var appContent = settings.appContent;
        var shouldBeVisible = getShouldBeVisible();
        var toggleButtonWrapper = new tf.dom.Div({ cssClass: toggleButtonWrapperClassName });
        var delayMillis = 0;
        var toolTipClass = "center";
        var toolTipArrowClass = "left";
        var toolTipStyle = undefined;
        var ls = tf.TFMap.LayoutSettings;
        var buttonSettings = {
            onClick: onToggleButtonClick, onHover: undefined, wrapper: toggleButtonWrapper, delayMillis: delayMillis, toolTipClass: toolTipClass, toolTipArrowClass: toolTipArrowClass, toolTipStyle: toolTipStyle
        };
        paneWrapper = new tf.dom.Div({ cssClass: wrapperClassName });
        paneContent = new tf.dom.Div({ cssClass: contentClassName });
        toggleButton = appContent.CreateToggleButton(tf.js.ShallowMerge(buttonSettings, {
            offsetX: 4,
            buttonClass: toggleButtonClassName + " ripple", classToggled: ls.arrowLeftBackgroundClassName, classNotToggled: ls.arrowRightBackgroundClassName,
            isToggled: shouldBeVisible, toolTipText: getToggleButtonToolTipText
        }));
        toggleButtonWrapper.AddContent(toggleButton.GetButton());
        paneWrapper.AddContent(paneContent, toggleButtonWrapper);
        setVisible(shouldBeVisible);
    }
    var wrapperClassName, contentClassName, collapsedClassName, visibleClassName, toggleButtonWrapperClassName, toggleButtonClassName;
    function createCSSClassNames() {
        wrapperClassName = tf.TFMap.CreateClassName(cssTag, "Wrapper");
        contentClassName = tf.TFMap.CreateClassName(cssTag, "Content");
        collapsedClassName = tf.TFMap.CreateClassName(cssTag, "Collapsed");
        visibleClassName = tf.TFMap.CreateClassName(cssTag, "Visible");
        toggleButtonWrapperClassName = tf.TFMap.CreateClassName(cssTag, "ToggleButtonWrapper");
        toggleButtonClassName = tf.TFMap.CreateClassName(cssTag, "ToggleButton");
    }
    function createCSSClasses() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var cssClasses = [];
        var ls = tf.TFMap.LayoutSettings;
        var sidePanelWidthInt = ls.sidePanelWidthInt, sidePanelWidthPx = sidePanelWidthInt + 'px';
        var sidePaneLeftMarginInt = ls.leftMarginInt;
        var sidePanelTopMarginInt = ls.topMarginInt, sidePanelTopMarginPx = sidePanelTopMarginInt + 'px';
        var lightBackground = ls.lightBackground;
        var toggleButtonHeightPx = ls.toggleButtonHeightInt + 'px';
        cssClasses[wrapperClassName] = {
            inherits: [CSSClasses.transitionPoint2s, CSSClasses.leftTopZero, CSSClasses.HOneHundred, CSSClasses.displayBlock, CSSClasses.overflowVisible,
            CSSClasses.backgroundColorTransparent, CSSClasses.cursorDefault, CSSClasses.pointerEventsNone, CSSClasses.noMarginNoBorderNoPadding, CSSClasses.positionAbsolute],
            zIndex: '' + (ls.rootDivZIndex + ls.sidePaneWrapperZIndexAdd),
            width: sidePanelWidthPx
        };
        cssClasses[contentClassName] = {
            inherits: [CSSClasses.pointerEventsNone, CSSClasses.WHOneHundred, CSSClasses.displayBlock, CSSClasses.overflowShow, CSSClasses.backgroundColorTransparent,
            CSSClasses.cursorDefault, CSSClasses.noMarginNoBorderNoPadding, CSSClasses.positionAbsolute, CSSClasses.leftTopZero, CSSClasses.zIndex1]
        };
        cssClasses[collapsedClassName] = {
            transform: "translateX(-" + (sidePanelWidthInt /*+ sidePaneLeftMarginInt*/) + "px)",
            "-webkit-transform": "translateX(-" + (sidePanelWidthInt /*+ sidePaneLeftMarginInt*/) + "px)"
        };
        cssClasses[visibleClassName] = {
            transform: "translateX(0px)",
            "-webkit-transform": "translateX(0px)"
        };
        cssClasses[toggleButtonWrapperClassName] = {
            inherits: [CSSClasses.borderRadius2px, CSSClasses.pointerEventsAll, CSSClasses.whiteSpaceNoWrap, CSSClasses.displayBlock, CSSClasses.overflowVisible, CSSClasses.cursorDefault,
            CSSClasses.noMargin, CSSClasses.noPadding, CSSClasses.positionAbsolute, CSSClasses.zIndex1],
            left: "calc(100% + 1px)", top: sidePanelTopMarginPx, background: lightBackground
        };
        cssClasses[toggleButtonClassName] = {
            inherits: [CSSClasses.borderRadius2px, CSSClasses.baseImageButton, CSSClasses.borderLeftD4, CSSClasses.boxShadow01403, CSSClasses.overflowHidden],
            width: "23px", height: toggleButtonHeightPx
        };
        cssClasses[toggleButtonClassName + ":hover"] = {
            border: "1px solid rgba(0,48,118,0.4)"
        };
        return cssClasses;
    }
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function onLayoutChange(notification) { registerCSSClasses(); }
    var lcl;
    function initialize() {
        cssTag = 'sidePane';
        createCSSClassNames();
        registerCSSClasses();
        createControl();
        lcl = settings.appContent.GetAppStyles().AddOnLayoutChangeListener(onLayoutChange);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: bottompane.js
tf.TFMap.BottomPane = function(settings) {
    var theThis, cssTag, paneWrapper, paneContent, underBottomWrapper;
    var upClassName, downClassName, fullWidthClassName, widthWithSidePanelClassName, underBottomWrapperClassName;
    this.GetPositionClasses = function() { return { upClassName: upClassName, downClassName: downClassName, fullWidthClassName: fullWidthClassName, widthWithSidePanelClassName: widthWithSidePanelClassName }; }
    this.GetContentPane = function() { return paneContent; }
    this.GetWrapper = function() { return paneWrapper; }
    this.GetUnderBottomWrapper = function() { return underBottomWrapper; }
    function createControl() {
        paneWrapper = new tf.dom.Div({ cssClass: wrapperClassName });
        paneContent = new tf.dom.Div({ cssClass: contentClassName });
        underBottomWrapper = new tf.dom.Div({ cssClass: underBottomWrapperClassName });
        paneContent.AddContent(underBottomWrapper);
        paneContent.AddContent();
        paneWrapper.AddContent(paneContent);
    }
    var wrapperClassName, contentClassName;
    function createCSSClassNames() {
        wrapperClassName = tf.TFMap.CreateClassName(cssTag, "Wrapper");
        contentClassName = tf.TFMap.CreateClassName(cssTag, "Content");
        underBottomWrapperClassName = tf.TFMap.CreateClassName(cssTag, "UnderBottomWrapper");
        upClassName = tf.TFMap.CreateClassName(cssTag, "Up");
        downClassName = tf.TFMap.CreateClassName(cssTag, "Down");
        fullWidthClassName = tf.TFMap.CreateClassName(cssTag, "FullWidth");
        widthWithSidePanelClassName = tf.TFMap.CreateClassName(cssTag, "WithSidePanel");
    }
    function createCSSClasses() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var cssClasses = [];
        var ls = tf.TFMap.LayoutSettings;
        var underBottomPaneHeightInt = ls.underBottomPaneHeightInt, underBottomPaneHeightPx = underBottomPaneHeightInt + 'px';
        var marginBottomWrapperInt = ls.marginBottomBottomPaneWrapperInt, marginBottomWrapperPx = marginBottomWrapperInt + 'px';
        var sidePanelWidthInt = ls.sidePanelWidthInt, sidePanelWidthPx = sidePanelWidthInt + 'px';
        cssClasses[wrapperClassName] = {
            inherits: [CSSClasses.zIndex1, CSSClasses.transitionPoint2s, CSSClasses.displayBlock, CSSClasses.overflowVisible,
            CSSClasses.backgroundColorTransparent, CSSClasses.cursorDefault, CSSClasses.pointerEventsNone,
            CSSClasses.noMarginNoBorderNoPadding, CSSClasses.positionAbsolute],
            height: "1px"
        };
        cssClasses[contentClassName] = {
            inherits: [CSSClasses.pointerEventsNone, CSSClasses.WHOneHundred, CSSClasses.displayBlock, CSSClasses.overflowShow,
            CSSClasses.backgroundColorTransparent, CSSClasses.cursorDefault, CSSClasses.noMarginNoBorderNoPadding,
            CSSClasses.positionAbsolute, CSSClasses.leftTopZero, CSSClasses.zIndex1]
        };
        cssClasses[underBottomWrapperClassName] = {
            inherits: [CSSClasses.transitionPoint2s, CSSClasses.displayBlock, CSSClasses.overflowVisible, CSSClasses.backgroundColorTransparent,
            CSSClasses.cursorDefault, CSSClasses.pointerEventsNone, CSSClasses.noMarginNoBorderNoPadding, CSSClasses.positionAbsolute],
            zIndex: '' + (ls.rootDivZIndex + ls.underBottomWrapperZIndexAdd),
            bottom: marginBottomWrapperPx, top: "calc(100% + " + marginBottomWrapperPx + ")", left: "0px", height: underBottomPaneHeightPx, width: "100%"
        };
        cssClasses[upClassName + " ." + wrapperClassName] = { bottom: (underBottomPaneHeightInt + marginBottomWrapperInt) + 'px' };
        cssClasses[downClassName + " ." + wrapperClassName] = { bottom: marginBottomWrapperPx };
        cssClasses[fullWidthClassName + " ." + wrapperClassName] = { inherits: [CSSClasses.WOneHundred], left: "0px" };
        cssClasses[widthWithSidePanelClassName + " ." + wrapperClassName] = { width: "calc(100% - " + sidePanelWidthPx + ")", left: sidePanelWidthPx };
        return cssClasses;
    }
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function onLayoutChange(notification) { registerCSSClasses(); }
    var lcl;
    function initialize() {
        cssTag = 'bottomPane';
        createCSSClassNames();
        registerCSSClasses();
        createControl();
        lcl = settings.appContent.GetAppStyles().AddOnLayoutChangeListener(onLayoutChange);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: compass.js
tf.TFMap.Compass = function(settings) {
    var theThis, cssTag, wrapper, clockWiseButton, resetButton, antiClockWiseButton;
    var wrapperClassName, antiClockButtonClassName, clockButtonClassName, clockAntiClockButtonClassName, compassButtonClassName, compassButtonSVGClassName;
    this.GetWrapper = function() { return wrapper; }
    function onButtonClicked(notification) {
        var diffRad, unit = 1;
        var appContent = settings.appContent, map = appContent.GetMap();
        switch (notification.sender) {
            case resetButton: map.AnimatedResetRotation(); break;
            case clockWiseButton: diffRad = unit; break;
            case antiClockWiseButton: diffRad = -unit; break;
        }
        if (diffRad != undefined) {
            var rotNow = map.GetRotationRad(), rotNew = rotNow + diffRad * Math.PI / 8;
            //var tolerance = 0.001;
            //if (diffRad > 0) { var lim = Math.PI; if (rotNew + tolerance >= lim) { rotNow -= lim; rotNew -= lim; map.SetRotationRad(rotNow); } }
            //else { var lim = -Math.PI; if (rotNew - tolerance <= lim) { rotNow += lim; rotNew += lim; map.SetRotationRad(rotNow); } }
            map.AnimatedSetRotation(rotNew);
        }
    }
    function makeFullToolTip(toolTipStr) {
        var topLine = 'Shift + Alt + mouse drag rotates the map';
        return tf.TFMap.MapTwoLineSpan(topLine, toolTipStr);
    }
    function createControl() {
        var ls = tf.TFMap.LayoutSettings;
        wrapper = new tf.dom.Div({ cssClass: wrapperClassName + " " + ls.aerialOrMapColorScheme });
        var appContent = settings.appContent;
        var delayMillis = tf.TFMap.toolTipDelayMillis;
        var toolTipClass = "*start";
        var toolTipArrowClass = "bottom";
        var buttonSettings = {
            onClick: onButtonClicked, onHover: undefined, wrapper: wrapper, delayMillis: delayMillis, toolTipClass: toolTipClass, toolTipArrowClass: toolTipArrowClass
        };
        var buttonsAdded = false;
        if (!!settings.compassButtons) {
            antiClockWiseButton = appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, {
                svgHTML: appContent.GetAppStyles().GetArrowDownFlipSVG(),
                buttonClass: clockAntiClockButtonClassName + " " + antiClockButtonClassName + " ripple", toolTipText: makeFullToolTip("Rotate Counter-clockwise")
            }));
            resetButton = appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, {
                svgHTML: appContent.GetAppStyles().GetCompassSVG(),
                buttonClass: compassButtonSVGClassName + " " + compassButtonClassName + " ripple", toolTipText: makeFullToolTip("Reset Rotation")
            }));
            clockWiseButton = appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, {
                svgHTML: appContent.GetAppStyles().GetArrowDownSVG(),
                buttonClass: clockAntiClockButtonClassName + " " + clockButtonClassName + " ripple", toolTipText: makeFullToolTip("Rotate Clockwise")
            }));
            buttonsAdded = true;
            wrapper.AddContent(antiClockWiseButton.GetButton(), resetButton.GetButton(), clockWiseButton.GetButton());
        }
        if (!buttonsAdded) {
            var ls = tf.TFMap.LayoutSettings;
            var wrapperE = wrapper.GetHTMLElement(), wrapperES = wrapperE.style;
            wrapperES.width = "1px";
            wrapperES.padding = wrapperES.margin = wrapperES.border = "0px";
            wrapperES.marginRight = -(ls.toolBarToToolBarHorSpacingInt) + "px"
        }
        rotateCompassButton();
    }
    function rotateCompassButton() { if (!!resetButton) { tf.GetStyles().RotateByDegree(resetButton.GetButton(), settings.appContent.GetMap().GetRotationDeg()); } }
    function onMapRotationChanged(notification) { rotateCompassButton(); }
    function createCSSClassNames() {
        wrapperClassName = tf.TFMap.CreateClassName(cssTag, "Wrapper");
        clockAntiClockButtonClassName = tf.TFMap.CreateClassName(cssTag, "ClockAntiClockButton");
        compassButtonClassName = tf.TFMap.CreateClassName(cssTag, "CompassButton");
        compassButtonSVGClassName = tf.TFMap.CreateClassName(cssTag, "CompassButtonSVG");
        antiClockButtonClassName = tf.TFMap.CreateClassName(cssTag, "AntiClockButton");
        clockButtonClassName = tf.TFMap.CreateClassName(cssTag, "ClockButton");
    }
    function createCSSClasses() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var cssClasses = [];
        var ls = tf.TFMap.LayoutSettings;
        var widthMapToolBarInt = ls.widthMapToolBarInt, widthMapToolBarPx = widthMapToolBarInt + 'px';
        var clockAntiClockSVGDims = "calc(100% - 9px)";
        cssClasses[wrapperClassName] = {
            inherits: [CSSClasses.whiteSpaceNoWrap, CSSClasses.boxShadow002003, CSSClasses.pointerEventsAll, CSSClasses.positionAbsolute],
            borderRadius: "4px",
            //bottom: ls.topMarginInt + 'px',
            bottom: "0px",  // anchored to other toolbar
            right: (ls.widthMapToolBarInt + ls.leftMarginInt + ls.toolBarToToolBarHorSpacingInt) + "px",
            padding: "2px"
        };
        cssClasses[clockAntiClockButtonClassName] = {
            inherits: [CSSClasses.boxShadow002003, CSSClasses.baseImageButton, CSSClasses.verticalAlignMiddle, CSSClasses.displayInlineBlock],
            width: Math.floor(widthMapToolBarInt / 1.6) + "px",
            height: widthMapToolBarPx
        };
        cssClasses[clockAntiClockButtonClassName + " svg"] = { width: clockAntiClockSVGDims, height: clockAntiClockSVGDims };
        cssClasses[clockAntiClockButtonClassName + ":hover"] = { border: "none" };
        cssClasses[antiClockButtonClassName] = { marginRight: "4px", marginLeft: "2px" };
        cssClasses[clockButtonClassName] = { marginLeft: "4px", marginRight: "2px" };
        cssClasses[compassButtonSVGClassName] = { inherits: [CSSClasses.boxShadow002003, CSSClasses.displayInlineBlock] };
        cssClasses[compassButtonSVGClassName + " svg"] = { width: "calc(100% - 1px)", height: "calc(100% - 1px)" };
        cssClasses[compassButtonSVGClassName + ":hover"] = { border: "none" };
        cssClasses[compassButtonClassName] = {
            inherits: [CSSClasses.baseImageButton, CSSClasses.verticalAlignMiddle],
            borderRadius: "50%", marginLeft: "4px", marginRight: "4px", width: widthMapToolBarPx, height: widthMapToolBarPx
        };
        return cssClasses;
    }
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function onLayoutChange(notification) { registerCSSClasses(); }
    var lcl, mapRotationListener;
    function initialize() {
        cssTag = 'mapCompass';
        createCSSClassNames();
        registerCSSClasses();
        createControl();
        var appContent = settings.appContent;
        lcl = appContent.GetAppStyles().AddOnLayoutChangeListener(onLayoutChange);
        mapRotationListener = appContent.GetMap().AddListener(tf.consts.mapRotationChangeEvent, onMapRotationChanged);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: maptoolbar.js
tf.TFMap.MapToolBar = function(settings) {
    var theThis, wrapper, geolocationButton, zoomInPlusButton, zoomOutMinusButton;
    var cssTag, wrapperClassName, toolBarButtonClassName;
    var geolocationButtonClassName, zoomInButtonClassName, zoomOutButtonClassName;
    var separatorMarginBottomClassName;
    this.GetWrapper = function() { return wrapper; }
    function onLevelChangeEnded() {
        setTimeout(function() { settings.appContent.OnMapLevelChange(); }, 0);
    }
    function onButtonClicked(notification) {
        var zoomDiff;
        switch (notification.sender) {
            case zoomInPlusButton: zoomDiff = 1; break;
            case zoomOutMinusButton: zoomDiff = -1; break;
            case geolocationButton:
                settings.appContent.ShowUserLocation();
                break;
        }
        if (zoomDiff != undefined) {
            var map = settings.appContent.GetMap();
            var newLevel = map.GetLevel() + zoomDiff;
            if (newLevel >= tf.TFMap.MinMapLevel && newLevel <= tf.TFMap.MaxMapLevel) { map.AnimatedSetLevel(newLevel, onLevelChangeEnded, 200, undefined); }
        }
    }
    function createControl() {
        var ls = tf.TFMap.LayoutSettings;
        wrapper = new tf.dom.Div({ cssClass: wrapperClassName + " " + ls.aerialOrMapColorScheme });
        var appContent = settings.appContent;
        var delayMillis = tf.TFMap.toolTipDelayMillis;
        var toolTipClass = "center";
        var toolTipArrowClass = "right";
        var buttonSettings = {
            onClick: onButtonClicked, onHover: undefined, wrapper: wrapper, delayMillis: delayMillis, toolTipClass: toolTipClass, toolTipArrowClass: toolTipArrowClass
        };
        var buttonsAdded = false;
        if (!!settings.userLocation) {
            var classNamesGeoLocationButton = geolocationButtonClassName;
            if (!!settings.zoom) { classNamesGeoLocationButton += " " + separatorMarginBottomClassName; }
            geolocationButton = appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, {
                svgHTML: appContent.GetAppStyles().GetGeolocationSVG(),
                buttonClass: toolBarButtonClassName + " " + classNamesGeoLocationButton + " ripple", toolTipText: "Show Your Location"
            }));
            wrapper.AddContent(geolocationButton.GetButton());
            buttonsAdded = true;
        }
        if (!!settings.zoom) {
            zoomInPlusButton = appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, {
                svgHTML: appContent.GetAppStyles().GetAddSVG(),
                buttonClass: toolBarButtonClassName + " " + zoomInButtonClassName + " ripple", toolTipText: "Zoom In"
            }));
            zoomOutMinusButton = appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, {
                svgHTML: appContent.GetAppStyles().GetMinusSVG(),
                buttonClass: toolBarButtonClassName + " " + zoomOutButtonClassName + " ripple", toolTipText: "Zoom Out"
            }));
            wrapper.AddContent(zoomInPlusButton.GetButton(), zoomOutMinusButton.GetButton());
            buttonsAdded = true;
        }
        if (!buttonsAdded) {
            var ls = tf.TFMap.LayoutSettings;
            var wrapperE = wrapper.GetHTMLElement(), wrapperES = wrapperE.style;
            wrapperES.width = "1px";
            wrapperES.padding = wrapperES.margin = wrapperES.border = "0px";
            wrapperES.marginRight = -(ls.widthMapToolBarInt /*- ls.leftMarginInt */ + ls.toolBarToToolBarHorSpacingInt) + "px";
        }
    }
    function createCSSClassNames() {
        wrapperClassName = tf.TFMap.CreateClassName(cssTag, "Wrapper");
        toolBarButtonClassName = tf.TFMap.CreateClassName(cssTag, "ToolBarButton");
        geolocationButtonClassName = tf.TFMap.CreateClassName(cssTag, "GeoLocationButton");
        zoomInButtonClassName = tf.TFMap.CreateClassName(cssTag, "ZoomInButton");
        zoomOutButtonClassName = tf.TFMap.CreateClassName(cssTag, "ZoomOutButton");
        separatorMarginBottomClassName = tf.TFMap.CreateClassName(cssTag, "SeparatorMarginBottom");
    }
    function createCSSClasses() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var cssClasses = [];
        var ls = tf.TFMap.LayoutSettings;
        var widthMapToolBarInt = ls.widthMapToolBarInt, widthMapToolBarPx = widthMapToolBarInt + 'px';
        var rightMarginInt = ls.leftMarginInt, rightMarginPx = rightMarginInt + "px";
        var bottomMarginInt = ls.topMarginInt, bottomMarginPx = bottomMarginInt + "px";
        var marginBottomMapToolBarInt = 6, marginBottomMapToolBar = marginBottomMapToolBarInt + "px";
        var svgDims = "calc(100% - 10px)";
        cssClasses[wrapperClassName] = {
            inherits: [CSSClasses.boxShadow002003, CSSClasses.borderRadius2px, CSSClasses.pointerEventsAll, CSSClasses.positionAbsolute],
            bottom: bottomMarginPx, right: rightMarginPx, padding: "4px"
        };
        cssClasses[toolBarButtonClassName] = { inherits: [CSSClasses.borderRadius2px, CSSClasses.boxShadow002003, CSSClasses.displayFlex, CSSClasses.flexFlowRowNoWrap] };
        cssClasses[toolBarButtonClassName + " svg"] = { width: svgDims, height: svgDims, margin: "auto" };
        cssClasses[toolBarButtonClassName + ":hover"] = { border: "none" };
        var baseToolBarButton = { inherits: [CSSClasses.baseImageButton, CSSClasses.verticalAlignMiddle], width: widthMapToolBarPx, height: widthMapToolBarPx };
        cssClasses[geolocationButtonClassName] = { inherits: [baseToolBarButton] };
        cssClasses[separatorMarginBottomClassName] = { marginBottom: (marginBottomMapToolBarInt * 3) + 'px' };
        cssClasses[zoomInButtonClassName] = { inherits: [baseToolBarButton], marginBottom: marginBottomMapToolBar };
        cssClasses[zoomOutButtonClassName] = { inherits: [baseToolBarButton] };
        return cssClasses;
    }
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function onLayoutChange(notification) { registerCSSClasses(); }
    var lcl;
    function initialize() {
        cssTag = 'mapToolBar';
        createCSSClassNames();
        registerCSSClasses();
        createControl();
        lcl = settings.appContent.GetAppStyles().AddOnLayoutChangeListener(onLayoutChange);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: maplocations.js
tf.TFMap.MapRevGeoCodedLocation = function(settings) {
    var theThis, lastRevGeoCoder, mapFeature, isInLayer, isGeoCoding, isRevGeoCoding
    this.PanToMapFeature = function() { if (!!mapFeature) { settings.appContent.AnimatedSetCenterIfDestVisible(mapFeature.GetPointCoords()); } }
    this.GetMapFeature = function() { return mapFeature; }
    this.GetIsGeoCoding = function() { return isGeoCoding; }
    this.GetIsRevGeoCoding = function() { return isRevGeoCoding; }
    this.GetIsShowing = function() { return isInLayer; }
    this.Show = function(coords) { return show(coords); }
    function notifyShown() { if (tf.js.GetFunctionOrNull(settings.onShown)) { settings.onShown({ sender: theThis, isShowing: isInLayer }); } }
    function hide() { if (!!mapFeature && isInLayer) { isInLayer = false; settings.layer.DelMapFeature(mapFeature); notifyShown(); } }
    function onClick(notification) {
        var button = notification.sender;
        if (!tf.js.GetFunctionOrNull(notification.sender.GetSettings)) {
            button = notification.toolTipSender;
        }
        if (tf.js.GetFunctionOrNull(button.GetSettings)) {
            var notificationSettings = button.GetSettings();
            var buttonSettings = notificationSettings.buttonSettings;
            switch (buttonSettings.clickVerb) {
                case 'hide':
                    hide();
                    settings.appContent.ShowMapFeatureProps(undefined);
                    break;
                case 'godb':
                    settings.appContent.GoDB(mapFeature.GetPointCoords());
                    break;
            }
        }
    }
    function getDisplayProps(mapFeatureParam) {
        var appContent = settings.appContent;
        var propsDisplayer = appContent.GetMapFeaturePropsDisplayer();
        var props = mapFeature.GetSettings(), innerHTML = "", notification = props.notification;
        var buttonClasses = propsDisplayer.GetMapFeaturePropsTextButtonClass();
        var addButtons = [];
        addButtons.push({ buttonClass: buttonClasses, toolTipText: "Get Local Reports for this location", clickVerb: "godb", buttonText: "Reports" });
        addButtons.push({ buttonClass: buttonClasses, toolTipText: "Remove location marker from map", clickVerb: "hide", buttonText: "Remove" });
        props.onClick = onClick;
        props.addButtons = addButtons;
        innerHTML = propsDisplayer.CreateMapFeatureTitleSpan(settings.locationName, "#fff");
        if (!!notification) {
            if (!!notification.HTML) {
                var HTMLUse= notification.HTML;
                HTMLUse = HTMLUse.replace(/<font color="#0000FF">/g, "");
                HTMLUse = HTMLUse.replace(/<\/font>/g, "");
                innerHTML += HTMLUse;
            } else { innerHTML += "Information not found"; }
        }
        else {
            innerHTML += '<div style="width=100%;text-align: center;">Retrieving...</div>';
        }
        return { innerHTML: innerHTML };
    }
    function onCloseDisplayProps(notification) {
        if (!settings.dontHideWhenPropsClose) {
            hide();
        }
    }
    function onTFReverseGeocoded(notification) {
        if (!!notification && tf.js.GetIsNonEmptyString(notification.HTML)) {
            var mapFeatureSettings = mapFeature.GetSettings();
            mapFeatureSettings.notification = notification;
            settings.appContent.ShowMapFeatureProps(mapFeature);
        }
        isRevGeoCoding = false;
    }
    function onRevGeoCodeCoordsKnown(coords) {
        if (!!coords) {
            isRevGeoCoding = true;
            var appContent = settings.appContent;
            var map = appContent.GetMap();
            var appStyles = appContent.GetAppStyles();
            var coordsToFlash;
            if (!mapFeature) {
                var toolTipProps = { toolTipText: settings.locationName, keepOnHoverOutTarget: false, offsetX: 24 };
                var mapFeatureStyle = settings.getMapFeatureStyle({ sender: theThis, coords: coords });
                mapFeature = new tf.map.Feature(tf.js.ShallowMerge(mapFeatureStyle, {
                    getDisplayProps: getDisplayProps, onClose: onCloseDisplayProps, notification: undefined
                }));
                tf.TFMap.SetMapFeatureToolTipProps(mapFeature, toolTipProps);
                settings.layer.AddMapFeature(mapFeature);
                isInLayer = true;
                coordsToFlash = [coords];
            }
            else {
                var mapFeatureSettings = mapFeature.GetSettings();
                mapFeatureSettings.notification = undefined;
                if (!isInLayer) { settings.layer.AddMapFeature(mapFeature); isInLayer = true; }
                var nowCoords = mapFeature.GetPointCoords();
                if (nowCoords[0] != coords[0] || nowCoords[1] != coords[1]) { mapFeature.SetPointCoords(coords); coordsToFlash = [coords]; }
                //else if (!!forceFlash) { coordsToFlash = [coords]; }
            }
            if (coordsToFlash != undefined) { appStyles.FlashCoords(appContent.GetMap(), coordsToFlash, "#00f"); notifyShown(); }
            var vidPassThrough = appContent.GetVidPassThrough();
            lastRevGeoCoder = new tf.services.TFReverseGeocoder({ callBack: onTFReverseGeocoded, pointCoords: coords, resolution: map.GetResolution(), vidParam: vidPassThrough.passThrough.vid, passThrough: vidPassThrough.passThrough });
        }
    }
    function doGeoLocate() {
        if (!!navigator.geolocation) {
            isGeoCoding = true;
            navigator.geolocation.getCurrentPosition(
                function geoSuccess(position) {
                    var coords = [position.coords.longitude, position.coords.latitude];
                    onRevGeoCodeCoordsKnown(coords);
                    //setTimeout(doGeoLocate, 3000);
                },
                function geoFailure(error) {
                    isGeoCoding = false;
                }
            );
        }
    }
    function show(coords) {
        isGeoCoding = isRevGeoCoding = false;
        if (!!coords) { hide(); onRevGeoCodeCoordsKnown(coords); }
        else if (!settings.dontGeoLocate) { hide(); doGeoLocate(); }
        else { onRevGeoCodeCoordsKnown(coords); }
    }
    function initialize() { isGeoCoding = isInLayer = false; }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.TFMap.MapClickedLocation = function(settings) {
    var theThis;
    function onShown(notification) {
        var appContent = settings.appContent;
        appContent.GetAppCtx().SetCtxAttribute(tf.TFMap.CAN_clickLocation, notification.isShowing ? theThis.GetMapFeature() : undefined);
        if (notification.isShowing) { appContent.ShowMapFeatureProps(theThis.GetMapFeature()); }
    }
    function getMapFeatureStyle(notification) {
        var appStyles = settings.appContent.GetAppStyles(); return appStyles.GetSVGMapMarkerWithFrameGeom(notification.coords, appStyles.GetTapImage(), [24, 24], 32);
    }
    function initialize() {
        var geoCodedLocationSettings = tf.js.ShallowMerge(settings, {
            onShown: onShown, locationName: "Clicked Location", getMapFeatureStyle: getMapFeatureStyle,
            dontHideWhenPropsClose: true
        });
        tf.TFMap.MapRevGeoCodedLocation.call(theThis, geoCodedLocationSettings);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.TFMap.MapClickedLocation, tf.TFMap.MapRevGeoCodedLocation);
tf.TFMap.MapUserLocation = function(settings) {
    var theThis;
    function onShown(notification) {
        var appContent = settings.appContent;
        appContent.GetAppCtx().SetCtxAttribute(tf.TFMap.CAN_userLocation, notification.isShowing ? theThis.GetMapFeature() : undefined);
        if (notification.isShowing) {
            theThis.PanToMapFeature();
        }
    }
    function getMapFeatureStyle(notification) { var appStyles = settings.appContent.GetAppStyles(); return appStyles.GetSVGMapMarkerWithFrameGeom(notification.coords, appStyles.GetGeolocationImage(), [20, 20], 32); }
    function initialize() {
        tf.TFMap.MapRevGeoCodedLocation.call(theThis, tf.js.ShallowMerge(settings,
            { onShown: onShown, locationName: "Your Location", getMapFeatureStyle: getMapFeatureStyle, dontHideWhenPropsClose: true }));
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.TFMap.MapClickedLocation, tf.TFMap.MapRevGeoCodedLocation);
tf.TFMap.MapSearchLocation = function(settings) {
    var theThis, lastGeoCoder, lastSearchText, toast;;
    this.SetAddress = function(searchText, coordinates) {
        closeLastToast();
        if (!!lastGeoCoder) { lastGeoCoder.Cancel(); }
        lastSearchText = searchText;
        theThis.Show(coordinates);
        //theThis.PanToMapFeature();
    }
    this.SearchAddress = function(searchText) {
        closeLastToast();
        if (searchText != lastSearchText) {
            if (!!lastGeoCoder) { lastGeoCoder.Cancel(); }
            theThis.Show(undefined);
            changeContext(true);
            lastSearchText = searchText;
            lastGeoCoder = new tf.services.Geocoder({ callBack: onGeocoded, address: searchText });
        }
        else if (lastGeoCoder == undefined || !lastGeoCoder.GetIsInProgress()) {
            var mapFeature = theThis.GetMapFeature();
            //theThis.Show(undefined);
            theThis.Show(mapFeature.GetPointCoords());
            theThis.PanToMapFeature();
        }
    }
    function closeLastToast() { if (!!toast) { toast.Close(); toast = undefined; } }
    function showToast(str, timeout) {
        closeLastToast();
        var toaster = settings.appContent.GetToaster();
        if (!!toaster) {
            if (timeout == undefined) { timeout = 0; }
            toast = toaster.Toast({ text: str, timeout: timeout });
        }
    }
    function onShown(notification) {
        var appContent = settings.appContent;
        appContent.GetAppCtx().SetCtxAttribute(tf.TFMap.CAN_searchAddressLocation, notification.isShowing ? theThis.GetMapFeature() : undefined);
        if (notification.isShowing) {
            theThis.PanToMapFeature();
        }
    }
    function changeContext(isSearchingAddress) {
        var appContent = settings.appContent;
        appContent.GetAppCtx().SetCtxAttribute(tf.TFMap.CAN_isSearchingAddress, isSearchingAddress);
        appContent.ShowMapFeatureProps(theThis.GetMapFeature());
    }
    function onGeocoded(notification) {
        var geoCodedOK;
        if (!!notification && notification.geocoderAccuracy > 0 && tf.js.GetIsArrayWithMinLength(notification.pointCoords, 2)) {
            geoCodedOK = true;
            theThis.Show(notification.pointCoords);
        }
        else {
            theThis.Show(undefined);
            var toastStr = "<span>Sorry! We can't find map coordinates for this address, please try a different one</span>";
            lastSearchText = undefined;
            showToast(toastStr, 5000);
        }
        changeContext(false);
    }
    function getMapFeatureStyle(notification) { var appStyles = settings.appContent.GetAppStyles(); return appStyles.GetSVGMapMarkerWithFrameGeom(notification.coords, appStyles.GetMapMarkerSearchImage(), [20, 20], 32); }
    function initialize() {
        tf.TFMap.MapRevGeoCodedLocation.call(theThis, tf.js.ShallowMerge(settings,
            { onShown: onShown, locationName: "Searched Location", getMapFeatureStyle: getMapFeatureStyle, dontHideWhenPropsClose: true, dontGeoLocate: true }));
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.TFMap.MapSearchLocation, tf.TFMap.MapRevGeoCodedLocation);

// SOURCE FILE: pinmapfeature.js
tf.TFMap.PinMapFeature = function(settings) {
    var theThis, mapFeature, isInLayer, lastToMapFeature;
    this.GetMapFeature = function() { return mapFeature; }
    this.GetLastToMapFeature = function() { return lastToMapFeature; }
    this.Update = function(toMapFeature) { if (!!toMapFeature) { lastToMapFeature = toMapFeature; showAt(toMapFeature.GetPointCoords()); } else { hide(); } }
    function showAt(pointCoords) {
        if (!mapFeature) { createMapFeature(); }
        var nowCoords = mapFeature.GetPointCoords();
        if (nowCoords[0] != pointCoords[0] || nowCoords[1] != pointCoords[1]) {
            mapFeature.SetPointCoords(pointCoords);
            mapFeature.RefreshStyle();
        }
        if (!isInLayer) { settings.layer.AddMapFeature(mapFeature); isInLayer = true; }
    }
    function hide() { if (isInLayer) { settings.layer.DelMapFeature(mapFeature); isInLayer = false; } }
    function createMapFeature() {
        var geom = { type: 'point', coordinates: [0, 0] };
        var toolTipProps = { toolTipText: "Get Directions", keepOnHoverOutTarget: false, offsetX: 16 };
        mapFeature = new tf.map.Feature(settings.addStyles(geom));
        tf.TFMap.SetMapFeatureToolTipProps(mapFeature, toolTipProps);
    }
    function initialize() {
        isInLayer = false;
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: datasetsbar.js
tf.TFMap.DataSetsBar = function(settings) {
    var theThis, paneWrapper, paneContent, toggleButton, isVisible, dataSetRows, clusterButton;
    var toolBarWrapper;
    var cssTag, wrapperClassName, contentClassName, toolBarWrapperClassName, dataSetWrapperClassName, clusterButtonClassName, clusterBkClassName, noClusterBkClassName,
        dataSetTitleLabelWrapperClassName, dataSetTitleLabelClassName, dataSetColorLabelClassName;
    var onOffButtonClassName, onOffButtonOnClassName, onOffButtonOffClassName;
    var loadedOKClassName, failedToLoadClassName, refreshingLoadClassName, dataSetLoadingButtonClassName;
    var darkenBackgroundClassName;
    var buttonInactiveTextClassName, buttonInactiveClassName, buttonActiveClassName;
    var paneCollapsedClassName, paneVisibleClassName;
    this.GetContentPane = function() { return paneContent; }
    this.GetWrapper = function() { return paneWrapper; }
    this.CheckIsVisible = function() { return checkIsVisible(); }
    this.UpdateAll = function() { return updateAll(); }
    this.Update = function(dataSetName) { return update(dataSetName); }
    function onToggleButtonClick(notification) { settings.appContent.GetAppCtx().SetCtxAttribute(tf.TFMap.CAN_dataSetsPanelVisible, toggleButton.GetIsToggled()); }
    function getToggleButtonToolTipText() { var verbStr = isVisible ? "Collapse" : "Expand"; return verbStr + " markers panel"; }
    function getShouldBeVisible() { return settings.appContent.GetAppCtx().GetCtxAttribute(tf.TFMap.CAN_dataSetsPanelVisible); }
    function setVisible(isVisibleSet) { tf.dom.ReplaceCSSClassCondition(paneWrapper, isVisible = isVisibleSet, paneVisibleClassName, paneCollapsedClassName); }
    function checkIsVisible() { var shouldBeVisible = getShouldBeVisible(); if (isVisible != shouldBeVisible) { setVisible(shouldBeVisible); } }
    function updateAll() { for (var i in dataSetRows) { update(i); } }
    function update(dataSetName) {
        var dataSetRow = dataSetRows[dataSetName];
        if (!!dataSetRow) {
            //console.log('updating ' + dataSetName);
            var dataSet = dataSetRow.dataSet;
            var dataSetSettings = dataSet.GetSettings();
            var searchingButton = dataSetRow.searchingButton;
            dataSetRow.colorLabel.GetButton().style.backgroundColor = dataSetRow.searchSetting.color;
            dataSetRow.titleLabel.GetButton().innerHTML = dataSetName;
            updateARToggleOfRow(dataSetRow);
            updateVToggleOfRow(dataSetRow);
        }
    }
    function updateVisibilityClass(dataSetRow, isVisible) {
        tf.dom.ReplaceCSSClassCondition(dataSetRow.visibilityToggle.GetButton(), isVisible, onOffButtonOnClassName, onOffButtonOffClassName);
    }
    function updateVToggleOfRow(dataSetRow) {
        if (!!dataSetRow) {
            var searchSetting = dataSetRow.searchSetting;
            var isVisible = settings.appContent.GetAppCtx().GetCtxAttribute(searchSetting.visibilityVerb);
            updateVisibilityClass(dataSetRow, isVisible);
        }
    }
    function updateARToggleOfRow(dataSetRow) {
        if (!!dataSetRow) {
            var searchSetting = dataSetRow.searchSetting;
            var dataSet = dataSetRow.dataSet;
            var searchingButton = dataSetRow.searchingButton;
            var isSearching = dataSet.GetIsSearching();
            if (!isSearching) {
                var autoRefreshes = settings.appContent.GetAppCtx().GetCtxAttribute(searchSetting.autoRefreshVerb);
                var completedOK = dataSet.GetLastSearchCompletedOK();
                var classNotToggled = autoRefreshes ? (completedOK ? loadedOKClassName : failedToLoadClassName) : refreshingLoadClassName;
                searchingButton.SetClassNotToggled(classNotToggled);
            }
            searchingButton.SetIsToggled(isSearching);
            updateVisibilityClass(dataSetRow, isVisible);
        }
    }
    function updateVisibilityToggle(title) { updateVToggleOfRow(dataSetRows[title]); }
    function updateAutoRefreshToggle(title) { updateARToggleOfRow(dataSetRows[title]); }
    function toggleCtxAttribute(notification, verb) {
        var sender = !!notification.toolTipSender ? notification.toolTipSender : notification.sender;
        var searchSetting = sender.searchSetting, verb = searchSetting[verb];
        if (tf.js.GetIsNonEmptyString(verb)) {
            var appCtx = settings.appContent.GetAppCtx();
            appCtx.SetCtxAttribute(verb, !appCtx.GetCtxAttribute(verb));
        }
    }
    function onVisibilityButtonClicked(notification) { toggleCtxAttribute(notification, "visibilityVerb"); }
    function onSearchingButtonClicked(notification) { toggleCtxAttribute(notification, "autoRefreshVerb"); }
    function getMarkerColorToolTip(sender) {
        var searchSetting = sender.searchSetting, verb = searchSetting.visibilityVerb;
        var dataSetRow = dataSetRows[searchSetting.title];
        var dataSet = dataSetRow.dataSet;
        var dataSetTitle = dataSet.GetDataSetTitle();
        return "\'" + dataSetTitle + "\' color";
    }
    function getSearchStatusToolTip(sender) {
        var searchSetting = sender.searchSetting, verb = searchSetting.autoRefreshVerb;
        var ls = tf.TFMap.LayoutSettings;
        var dataSetRow = dataSetRows[searchSetting.title];
        var dataSet = dataSetRow.dataSet;
        var completedOK = dataSet.GetLastSearchCompletedOK();
        var dataSetTitle = dataSet.GetDataSetTitle();
        var spanStartStr = "<span class='" + ls.defaultHorMarginsClassName + "'>";
        var spanRedStartStr = "<span class='" + ls.defaultHorMarginsClassName + " " + ls.smallerTextClassName + " " + ls.redFontColorShadowClassName + "'>", spanEndStr = "</span>";
        var isSearched = settings.appContent.GetAppCtx().GetCtxAttribute(verb);
        var notStr = isSearched ? " " : " <u>not</u>"
        var isSearchedNotSearched = "is" + notStr + " searched ";
        var isSearchedStr = spanStartStr + "\'" + dataSetTitle + "\' " + isSearchedNotSearched + "<br/>when the map view changes" + spanEndStr;
        var startHTML = "<div class='" + ls.defaultHorMarginsClassName + "' style='text-align:center;'>";
        var completedOKStr = completedOK ? "" : "<br/>" + spanRedStartStr + "last search failed" + spanEndStr;
        var switchVerbStr = isSearched ? "Off" : "On";
        var switchItStr = "Switch it " + switchVerbStr;
        var commandStr = "<span class='" + ls.defaultHorMarginsClassName + "'>" + switchItStr + spanEndStr;
        startHTML += isSearchedStr;
        startHTML += completedOKStr;
        startHTML += "</div>";
        startHTML += tf.TFMap.MakeHRDivHTML();
        startHTML += commandStr;
        return startHTML;
    }
    function getVisibilityToolTip(sender) {
        var searchSetting = sender.searchSetting, verb = searchSetting.visibilityVerb;
        var isVisible = settings.appContent.GetAppCtx().GetCtxAttribute(verb);
        var dataSetRow = dataSetRows[searchSetting.title];
        var dataSet = dataSetRow.dataSet;
        var dataSetTitle = dataSet.GetDataSetTitle();
        var notStr = isVisible ? " " : " <u>not</u> "
        var isVisibleNotVisible = "is" + notStr + "visible";
        var onOffStr = isVisible ? "Off" : "On";
        return tf.TFMap.MapTwoLineSpan("'" + dataSetTitle + "' " + isVisibleNotVisible, "Switch it " + onOffStr);
    }
    function createDataSetRow(searchSetting, index) {
        var appContent = settings.appContent;
        var searchTitle = searchSetting.title;
        var dataSet = settings.getDataSet(searchTitle);
        var wrapper = new tf.dom.Div({ cssClass: dataSetWrapperClassName });
        var delayMillis = tf.TFMap.toolTipDataSetDelayMillis;
        var toolTipClass = "*start";
        var toolTipArrowClass = "left";
        var toolTipStyle = undefined;
        var buttonSettings = { wrapper: wrapper, delayMillis: delayMillis, toolTipClass: toolTipClass, toolTipArrowClass: toolTipArrowClass, toolTipStyle: toolTipStyle, offsetX: 4 };
        var colorLabel = appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, { buttonClass: dataSetColorLabelClassName + " " + buttonInactiveClassName, toolTipText: getMarkerColorToolTip }));
        colorLabel.searchSetting = searchSetting;
        var visibilityToggle = appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, {
            svgHTML: appContent.GetAppStyles().GetOnOffSVG(),
            onClick: onVisibilityButtonClicked, buttonClass: onOffButtonClassName + " " + buttonActiveClassName, toolTipText: getVisibilityToolTip
        }));
        visibilityToggle.searchSetting = searchSetting;
        var titleLabelWrapper = new tf.dom.Div({ cssClass: dataSetTitleLabelWrapperClassName });
        var titleLabel = appContent.CreateDataSetListButton(paneWrapper, titleLabelWrapper, dataSetTitleLabelClassName + " " + buttonInactiveTextClassName, dataSet);
        titleLabel.searchSetting = searchSetting;
        titleLabelWrapper.AddContent(titleLabel.GetButton());
        var searchingButton = appContent.CreateToggleButton(tf.js.ShallowMerge(buttonSettings, {
            onClick: onSearchingButtonClicked,
            buttonClass: buttonActiveClassName, classToggled: dataSetLoadingButtonClassName, classNotToggled: loadedOKClassName, toolTipText: getSearchStatusToolTip, isToggled: true, autoToggle: false
        }));
        searchingButton.searchSetting = searchSetting;
        searchingButton.isSearchingButton = true;
        if ((index % 2) == 1) { tf.dom.AddCSSClass(wrapper, darkenBackgroundClassName); }
        wrapper.AddContent(colorLabel.GetButton(), searchingButton.GetButton(), visibilityToggle.GetButton(), /*titleLabel.GetButton()*/ titleLabelWrapper);
        return {
            title: searchTitle, searchSetting: searchSetting, dataSet: dataSet, wrapper: wrapper, colorLabel: colorLabel,
            titleLabel: titleLabel, searchingButton: searchingButton,
            visibilityToggle: visibilityToggle
        };
    }
    function createDataSetRows() {
        var getDataSet = settings.getDataSet;
        var searchSettings = settings.searchSettings;
        var nSettings = tf.js.GetIsNonEmptyArray(searchSettings) ? searchSettings.length : 0;
        dataSetRows = {};
        for (var i = 0; i < nSettings; ++i) {
            var searchSetting = searchSettings[i];
            var dataSetRow = createDataSetRow(searchSetting, i);
            paneContent.AddContent((dataSetRows[dataSetRow.title] = dataSetRow).wrapper);
            updateVisibilityToggle(searchSetting.title);
        }
    }
    function onToggleClusters() {
        //settings.appContent.GetBaseLayersPanel().SetVisible(true);
        settings.appContent.ToggleClusters();
    }
    function getClustersToolTip(notification) {
        var usingClusters = settings.appContent.GetUsesClusters();
        var notStr = usingClusters ? "" : "<u>not</u> ";
        var usingClustersStr = "Markers are " + notStr + "clustered";
        var switchVerbStr = usingClusters ? "Off" : "On";
        return tf.TFMap.MapTwoLineSpan(usingClustersStr, "switch it " + switchVerbStr);
    }
    function createControl() {
        var shouldBeVisible = getShouldBeVisible();
        var ls = tf.TFMap.LayoutSettings;
        paneWrapper = new tf.dom.Div({ cssClass: wrapperClassName });
        paneContent = new tf.dom.Div({ cssClass: contentClassName });
        var toggleButtonWrapper = new tf.dom.Div({ cssClass: toggleButtonWrapperClassName });
        var appContent = settings.appContent;
        var delayMillis = 0;
        var toolTipClass = "center";
        var toolTipArrowClass = "left";
        var buttonSettings = {
            onClick: onToggleButtonClick, onHover: undefined, wrapper: toggleButtonWrapper, delayMillis: delayMillis, toolTipClass: toolTipClass, toolTipArrowClass: toolTipArrowClass
        };
        toggleButton = appContent.CreateToggleButton(tf.js.ShallowMerge(buttonSettings, {
            offsetX: 4,
            buttonClass: toggleButtonClassName + " ripple", classToggled: ls.arrowLeftBackgroundClassName, classNotToggled: ls.arrowRightBackgroundClassName,
            isToggled: shouldBeVisible, toolTipText: getToggleButtonToolTipText
        }));
        toggleButtonWrapper.AddContent(toggleButton.GetButton());
        createDataSetRows();
        toolBarWrapper = new tf.dom.Div({ cssClass: toolBarWrapperClassName });
        buttonSettings.wrapper = toolBarWrapper;
        buttonSettings.onClick = onToggleClusters;
        clusterButton = appContent.CreateToggleButton(tf.js.ShallowMerge(buttonSettings, {
            buttonClass: clusterButtonClassName + " ripple", classToggled: clusterBkClassName, classNotToggled: noClusterBkClassName,
            isToggled: settings.appContent.GetUsesClusters(), toolTipText: getClustersToolTip
        }));
        toolBarWrapper.AddContent(clusterButton.GetButton());
        paneContent.AddContent(toolBarWrapper, toggleButtonWrapper);
        paneWrapper.AddContent(paneContent);
        setVisible(shouldBeVisible);
    }
    var toggleButtonWrapperClassName, toggleButtonClassName;
    function createCSSClassNames() {
        wrapperClassName = tf.TFMap.CreateClassName(cssTag, "Wrapper");
        contentClassName = tf.TFMap.CreateClassName(cssTag, "Content");
        toolBarWrapperClassName = tf.TFMap.CreateClassName(cssTag, "ToolBarWrapper");
        dataSetWrapperClassName = tf.TFMap.CreateClassName(cssTag, "DataSetWrapper");
        buttonInactiveTextClassName = tf.TFMap.CreateClassName(cssTag, "ButtonInactiveText");
        buttonInactiveClassName = tf.TFMap.CreateClassName(cssTag, "ButtonInactive");
        buttonActiveClassName = tf.TFMap.CreateClassName(cssTag, "ButtonActive");
        clusterButtonClassName = tf.TFMap.CreateClassName(cssTag, "ClusterButton");
        clusterBkClassName = tf.TFMap.CreateClassName(cssTag, "Cluster");
        noClusterBkClassName = tf.TFMap.CreateClassName(cssTag, "NoCluster");
        dataSetTitleLabelWrapperClassName = tf.TFMap.CreateClassName(cssTag, "TitleLabelWrapper");
        dataSetTitleLabelClassName = tf.TFMap.CreateClassName(cssTag, "TitleLabel");
        dataSetColorLabelClassName = tf.TFMap.CreateClassName(cssTag, "ColorLabel");
        onOffButtonClassName = tf.TFMap.CreateClassName(cssTag, "OnOffButton");
        onOffButtonOnClassName = tf.TFMap.CreateClassName(cssTag, "OnOffButtonOn");
        onOffButtonOffClassName = tf.TFMap.CreateClassName(cssTag, "OnOffButtonOff");
        loadedOKClassName = tf.TFMap.CreateClassName(cssTag, "LoadedOK");
        failedToLoadClassName = tf.TFMap.CreateClassName(cssTag, "FailedToLoad");
        refreshingLoadClassName = tf.TFMap.CreateClassName(cssTag, "RefreshingLoad");
        paneCollapsedClassName = tf.TFMap.CreateClassName(cssTag, "Collapsed");
        paneVisibleClassName = tf.TFMap.CreateClassName(cssTag, "Visible");
        darkenBackgroundClassName = tf.TFMap.CreateClassName(cssTag, "DarkenBackground");
        toggleButtonWrapperClassName = tf.TFMap.CreateClassName(cssTag, "ToggleButtonWrapper");
        toggleButtonClassName = tf.TFMap.CreateClassName(cssTag, "ToggleButton");
    }
    function createCSSClasses() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var cssClasses = [];
        var ls = tf.TFMap.LayoutSettings;
        var lightBackground = ls.lightBackground;
        var darkTextColor = ls.darkTextColor, darkTextShadow = ls.darkTextShadow;
        var leftMarginInt = ls.leftMarginInt, leftMarginPx = leftMarginInt + 'px';
        var toggleButtonHeightPx = ls.toggleButtonHeightInt + 'px';
        var wrapperMarginTopPx = ls.dataSetsWrapperMarginTopInt + 'px';
        cssClasses[wrapperClassName] = {
            inherits: [CSSClasses.transitionPoint2s, CSSClasses.displayBlock, CSSClasses.overflowVisible, CSSClasses.cursorDefault,
            CSSClasses.pointerEventsNone, CSSClasses.noMarginNoBorderNoPadding, CSSClasses.positionAbsolute, CSSClasses.zIndex2],
            marginTop: wrapperMarginTopPx
        };
        cssClasses[contentClassName] = {
            inherits: [CSSClasses.borderRadius2px, CSSClasses.boxShadow01403, CSSClasses.transitionPoint2s, CSSClasses.displayBlock, CSSClasses.overflowVisible,
            CSSClasses.cursorDefault, CSSClasses.pointerEventsAll, CSSClasses.noMarginNoBorderNoPadding, CSSClasses.zIndex2],
            background: lightBackground
        };
        var dimDataSetButtonPx = ls.dataSetsRowHeightInt + "px";
        var dataSetRow = {
            inherits: [CSSClasses.overflowVisible, CSSClasses.whiteSpaceNoWrap, CSSClasses.displayBlock, CSSClasses.positionRelative, CSSClasses.displayFlex],
            borderRadius: "4px",
            lineHeight: "20px",
            fontSize: "18px",
            height: dimDataSetButtonPx,
            fontWeight: "400", alignItems: "center"
        };
        var dimToolBarButtonPx = ls.dataSetsToolBarHeightInt + "px";
        cssClasses[toolBarWrapperClassName] = {
            inherits: [dataSetRow, CSSClasses.positionAbsolute, CSSClasses.flexFlowRowReverseNoWrap, CSSClasses.boxShadow01403],
            /*boxShadow: "4px 1px 6px rgba(0,0,0,0.3)", */left: "0px", top: "calc(100% + 1px)",
            width: "calc(100%)",
            height: dimToolBarButtonPx,
            borderRadius: "2px", background: lightBackground
        };
        cssClasses[dataSetWrapperClassName] = { inherits: [dataSetRow, , CSSClasses.flexFlowRowNoWrap] };
        cssClasses[buttonInactiveTextClassName] = {
            inherits: [CSSClasses.robotoFontFamily, CSSClasses.noBorder, CSSClasses.noMargin, CSSClasses.cursorDefault, CSSClasses.outline0, CSSClasses.verticalAlignMiddle,
            CSSClasses.listStyleNone, CSSClasses.overflowVisible, CSSClasses.backgroundColorTransparent],
            color: 'inherit', boxShadow: 'none'
        };
        var buttonBase = {
            inherits: [CSSClasses.robotoFontFamily, CSSClasses.noMarginNoBorderNoPadding, CSSClasses.cursorDefault, CSSClasses.outline0, CSSClasses.verticalAlignMiddle,
            CSSClasses.listStyleNone, CSSClasses.overflowVisible, CSSClasses.displayInlineBlock],
            marginLeft: "2px", marginTop: "1px", marginBottom: "1px", borderRadius: "4px",
            width: dimToolBarButtonPx,
            height: dimToolBarButtonPx,
            boxShadow: 'none'
        };
        cssClasses[buttonInactiveClassName] = { inherits: [buttonBase, CSSClasses.cursorNormal] };
        cssClasses[buttonActiveClassName] = { inherits: [buttonBase, CSSClasses.cursorPointer] };
        var dataSetHorMarginInt = 8, dataSetHorMarginPx = dataSetHorMarginInt + 'px';
        cssClasses[clusterButtonClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.cursorPointer, CSSClasses.outline0, CSSClasses.verticalAlignMiddle,
            CSSClasses.listStyleNone, CSSClasses.overflowVisible, CSSClasses.displayInlineBlock],
            borderRadius: "4px",
            width: dimToolBarButtonPx,
            height: dimToolBarButtonPx,
            //width: "24px", 
            //height: "24px", 
            boxShadow: 'none', marginRight: dataSetHorMarginPx
        };
        cssClasses[clusterBkClassName] = { inherits: [CSSClasses.clusterBackground] };
        cssClasses[noClusterBkClassName] = { inherits: [CSSClasses.noClusterBackground] };
        var dataSetVerticalAlign = "text-bottom";
        cssClasses[dataSetTitleLabelClassName] = {
            inherits: [CSSClasses.flexGrowOne, CSSClasses.displayInlineBlock],
            color: darkTextColor, textShadow: darkTextShadow,
            fontSize: "14px",
            fontWeight: "400",
            padding: "2px", paddingRight: "10px",
            maxWidth: "20rem", verticalAlign: dataSetVerticalAlign,
            overflow: "hidden", textOverflow: "ellipsis"
        };
        cssClasses[dataSetTitleLabelWrapperClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.flexGrowOne, CSSClasses.flexShrinkZero, CSSClasses.positionRelative, CSSClasses.displayInlineBlock],
            verticalAlign: dataSetVerticalAlign
        };
        var dataSetColorLabelWidthInt = 14, dataSetColorLabelWidthPx = dataSetColorLabelWidthInt + "px";
        cssClasses[dataSetColorLabelClassName] = {
            inherits: [CSSClasses.displayInlineBlock, CSSClasses.overflowHidden, CSSClasses.textOverflowEllipsis],
            verticalAlign: dataSetVerticalAlign,
            width: dataSetColorLabelWidthPx, height: dataSetColorLabelWidthPx,
            marginLeft: dataSetHorMarginPx, marginRight: dataSetHorMarginPx,
            borderRadius: "27%",
            border: "1px solid rgba(0,0,0,0.3)"
        };
        cssClasses[onOffButtonClassName] = { background: "transparent", marginRight: dataSetHorMarginPx };
        cssClasses[onOffButtonOnClassName] = { fill: "green" };
        cssClasses[onOffButtonOffClassName] = { fill: "goldenrod" };
        var commonLoading = { marginRight: dataSetHorMarginPx };
        cssClasses[loadedOKClassName] = { inherits: [commonLoading, CSSClasses.loadedOKBackgroundTransparent] };
        cssClasses[failedToLoadClassName] = { inherits: [commonLoading, CSSClasses.failedToLoadBackground] };
        cssClasses[refreshingLoadClassName] = { inherits: [commonLoading, CSSClasses.refreshGrayBackground] };
        dataSetLoadingButtonClassName = "LoadingButton";
        cssClasses[dataSetLoadingButtonClassName] = { inherits: [CSSClasses.loadingBackgroundTransparent], marginRight: dataSetHorMarginPx };
        cssClasses[paneCollapsedClassName] = { transform: "translateX(-100%)", "-webkit-transform": "translateX(-100%)" };
        cssClasses[paneVisibleClassName] = { transform: "translateX(" + leftMarginPx + ")", "-webkit-transform": "translateX(" + leftMarginPx + ")" };
        cssClasses[darkenBackgroundClassName] = { background: "rgba(0,0,0,0.03)" };
        cssClasses[toggleButtonWrapperClassName] = {
            inherits: [CSSClasses.borderRadius2px, CSSClasses.pointerEventsAll, CSSClasses.whiteSpaceNoWrap, CSSClasses.displayBlock, CSSClasses.overflowVisible,
            CSSClasses.cursorDefault, CSSClasses.noMargin, CSSClasses.noPadding, CSSClasses.positionAbsolute, CSSClasses.zIndex1],
            top: "0px", left: "calc(100% + 1px)", background: lightBackground
        };
        cssClasses[toggleButtonClassName] = {
            inherits: [CSSClasses.borderRadius2px, CSSClasses.baseImageButton, CSSClasses.borderLeftD4, CSSClasses.boxShadow01403, CSSClasses.overflowHidden],
            width: "23px", height: toggleButtonHeightPx
        };
        cssClasses[toggleButtonClassName + ":hover"] = { border: "1px solid rgba(0,48,118,0.4)" };
        return cssClasses;
    }
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function onLayoutChange(notification) { registerCSSClasses(); }
    function initialize() {
        cssTag = 'dataSets';
        createCSSClassNames();
        registerCSSClasses();
        createControl();
        updateAll();
        settings.appContent.GetAppStyles().AddOnLayoutChangeListener(onLayoutChange);
        //setTimeout(function () { settings.appContent.GetBaseLayersPanel().SetVisible(true); }, 1000);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: baselayers.js
tf.TFMap.LegendGroupItem = function (settings) {
    var theThis, wrapper, selectedWrapper, contentWrapper, isSelected, visibilityOptionsRow, onChangeVisibleCB, defaultIsVisible, onResolution, titleWrapper;
    this.GetWrapper = function () { return wrapper; }
    this.GetIsSelected = function () { return isSelected; }
    this.GetIsVisible = function () { return settings.item.visible; }
    this.SetDefaultVisible = function (skipNotification) { return theThis.SetIsVisible(defaultIsVisible, skipNotification); }
    this.GetIsOnResolution = function () { return onResolution; }
    this.OnMapResolutionChange = function () {
        onResolution = false;
        var map = settings.appContent.GetMap(), res = map.GetResolution();
        var nComposites = settings.item.composites.length;
        var tolerance = 0.00001;
        for (var i = 0; i < nComposites && !onResolution; ++i) {
            var composite = settings.item.composites[i];
            onResolution = (composite.min - tolerance <= res && composite.max + tolerance >= res);
        }
        var displayVerb = onResolution ? "block" : "none";
        wrapper.GetHTMLElement().style.display = displayVerb;
        /*if (settings.item.name.trim() == "year built") {
            console.log("year built: " + onResolution);
            console.log("18: " + tf.units.GetResolutionByLevel(18));
            console.log("19: " + tf.units.GetResolutionByLevel(19));
        }*/
        return onResolution;
    }
    this.SetIsVisible = function (isVisible, skipNotification) {
        //console.log('change visible: ' + settings.item.name + ' ' + isVisible);
        var changed = false;
        if (settings.item.visible != (isVisible = !!isVisible)) {
            changed = true;
            settings.item.visible = isVisible;
            updateIsVisibleStyle();
            if (!skipNotification) {
                notify(onChangeVisibleCB);
            }
        }
        return changed;
    }
    this.SetIsSelected = function (newIsSelected) {
        if (isSelected != (newIsSelected = !!newIsSelected)) {
            isSelected = newIsSelected;
            tf.dom.ReplaceCSSClassCondition(selectedWrapper, isSelected, settings.itemSelectedClassName, settings.itemUnSelectedClassName);
        }
    }
    function notify(theCB, options) { if (!!theCB) { theCB(tf.js.ShallowMerge(options, { sender: theThis })) }; }
    function updateIsVisibleStyle() {
        if (!!visibilityOptionsRow) {
            var isVisible = theThis.GetIsVisible();
            for (var i in visibilityOptionsRow.elements) {
                var isSelected = false;
                switch (i) {
                    case settings.itemVisibleCommand:
                        isSelected = isVisible;
                        break;
                    default:
                    case settings.itemHiddenCommand:
                        isSelected = !isVisible;
                        break;
                }
                tf.dom.ReplaceCSSClassCondition(visibilityOptionsRow.elements[i].div, isSelected, settings.optionSelectedClassName, settings.optionUnSelectedClassName);
            }
        }
        updateTitle();
    }
    function onClick(notification) { theThis.SetIsVisible(!theThis.GetIsVisible()); }
    function onHover(notification) { /*console.log('hover');*/ }
    function updateTitle() {
        var iV = theThis.GetIsVisible();
        var label = iV ? settings.itemVisibleCommand : settings.itemHiddenCommand;
        titleWrapper.GetHTMLElement().innerHTML = settings.item.name + " (" + label.toLowerCase() + ")";
    }
    function createControl() {
        var item = settings.item;
        titleWrapper = new tf.dom.Div({ cssClass: settings.titleWrapperClassName });
        //wrapper = new tf.dom.Div({ cssClass: wrapperClassName + " " + settings.wrapperAddClassName/*, onClick: onClick, onHover: onHover*/ });
        wrapper = new tf.dom.Button({ cssClass: wrapperClassName + " " + settings.wrapperAddClassName, onClick: onClick, onHover: onHover });
        wrapper.GetHTMLElement().style.cursor = "pointer";
        selectedWrapper = new tf.dom.Div({ cssClass: settings.itemUnSelectedClassName });
        contentWrapper = new tf.dom.Div({ cssClass: settings.rowContainerClassName });
        var titleDescWrapper = new tf.dom.Div({ cssClass: settings.colContainerClassName });
        //console.log(item.name);
        updateTitle();
        titleDescWrapper.AddContent(titleWrapper);
        if (item.desc != item.name && tf.js.GetIsNonEmptyString(item.desc)) {
            var descWrapper = new tf.dom.Div({ cssClass: settings.descWrapperClassName });
            descWrapper.GetHTMLElement().innerHTML = item.desc;
            titleDescWrapper.AddContent(descWrapper);
        }
        //var resWrapper = new tf.dom.Div({ cssClass: settings.descWrapperClassName });
        //var minResName = item.min == 0 ? "min" : "1:" + item.min.toFixed(0);
        //resWrapper.GetHTMLElement().innerHTML = "displayed at map resolutions from " + minResName + " to 1:" + item.max.toFixed(0);
        //titleDescWrapper.AddContent(resWrapper);
        contentWrapper.AddContent(titleDescWrapper);
        //visibilityOptionsRow = settings.createOptionsRow([settings.itemVisibleCommand, settings.itemHiddenCommand], onOptionClicked);
        //visibilityOptionsRow.wrapper.GetHTMLElement().style.borderBottom = 'none';
        wrapper.AddContent(selectedWrapper, contentWrapper/*, visibilityOptionsRow.wrapper*/);
        settings.wrapper.AddContent(wrapper);
        theThis.SetIsSelected(settings.isSelected);
        theThis.OnMapResolutionChange();
        updateIsVisibleStyle();
    }
    function onOptionClicked(notification) {
        try {
            var appContent = settings.appContent;
            var needsModeToggle = false;
            switch (notification.callBackSettings.optionName) {
                case settings.itemVisibleCommand:
                    theThis.SetIsVisible(true);
                    break;
                case settings.itemHiddenCommand:
                    theThis.SetIsVisible(false);
                    break;
            }
            if (needsModeToggle) { settings.appContent.SwitchMapType(); }
        }
        catch (e) { console.log('exception while processing option click'); }
    }
    var cssTag, wrapperClassName;
    function createCSSClassNames() {
        wrapperClassName = tf.TFMap.CreateClassName(cssTag, "Wrapper");
    }
    function createCSSClasses() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var cssClasses = [];
        var ls = tf.TFMap.LayoutSettings;
        cssClasses[wrapperClassName] = {
            background: 'rgb(255, 255, 240)'
        };
        return cssClasses;
    }
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function onLayoutChange(notification) { registerCSSClasses(); }
    var lcl;
    function initialize() {
        defaultIsVisible = settings.item.visible;
        onChangeVisibleCB = tf.js.GetFunctionOrNull(settings.onChangeVisible);
        isSelected = false;
        cssTag = 'LegendGroupItem';
        createCSSClassNames();
        registerCSSClasses();
        createControl();
        lcl = settings.appContent.GetAppStyles().AddOnLayoutChangeListener(onLayoutChange);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.TFMap.LegendGroupSetItem = function (settings) {
    var theThis, wrapper, descWrapper, groupsWrapper, groupsAreVisible, groupItems, onChangeVisibleCB;
    var selectedWrapper, titleWrapper;
    this.GetWrapper = function () { return wrapper; }
    this.OnMapResolutionChange = function () {
        var nOnResolution = 0, nGroups = groupItems.length;
        for (var i = 0; i < nGroups; ++i) {
            if (groupItems[i].OnMapResolutionChange()) {
                ++nOnResolution;
            }
        }
        var displayVerb = nOnResolution > 0 ? "block" : "none";
        wrapper.GetHTMLElement().style.display = displayVerb;
        if (nOnResolution > 0) {
            updateDesc();
        }
    }
    this.GetIsExpanded = function () { return groupsAreVisible; }
    this.ExpandCollapse = function (expandBool) {
        if (groupsAreVisible != (expandBool = !!expandBool)) {
            var displayStr = (groupsAreVisible = expandBool) ? "block" : "none";
            groupsWrapper.GetHTMLElement().style.display = displayStr;
            var wrapperE = wrapper.GetHTMLElement(), wrapperES = wrapperE.style;
            if (groupsAreVisible) {
                wrapperES.borderBottom = "1px solid " + tf.TFMap.LayoutSettings.directionsSelectedColor;
            }
            else {
                //wrapperES.borderBottom = '1px solid transparent';
                wrapperES.borderBottom = 'none';
            }
            checkSelectedStyle();
        }
    }
    this.SetIsVisible = function (isVisible, skipNotification) { return showHideAll(isVisible, skipNotification); }
    this.SetDefaultVisible = function (skipNotification) {
        var changed = false, nGroups = groupItems.length;
        for (var i = 0; i < nGroups; ++i) { if (groupItems[i].SetDefaultVisible(true)) { changed = true; } }
        if (changed) { if (skipNotification) { updateDesc(); } else { onChangeVisible(); } }
        return changed;
    }
    function checkSelectedStyle() {
        tf.dom.ReplaceCSSClassCondition(selectedWrapper, groupsAreVisible, settings.itemSelectedClassName, settings.itemUnSelectedClassName);
        updateName();
    }
    function onChangeVisible() { updateDesc(); notify(onChangeVisibleCB); }
    function notify(theCB, options) { if (!!theCB) { theCB(tf.js.ShallowMerge(options, { sender: theThis })) }; }
    function updateName() {
        var labelToggle = groupsAreVisible ? '-' : '+';
        titleWrapper.GetHTMLElement().innerHTML = labelToggle + ' ' + settings.item.name;
    }
    function updateDesc() {
        if (!!descWrapper) {
            var nGroups = groupItems.length, nVisible = 0, descStr = "", nEffectiveGroups = 0;
            for (var i = 0; i < nGroups; ++i) {
                var gi = groupItems[i], onRes = gi.GetIsOnResolution();
                if (onRes) {
                    ++nEffectiveGroups;
                    if (gi.GetIsVisible()) { ++nVisible; }
                }
            }
            nGroups = nEffectiveGroups;
            var isAreGroups = nGroups == 1 ? "is" : "are";
            var isAreVisible = nVisible == 1 ? "is" : "are";
            var groupGroups = nGroups == 1 ? "group" : "groups";
            var allStr = nGroups == 1 ? "" : "All ";
            var groupGroupsIsAre = " " + groupGroups + " " + isAreGroups + " ";
            if (nVisible == 0) { descStr = allStr + nGroups + groupGroupsIsAre + settings.itemHiddenCommand.toLowerCase(); }
            else if (nVisible == nGroups) { descStr = allStr + nGroups + groupGroupsIsAre + settings.itemVisibleCommand.toLowerCase(); }
            else { descStr = nVisible + " out of " + nGroups + " " + groupGroups + " " + isAreVisible + " " + settings.itemVisibleCommand.toLowerCase(); }
            descWrapper.GetHTMLElement().innerHTML = descStr;
        }
        updateName();
    }
    function showHideAll(showBool, skipNotification) {
        var changed = false, nGroups = groupItems.length;
        //console.log('nGroups ' +  nGroups);
        for (var i = 0; i < nGroups; ++i) { if (groupItems[i].SetIsVisible(showBool, true)) { changed = true; } }
        if (changed) { if (skipNotification) { updateDesc(); } else { onChangeVisible(); } }
        return changed;
    }
    function toggleExpanded() { theThis.ExpandCollapse(!theThis.GetIsExpanded()); }
    function onClick(notification) { toggleExpanded(); }
    function onHover(notification) { /*console.log('hover');*/ }
    function onOptionClicked(notification) {
        try {
            var appContent = settings.appContent;
            var needsModeToggle = false;
            switch (notification.callBackSettings.optionName) {
                case settings.showAllCommand:
                    showHideAll(true, false);
                    break;
                case settings.hideAllCommand:
                    showHideAll(false, false);
                    break;
            }
            if (needsModeToggle) { settings.appContent.SwitchMapType(); }
        }
        catch (e) { console.log('exception while processing option click'); }
    }
    function createControl() {
        var item = settings.item;
        var ls = tf.TFMap.LayoutSettings;
        titleWrapper = new tf.dom.Div({ cssClass: settings.titleWrapperClassName });
        wrapper = new tf.dom.Div({ cssClass: wrapperClassName });
        var wrapperE = wrapper.GetHTMLElement(), wrapperES = wrapperE.style;
        wrapperES.border = "1px solid " + ls.directionsSelectedColor;
        wrapperES.borderBottom = 'none';
        //wrapperES.borderBottom = '1px solid transparent';
        //wrapperES.border = "1px solid " + ls.backgroundLivelyColor;
        selectedWrapper = new tf.dom.Div({ cssClass: settings.itemUnSelectedClassName });
        var groupWrapper = new tf.dom.Button({ cssClass: wrapperClassName + " " + settings.wrapperAddClassName, onClick: onClick, onHover: onHover });
        var groupWrapperE = groupWrapper.GetHTMLElement(), groupWrapperES = groupWrapperE.style;
        
        groupWrapperES.borderBottom = 'none';
        groupWrapperES.cursor = "pointer";
        //descWrapper = new tf.dom.Div({ cssClass: settings.descWrapperClassName });
        //descWrapper.GetHTMLElement().style.paddingBottom = "0px";
        groupWrapper.AddContent(titleWrapper/*, descWrapper*/);
        //var optionsRow = settings.createOptionsRow([settings.showAllCommand, settings.hideAllCommand], onOptionClicked);
        var nonGroupsWrapper = new tf.dom.Div({ cssClass: settings.colContainerClassName });
        nonGroupsWrapper.AddContent(selectedWrapper, groupWrapper/*, optionsRow.wrapper*/);
        wrapper.AddContent(nonGroupsWrapper);
        groupsWrapper = new tf.dom.Div({ cssClass: settings.colContainerClassName + " " + groupsWrapperClassName + " " + settings.wrapperAddClassName });
        var nGroups = item.groups.length;
        var itemSettings = tf.js.ShallowMerge(settings, { wrapper: groupsWrapper, isSelected: true, onChangeVisible: onChangeVisible });
        groupItems = [];
        for (var i = 0; i < nGroups; ++i) {
            var legendItem = new tf.TFMap.LegendGroupItem(tf.js.ShallowMerge(itemSettings, { item: item.groups[i] }));
            groupItems.push(legendItem);
        }
        wrapper.AddContent(groupsWrapper);
        groupsWrapper.GetHTMLElement().style.display = "none";
        settings.wrapper.AddContent(wrapper);
        updateDesc();
        checkSelectedStyle();
    }
    var cssTag, wrapperClassName, groupsWrapperClassName;
    function createCSSClassNames() {
        wrapperClassName = tf.TFMap.CreateClassName(cssTag, "Wrapper");
        groupsWrapperClassName = tf.TFMap.CreateClassName(cssTag, "groupsWrapper")
    }
    function createCSSClasses() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var cssClasses = [];
        var ls = tf.TFMap.LayoutSettings;
        cssClasses[wrapperClassName] = {
            background: 'rgb(240, 255, 255)'
        };
        cssClasses[groupsWrapperClassName] = {
            marginTop: "0px"
        };
        return cssClasses;
    }
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function onLayoutChange(notification) { registerCSSClasses(); }
    var lcl;
    function initialize() {
        onChangeVisibleCB = tf.js.GetFunctionOrNull(settings.onChangeVisible);
        cssTag = 'LegendGroupSetItem';
        createCSSClassNames();
        registerCSSClasses();
        createControl();
        lcl = settings.appContent.GetAppStyles().AddOnLayoutChangeListener(onLayoutChange);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.TFMap.LegendList = function (settings) {
    var theThis, wrapper, decodedLegend, groupSetItems, allItems, onChangeVisibleCB;
    this.GetWrapper = function () { return wrapper; }
    this.GetDecodedLegend = function() { return decodedLegend; }
    this.OnMapResolutionChange = function () { for (var i in allItems) { allItems[i].OnMapResolutionChange(); } }
    this.ExpandCollapseAll = function (expandBool) { for (var i in groupSetItems) { groupSetItems[i].ExpandCollapse(expandBool); } }
    this.SetDefaultVisible = function () {
        var changed = false;
        for (var i in allItems) { if (allItems[i].SetDefaultVisible(true)) { changed = true; } }
        if (changed) { notify(onChangeVisibleCB); }
        return changed;
    }
    this.SetIsVisible = function (isVisible) {
        var changed = false;
        for (var i in allItems) { if (allItems[i].SetIsVisible(isVisible, true)) { changed = true; } }
        if (changed) { notify(onChangeVisibleCB); }
        return changed;
    }
    function notify(theCB, options) { if (!!theCB) { theCB(tf.js.ShallowMerge(options, { sender: theThis })) }; }
    function createControl() {
        wrapper = new tf.dom.Div({ cssClass: wrapperClassName });
        var itemSettings = tf.js.ShallowMerge(settings, { wrapper: wrapper, isSelected: false });
        allItems = [];
        groupSetItems = [];
        for (var i = 0; i < decodedLegend.length; ++i) {
            var decodedItem = decodedLegend[i];
            var isGroupSet = tf.js.GetIsNonEmptyArray(decodedItem.groups);
            var itemClass = isGroupSet ? tf.TFMap.LegendGroupSetItem : tf.TFMap.LegendGroupItem;
            var legendItem = new itemClass(tf.js.ShallowMerge(itemSettings, { item: decodedItem }));
            if (isGroupSet) { groupSetItems.push(legendItem); }
            allItems.push(legendItem);
            //wrapper.AddContent(legendItem.GetWrapper());
        }
    }
    function createCSSClassNames() {
        wrapperClassName = tf.TFMap.CreateClassName(cssTag, "Wrapper");
    }
    function createCSSClasses() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var cssClasses = [];
        var ls = tf.TFMap.LayoutSettings;
        cssClasses[wrapperClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.overflowVisible], background: 'transparent'
        };
        return cssClasses;
    }
    var cssTag, wrapperClassName;
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function onLayoutChange(notification) { registerCSSClasses(); }
    var lcl;
    function initialize() {
        onChangeVisibleCB = tf.js.GetFunctionOrNull(settings.onChangeVisible);
        decodedLegend = tf.js.DecodeLegend(settings.legendStr);
        //console.log(decodedLegend);
        cssTag = 'LegendList';
        createCSSClassNames();
        registerCSSClasses();
        createControl();
        lcl = settings.appContent.GetAppStyles().AddOnLayoutChangeListener(onLayoutChange);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.TFMap.BaseLayersPanel = function (settings) {
    var theThis, panelName, panelNameShort, wrapper, contentWrapper, closeButton, isShowing, topContent, botContent;
    var allNoneDefaultOptions, expandCollapseOptions, aerialMapModeOptions;
    var isM2;
    var legendListH, legendListM;
    var currentLegendList;
    var openPanelStr, closePanelStr;
    var setAllVisibleLabelName, setAllHiddenLabelName, setDefaultsLabelName;
    this.OnMapResolutionChange = function () {
        if (isShowing) {
            if (!!currentLegendList) {
                currentLegendList.OnMapResolutionChange();
            }
        }
    }
    this.GetPanelName = function () { return panelName; }
    this.GetPanelNameShort = function () { return panelNameShort; }
    this.GetWrapper = function () { return wrapper; }
    this.UpdateForMapType = function() {
        if (isM2) {
            var isSHowingAerial = getIsShowingAerial();
            if (!!aerialMapModeOptions) {
                for (var i in aerialMapModeOptions.elements) {
                    var isSelected = false;
                    switch (i) {
                        case mapAerialLabelName:
                            isSelected = isSHowingAerial;
                            break;
                        default:
                        case mapMapLabelName:
                            isSelected = !isSHowingAerial;
                            break;
                    }
                    tf.dom.ReplaceCSSClassCondition(aerialMapModeOptions.elements[i].div, isSelected, optionSelectedClassName, optionUnSelectedClassName);
                }
            }
            currentLegendList = isSHowingAerial ? legendListH : legendListM;
            var otherList = isSHowingAerial ? legendListM : legendListH;
            theThis.OnMapResolutionChange();
            currentLegendList.GetWrapper().GetHTMLElement().style.display = 'block';
            otherList.GetWrapper().GetHTMLElement().style.display = 'none';
        }
    }
    this.SetVisible = function (visible) {
        if (isShowing != (visible = !!visible)) {
            var ls = tf.TFMap.LayoutSettings;
            tf.dom.ReplaceCSSClassCondition(wrapper, isShowing = visible, ls.sidePanelWrapperVisibleClassName, ls.sidePanelWrapperCollapsedClassName);
            if (isShowing) { theThis.OnMapResolutionChange(); }
            settings.appContent.SetHasSidePanelFullContent(isShowing);
        }
    }
    this.GetIsVisible = function () { return isShowing; }
    this.GetOpenCloseToolTip = function () { return isShowing ? closePanelStr : openPanelStr; }
    function getIsShowingAerial() { return settings.appContent.GetIsShowingAerial(); }
    function createSVGButton(buttonSettings, svgHTML, buttonClass, toolTipText, svgAddClasses, modeVerb) {
        var button = settings.appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, {
            svgHTML: svgHTML,
            buttonClass: buttonClass + " rippleWhite", toolTipText: toolTipText
        }));
        button.GetSettings().modeVerb = modeVerb;
        var buttonSVG = button.GetButton().firstChild;
        if (svgAddClasses != undefined) { tf.dom.AddCSSClass(buttonSVG, svgAddClasses); }
        return button;
    }
    function onCloseClicked() {
        theThis.SetVisible(false);
    }
    function createControl() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles();
        var ls = tf.TFMap.LayoutSettings;
        var customizedScrollBarClassName = ls.customizedScrollBarClassName;
        var delayMillis = 0;
        var toolTipClass = "*end";
        var toolTipArrowClass = "top";
        var buttonSettings = {
            offsetY: 0, onClick: undefined, onHover: undefined, delayMillis: delayMillis, toolTipClass: toolTipClass, toolTipArrowClass: toolTipArrowClass
        };
        wrapper = new tf.dom.Div({ cssClass: ls.sidePanelWrapperClassName });
        contentWrapper = new tf.dom.Div({ cssClass: ls.sidePanelContentWrapperClassName + " " + ls.sidePaneFullHeightContentWrapperClassName });
        topContent = new tf.dom.Div({ cssClass: ls.sidePaneContentFixedHeightClassName });
        botContent = new tf.dom.Div({ cssClass: ls.sidePaneContentVariableHeightClassName + " " + customizedScrollBarClassName });
        closeButton = createSVGButton(tf.js.ShallowMerge(buttonSettings, {
            wrapper: contentWrapper, toolTipClass: "*start", onClick: onCloseClicked
        }), appStyles.GetXMarkSVG(), ls.sidePanelCloseButtonClassName, closePanelStr, undefined);
        var topCaption = new tf.dom.Div({ cssClass: topCaptionClassName });
        topCaption.GetHTMLElement().innerHTML = panelName;
        topContent.AddContent(topCaption);
        if (isM2 && settings.allowChangeType) {
            aerialMapModeOptions = createOptionsRow([mapAerialLabelName, mapMapLabelName]);
            topContent.AddContent(aerialMapModeOptions.wrapper);
        }
        allNoneDefaultOptions = createOptionsRow([setAllVisibleLabelName, setAllHiddenLabelName, setDefaultsLabelName]);
        expandCollapseOptions = createOptionsRow([expandAllGroupsLabel, collapseAllGroupsLabel]);
        topContent.AddContent(allNoneDefaultOptions.wrapper, expandCollapseOptions.wrapper);
        var legendSettings = {
            onChangeVisible: onChangeVisible,
            itemVisibleCommand: itemVisibleCommand,
            itemHiddenCommand: itemHiddenCommand,
            showAllCommand: setAllVisibleLabelName,
            hideAllCommand: setAllHiddenLabelName,
            optionSelectedClassName: optionSelectedClassName,
            optionUnSelectedClassName: optionUnSelectedClassName,
            appContent: settings.appContent,createOptionsRow: createOptionsRow,
            wrapperAddClassName: wrapperAddClassName, titleWrapperClassName: titleWrapperClassName, descWrapperClassName: descWrapperClassName,
            itemSelectedClassName: itemSelectedClassName, itemUnSelectedClassName: itemUnSelectedClassName,
            rowContainerClassName: rowContainerClassName, colContainerClassName: colContainerClassName
        };
        legendListH = new tf.TFMap.LegendList(tf.js.ShallowMerge(legendSettings, {legendStr: settings.legendH}));
        botContent.AddContent(legendListH.GetWrapper());
        if (isM2) {
            legendListM = new tf.TFMap.LegendList(tf.js.ShallowMerge(legendSettings, { legendStr: settings.legendM }));
            botContent.AddContent(legendListM.GetWrapper());
        }
        contentWrapper.AddContent(closeButton.GetButton(), topContent, botContent);
        wrapper.AddContent(contentWrapper);
    }
    function onChangeVisible(notification) {
        var decodedLegendH = legendListH.GetDecodedLegend();
        var decodedLegendM = isM2 ? legendListM.GetDecodedLegend() : decodedLegendH;
        settings.appContent.GetMap().SetDecodedLegends(decodedLegendH, decodedLegendM);
    }
    function onClickOption(notification) {
        try {
            var appContent = settings.appContent;
            var needsModeToggle = false;
            var needsResetScroll = false;
            switch (notification.callBackSettings.optionName) {
                case setAllVisibleLabelName:
                    if (!!currentLegendList) { currentLegendList.SetIsVisible(true); }
                    break;
                case setAllHiddenLabelName:
                    if (!!currentLegendList) { currentLegendList.SetIsVisible(false); }
                    break;
                case setDefaultsLabelName:
                    if (!!currentLegendList) { currentLegendList.SetDefaultVisible(); }
                    break;
                case expandAllGroupsLabel:
                    if (!!currentLegendList) { currentLegendList.ExpandCollapseAll(true); needsResetScroll = true; }
                    break;
                case collapseAllGroupsLabel:
                    if (!!currentLegendList) { currentLegendList.ExpandCollapseAll(false); needsResetScroll = true; }
                    break;
                case mapAerialLabelName:
                    needsModeToggle = !getIsShowingAerial();
                    break;
                case mapMapLabelName:
                    needsModeToggle = getIsShowingAerial();
                    break;
            }
            if (needsResetScroll) { botContent.GetHTMLElement().scrollTop = 0; }
            if (needsModeToggle) { settings.appContent.SwitchMapType(); }
        }
        catch (e) { console.log('exception while processing option click'); }
    }
    function createOptionsRow(optionNames, optionalOnClickOption) {
        var onClickOptionUse = tf.js.GetFunctionOrNull(optionalOnClickOption) ? optionalOnClickOption : onClickOption;
        var wrapper = new tf.dom.Div({ cssClass: optionsRowClassName });
        var count = tf.js.GetIsNonEmptyArray(optionNames) ? optionNames.length : 0;
        var elements = {};
        for (var i = 0; i < count; ++i) {
            var optionName = optionNames[i];
            var className = optionInRowClassName + " " + optionUnSelectedClassName;
            if (i < count - 1) { className += " " + notLastOptionInRowClassName; }
            var optionDiv = new tf.dom.Button({ cssClass: className, onClick: onClickOptionUse, onClickSettings: { optionName: optionName }, optionalScope: theThis });
            elements[optionName] = { div: optionDiv };
            optionDiv.GetHTMLElement().innerHTML = optionName;
            wrapper.AddContent(optionDiv);
        }
        return { wrapper: wrapper, elements: elements };
    }
    var cssTag, topCaptionClassName, wrapperAddClassName, titleWrapperClassName, descWrapperClassName, itemUnSelectedClassName, itemSelectedClassName;
    var rowContainerClassName, colContainerClassName;
    var optionsRowClassName, optionInRowClassName, optionSelectedClassName, optionUnSelectedClassName, notLastOptionInRowClassName;
    function createCSSClassNames() {
        topCaptionClassName = tf.TFMap.CreateClassName(cssTag, "TopCaption");
        wrapperAddClassName = tf.TFMap.CreateClassName(cssTag, "WrapperAdd");
        titleWrapperClassName = tf.TFMap.CreateClassName(cssTag, "TitleWrapper");
        descWrapperClassName = tf.TFMap.CreateClassName(cssTag, "DescWrapper");
        rowContainerClassName = tf.TFMap.CreateClassName(cssTag, "RowContainer");
        colContainerClassName = tf.TFMap.CreateClassName(cssTag, "ColContainer");
        optionsRowClassName = tf.TFMap.CreateClassName(cssTag, "OptionsRow");
        optionInRowClassName = tf.TFMap.CreateClassName(cssTag, "OptionInRow");
        notLastOptionInRowClassName = tf.TFMap.CreateClassName(cssTag, "NotLastOptionInRow");
        optionUnSelectedClassName = tf.TFMap.CreateClassName(cssTag, "OptionUnSelected");
        optionSelectedClassName = tf.TFMap.CreateClassName(cssTag, "OptionSelected");
        itemUnSelectedClassName = tf.TFMap.CreateClassName(cssTag, "ItemUnSelected");
        itemSelectedClassName = tf.TFMap.CreateClassName(cssTag, "ItemSelected");
    }
    function createCSSClasses() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var cssClasses = [];
        var ls = tf.TFMap.LayoutSettings;
        var backgroundLivelyStyle = { backgroundColor: ls.backgroundLivelyColor };
        var directionsSelectedColor = ls.directionsSelectedColor;
        cssClasses[topCaptionClassName] = {
            inherits: [CSSClasses.positionRelative, CSSClasses.noMarginNoBorderNoPadding, backgroundLivelyStyle,
                CSSClasses.displayBlock/*, CSSClasses.robotoFontFamily*/],
            padding: "10px",
            width: "calc(100% - 20px)",
            paddingTop: ls.baseLayersPaneTopCaptionVerPaddingInt + 'px',
            paddingBottom: ls.baseLayersPaneTopCaptionVerPaddingInt + 'px',
            marginBottom: "4px",
            color: "white",
            fontSize: ls.baseLayersPaneTopCaptionFontSizeInt + 'px',
            lineHeight: ls.baseLayersPaneTopCaptionLineHeightInt + 'px'
        };
        cssClasses[wrapperAddClassName] = {
            inherits: [CSSClasses.transparentImageButton, CSSClasses.darkTextColor, CSSClasses.darkTextShadow, CSSClasses.noMarginNoBorderNoPadding,
                CSSClasses.overflowVisible, CSSClasses.positionRelative, CSSClasses.displayBlock, CSSClasses.cursorDefault],
            textAlign: "left",
            width: "calc(100% - 20px)",
            borderBottom: "1px solid #ebebeb",
            fontSize: ls.baseLayersPaneDefaultFontSizeInt + 'px',
            lineHeight: ls.baseLayersPaneDefaultLineHeightInt + 'px',
            padding: ls.baseLayersPaneTitlePaddingtInt + "px",
            paddingLeft: "10px"
        };
        cssClasses[titleWrapperClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding],
            lineHeight: ls.baseLayersPaneTitleLineHeightInt + 'px'
        };
        cssClasses[descWrapperClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding],
            paddingTop: "4px", paddingLeft: "10px", //paddingBottom: "4px",
            fontSize: ls.baseLayersPaneDescFontSizeInt + 'px',
            lineHeight: ls.baseLayersPaneDescLineHeightInt + 'px',
            color: "#555"
        };
        cssClasses[rowContainerClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.displayFlex, CSSClasses.flexFlowRowNoWrap, CSSClasses.positionRelative]
        };
        cssClasses[colContainerClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.displayFlex, CSSClasses.flexFlowColumnNoWrap, CSSClasses.positionRelative, CSSClasses.transitionWithColor]
        };
        cssClasses[optionsRowClassName] = {
            inherits: [CSSClasses.displayFlex, CSSClasses.flexFlowRowNoWrap, CSSClasses.positionRelative],
            borderRadius: "2px",
            width: "calc(100% - 4px)",
            padding: "2px",
            paddingTop: "0px",
            paddingBottom: "0px",
            borderBottom: "1px solid #ebebeb",
            fontSize: ls.baseLayersOptionsRowFontSizeInt + 'px',
            lineHeight: ls.baseLayersOptionsRowLineHeightInt + 'px',
            //fontSize: "14px",
            //lineHeight: "24px",
            fontWeight: "500"
        };
        cssClasses[optionInRowClassName] = {
            inherits: [CSSClasses.transparentImageButton, CSSClasses.displayBlock, CSSClasses.flexOne],
            lineHeight: "inherit",
            fontSize: "inherit",
            fontFamily: "inherit",
            fontWeight: "inherit",
            borderRadius: "2px",
            textAlign: "center"
        };
        cssClasses[optionInRowClassName + ":hover"] = {
            textDecoration:"underline",
            cursor: "pointer"
        };
        cssClasses[notLastOptionInRowClassName] = {
            borderRight: "1px solid #ebebeb"
        };
        cssClasses[optionUnSelectedClassName] = {
            inherits: [CSSClasses.darkTextColor, CSSClasses.backgroundColorTransparent]
        };
        cssClasses[optionSelectedClassName] = {
            inherits: [backgroundLivelyStyle], color: "white"
        };
        var itemCommon = {
            inherits: [CSSClasses.positionAbsolute, CSSClasses.noMarginNoBorderNoPadding, CSSClasses.overflowVisible, CSSClasses.displayBlock],
            left: "0px", top: "-1px",
            zIndex: '' + (ls.rootDivZIndex + ls.baseLayersItemCommonZIndexAdd),
            height: "calc(100% + 2px)", width: "1px"
        };
        cssClasses[itemUnSelectedClassName] = {
            inherits: [itemCommon],
            borderLeft: "5px solid transparent"
        };
        cssClasses[itemSelectedClassName] = {
            inherits: [itemCommon],
            borderLeft: "6px solid " + directionsSelectedColor
        };
        return cssClasses;
    }
    var itemVisibleCommand, itemHiddenCommand;
    var expandAllGroupsLabel, collapseAllGroupsLabel;
    var mapAerialLabelName, mapMapLabelName;
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function calcProptNames() {
        var isSmallScreen = true;// settings.appContent.GetAppStyles().GetIsSmallScreen();
        expandAllGroupsLabel = isSmallScreen ? "Expand all" : "Expand all groups";
        collapseAllGroupsLabel = isSmallScreen ? "Collapse all" : "Collapse all groups";
        mapAerialLabelName = isSmallScreen ? "Aerial view" : "Show Aerial view groups";
        mapMapLabelName = isSmallScreen ? "Map view" : "Show Map view groups";
        setAllVisibleLabelName = isSmallScreen ? "All " + itemVisibleCommand : "Set all " + itemVisibleCommand;
        setAllHiddenLabelName = isSmallScreen ? "All " + itemHiddenCommand : "Set all " + itemHiddenCommand;
        setDefaultsLabelName = isSmallScreen ? "Defaults" : "Default Settings";
    }
    function onLayoutChange(notification) {
        calcProptNames();
        registerCSSClasses();
    }
    var lcl;
    function initialize() {
        isM2 = settings.mapEngine != tf.consts.mapnikEngine;
        itemVisibleCommand = "On";
        itemHiddenCommand = "Off";
        cssTag = 'baseLayersPanel';
        panelName = "Map Layers";
        panelNameShort = "Layers";
        closePanelStr = "Close " + panelName;
        openPanelStr = "Select " + panelName;
        isShowing = undefined;
        createCSSClassNames();
        calcProptNames();
        registerCSSClasses();
        createControl();
        theThis.SetVisible(false);
        theThis.UpdateForMapType();
        lcl = settings.appContent.GetAppStyles().AddOnLayoutChangeListener(onLayoutChange);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: baselayerstoolbar.js
tf.TFMap.BaseLayersToolBar = function (settings) {
    var theThis, wrapper, mapWrapper, selectBaseLayersButton, perspectiveMapButton;
    this.GetWrapper = function () { return wrapper; }
    function getBaseLayersToolTipText() {
        var baseLayersPanel = settings.appContent.GetBaseLayersPanel();
        return !!baseLayersPanel ? baseLayersPanel.GetOpenCloseToolTip() : undefined;
    }
    function onClickBaseLayersButton() {
        var baseLayersPanel = settings.appContent.GetBaseLayersPanel();
        if (!!baseLayersPanel) { baseLayersPanel.SetVisible(!baseLayersPanel.GetIsVisible()); }
    }
    function onClickPerspectiveMapButton() { var perspectiveMap = getPerspectiveMap(); perspectiveMap.SetIsVisible(!getPerspectiveMapIsVisible()); }
    function getPerspectiveMapToolTipText() {
        var pText = '3D perspective view';
        var fText = '2D orthogonal view';
        var isPerspectiveMapVisible = getPerspectiveMapIsVisible();
        var topLine = ("displaying " + (isPerspectiveMapVisible ? pText : fText)) ;
        var botLine = ("switch to " + (isPerspectiveMapVisible ? fText : pText));
        return tf.TFMap.MapTwoLineSpan(topLine, botLine);
    }
    function updatePerspectiveMapButtonText() {
        var text = getPerspectiveMapIsVisible() ? "2D" : "3D";
        perspectiveMapButton.GetButton().innerHTML = text;
    }
    function getPerspectiveMap() { return settings.appContent.GetPerspectiveMap(); }
    function getPerspectiveMapIsVisible() { return getPerspectiveMap().GetIsVisible(); }
    function onPerspectiveMapVisibilityChange() { updatePerspectiveMapButtonText(); }
    function createControl() {
        var ls = tf.TFMap.LayoutSettings;
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles();
        var baseLayersPanel = appContent.GetBaseLayersPanel();
        var buttonLabel = !!baseLayersPanel ? baseLayersPanel.GetPanelNameShort() : "Layers";
        wrapper = new tf.dom.Div({ cssClass: wrapperClassName + " " + ls.aerialOrMapColorScheme });
        var delayMillis = tf.TFMap.toolTipDataSetDelayMillis;
        var toolTipClass = "center";
        var toolTipArrowClass = "left";
        var toolTipStyle = undefined;
        var buttonSettings = {
            wrapper: wrapper, delayMillis: delayMillis, toolTipClass: toolTipClass, toolTipArrowClass: toolTipArrowClass, toolTipStyle: toolTipStyle
        };
        var baseButtonClassName = buttonSVGClassName + " " + textButtonClassName + " ripple";
        var buttonAdded = false, buttonClassNameUse = baseButtonClassName;
        if (settings.usePerspectiveMap) {
            perspectiveMapButton = settings.appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, {
                onClick: onClickPerspectiveMapButton,
                buttonClass: buttonClassNameUse, toolTipText: getPerspectiveMapToolTipText,
                svgHTML: undefined//appStyles.GetLayersSVG()
            }));
            wrapper.AddContent(perspectiveMapButton.GetButton());
            if (!buttonAdded) { buttonAdded = true; buttonClassNameUse = buttonSpaceClassName + " " + buttonClassNameUse }
            appContent.GetPerspectiveMap().AddListener(tf.consts.perspectiveMapVisibilityChangeEvent, onPerspectiveMapVisibilityChange);
            updatePerspectiveMapButtonText();
        }
        if (settings.useBaseLayers) {
            selectBaseLayersButton = settings.appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, {
                onClick: onClickBaseLayersButton,
                buttonClass: buttonClassNameUse, toolTipText: getBaseLayersToolTipText,
                svgHTML: appStyles.GetLayersSVG()
            }));
            wrapper.AddContent(selectBaseLayersButton.GetButton());
            if (!buttonAdded) { buttonAdded = true; buttonClassNameUse = buttonSpaceClassName + " " + buttonClassNameUse }
        }
    }
    var cssTag, wrapperClassName, buttonClassName, buttonSVGClassName, textButtonClassName, buttonSpaceClassName;
    function createCSSClassNames() {
        wrapperClassName = tf.TFMap.CreateClassName(cssTag, "Wrapper");
        buttonClassName = tf.TFMap.CreateClassName(cssTag, "Button");
        buttonSVGClassName = tf.TFMap.CreateClassName(cssTag, "ButtonSVG");
        textButtonClassName = tf.TFMap.CreateClassName(cssTag, "textButton");
        buttonSpaceClassName = tf.TFMap.CreateClassName(cssTag, "ButtonSpace");
    }
    function createCSSClasses() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var cssClasses = [];
        var ls = tf.TFMap.LayoutSettings;
        var darkTextColor = ls.darkTextColor;
        var widthMapToolBarInt = ls.widthMapToolBarInt, widthMapToolBarPx = widthMapToolBarInt + 'px';
        var dimMapTypeAuxInt = ls.dimMapTypeAuxInt, dimMapTypeAuxPx = dimMapTypeAuxInt + "px";
        var dimMapTypeAuxMarginInt = ls.dimMapTypeAuxMarginInt, dimMapTypeAuxMarginPx = dimMapTypeAuxMarginInt + "px";
        var leftWrapper = ls.createAuxTypeMap ? (dimMapTypeAuxMarginInt + dimMapTypeAuxInt + ls.toolBarToToolBarHorSpacingInt) : (dimMapTypeAuxMarginInt);
        var leftWrapperPx = leftWrapper + 'px';
        cssClasses[wrapperClassName] = {
            inherits: [CSSClasses.whiteSpaceNoWrap, CSSClasses.boxShadow002003, CSSClasses.pointerEventsAll, CSSClasses.positionAbsolute,
                CSSClasses.displayFlex, CSSClasses.flexFlowColumnNoWrap],
            borderRadius: "4px",
            left: leftWrapperPx,
            //zIndex: '' + (ls.rootDivZIndex + ls.baseLayersToolBarWrapperZIndexAdd),
            bottom: (ls.scaleLineHeightInt + ls.toolBarToScaleLineVerSpacingInt) + 'px',
            //bottom: "calc(100% + " + (dimMapTypeAuxMarginInt) + "px)",
            padding: "4px"
        };
        var svgDims = "calc(100% - 6px)"
        cssClasses[buttonSVGClassName] = { inherits: [CSSClasses.boxShadow002003, CSSClasses.displayBlock] };
        cssClasses[buttonSVGClassName + " svg"] = { width: svgDims, height: svgDims, margin: "auto" };
        cssClasses[buttonSVGClassName + ":hover"] = { border: "none" };
        cssClasses[buttonClassName] = {
            inherits: [CSSClasses.baseImageButton, CSSClasses.verticalAlignMiddle],
            height: widthMapToolBarPx
        };
        var marginLeftDisplace = "0px";
        var baseToolBarButton = { inherits: [CSSClasses.baseImageButton, CSSClasses.verticalAlignMiddle], width: widthMapToolBarPx, height: widthMapToolBarPx };
        cssClasses[textButtonClassName] = {
            inherits: [baseToolBarButton, CSSClasses.borderRadius2px],
            fontSize: ls.buttonTextFontSizeInt + 'px',
            lineHeight: ls.buttonTextFontSizeInt + 'px',
            color: 'inherit',
            fontWeight: "600",
            width: widthMapToolBarPx,
            height: widthMapToolBarPx,
            marginLeft: marginLeftDisplace
        };
        cssClasses[textButtonClassName + ":hover"] = {
            fontSize: (ls.buttonTextFontSizeInt + 2) + 'px',
            lineHeight: (ls.buttonTextFontSizeInt + 2) + 'px'
        }
        //var topMarginPx = ls.topMarginInt + 'px';
        cssClasses[buttonSpaceClassName] = {
            marginTop: "6px"
        };
        return cssClasses;
    }
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function onLayoutChange(notification) { registerCSSClasses(); }
    var lcl;
    function initialize() {
        cssTag = 'baseLayersToolBar';
        createCSSClassNames();
        registerCSSClasses();
        createControl();
        lcl = settings.appContent.GetAppStyles().AddOnLayoutChangeListener(onLayoutChange);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: auxmapwrapper.js
tf.TFMap.AuxMapWrapper = function(settings) {
    var theThis, wrapper, mapWrapper, changeMapTypeButton;
    this.GetWrapper = function () { return wrapper; }
    this.GetMapWrapper = function () { return mapWrapper; }
    function getToolTipText() { return "Switch to " + settings.appContent.GetSwitchToMapTypeName() + " view"; }
    function checkButtonType() {
        tf.dom.ReplaceCSSClassCondition(wrapper, settings.appContent.GetIsShowingAerial(), notMapTypeClassName, mapTypeClassName);
    }
    function onClickButton() {
        settings.appContent.SwitchMapType();
        checkButtonType();
    }
    function createControl() {
        wrapper = new tf.dom.Div({ cssClass: wrapperClassName });
        var delayMillis = tf.TFMap.toolTipDataSetDelayMillis;
        var toolTipClass = "center";
        var toolTipArrowClass = "left";
        var toolTipStyle = undefined;
        var buttonSettings = {
            onClick: onClickButton, wrapper: wrapper, delayMillis: delayMillis, toolTipClass: toolTipClass, toolTipArrowClass: toolTipArrowClass, toolTipStyle: toolTipStyle
        };
        changeMapTypeButton = settings.appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, {
            buttonClass: changeMapTypeButtonClassName + " ripple", toolTipText: getToolTipText
        }));
        checkButtonType();
        mapWrapper = new tf.dom.Div({ cssClass: mapWrapperClassName });
        wrapper.AddContent(mapWrapper, changeMapTypeButton.GetButton());
    }
    var cssTag, wrapperClassName, mapWrapperClassName, notMapTypeClassName, mapTypeClassName, changeMapTypeButtonClassName;
    function createCSSClassNames() {
        wrapperClassName = tf.TFMap.CreateClassName(cssTag, "Wrapper");
        mapWrapperClassName = tf.TFMap.CreateClassName(cssTag, "MapWrapper");
        notMapTypeClassName = tf.TFMap.CreateClassName(cssTag, "NotMap");
        mapTypeClassName = tf.TFMap.CreateClassName(cssTag, "Map");
        changeMapTypeButtonClassName = tf.TFMap.CreateClassName(cssTag, "ChangeMapTypeButton");
    }
    function createCSSClasses() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var cssClasses = [];
        var ls = tf.TFMap.LayoutSettings;
        var toolTipContentBackground = ls.toolTipContentBackground;
        var dimMapTypeAuxInt = ls.dimMapTypeAuxInt, dimMapTypeAuxPx = dimMapTypeAuxInt + "px";
        var dimMapTypeAuxMarginInt = ls.dimMapTypeAuxMarginInt, dimMapTypeAuxMarginPx = dimMapTypeAuxMarginInt + "px";
        var auxMapBorderDimPx = ls.auxMapBorderDimInt + 'px';
        cssClasses[wrapperClassName] = {
            inherits: [CSSClasses.positionAbsolute, CSSClasses.overflowVisible, CSSClasses.pointerEventsAll, CSSClasses.boxShadow01403],
            left: dimMapTypeAuxMarginPx,
            //bottom: "calc(100% + " + (dimMapTypeAuxMarginInt) + "px)",
            bottom: (ls.scaleLineHeightInt + ls.toolBarToScaleLineVerSpacingInt) + 'px',
            zIndex: '' + (ls.rootDivZIndex + ls.auxMapWrapperZIndexAdd),
            width: dimMapTypeAuxPx,
            height: dimMapTypeAuxPx
        };
        cssClasses[mapWrapperClassName] = {
            inherits: [CSSClasses.positionAbsolute, CSSClasses.overflowVisible, CSSClasses.pointerEventsNone, CSSClasses.WHOneHundred, CSSClasses.leftTopZero]
        };
        cssClasses[notMapTypeClassName] = { border: auxMapBorderDimPx + " solid " + toolTipContentBackground };
        cssClasses[mapTypeClassName] = { border: auxMapBorderDimPx + " solid white" };
        cssClasses[changeMapTypeButtonClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.cursorPointer, CSSClasses.outline0, CSSClasses.verticalAlignMiddle, CSSClasses.listStyleNone,
            CSSClasses.overflowVisible, CSSClasses.positionAbsolute, CSSClasses.leftTopZero, CSSClasses.WHOneHundred],
            zIndex: '' + (ls.rootDivZIndex + ls.changeMapTypeButtonAddZIndex), color: 'inherit', background: 'inherit', boxShadow: 'none'
        };
        return cssClasses;
    }
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function onLayoutChange(notification) { registerCSSClasses(); }
    var lcl;
    function initialize() {
        cssTag = 'auxMap';
        createCSSClassNames();
        registerCSSClasses();
        createControl();
        lcl = settings.appContent.GetAppStyles().AddOnLayoutChangeListener(onLayoutChange);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: directionsaddress.js
tf.TFMap.DirectionsAddress = function(settings) {
    var theThis, wrapper, inputBoxWrapperIsInHover, inputBoxWrapper, inputBox, inputBoxHasFocus, searchButton, inputBoxWrapperHoverListener, inputBoxBoxFocusListener, inputBoxWrapperClickListener, placeHolder;
    var value, inputFade;
    var lastGeoCoder, lastRevGeoCoder;
    var geoCoderCount, revGeocoderCount;
    var isInError;
    var isSwappingValue, isSettingValue;
    var lastIsValid;
    var mapFeatureIconWrapper, mapFeatureIconButton;
    var delayedRevGeoCode;
    this.SetSelected = function() {
        if (theThis.GetIsValid()) {
            var coords = value.coords.slice(0);
            settings.appContent.MakeSureMapCoordsAreVisible(coords);
            flashCoords(coords);
        }
        inputBox.GetInputBox().focus();
    }
    this.GetSettings = function() { return settings; }
    this.GetPlaceHolder = function() { return settings.placeHolder; }
    this.GetValueForSwap = function() { return { value: value, inputBoxText: inputBox.GetText(), isInError: isInError }; }
    this.SetValueForSwap = function(valueForSwap) { isSwappingValue = true; value = valueForSwap.value; inputBox.SetText(valueForSwap.inputBoxText); isInError = valueForSwap.isInError; showIsInError(); isSwappingValue = false; }
    this.GetInputText = function() { return inputBox.GetText(); }
    this.GetHasInputText = function() { return theThis.GetInputText().length > 0; }
    this.GetIsValid = function() { lastIsValid = value != undefined && inputBox.GetUnTrimText() == value.address; return lastIsValid; }
    this.GetIsInError = function() { return isInError; }
    this.SetValue = function(newValue) {
        isSettingValue = true;
        clearIsInError();
        if (newValue != undefined) {
            value = { address: newValue.address, coords: newValue.coords.slice(0) };
            inputBox.SetText(value.address);
        }
        else {
            value = undefined;
            inputBox.SetText("");
        }
        showIsInError();
        isSettingValue = false;
    }
    this.GetValue = function() { return tf.js.ShallowMerge(value); }
    this.GetWrapper = function() { return wrapper; }
    this.GetHasCoords = function(coords) {
        return value != undefined &&
            value.coords[0] == coords[0] &&
            value.coords[1] == coords[1];
    }
    this.Geocode = function() {
        var inputBoxText = inputBox.GetText();
        if (tf.js.GetIsNonEmptyString(inputBoxText)) {
            cancelGeoCoders();
            lastGeoCoder = new tf.services.Geocoder({ callBack: onGeocoded, address: inputBoxText, requestProps: { address: inputBoxText, geoCoderCount: ++geoCoderCount } });
        }
    }
    this.RevGeocode = function() { delayedRevGeoCode.DelayCallBack(); }
    function doRevGeoCode() {
        if (value != undefined) {
            cancelGeoCoders();
            var props = { coords: value.coords, revGeocoderCount: ++revGeocoderCount };
            lastRevGeoCoder = new tf.services.TFReverseGeocoder({ callBack: onRevGeocoded, pointCoords: value.coords, requestProps: props, getJSON: true });
        }
    }
    function clearIsInError() {
        if (isInError) { isInError = false; showIsInError(); }
    }
    function setIsInError() {
        if (!isInError) { isInError = true; showIsInError(); notifyInputChange(); }
    }
    function showIsInError() {
        var isValid = theThis.GetIsValid();
        var errorClass = inputErrorClassName;
        var validClass = inputValidClassName;
        var okClass = inputOKClassName;
        var classesIn = isInError ? errorClass : (isValid ? validClass : okClass);
        var classesOut = isInError ? okClass + " " + validClass : (isValid ? errorClass + " " + okClass : errorClass + " " + validClass);
        var classNameVisible = settings.itemVisibleClassName, classNameHidden = settings.itemHiddenClassName;
        lastIsValid = isValid;
        tf.dom.ReplaceCSSClassCondition(inputBox.GetInputBox(), true, classesIn, classesOut);
        tf.dom.ReplaceCSSClassCondition(mapFeatureIconWrapper, isValid, classNameVisible, classNameHidden);
    }
    function cancelGeoCoders() {
        if (!!lastGeoCoder) { lastGeoCoder.Cancel(); lastGeoCoder = undefined; }
        if (!!lastRevGeoCoder) { lastRevGeoCoder.Cancel(); lastRevGeoCoder = undefined; }
    }
    function onGeocoded(notification) {
        if (lastGeoCoder != undefined) {
            lastGeoCoder = undefined;
            if (tf.js.GetIsValidObject(notification) && notification.geocoderAccuracy > 0 && notification.geocoderAccuracy < 4) {
                if (notification.requestProps.geoCoderCount == geoCoderCount) {
                    if (!theThis.GetIsValid()) {
                        theThis.SetValue({ address: notification.requestProps.address, coords: notification.pointCoords });
                    }
                }
            }
            else { setIsInError(); }
        }
    }
    function onRevGeocoded(notification) {
        //console.log('rev geocoded returned');
        if (notification.sender.WasCancelled()) {
            //console.log('rev geocode had been cancelled');
            return;
        }
        if (lastRevGeoCoder != undefined) {
            lastRevGeoCoder = undefined;
            if (tf.js.GetIsValidObject(notification) && notification.success) {
                //console.log('rev geocoded ok');
                if (notification.requestProps.revGeocoderCount == revGeocoderCount) {
                    var fullAddr = notification.address;
                    if (tf.js.GetIsNonEmptyString(fullAddr)) { theThis.SetValue({ address: fullAddr, coords: notification.requestProps.coords }); } else { setIsInError(); }
                }
            }
            else {
                //console.log(JSON.stringify(notification));
                setIsInError();
            }
        }
        else {
            //console.log('lastRevGeoCoder is undefined!');
        }
    }
    function notify(cb, extraParams) { if (tf.js.GetFunctionOrNull(cb)) { cb(tf.js.ShallowMerge({ sender: theThis }, extraParams)) } }
    function notifyInputChange(notification) {
        if (!(isSwappingValue /*|| isSettingValue*/)) {
            notify(settings.onInputChange, { notification: notification });
        }
    }
    function onInputChange(notification) {
        if (!!lastIsValid) {
            showIsInError();
        }
        else {
            clearIsInError();
            showIsInError();
        }
        notifyInputChange(notification);
    }
    function onGo() {
        notify(settings.onGo);
    }
    function createSVGButton(buttonSettings, svgHTML, buttonClass, toolTipText, svgAddClasses, modeVerb) {
        var button = settings.appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, {
            svgHTML: svgHTML,
            buttonClass: buttonClass, toolTipText: toolTipText
        }));
        button.GetSettings().modeVerb = modeVerb;
        var buttonSVG = button.GetButton().firstChild;
        tf.dom.AddCSSClass(buttonSVG, svgAddClasses);
        return button;
    }
    function onHoverInputBoxWrapper(notification) {
        var target = notification.event.target;
        if (target == inputBoxWrapper.GetHTMLElement()) {
            inputBoxWrapperIsInHover = notification.isInHover;
            if (!inputBoxHasFocus) { showFocusedStyles(false); }
        }
    }
    function showFocusedStyles(showBool) {
        tf.dom.ReplaceCSSClassCondition(inputBoxWrapper, showBool, inputFocusedClassName, inputNonFocusedClassName);
    }
    function setFocusToInput() { inputBox.GetInputBox().focus(); }
    function onFocusInputBoxBox(notification) {
        var hasFocus = notification.hasFocus;
        var target = notification.event.target;
        var targetIsInputBox = target == inputBox.GetInputBox();
        if (targetIsInputBox /*|| targetIsSearchButton*/) {
            var activeElement = document.activeElement;
            inputBoxHasFocus = hasFocus || activeElement == searchButton.GetButton();
            if (inputBoxHasFocus) { showFocusedStyles(true); }
            else if (!inputBoxWrapperIsInHover) { showFocusedStyles(false); }
        }
    }
    function onClickInputBoxWrapper(notification) {
        var target = notification.event.target;
        if (target == inputBoxWrapper.GetHTMLElement()) { setFocusToInput(); }
    }
    function flashCoords(coords) { var appContent = settings.appContent; appContent.GetAppStyles().FlashCoords(appContent.GetMap(), [coords], "#0f0"); }
    function onButtonClicked(notification) {
        var button = notification.sender;
        setFocusToInput();
        switch (button) {
            case searchButton:
                onGo();
                break;
            case mapFeatureIconButton:
                if (theThis.GetIsValid()) {
                    var coords = value.coords.slice(0);
                    settings.appContent.AnimatedSetCenterIfDestVisible(coords);
                    setTimeout(function() { flashCoords(coords); }, 500);
                }
                break;
        }
    }
    function getSearchToolTip() {
        return inputBox.GetText().length > 0 ? "Search" : placeHolder;
    }
    function createControl() {
        wrapper = new tf.dom.Div({ cssClass: wrapperClassName });
        var appContent = settings.appContent;
        var appStyles = appContent.GetAppStyles();
        var delayMillis = tf.TFMap.toolTipDelayMillis;
        var toolTipClass = "end";
        var toolTipArrowClass = "top";
        inputBoxWrapper = new tf.dom.Div({ cssClass: inputWrapperClassName + " " + inputNonFocusedClassName });
        var buttonSettings = {
            offsetY: 6, onClick: onButtonClicked, onHover: undefined, wrapper: inputBoxWrapper, delayMillis: delayMillis, toolTipClass: toolTipClass, toolTipArrowClass: toolTipArrowClass
        };
        placeHolder = "Search " + settings.placeHolder + " or select it on map";
        inputBox = new tf.TFMap.InputBox({ onChange: onInputChange, onGo: onGo, placeHolder: placeHolder, className: inputClassName, maxLength: tf.TFMap.maxCharsAddressInput });
        inputFade = new tf.dom.Div({ cssClass: inputFadeClassName });
        buttonSettings.toolTipClass = "start";
        searchButton = createSVGButton(buttonSettings, appStyles.GetSearchSVG(),
            buttonBaseClassName + " " + searchButtonClassName + " rippleWhite",
            getSearchToolTip,
            searchButtonSVGClassName, tf.TFMap.directionModeDrive);
        showIsInError();
        var inputBoxBox = inputBox.GetInputBox();
        inputBoxWrapper.AddContent(inputBoxBox, inputFade, searchButton.GetButton());
        buttonSettings.toolTipClass = "end";
        mapFeatureIconWrapper = new tf.dom.Div({
            cssClass: mapFeatureIconWrapperClassName + " " + settings.itemHiddenClassName
        });
        mapFeatureIconButton = appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, {
            buttonClass: mapFeatureIconButtonClassName + " ripple", toolTipText: "Center map to " + settings.placeHolder
        }));
        var mapFeatureIconButtonButton = mapFeatureIconButton.GetButton();
        mapFeatureIconButtonButton.appendChild(settings.mapFeatureIcon);
        mapFeatureIconWrapper.AddContent(mapFeatureIconButtonButton);
        wrapper.AddContent(mapFeatureIconWrapper, inputBoxWrapper);
        inputBoxWrapperClickListener = new tf.events.DOMClickListener({ target: inputBoxWrapper, callBack: onClickInputBoxWrapper, optionalScope: theThis, callBackSettings: null });
        inputBoxWrapperHoverListener = new tf.events.DOMMouseEnterLeaveListener({ target: inputBoxWrapper, callBack: onHoverInputBoxWrapper, optionalScope: theThis, callBackSettings: null });
        inputBoxBoxFocusListener = new tf.events.DOMFocusBlurListener({ target: inputBox.GetInputBox(), callBack: onFocusInputBoxBox, optionalScope: theThis, callBackSettings: null });
    }
    var cssTag, wrapperClassName, inputWrapperClassName, inputClassName, inputFocusedClassName, inputNonFocusedClassName, inputValidClassName, inputOKClassName, inputErrorClassName,
        inputFadeClassName, searchButtonClassName, searchButtonSVGClassName, buttonBaseClassName, mapFeatureIconWrapperClassName, mapFeatureIconButtonClassName;
    function createCSSClassNames() {
        wrapperClassName = tf.TFMap.CreateClassName(cssTag, "Wrapper");
        inputClassName = tf.TFMap.CreateClassName(cssTag, "Input");
        inputFocusedClassName = tf.TFMap.CreateClassName(cssTag, "InputFocused");
        inputNonFocusedClassName = tf.TFMap.CreateClassName(cssTag, "InputNonFocused");
        inputWrapperClassName = tf.TFMap.CreateClassName(cssTag, "InputWrapper");
        inputValidClassName = tf.TFMap.CreateClassName(cssTag, "InputValid");
        inputOKClassName = tf.TFMap.CreateClassName(cssTag, "InputOK");
        inputErrorClassName = tf.TFMap.CreateClassName(cssTag, "InputError");
        inputFadeClassName = tf.TFMap.CreateClassName(cssTag, "InputFade");
        buttonBaseClassName = tf.TFMap.CreateClassName(cssTag, "Button");
        searchButtonClassName = tf.TFMap.CreateClassName(cssTag, "SearchButton");
        searchButtonSVGClassName = tf.TFMap.CreateClassName(cssTag, "SearchButtonSVG");
        mapFeatureIconWrapperClassName = tf.TFMap.CreateClassName(cssTag, "mapFeatureIconWrapper");
        mapFeatureIconButtonClassName = tf.TFMap.CreateClassName(cssTag, "mapFeatureIconButton");
    }
    function createCSSClasses() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var cssClasses = [];
        var ls = tf.TFMap.LayoutSettings;
        var darkTextColor = ls.darkTextColor, darkTextShadow = ls.darkTextShadow;
        var livelyColor = ls.backgroundLivelyColor;
        var sidePanelWidthInt = ls.sidePanelWidthInt, sidePaneWidthPx = sidePanelWidthInt + 'px';
        var paddingLeftWayPointAddressInt = ls.paddingLeftWayPointAddressInt, paddingLeftWayPointAddressPx = paddingLeftWayPointAddressInt + 'px';
        var heightWayPointAddressInt = ls.directionsHeightWayPointAddressInt, heightWayPointAddressPx = heightWayPointAddressInt + 'px';
        var directionxWayPointInputLeftInt = paddingLeftWayPointAddressInt;
        var directionxWayPointInputLeftPx = directionxWayPointInputLeftInt + "px";
        var directionsInputHorizontalPaddingInt = 4;
        var directionsInputHorizontalPaddingPx = directionsInputHorizontalPaddingInt + 'px';
        var directionsWidthInputInt = sidePanelWidthInt - paddingLeftWayPointAddressInt - 80;
        //var directionsWidthInputPx = directionsWidthInputInt + 'px';
        var directionsHeightInputInt = ls.directionsHeightInputInt;
        var directionsFontSizeInputPx = ls.directionsFontSizeInputInt + 'px';
        var directionsHeightInputPx = directionsHeightInputInt + 'px';
        var directionsWayPointInputFadeWidth = 20;
        cssClasses[wrapperClassName] = {
            inherits: [CSSClasses.positionRelative], height: heightWayPointAddressPx, width: "calc(100% - " + paddingLeftWayPointAddressPx + ')',
            paddingLeft: paddingLeftWayPointAddressPx, paddingTop: "10px", paddingBottom: "10px", transform: 'initial'
        };
        cssClasses[inputClassName] = {
            inherits: [CSSClasses.robotoFontFamily, CSSClasses.positionAbsolute, CSSClasses.overflowHidden, CSSClasses.leftTopZero],
            color: 'white', outline: 'none', border: 'none',
            fontSize: directionsFontSizeInputPx,
            lineHeight: directionsHeightInputPx + ' !important',
            padding: '0',
            verticalAlign: 'middle', listStyle: 'none', borderRadius: "4px",
            background: 'transparent', margin: '0 !important',
            paddingLeft: directionsInputHorizontalPaddingPx, height: directionsHeightInputPx + ' !important',
            zIndex: '' + (ls.rootDivZIndex + ls.directionsInputZIndexAdd)
        };
        cssClasses[inputFocusedClassName + " ." + inputClassName] = {
            width: (directionsWidthInputInt) + 'px',
            paddingRight: (directionsInputHorizontalPaddingInt + directionsHeightInputInt) + 'px'
        };
        cssClasses[inputNonFocusedClassName + " ." + inputClassName] = {
            width: (directionsWidthInputInt + directionsHeightInputInt) + 'px',
            paddingRight: (directionsInputHorizontalPaddingInt) + 'px'
        };
        cssClasses[inputWrapperClassName] = {
            inherits: [CSSClasses.cursorText, CSSClasses.noMarginNoBorderNoPadding, CSSClasses.positionAbsolute, CSSClasses.overflowVisible],
            width: (directionsWidthInputInt + 2 * directionsInputHorizontalPaddingInt + directionsHeightInputInt + directionsHeightInputInt) + 'px',
            height: directionsHeightInputPx + ' !important',
            left: directionxWayPointInputLeftPx
        };
        cssClasses[inputValidClassName] = { borderBottom: '1px solid rgba(0,255,0,1)' };
        cssClasses[inputOKClassName] = { borderBottom: '1px solid rgba(255,255,255,0.3)' };
        cssClasses[inputErrorClassName] = { borderBottom: '1px solid rgba(255,0,0,1)' };
        cssClasses[inputFadeClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.pointerEventsNone, CSSClasses.positionAbsolute, CSSClasses.overflowVisible],
            top: "0px", background: "linear-gradient(to right, rgba(30, 144, 255,0),rgba(30, 144, 255, 1))",
            zIndex: '' + (ls.rootDivZIndex + ls.directionsInputFadeZIndexAdd),
            padding: '0', paddingLeft: directionsInputHorizontalPaddingPx, paddingRight: directionsInputHorizontalPaddingPx,
            width: directionsWayPointInputFadeWidth + 'px', height: directionsHeightInputPx + ' !important'
        };
        cssClasses[inputFocusedClassName + " ." + inputFadeClassName] = { left: (directionsWidthInputInt - directionsWayPointInputFadeWidth) + 'px' };
        cssClasses[inputNonFocusedClassName + " ." + inputFadeClassName] = { left: (directionsHeightInputInt + directionsWidthInputInt - directionsWayPointInputFadeWidth) + 'px' };
        cssClasses[buttonBaseClassName] = {
            inherits: [CSSClasses.transparentImageButton, CSSClasses.overflowHidden, CSSClasses.displayBlock],
            fill: "rgba(255,255,255,0.5)", background: 'transparent'
        };
        cssClasses[buttonBaseClassName + ":hover"] = { fill: "white" };
        cssClasses[searchButtonClassName] = {
            inherits: [CSSClasses.positionAbsolute],
            zIndex: '' + (ls.rootDivZIndex + ls.diretionsSearchButtonZIndexAdd),
            background: livelyColor, borderRadius: "50%", height: directionsHeightInputPx
        };
        cssClasses[searchButtonSVGClassName] = { disabled: 'inherit', opacity: 'inherit', visibility: 'inherit', width: "16px", height: "16px", strokeWidth: "0" };
        cssClasses[inputFocusedClassName + " ." + searchButtonClassName] = {
            inherits: [CSSClasses.visibilityVisible], opacity: "1", disabled: 'false', width: directionsHeightInputPx, left: 'initial', right: directionsHeightInputPx
        };
        cssClasses[inputNonFocusedClassName + " ." + searchButtonClassName] = {
            inherits: [CSSClasses.visibilityHidden], opacity: "0", disabled: 'true', width: '0px', right: 'initial', left: "100%"
        };
        cssClasses[mapFeatureIconWrapperClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.overflowVisible, CSSClasses.positionAbsolute],
            top: "8px", left: "12px", width: (directionsHeightInputInt + 6) + 'px', height: (directionsHeightInputInt + 6) + 'px'
        };
        cssClasses[mapFeatureIconButtonClassName] = {
            inherits: [CSSClasses.transparentImageButton],
            background: 'lightblue', borderRadius: "50%", padding: "2px", width: "calc(100% - 2px)", height: "calc(100% - 2px)"
        };
        cssClasses[mapFeatureIconButtonClassName + ":focus"] = { background: 'white' };
        cssClasses[mapFeatureIconButtonClassName + " img"] = { width: "100%", height: "100%" };
        return cssClasses;
    }
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function onLayoutChange(notification) { registerCSSClasses(); }
    function initialize() {
        delayedRevGeoCode = new tf.events.DelayedCallBack(tf.TFMap.DelayDirections, doRevGeoCode, theThis);
        isSwappingValue = isSettingValue = isInError = false;
        revGeocoderCount = geoCoderCount = 0;
        inputBoxWrapperIsInHover = false;
        inputBoxHasFocus = false;
        cssTag = 'directionsAddress';
        createCSSClassNames();
        registerCSSClasses();
        createControl();
        settings.appContent.GetAppStyles().AddOnLayoutChangeListener(onLayoutChange);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: directionsresultsitem.js
tf.TFMap.DirectionsResultsItem = function(settings) {
    var theThis, wrapper, subDirections, content, iconButton, itemDistance, lastInstruction, selectedDiv;
    var clickListener, subDirectionsClickListener;
    var mapFeature, mapFeatureInLayer;
    var subDirectionsFrom, subDirectionsTo;
    this.GetMapFeature = function() { return mapFeature; }
    this.SetSelected = function (bool) { tf.dom.ReplaceCSSClassCondition(selectedDiv, !!bool, settings.itemClassNames.wrapperVisibleClassName, settings.itemClassNames.wrapperHiddenClassName); }
    this.GetWrapper = function() { return wrapper; }
    this.UpdateDistance = function() { return updateDistance(); }
    this.Update = function(instructionsAndRoute, index) {
        var appContent = settings.appContent;
        var appStyles = appContent.GetAppStyles();
        var instructions = instructionsAndRoute.instructions;
        var instruction = instructions[index];
        var props = instruction.properties;
        var code = props.instructionCode;
        var codeSVG;
        var directionSVGs = appStyles.GetDirectionsStepsSVGs();
        var instructionHTML;
        var needsWalkSubDirections;
        if (instructionsAndRoute.transitInstructions) {
            switch (code) {
                //case tf.Transit.PlanTripSteps.arriveAtEndLocation:
                //case tf.Transit.PlanTripSteps.fromStartLocation:
                case tf.Transit.PlanTripSteps.walkFromStartToStop:
                case tf.Transit.PlanTripSteps.walkFromStopToNearbyStop:
                case tf.Transit.PlanTripSteps.walkFromStopToEndLocation:
                    codeSVG = appStyles.GetWalkSVG();
                    needsWalkSubDirections = true;
                    subDirectionsFrom = instruction.fromCoords;
                    subDirectionsTo = instruction.toCoords;
                    break;
                case tf.Transit.PlanTripSteps.takeTripAtStop:
                    codeSVG = appStyles.GetBusSVG();
                    break;
                case tf.Transit.PlanTripSteps.leaveTripAtStop:
                    codeSVG = appStyles.GetBusStopSVG();
                    break;
            }
            var instructionStr = props.instruction;
            instructionHTML = instructionStr;
            //instructionHTML = code + ' ' + instruction;
        }
        else {
            codeSVG = directionSVGs[code];
            instructionHTML = props.instruction + " " + props.streetName;
        }
        //var innerHTML = (index + 1) + ' ' + instructionHTML;
        subDirections.GetHTMLElement().style.display = needsWalkSubDirections ? "block" : "none";
        var innerHTML = instructionHTML;
        theThis.SetSelected(false);
        lastInstruction = instruction;
        iconButton.GetHTMLElement().innerHTML = codeSVG;
        content.GetHTMLElement().innerHTML = innerHTML;
        updateDistance();
        updateMapFeature();
    }
    this.Hide = function() {
        if (!!mapFeature) {
            if (mapFeatureInLayer) {
                mapFeatureInLayer = false;
                settings.itemsLayer.DelMapFeature(mapFeature);
            }
        }
    }
    function updateMapFeature() {
        if (lastInstruction != undefined) {
            var instruction = lastInstruction;
            var geom = tf.js.ShallowMerge(instruction.geometry);
            var props = instruction.properties;
            var toolTipProps = { toolTipText: props.instruction + " " + props.streetName, keepOnHoverOutTarget: false, offsetX: 20 };
            var angle = props.postTurnDirection * Math.PI / 180;
            if (mapFeature == undefined) {
                mapFeature = new tf.map.Feature(tf.js.ShallowMerge(geom, settings.itemMapFeatureStyles));
                mapFeature.GetSettings().directionsResultsItem = theThis;
            }
            else {
                mapFeature.SetPointCoords(geom.coordinates);
            }
            mapFeature.GetSettings().directionsAngle = angle;
            mapFeature.RefreshStyle();
            tf.TFMap.SetMapFeatureToolTipProps(mapFeature, toolTipProps);
            settings.itemsLayer.AddMapFeature(mapFeature);
            mapFeatureInLayer = true;
        }
    }
    function updateDistance() {
        if (lastInstruction != undefined) {
            var instruction = lastInstruction;
            var props = instruction.properties;
            var useUSScaleUnits = settings.appContent.GetMap().GetIsUSScaleUnits();
            var distanceText = tf.TFMap.GetDirectionsDistanceText(props.lengthMeters, useUSScaleUnits);
            /*if (!!instruction.step) {
                distanceText += " (" + tf.TFMap.GetWalkRideDistanceStr(instruction.step.walkkm, instruction.step.tripkm, useUSScaleUnits) + ")";
            }*/
            itemDistance.GetHTMLElement().innerHTML = distanceText;
        }
    }
    function onClickWrapper(notification) { if (tf.js.GetFunctionOrNull(settings.onClick)) { settings.onClick({ sender: theThis }); } }
    function onClickSubDirections() {
        //console.log('From: ' + subDirectionsFrom + ' to: ' + subDirectionsTo);
        settings.appContent.GetDirectionsPanel().PushDirections({
            fromCoords: subDirectionsFrom,
            toCoords: subDirectionsTo,
            mode: tf.TFMap.directionModeWalk
        });
    }
    function createControl() {
        var itemClassNames = settings.itemClassNames;
        wrapper = new tf.dom.Div({ cssClass: itemClassNames.wrapperClassName });
        subDirections = new tf.dom.Div({ cssClass: itemClassNames.subDirectionsClassName });
        content = new tf.dom.Div({ cssClass: itemClassNames.contentClassName });
        iconButton = new tf.dom.Div({ cssClass: itemClassNames.iconClassName });
        itemDistance = new tf.dom.Div({ cssClass: itemClassNames.itemDistanceClassName });
        selectedDiv = new tf.dom.Div({ cssClass: itemClassNames.itemSelectedClassName });
        wrapper.AddContent(iconButton, subDirections, content, itemDistance, selectedDiv);
        clickListener = new tf.events.DOMClickListener({ target: wrapper, callBack: onClickWrapper, optionalScope: theThis, callBackSettings: null });
        subDirectionsClickListener = new tf.events.DOMClickListener({ target: subDirections, callBack: onClickSubDirections, optionalScope: theThis, callBackSettings: null });
    }
    function initialize() {
        createControl();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: directionsresultscontent.js
tf.TFMap.DirectionsResultsContent = function(settings) {
    var theThis, wrapper, content, directionResultsItemCache, selectedItem;
    var itemMapFeatureStyles;
    var firstRow, lastRow;
    var firstClickListener, lastClickListener;
    var autoSetNextExtent;
    var curStartAddress, curEndAddress, curInstructionsAndRoute;
    this.SetAutoSetNextExtent = function () { autoSetNextExtent = true; }
    this.OnResize = function() {
        if (curStartAddress != undefined) {
            update(curStartAddress, curEndAddress, curInstructionsAndRoute);
        }
    }
    this.SelectResultItem = function(directionsResultsItem) { return selectItem(directionsResultsItem, false, true); }
    this.UpdateDistances = function() { return updateDistances(); }
    this.Update = function(startAddress, endAddress, instructionsAndRoute) { return update(startAddress, endAddress, instructionsAndRoute); }
    this.Show = function(bool) {
        if (!bool) {
            hideItems();
        }
        return showWrapper(bool);
    }
    this.GetWrapper = function() { return wrapper; }
    function showWrapper(bool) {
        var classNameVisible = settings.itemVisibleClassName, classNameHidden = settings.itemHiddenClassName;
        tf.dom.ReplaceCSSClassCondition(wrapper, bool, classNameVisible, classNameHidden);
        tf.dom.ReplaceCSSClassCondition(settings.contentBotWrapperFadeTop, bool, classNameVisible, classNameHidden);
        tf.dom.ReplaceCSSClassCondition(settings.contentBotWrapperFadeBot, bool, classNameVisible, classNameHidden);
    }
    function updateDistances() {
        var items = directionResultsItemCache.GetObjects(), nActive = directionResultsItemCache.GetActiveCount();
        for (var i = 0; i < nActive; ++i) { items[i].UpdateDistance(); }
        updateStartEnd();
    }
    function hideItems() {
        curStartAddress = curEndAddress = curInstructionsAndRoute = undefined;
        var items = directionResultsItemCache.GetObjects(), nActive = directionResultsItemCache.GetActiveCount();
        for (var i = 0; i < nActive; ++i) {
            items[i].Hide();
        }
    }
    function updateStartEnd() {
        if (!!curInstructionsAndRoute) {
            var totalDistanceMeters = curInstructionsAndRoute.total_distance;
            var totalTimeSeconds = curInstructionsAndRoute.total_time;
            var summaryAddressStart = '<span class="' + classNames.summaryAddressClassName + '">';
            var summarySpanEnd = "</span>";
            var isUSScaleUnits = settings.appContent.GetMap().GetIsUSScaleUnits();
            var distanceStr = tf.TFMap.GetDirectionsDistanceText(totalDistanceMeters, isUSScaleUnits);
            if (curInstructionsAndRoute.transitInstructions && !!curInstructionsAndRoute.plan) {
                var steps = curInstructionsAndRoute.plan.steps, nSteps = steps.length, lastStep = steps[nSteps - 1];
                distanceStr += " -- " + tf.TFMap.GetWalkRideDistanceStr(lastStep.walkkm, lastStep.tripkm, isUSScaleUnits);
            }
            var summaryText = '<br /><span class="' + classNames.summaryTimeClassName + '">' + tf.js.ConvertToHourMinute2(totalTimeSeconds) + summarySpanEnd +
                ' <span class="' + classNames.summaryDistanceClassName + '">(' + distanceStr + ')' + summarySpanEnd;
            firstRow.GetHTMLElement().innerHTML = summaryAddressStart + curStartAddress.GetInputText() + summarySpanEnd + summaryText;
            lastRow.GetHTMLElement().innerHTML = summaryAddressStart + curEndAddress.GetInputText() + summarySpanEnd + summaryText;
        }
    }
    function update(startAddress, endAddress, instructionsAndRoute) {
        var instructions = instructionsAndRoute.instructions;
        var nInstructions = instructions.length;
        var nReps = 1;
        //var nReps = 10;
        content.ClearContent();
        selectedItem = undefined;
        hideItems();
        directionResultsItemCache.Reset();
        settings.scrollerWrapper.GetHTMLElement().scrollTop = "0px";
        content.AddContent(firstRow);
        curStartAddress = startAddress;
        curEndAddress = endAddress;
        curInstructionsAndRoute = instructionsAndRoute;
        updateStartEnd();
        for (var j = 0; j < nReps; ++j) {
            for (var i = 0; i < nInstructions; ++i) {
                var instructionItem = directionResultsItemCache.GetNext();
                instructionItem.Update(instructionsAndRoute, i);
                content.AddContent(instructionItem.GetWrapper());
            }
        }
        content.AddContent(lastRow);
        if (autoSetNextExtent) {
            autoSetNextExtent = false;
            setMapExtent(true);
        }
    }
    function setMapExtent(keepDirectionsOpen) {
        if (!!curInstructionsAndRoute) {
            settings.appContent.SetMapExtent(curInstructionsAndRoute.extent, keepDirectionsOpen);
        }
    }
    function onSummaryRowClicked(notification) { setMapExtent(false); }
    function createNewDirectionResultItem(notification) {
        return new tf.TFMap.DirectionsResultsItem(tf.js.ShallowMerge(settings, {
            itemClassNames: itemClassNames,
            wrapper: content, scrollerWrapper: settings.scrollerWrapper, onClick: onItemClicked, itemMapFeatureStyles: itemMapFeatureStyles
        }));
    }
    function deleteDirectionResultItem() { }
    function flashCoords(coords) { var appContent = settings.appContent; appContent.GetAppStyles().FlashCoords(appContent.GetMap(), [coords], "#0f0"); }
    function selectItem(newSelectedItem, animateBool, flashBool) {
        if (selectedItem != undefined) { selectedItem.SetSelected(false); }
        (selectedItem = newSelectedItem).SetSelected(true);
        tf.dom.ScrollVerticallyToEnsureVisible(settings.scrollerWrapper, selectedItem.GetWrapper());
        var coords = selectedItem.GetMapFeature().GetPointCoords();
        var appContent = settings.appContent;
        if (!!animateBool) {
            appContent.AnimatedSetCenterIfDestVisible(coords);
            if (!!flashBool) { setTimeout(function() { flashCoords(coords); }, 500); }
        }
        else if (!!flashBool) {
            appContent.MakeSureMapCoordsAreVisible(coords);
            flashCoords(coords);
        }
    }
    function onItemClicked(notification) { selectItem(notification.sender, true, true); }
    function createItemMapFeatureStyles() {
        var radius = 19;
        var colorFill = "#0f0";
        var shapePoints = 3;
        function getStyle(keyedFeature, mapFeature) {
            var isHover = mapFeature.GetIsDisplayingInHover();
            var mapFeatureSettings = mapFeature.GetSettings();
            var shapeRadius = isHover ? radius + 2 : radius;
            var shapeZIndex = isHover ? 5 : 0;
            var rotationRad = mapFeatureSettings.directionsAngle;
            var appStyles = settings.appContent.GetAppStyles();
            var snaptopixel = false;
            var itemMapFeatureStyle = [];
            var imageStyle = appStyles.GetSVGMapMarkerStyle(appStyles.GetDirectionsMapArrowImage(), [shapeRadius + 4, shapeRadius + 4], [0.5, 0.5], 0, ++shapeZIndex)
            imageStyle.rotate_with_map = true;
            imageStyle.rotation_rad = rotationRad;
            imageStyle.snaptopixel = snaptopixel;
            itemMapFeatureStyle.push(imageStyle);
            return itemMapFeatureStyle;
        }
        itemMapFeatureStyles = { style: getStyle, hoverStyle: getStyle };
    }
    function createControl() {
        wrapper = new tf.dom.Div({ cssClass: classNames.wrapperClassName });
        content = new tf.dom.Div({ cssClass: classNames.contentClassName });
        firstRow = new tf.dom.Div({ cssClass: classNames.summaryTopClassName });
        lastRow = new tf.dom.Div({ cssClass: classNames.summaryBotClassName });
        firstClickListener = new tf.events.DOMClickListener({ target: firstRow, callBack: onSummaryRowClicked, optionalScope: theThis, callBackSettings: null });
        lastClickListener = new tf.events.DOMClickListener({ target: lastRow, callBack: onSummaryRowClicked, optionalScope: theThis, callBackSettings: null });
        wrapper.AddContent(content);
    }
    var cssTag, classNames, itemClassNames;
    function createCSSClassNames() {
        classNames = {
            wrapperClassName: tf.TFMap.CreateClassName(cssTag, "Wrapper"),
            contentClassName: tf.TFMap.CreateClassName(cssTag, "Content"),
            summaryTopClassName: tf.TFMap.CreateClassName(cssTag, "SummaryTop"),
            summaryBotClassName: tf.TFMap.CreateClassName(cssTag, "SummaryBot"),
            summaryTimeClassName: tf.TFMap.CreateClassName(cssTag, "STime"),
            summaryDistanceClassName: tf.TFMap.CreateClassName(cssTag, "SDist"),
            summaryAddressClassName: tf.TFMap.CreateClassName(cssTag, "SAddr")
        };
        itemClassNames = {
            wrapperClassName: tf.TFMap.CreateClassName(cssTag, "DirItemWrapper"),
            wrapperVisibleClassName: tf.TFMap.CreateClassName(cssTag, "DirItemWrapperVisible"),
            wrapperHiddenClassName: tf.TFMap.CreateClassName(cssTag, "DirItemWrapperHidden"),
            contentClassName: tf.TFMap.CreateClassName(cssTag, "DirItemContent"),
            iconClassName: tf.TFMap.CreateClassName(cssTag, "DirItemIcon"),
            itemSelectedClassName: tf.TFMap.CreateClassName(cssTag, "DirItemItemSelected"),
            itemDistanceClassName: tf.TFMap.CreateClassName(cssTag, "DirItemItemDistance"),
            subDirectionsClassName: tf.TFMap.CreateClassName(cssTag, "DirItemSubDirections")
        };
    }
    function createCSSClasses() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var cssClasses = [];
        var ls = tf.TFMap.LayoutSettings;
        var darkTextColor = ls.darkTextColor, darkTextShadow = ls.darkTextShadow;
        var sidePanelWidthInt = ls.sidePanelWidthInt, sidePaneWidthPx = sidePanelWidthInt + 'px';
        var resultsResultsIconDimInt = ls.directionsResultsIconDimInt, resultsResultsIconDimPx = resultsResultsIconDimInt + 'px';
        var directionsSelectedColor = ls.directionsSelectedColor;
        var backgroundLivelyStyle = { backgroundColor: ls.backgroundLivelyColor };
        var itemDistanceFontSizeInt = ls.directionsItemDistanceFontSizeInt, itemDistanceFontSizePx = itemDistanceFontSizeInt + 'px';
        cssClasses[classNames.wrapperClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, backgroundLivelyStyle, CSSClasses.overflowVisible, CSSClasses.positionRelative],
            color: 'black', background: 'white', fontSize: "14px", fontWeight: "400", lineHeight: "20px"
        };
        cssClasses[classNames.contentClassName] = { inherits: [CSSClasses.overflowVisible, CSSClasses.positionRelative], height: "100%" };
        var widthSub = ls.directionsSummaryCommonWidthSubInt;
        var summaryCommon = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.overflowVisible, CSSClasses.displayInlineBlock, CSSClasses.positionRelative, CSSClasses.cursorPointer],
            marginLeft: "6px",
            padding: ls.directionsSummaryPaddingInt +"px",
            paddingLeft: "14px", width: "calc(100% - " + (widthSub) + "px)",
            borderTop: "2px solid transparent", borderBottom: "2px solid transparent"
        };
        cssClasses[classNames.summaryTopClassName] = { inherits: [summaryCommon], paddingBottom: "6px" };
        cssClasses[classNames.summaryTopClassName + ":hover"] = { borderBottom: "2px solid " + directionsSelectedColor };
        cssClasses[classNames.summaryBotClassName] = { inherits: [summaryCommon], paddingTop: "10px" };
        cssClasses[classNames.summaryBotClassName + ":hover"] = { borderTop: "2px solid " + directionsSelectedColor };
        cssClasses[classNames.summaryTimeClassName] = {
            color: "black",
            fontSize: ls.directionsSummarySmallFontSizeInt + "px",
            fontWeight: "700"
        };
        cssClasses[classNames.summaryDistanceClassName] = {
            color: "#778",
            fontSize: ls.directionsSummaryLargeFontSizeInt + "px",
            fontWeight: "300"
        };
        cssClasses[classNames.summaryAddressClassName] = {
            color: darkTextColor,
            fontSize: ls.directionsSummaryLargeFontSizeInt + "px",
            fontWeight: "500"
        };
        cssClasses[itemClassNames.wrapperClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.overflowVisible, CSSClasses.displayBlock, CSSClasses.positionRelative],
            color: "black", backgroundColor: "white", textAlign: 'left', fontSize: 'inherit', lineHeight: 'inherit', fontWeight: 'inherit',
            width: (sidePanelWidthInt - resultsResultsIconDimInt - 0/*12*/) + "px", marginBottom: "10px", paddingLeft: "10px"
        };
        cssClasses[itemClassNames.wrapperVisibleClassName] = { inherits: [CSSClasses.displayBlock] };
        cssClasses[itemClassNames.wrapperHiddenClassName] = { inherits: [CSSClasses.displayNone] };
        //var subWidthPx = "52px";
        var subWidthPx = "62px";
        cssClasses[itemClassNames.contentClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.overflowVisible, CSSClasses.displayInlineBlock, CSSClasses.positionRelative],
            verticalAlign: "top", background: 'transparent', borderBottom: "1px solid #e6e6e6", padding: "12px", paddingLeft: "0px",
            fontSize: ls.directionsItemContentFontSizeInt + "px",
            lineHeight: ls.directionsItemContentLineHeightInt + "px",
            paddingBottom: ls.directionsItemContentPaddingBottomInt + "px",
            paddingTop: "6px", width: "calc(100% - " + subWidthPx + ")"
        };
        cssClasses[itemClassNames.iconClassName] = {
            inherits: [CSSClasses.displayInlineBlock, CSSClasses.noMarginNoBorderNoPadding],
            background: 'transparent', verticalAlign: "top", width: resultsResultsIconDimPx, height: resultsResultsIconDimPx
        };
        cssClasses[itemClassNames.iconClassName + " svg"] = {
            fill: ls.darkTextColor,
            marginLeft: ls.directionsResultsIconMarginLeftInt + "px",
            marginTop: ls.directionsResultsIconMarginTopInt + "px",
            width: "16px",
            height: "16px"
        };
        cssClasses[itemClassNames.itemSelectedClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.overflowVisible, CSSClasses.positionAbsolute],
            top: "0px", left: "0px", height: "100%", width: "1px", borderLeft: "5px solid " + directionsSelectedColor
        };
        cssClasses[itemClassNames.itemDistanceClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.overflowVisible, CSSClasses.displayBlock, CSSClasses.positionAbsolute],
            //bottom: (-itemDistanceFontSizeInt) + "px",
            bottom: "0px",
            lineHeight: itemDistanceFontSizeInt + 'px',
            //top: "calc(100% - " + itemDistanceFontSizePx + ")",
            background: 'white', color: "#778", paddingRight: "6px",
            left: (resultsResultsIconDimInt + 12) + 'px', fontSize: itemDistanceFontSizePx
        };
        var subDirectionsTransformStr = "translateX(-100%)";
        var subDirectionsDim = ls.directionsSubDirectionsButtonDimPxInt + 'px';
        cssClasses[itemClassNames.subDirectionsClassName] = {
            inherits: [CSSClasses.overflowVisible, CSSClasses.positionAbsolute, CSSClasses.directionsButtonBackground, CSSClasses.displayBlock, CSSClasses.backgroundColorTransparent,
            CSSClasses.cursorPointer],
            zIndex: 1,
            bottom: "1px", left: "100%",
            transform: subDirectionsTransformStr,
            "-webkit-transform": subDirectionsTransformStr,
            width: subDirectionsDim, height: subDirectionsDim,
            borderRadius: "2px"
        };
        cssClasses[itemClassNames.subDirectionsClassName + " svg"] = { fill: "black", width: "100%", height: "100%" };
        return cssClasses;
    }
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function onLayoutChange(notification) { registerCSSClasses(); theThis.OnResize(); }
    function initialize() {
        autoSetNextExtent = false;
        createItemMapFeatureStyles();
        directionResultsItemCache = new tf.js.ObjectCache({ createNew: createNewDirectionResultItem, onDelete: deleteDirectionResultItem });
        cssTag = 'directionsContent';
        createCSSClassNames();
        registerCSSClasses();
        createControl();
        settings.appContent.GetAppStyles().AddOnLayoutChangeListener(onLayoutChange);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: directionsresults.js
tf.TFMap.DirectionsResults = function (settings) {
    var theThis, wrapper, isVisible, canSearch, hasAddressErrors, errorsWrapper, errorsContent, searchingWrapper, searchingContent;
    var featurePointCoords, directionSearchCoords;
    var modeOfTransportation;
    var mapFeatures;
    var lastRouting, routingCount;
    var startMapFeature, endMapFeature;
    var routeFeature;
    var totalDistanceMeters, totalTimeSeconds;
    var routingErrorMsg;
    var routeStyles;
    var instructionsAndRoute;
    var directionsResultsContent;
    var startAddress, endAddress, wayPoints;
    var delayedCheckCanSearch;
    var lastCoordinates;
    var currentState;
    var inErrorAddresses;
    var delayedShowSearching;
    var onFoundOutCanSearchCB;
    var transitPlanService;
    this.SetAutoSetNextExtent = function () { directionsResultsContent.SetAutoSetNextExtent(); }
    this.UpdateDistances = function() { return directionsResultsContent.UpdateDistances(); }
    this.SelectResultItem = function(directionsResultsItem) { return directionsResultsContent.SelectResultItem(directionsResultsItem); }
    this.GetModeOfTransportation = function() { return modeOfTransportation; }
    this.SetModeOfTransportation = function(newModeOfTransportation) { modeOfTransportation = newModeOfTransportation; if (canSearch) { doSearch(directionSearchCoords); } }
    this.GetWrapper = function() { return wrapper; }
    this.GetCanSearch = function() { return canSearch; }
    this.OnResize = function() { directionsResultsContent.OnResize(); }
    this.GetRouteCoordinates = function() { return lastCoordinates; }
    function checkWayPointsLayerVisibility() { settings.wayPointsLayer.SetVisible(modeOfTransportation != tf.TFMap.directionModeBus); }
    function doCheckCanSearch() {
        checkWayPointsLayerVisibility();
        inErrorAddresses = [];
        featurePointCoords = [];
        directionSearchCoords = [];
        hasAddressErrors = canSearch = false;
        routingErrorMsg = undefined;
        instructionsAndRoute = undefined;
        var addresses = [];
        if (startAddress != undefined) { addresses.push(startAddress); }
        if (endAddress != undefined) { addresses.push(endAddress); }
        if (tf.js.GetIsNonEmptyArray(addresses)) {
            var nAddr = addresses.length;
            canSearch = true;
            for (var i = 0; i < nAddr; ++i) {
                var addr = addresses[i];
                if (addr.GetIsValid()) {
                    var isStart = i == 0;
                    var isEnd = i == nAddr - 1;
                    var coords = addr.GetValue().coords;
                    featurePointCoords.push({ coords: coords, isStart: isStart, isEnd: isEnd });
                    directionSearchCoords.push(coords);
                    if (isStart) { if (tf.js.GetIsNonEmptyArray(wayPoints)) { Array.prototype.push.apply(directionSearchCoords, wayPoints); } }
                }
                else {
                    canSearch = false;
                    if (addr.GetIsInError()) { hasAddressErrors = true; inErrorAddresses.push(addr); }
                }
            }
            if (canSearch) { doSearch(directionSearchCoords); }
            //else if (hasAddressErrors) { }
            //else { console.log("can't search but have no errors"); }
        }
        if (hasAddressErrors) { setState("addressError"); } else if (!canSearch) { setState("idle"); }
        addMapFeatures(featurePointCoords);
        if (!!onFoundOutCanSearchCB) { onFoundOutCanSearchCB({ sender: theThis }); }
    }
    function doShowSearching() {
        if (currentState == "searching") {
            showSearchingWrapper(true);
        }
    }
    function setState(newState) {
        var needsToShow = false, needsToShowResults = false, needsToShowErrors = false, needsToShowSearching = false;
        //console.log('state: ' + newState);
        switch (currentState = newState) {
            case "idle":
                break;
            case "addressError":
                routingErrorMsg = undefined;
                needsToShow = needsToShowErrors = true;
                break;
            case "searching":
                needsToShow = needsToShowSearching = true;
                break;
            case "searchError":
                routingErrorMsg = "A route could not be found, please try different locations";
                needsToShow = needsToShowErrors = true;
                break;
            case "searchOK":
                needsToShow = needsToShowResults = true;
                break;
        }
        if (needsToShowSearching) { delayedShowSearching.DelayCallBack(); }
        else { delayedShowSearching.CancelCallBack(); showSearchingWrapper(false); }
        if (needsToShowResults) { showResults(); } else { directionsResultsContent.Show(false); }
        if (needsToShowErrors) { showErrors(inErrorAddresses); } else { showErrorsWrapper(false); }
        showHide(needsToShow);
    }
    this.CheckCanSearch = function(startAddressSet, endAddressSet, wayPointsSet) {
        startAddress = startAddressSet;
        endAddress = endAddressSet;
        wayPoints = wayPointsSet;
        canSearch = false;
        delayedCheckCanSearch.DelayCallBack();
    }
    function getInstructionsAndRoute(notification, startKey) {
        var instructions = [];
        var message = "Routing server not available ";
        var success = false, extent, total_distance = 0, total_time = 0;
        if (notification != undefined) {
            if (notification.status == 0 || notification.status == 200) {
                var key = startKey != undefined ? startKey : 0;
                var len = notification.route_instructions.length, lastIndex = len - 1;
                var mapFeatureGeomSettings = { type: 'linestring', coordinates: notification.route_geometry };
                var mapFeatureGeom = new tf.map.FeatureGeom(mapFeatureGeomSettings);
                var routeSummary = notification.route_summary;
                total_distance = routeSummary.total_distance;
                total_time = routeSummary.total_time;
                lastCoordinates = notification.route_geometry;
                routeFeature.SetGeom(mapFeatureGeom);
                routeFeature.RefreshStyle();
                message = notification.status_message;
                success = true;
                var nInstructions = notification.route_instructions.length;
                for (var i = 0; i < nInstructions; ++i) {
                    var instruction = notification.route_instructions[i];
                    var coord = notification.route_geometry[instruction[3]];
                    var instructionStr = tf.services.TranslateRoutingInstruction(instruction[0]);
                    var streetName;
                    if (key != lastIndex) {
                        streetName = instruction[1];
                        streetName = streetName.replace('{', '');
                        streetName = streetName.replace('}', '');
                        streetName = streetName.replace(':', ' ');
                        streetName = streetName.replace('_', ' ');
                        if (streetName == '') {
                            if (i == 0) { streetName = routeSummary.start_point; }
                            else if (i == nInstructions - 1) { streetName = routeSummary.end_point; }
                            else { streetName = "ahead"; }
                        }
                        if (instructionStr == undefined) { console.log('unknown direction instruction'); instructionStr = "Go"; }
                    }
                    else { streetName = "is ahead"; instructionStr = "Destination"; }
                    var data = {
                        geometry: { type: 'point', coordinates: coord },
                        properties: {
                            //timeInSeconds: instruction[4], lengthMetersStr: instruction[5], postTurnDirectionStr: instruction[6],
                            instructionCode: parseInt(instruction[0], 10), instruction: instructionStr, streetName: streetName, lengthMeters: instruction[2], postTurnDirection: instruction[7]
                        }
                    };
                    extent = tf.js.UpdateMapExtent(extent, coord);
                    ++key;
                    instructions.push(data);
                }
            }
            else { message = notification.status_message; }
        }
        return { total_distance: total_distance, total_time: total_time, instructions: instructions, message: message, routeFeature: routeFeature, success: success, extent: extent };
    }
    function createRouteStyle(lineWidth, lineCap, lineDash, zIndex) {
        var style = [
            { zindex: zIndex++, line_cap: lineCap, line: true, line_opacity: 1, line_color: "#fff", line_width: lineWidth },
            { zindex: zIndex++, line_cap: lineCap, line: true, line_opacity: 70, line_color: "#ebebeb", line_width: lineWidth + 2, line_dash: lineDash },
            { zindex: zIndex++, line_cap: lineCap, line: true, line_color: "#1fa0ff", line_width: lineWidth, line_dash: lineDash }
        ];
        return style;
    }
    function getRouteStyle(keyedFeature, mapFeature) { var routeStyle = routeStyles[modeOfTransportation]; return routeStyle.style; }
    function createRouteStyles() {
        var lineWidth = 9;
        routeStyles = {};
        routeStyles[tf.consts.routingServiceModeFoot] = { style: createRouteStyle(lineWidth, "round", [1, lineWidth + 1], 1) };
        routeStyles[tf.consts.routingServiceModeBicycle] = { style: createRouteStyle(lineWidth, "butt", [lineWidth / 2, lineWidth / 5], 1) };
        routeStyles[tf.consts.routingServiceModeCar] = { style: createRouteStyle(lineWidth - 2, "square", [lineWidth, lineWidth * 1.2, lineWidth / 2, lineWidth * 1.2], 1) };
        routeStyles[tf.consts.routingServiceModeBus] = { style: createRouteStyle(lineWidth / 2, "butt", [lineWidth / 2, lineWidth / 3], 1) };
    }
    function showResults() {
        if (instructionsAndRoute != undefined) { directionsResultsContent.Update(startAddress, endAddress, instructionsAndRoute); }
        directionsResultsContent.Show(true);
    }
    function onInstructionsAndRouteSuccess() {
        routingErrorMsg = undefined;
        totalDistanceMeters = instructionsAndRoute.total_distance;
        totalTimeSeconds = instructionsAndRoute.total_time;
        settings.layer.AddMapFeature(routeFeature);
        mapFeatures.push(instructionsAndRoute.routeFeature);
        setState("searchOK");
    }
    function onRouted(notification) {
        if (!!lastRouting) {
            if (lastRouting == notification.sender) {
                lastRouting = undefined;
                if (!notification.sender.WasCancelled()) {
                    var searchedOK = false;
                    if (!!notification && notification.requestProps.routingCount == routingCount) {
                        instructionsAndRoute = getInstructionsAndRoute(notification, 0);
                        if (instructionsAndRoute.success) {
                            lastInstructionsAndRoute = instructionsAndRoute;
                            lastModeOfTransportation = modeOfTransportation;
                            onInstructionsAndRouteSuccess();
                            searchedOK = true;
                        }
                        else {
                            lastInstructionsAndRoute = undefined;
                        }
                    }
                    if (!searchedOK) { setState("searchError"); }
                }
            }
        }
    }
    function getMapFeatureToolTip(toolTipProps) {
        var mapFeature = toolTipProps.mapFeature;
        var toolTipText;
        var dragToChangeStr = "drag to change";
        var ls = tf.TFMap.LayoutSettings;
        var spanStart = "<span class='" + ls.defaultHorMarginsClassName + "'>";
        switch (mapFeature) {
            case startMapFeature:
                toolTipText = tf.TFMap.MapTwoLineSpan(tf.TFMap.StartLocationName, dragToChangeStr);
                break;
            case endMapFeature:
                if (canSearch) {
                    toolTipText = spanStart + tf.TFMap.UserFriendlyModeVerbs[modeOfTransportation] + '</span><br />';
                    toolTipText += spanStart + tf.js.ConvertToHourMinute2(totalTimeSeconds);
                    toolTipText += ' (' + tf.TFMap.GetDirectionsDistanceText(totalDistanceMeters, settings.appContent.GetMap().GetIsUSScaleUnits()) + ')</span>';
                    toolTipText = toolTipText + tf.TFMap.MakeHRDivHTML() + spanStart + "drag to change" + '</span>';
                }
                else {
                    toolTipText = tf.TFMap.MapTwoLineSpan(tf.TFMap.EndLocationName, dragToChangeStr);
                }
                break;
        }
        return toolTipText;
    }
    function onTransitPlanPostRefresh() {
        if (!!lastRouting) {
            if (lastRouting == transitPlanService) {
                lastRouting = undefined;
                lastInstructionsAndRoute = undefined;
                instructionsAndRoute = transitPlanService.GetInstructionsAndRouteGeom();
                if (instructionsAndRoute.success) {
                    lastInstructionsAndRoute = instructionsAndRoute;
                    lastModeOfTransportation = modeOfTransportation;
                    routeFeature.SetGeom(instructionsAndRoute.routeGeom);
                    routeFeature.RefreshStyle();
                    onInstructionsAndRouteSuccess();
                }
                else { setState("searchError"); }
            }
        }
    }
    function callRouting(coords) {
        if (modeOfTransportation == tf.TFMap.directionModeBus) {
            //if (!transitPlanService) { transitPlanService = new tf.Transit.PlanService({ onPostRefresh: onTransitPlanPostRefresh }); }
            if (!transitPlanService) { transitPlanService = new tf.Transit.PlanService({ onFullDirectionsLoaded: onTransitPlanPostRefresh }); }
            if (!!transitPlanService) { (lastRouting = transitPlanService).GetPlan(coords[0], coords[coords.length - 1]); }
        }
        else {
            lastRouting = new tf.services.Routing({
                findAlternatives: false, level: 18, lineStringCoords: coords,
                mode: modeOfTransportation, optionalScope: theThis, instructions: true,
                callBack: onRouted, requestProps: { routingCount: ++routingCount }
            });
        }
    }
    var lastDirectionsSearchCoords, lastInstructionsAndRoute, lastModeOfTransportation;
    function doSearch(directionSearchCoords) {
        checkWayPointsLayerVisibility();
        routingErrorMsg = undefined;
        instructionsAndRoute = undefined;
        var nCoords = directionSearchCoords.length;
        if (nCoords > 0) {
            var newCoords = true;
            if (lastDirectionsSearchCoords != undefined && lastInstructionsAndRoute != undefined && lastModeOfTransportation == modeOfTransportation) {
                if (lastDirectionsSearchCoords.length == nCoords) {
                    newCoords = false;
                    for (var i = 0; i < nCoords && !newCoords; ++i) {
                        var directionSearchCoordCoords = directionSearchCoords[i];
                        var lastCoord = lastDirectionsSearchCoords[i];
                        newCoords = (directionSearchCoordCoords[0] != lastCoord[0] || directionSearchCoordCoords[1] != lastCoord[1]);
                    }
                }
            }
            if (newCoords) {
                hideRouteFeature();
                if (!!lastRouting) { lastRouting.Cancel(); }
                var coords = directionSearchCoords.slice(0);
                lastDirectionsSearchCoords = coords.slice(0);
                setState("searching");
                callRouting(coords);
                //setTimeout(function () { callRouting(coords); }, 500000000);
            }
            else {
                //console.log('skipped search');
                instructionsAndRoute = lastInstructionsAndRoute;
                onInstructionsAndRouteSuccess();
            }
        }
    }
    function addMapFeatures(featurePointCoords) {
        hideMapFeatures();
        var nCoords = featurePointCoords.length;
        if (nCoords > 0) {
            var layer = settings.pinLayer;
            for (var i = 0; i < nCoords; ++i) {
                var featurePointCoord = featurePointCoords[i];
                var isStart = featurePointCoord.isStart, isEnd = featurePointCoord.isEnd;
                var pointCoords = featurePointCoord.coords.slice(0);
                var mapFeature = isStart ? startMapFeature : endMapFeature;
                mapFeature.GetSettings().directionsAddressItem = isStart ? startAddress : endAddress;
                mapFeature.SetPointCoords(pointCoords);
                mapFeature.RefreshStyle();
                layer.AddMapFeature(mapFeature, true);
                mapFeatures.push(mapFeature);
            }
            layer.AddWithheldFeatures();
        }
    }
    function hideRouteFeature() {
        if (!instructionsAndRoute) {
            settings.layer.RemoveAllFeatures();
        }
    }
    function hideMapFeatures() {
        settings.wayPointsLayer.SetVisible(false);
        hideRouteFeature();
        if (mapFeatures.length > 0) {
            checkWayPointsLayerVisibility();
            settings.pinLayer.RemoveAllFeatures();
            mapFeatures = [];
        }
    }
    function showErrors(inErrorAddresses) {
        showErrorsWrapper(true);
        if (tf.js.GetIsNonEmptyString(routingErrorMsg)) {
            errorsContent.GetHTMLElement().innerHTML = routingErrorMsg;
        }
        else if (tf.js.GetIsNonEmptyArray(inErrorAddresses)) {
            var nErrors = inErrorAddresses.length;
            if (nErrors > 0) {
                var errorStr = "Sorry! We could not find map coordinates for:"
                for (var i = 0; i < nErrors; ++i) {
                    var addr = inErrorAddresses[i];
                    var placeHolder = addr.GetPlaceHolder();
                    var addressStr = addr.GetInputText();
                    errorStr += "<br><b>" + placeHolder + "</b>: <text>" + tf.TFMap.ReplaceHTML(addressStr) + "</text>";
                }
                errorStr += "<br>Please try a different address, or select a location on the map"
                errorsContent.GetHTMLElement().innerHTML = errorStr;
            }
        }
        else {
            console.log('unexpected error');
            errorsContent.GetHTMLElement().innerHTML = "unexpected error";
        }
    }
    function showHide(bool) { return !!bool ? show() : hide(); }
    function show() { if (!isVisible) { isVisible = true; setVisibleStyle(); } }
    function hide() { if (isVisible) { isVisible = false; setVisibleStyle(); } }
    function setVisibleStyle() { setWrapperVisibleClass(wrapper, isVisible); }
    function showSearchingWrapper(bool) { setWrapperVisibleClass(searchingWrapper, bool); }
    function showErrorsWrapper(bool) { setWrapperVisibleClass(errorsWrapper, bool); }
    function setWrapperVisibleClass(theWrapper, isVisibleBool) {
        var classNameVisible = settings.itemVisibleClassName, classNameHidden = settings.itemHiddenClassName;
        tf.dom.ReplaceCSSClassCondition(theWrapper, isVisibleBool, classNameVisible, classNameHidden);
    }
    function getMapFeatureStyle(imageUse, imageSizeUse, radiusMaxUse, colorFillUse) {
        var appStyles = settings.appContent.GetAppStyles();
        return appStyles.GetSVGMapMarkerWithFrameGeom([0, 0], imageUse, imageSizeUse, radiusMaxUse, colorFillUse, [0.5, 1]);
    }
    function setMapFeatureToolTipProps(mapFeature, toolTipText) {
        var toolTipProps = { toolTipText: toolTipText, keepOnHoverOutTarget: false, offsetX: 24 };
        tf.TFMap.SetMapFeatureToolTipProps(mapFeature, toolTipProps);
        return mapFeature;
    }
    function createFeatures() {
        var appContent = settings.appContent;
        var appStyles = appContent.GetAppStyles();
        var imgMult = tf.TFMap.DirectionsFeatureDimMult;
        var imageSizeUse = [20 * imgMult, 30 * imgMult], iconAnchor = [0.5, 1], startZIndex = 4;
        startMapFeature = new tf.map.Feature(appStyles.GetSVGMapMarkerGeomAndStyles(undefined, appStyles.GetFromImage(), imageSizeUse, iconAnchor, 0, startZIndex++));
        setMapFeatureToolTipProps(startMapFeature, getMapFeatureToolTip);
        endMapFeature = new tf.map.Feature(appStyles.GetSVGMapMarkerGeomAndStyles(undefined, appStyles.GetToImage(), imageSizeUse, iconAnchor, 0, startZIndex++));
        setMapFeatureToolTipProps(endMapFeature, getMapFeatureToolTip);
        var routeGeom = { type: 'linestring', coordinates: [[0, 0], [0, 0]], style: getRouteStyle, hoverStyle: getRouteStyle };
        routeFeature = new tf.map.Feature(routeGeom);
        routeFeature.GetSettings().isDirectionRoute = true;
    }
    function createControl() {
        wrapper = new tf.dom.Div({ cssClass: wrapperClassName });
        errorsWrapper = new tf.dom.Div({ cssClass: errorsWrapperClassName });
        errorsContent = new tf.dom.Div({ cssClass: errorsContentClassName });
        errorsWrapper.AddContent(errorsContent);
        searchingWrapper = new tf.dom.Div({ cssClass: searchingWrapperClassName });
        searchingContent = new tf.dom.Div({ cssClass: searchingContentClassName });
        searchingContent.GetHTMLElement().innerHTML = "<div class='" + searchingIconClassName + "'></div>Searching...";
        searchingWrapper.AddContent(searchingContent);
        directionsResultsContent = new tf.TFMap.DirectionsResultsContent(settings);
        wrapper.AddContent(errorsWrapper, searchingWrapper, directionsResultsContent.GetWrapper());
        showErrorsWrapper(false);
        setVisibleStyle();
    }
    var cssTag, wrapperClassName, errorsWrapperClassName, errorsContentClassName, searchingWrapperClassName, searchingContentClassName, searchingIconClassName;
    function createCSSClassNames() {
        wrapperClassName = tf.TFMap.CreateClassName(cssTag, "Wrapper");
        errorsWrapperClassName = tf.TFMap.CreateClassName(cssTag, "ErrorsWrapper");
        errorsContentClassName = tf.TFMap.CreateClassName(cssTag, "ErrorsContent");
        searchingWrapperClassName = tf.TFMap.CreateClassName(cssTag, "SearchingWrapper");
        searchingContentClassName = tf.TFMap.CreateClassName(cssTag, "SearchingContent");
        searchingIconClassName = tf.TFMap.CreateClassName(cssTag, "SearchingIcon");
    }
    function createCSSClasses() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var cssClasses = [];
        var layoutSettings = tf.TFMap.LayoutSettings;
        var backgroundLivelyStyle = { backgroundColor: layoutSettings.backgroundLivelyColor };
        cssClasses[wrapperClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, /*backgroundLivelyStyle, */CSSClasses.overflowVisible], background: 'transparent'
        };
        cssClasses[errorsWrapperClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, backgroundLivelyStyle, CSSClasses.overflowVisible, CSSClasses.positionRelative],
            color: 'black', background: 'beige', fontSize: "0.8rem", lineHeight: "1.2rem"
        };
        cssClasses[errorsContentClassName] = { inherits: [CSSClasses.overflowVisible, CSSClasses.positionRelative], padding: "8px" };
        cssClasses[searchingWrapperClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, backgroundLivelyStyle, CSSClasses.overflowVisible, CSSClasses.positionRelative],
            color: 'black', background: 'white', fontSize: "14px", lineHeight: "20px"
        };
        cssClasses[searchingContentClassName] = { inherits: [CSSClasses.overflowVisible, CSSClasses.positionRelative], height: "20px", padding: "8px" };
        cssClasses[searchingIconClassName] = { inherits: [CSSClasses.loadingBackgroundTransparent, CSSClasses.displayInlineBlock], verticalAlign: "top", width: "20px", height: "20px", marginRight: "6px" };
        return cssClasses;
    }
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function onLayoutChange(notification) { registerCSSClasses(); }
    function initialize() {
        onFoundOutCanSearchCB = tf.js.GetFunctionOrNull(settings.onFoundOutCanSearch);
        delayedShowSearching = new tf.events.DelayedCallBack(tf.TFMap.DelayShowSearching, doShowSearching, theThis);
        currentState = "idle";
        delayedCheckCanSearch = new tf.events.DelayedCallBack(tf.TFMap.DelayDirections, doCheckCanSearch, theThis);
        modeOfTransportation = tf.js.GetNonEmptyString(settings.modeOfTransportation, tf.consts.routingServiceModeCar);
        createRouteStyles();
        totalDistanceMeters = totalTimeSeconds = 0;
        routingCount = 0;
        mapFeatures = [];
        featurePointCoords = [];
        canSearch = hasAddressErrors = isVisible = false;
        cssTag = 'directionsResults';
        createCSSClassNames();
        registerCSSClasses();
        createControl();
        createFeatures();
        settings.appContent.GetAppStyles().AddOnLayoutChangeListener(onLayoutChange);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: directionspanel.js
tf.TFMap.DirectionsPanel = function(settings) {
    var theThis, wrapper, isShowing, caption, backButton, closeButton, driveButton, walkButton, bikeButton, busButton, currentMode, modeButtons, switchStartEndButton;
    var wayPointAddressesWrapper;
    var disclaimerWrapper;
    var startAddress, endAddress;
    var canSearch;
    var directionsResults;
    var contentWrapper;
    var contentBotWrapper;
    var contentBotWrapperFadeTop, contentBotWrapperFadeBot;
    var wayPoints, wayPointMapFeatures;
    var pushedDirections;
    this.PushDirections = function (directionSettings) {
        if (currentMode == tf.TFMap.directionModeBus) {
            var appContent = settings.appContent, map = appContent.GetMap();
            pushedDirections = {
                fromCoords: startAddress.GetValue().coords,
                toCoords: endAddress.GetValue().coords,
                mode: tf.TFMap.directionModeBus,
                center: map.GetCenter(),
                res: map.GetResolution()
            };
            setDirections(directionSettings);
        }
    }
    function setDirections(directionSettings) {
        var appContent = settings.appContent;
        clearWayPoints();
        appContent.GetAppCtx().SetCtxAttribute(tf.TFMap.CAN_directionsMode, directionSettings.mode);
        setSelectedMode();
        setAddressItemCoords(startAddress, directionSettings.fromCoords);
        setAddressItemCoords(endAddress, directionSettings.toCoords);
        if (!!directionSettings.center) {
            var map = appContent.GetMap();
            map.SetCenter(directionSettings.center);
            map.SetResolution(directionSettings.res);
        }
    }
    function backToBusDirections() {
        if (!!pushedDirections) {
            var pd = pushedDirections;
            pushedDirections = undefined;
            setDirections(pd);
        }
    }
    this.SetAutoSetNextExtent = function () { directionsResults.SetAutoSetNextExtent(); }
    this.GetRouteCoordinates = function() {
        return directionsResults.GetRouteCoordinates();
    }
    this.GetCanAddWayPoint = function() {
        return canSearch && wayPoints.length < tf.TFMap.MaxDirectionsWayPoints && currentMode != tf.TFMap.directionModeBus;
    }
    this.DeleteWayPoint = function(mapFeature) {
        var nWayPoints = wayPointMapFeatures.length;
        for (var i = 0; i < nWayPoints; ++i) {
            if (wayPointMapFeatures[i] == mapFeature) {
                mapFeature.GetSettings().wayPointIndex = undefined;
                wayPoints.splice(i, 1);
                wayPointMapFeatures.splice(i, 1);
                break;
            }
        }
        renumWayPoints();
        checkCanSearch();
    }
    this.AddWayPoint = function(mapFeature) {
        if (theThis.GetCanAddWayPoint()) {
            var coordsAdd = mapFeature.GetPointCoords().slice(0);
            var nWayPoints = wayPoints.length;
            if (nWayPoints < 1) {
                wayPoints = [coordsAdd];
                wayPointMapFeatures = [mapFeature];
                checkCanSearch();
            }
            else {
                var routeCoordinates = theThis.GetRouteCoordinates();
                var hitTestAddWayPoint = tf.helpers.HitTestMapCoordinatesArray(routeCoordinates, coordsAdd, undefined, undefined, undefined);
                var indexAdd = nWayPoints;
                var wayPointHitTests = [];
                for (var i = 0; i < nWayPoints; ++i) {
                    var wpmf = wayPointMapFeatures[i];
                    wayPointHitTests.push(tf.helpers.HitTestMapCoordinatesArray(routeCoordinates, wpmf.GetPointCoords(), undefined, undefined, undefined));
                }
                wayPointHitTests.sort(function sortWayPoints(a, b) {
                    if (a.minDistanceIndex < b.minDistanceIndex) { return -1; }
                    else if (a.minDistanceIndex > b.minDistanceIndex) { return 1; }
                    else if (a.proj < b.proj) { return -1; }
                    else if (a.proj < b.proj) { return 1; }
                    return 0;
                });
                for (var i = 0; i < nWayPoints; ++i) {
                    var htwp = wayPointHitTests[i];
                    if (htwp.minDistanceIndex > hitTestAddWayPoint.minDistanceIndex ||
                        (htwp.minDistanceIndex == hitTestAddWayPoint.minDistanceIndex && htwp.proj > hitTestAddWayPoint.proj)) {
                        indexAdd = i;
                        break;
                    }
                }
                wayPoints.splice(indexAdd, 0, coordsAdd);
                wayPointMapFeatures.splice(indexAdd, 0, mapFeature);
            }
            renumWayPoints();
        }
    }
    this.OnWayPointChangedCoords = function(mapFeature) {
        for (var i in wayPointMapFeatures) {
            if (wayPointMapFeatures[i] == mapFeature) {
                wayPoints[i] = mapFeature.GetPointCoords().slice(0);
                checkCanSearch();
                break;
            }
        }
    }
    this.OnResize = function() { return directionsResults.OnResize(); }
    this.OnAddressMapFeatureChangedCoords = function(directionsAddressItem, pointCoords) {
        if (directionsAddressItem == startAddress || directionsAddressItem == endAddress) {
            setAddressItemCoords(directionsAddressItem, pointCoords);
        }
    }
    this.SelectAddressItem = function(directionsAddressItem) {
        settings.appContent.EnsureDirectionsVisible();
        directionsAddressItem.SetSelected();
    }
    this.SelectResultItem = function(directionsResultsItem) {
        settings.appContent.EnsureDirectionsVisible();
        return directionsResults.SelectResultItem(directionsResultsItem);
    }
    this.UpdateDistances = function() { return directionsResults.UpdateDistances(); }
    this.GetWrapper = function() { return wrapper; }
    this.GetNeedsAddress = function() {
        return !startAddress.GetHasInputText() || !endAddress.GetHasInputText();
    }
    this.SetDirectionsTargetToCoords = function(pointCoords, forceEnd, skipEnsureVisible) {
        var appContent = settings.appContent, appCtx = appContent.GetAppCtx();
        if (!skipEnsureVisible) { appContent.EnsureDirectionsVisible(); }
        if (!hasCoords(pointCoords)) {
            var addressSet = (!!forceEnd || (startAddress.GetIsValid() || startAddress.GetHasInputText())) ? endAddress : startAddress;
            clearWayPoints();
            setAddressItemCoords(addressSet, pointCoords);
            if (!skipEnsureVisible) { appContent.MakeSureMapCoordsAreVisible(pointCoords); }
        }
    }
    this.UpdateVisibility = function() {
        var shouldBeVisible = theThis.GetShouldBeVisible();
        if (isShowing != shouldBeVisible) {
            var ls = tf.TFMap.LayoutSettings;
            tf.dom.ReplaceCSSClassCondition(wrapper, isShowing = shouldBeVisible, ls.sidePanelWrapperVisibleClassName, ls.sidePanelWrapperCollapsedClassName);
        }
    }
    this.UpdateMode = function() {
        setSelectedMode();
    }
    this.GetShouldBeVisible = function() { return settings.appContent.GetAppCtx().GetCtxAttribute(tf.TFMap.CAN_showingDirections); }
    function renumWayPoints() {
        var nWayPoints = wayPointMapFeatures.length;
        for (var i = 0; i < nWayPoints; ++i) {
            var wayPointMapFeature = wayPointMapFeatures[i];
            wayPointMapFeature.GetSettings().wayPointIndex = i;
            wayPointMapFeature.RefreshStyle();
        }
    }
    function clearWayPoints() {
        wayPoints = [];
        wayPointMapFeatures = [];
        settings.appContent.OnDirectionWayPointsDiscarded();
    }
    function setAddressItemCoords(addressSet, pointCoords) {
        var addressStr = pointCoords[1].toFixed(5) + ", " + pointCoords[0].toFixed(5);
        addressSet.SetValue({ address: addressStr, coords: pointCoords });
        addressSet.RevGeocode();
        checkCanSearch();
    }
    function hasCoords(coords) {
        return startAddress.GetHasCoords(coords) || endAddress.GetHasCoords(coords);
    }
    function switchStartEnd() {
        var value = startAddress.GetValueForSwap();
        startAddress.SetValueForSwap(endAddress.GetValueForSwap());
        endAddress.SetValueForSwap(value);
        checkCanSearch();
    }
    function onButtonClicked(notification) {
        var button = !!notification.toolTipSender ? notification.toolTipSender : notification.sender;
        var modeVerb;
        switch (button) {
            case switchStartEndButton:
                switchStartEnd();
                break;
            case backButton:
                backToBusDirections();
                break;
            case closeButton:
                settings.appContent.GetAppCtx().SetCtxAttribute(tf.TFMap.CAN_showingDirections, false);
                break;
            default:
                if ((modeVerb = button.GetSettings().modeVerb) != undefined) {
                    settings.appContent.GetAppCtx().SetCtxAttribute(tf.TFMap.CAN_directionsMode, modeVerb);
                }
                break;
        }
    }
    function createSVGButton(buttonSettings, svgHTML, buttonClass, toolTipText, svgAddClasses, modeVerb) {
        var button = settings.appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, {
            svgHTML: svgHTML,
            buttonClass: buttonClass + " rippleWhite", toolTipText: toolTipText
        }));
        button.GetSettings().modeVerb = modeVerb;
        var buttonSVG = button.GetButton().firstChild;
        if (svgAddClasses != undefined) { tf.dom.AddCSSClass(buttonSVG, svgAddClasses); }
        return button;
    }
    function setSelectedMode() {
        var selMode = settings.appContent.GetAppCtx().GetCtxAttribute(tf.TFMap.CAN_directionsMode);
        if (selMode != currentMode) {
            currentMode = selMode;
            for (var i in modeButtons) {
                var modeButton = modeButtons[i], buttonMode = modeButton.GetSettings().modeVerb;
                tf.dom.ReplaceCSSClassCondition(modeButton.GetButton(), buttonMode == currentMode, captionButtonSelectedClassName, captionButtonUnSelectedClassName);
            }
            directionsResults.SetModeOfTransportation(selMode);
        }
        var backButtonDisplayStr = (!!pushedDirections) ? "inline-block" : "none";
        backButton.GetButton().style.display = backButtonDisplayStr;
    }
    function onAddressInputChange(notification) { checkCanSearch(); }
    function onAddressInputSearch(notification) {
        var address = notification.sender;
        if (!address.GetIsValid()) {
            address.Geocode();
        }
    }
    function checkCanSearch() {
        canSearch = startAddress.GetIsValid() && endAddress.GetIsValid();
        //console.log('can search ' + canSearch);
        directionsResults.CheckCanSearch(startAddress, endAddress, wayPoints);
        showDisclaimer();
    }
    function onFoundOutCanSearch(notification) {
        showDisclaimer();
    }
    function showDisclaimer() {
        var disclaimerVisible = directionsResults.GetCanSearch();
        var ls = tf.TFMap.LayoutSettings;
        tf.dom.ReplaceCSSClassCondition(disclaimerWrapper, disclaimerVisible, disclaimerWrapperVisibleClassName, disclaimerWrapperHiddenClassName);
        tf.dom.ReplaceCSSClassCondition(contentWrapper, disclaimerVisible, contentWithDisclaimerClassName, ls.sidePaneFullHeightContentWrapperClassName);
    }
    function createWayPointAddress(placeHolder, mapFeatureIcon) {
        return new tf.TFMap.DirectionsAddress({
            itemVisibleClassName: itemVisibleClassName, itemHiddenClassName: itemHiddenClassName,
            placeHolder: placeHolder, appContent: settings.appContent, onInputChange: onAddressInputChange,
            onGo: onAddressInputSearch, mapFeatureIcon: mapFeatureIcon
        });
    }
    function getSelModeFromContext() { return settings.appContent.GetAppCtx().GetCtxAttribute(tf.TFMap.CAN_directionsMode); }
    function createControl() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles();
        var ls = tf.TFMap.LayoutSettings;
        var customizedScrollBarClassName = ls.customizedScrollBarClassName;
        var useBusDirections = !!settings.useBusDirections;
        wrapper = new tf.dom.Div({ cssClass: ls.sidePanelWrapperClassName });
        contentWrapper = new tf.dom.Div({ cssClass: ls.sidePanelContentWrapperClassName });
        caption = new tf.dom.Div({ cssClass: captionClassName });
        var delayMillis = 0;
        var toolTipClass = "*end";
        var toolTipArrowClass = "top";
        var buttonSettings = {
            offsetY: 0, onClick: onButtonClicked, onHover: undefined, wrapper: caption, delayMillis: delayMillis, toolTipClass: toolTipClass, toolTipArrowClass: toolTipArrowClass
        };
        var directionsCaptionToolBar = new tf.dom.Div({ cssClass: captionToolBarClassName });
        backButton = createSVGButton(buttonSettings,
            appStyles.GetArrowLeftSVGNoColor(), modeButtonClassName + " " + captionButtonUnSelectedClassName, "Back to bus directions", modesSVGsClassName);
        driveButton = createSVGButton(buttonSettings, appContent.GetAppStyles().GetCarSVG(),
            modeButtonClassName, tf.TFMap.UserFriendlyModeVerbs[tf.TFMap.directionModeDrive],
            modesSVGsClassName, tf.TFMap.directionModeDrive);
        walkButton = createSVGButton(buttonSettings, appContent.GetAppStyles().GetWalkSVG(),
            modeButtonClassName, tf.TFMap.UserFriendlyModeVerbs[tf.TFMap.directionModeWalk],
            modesSVGsClassName, tf.TFMap.directionModeWalk);
        bikeButton = createSVGButton(buttonSettings, appContent.GetAppStyles().GetBikeSVG(),
            modeButtonClassName, tf.TFMap.UserFriendlyModeVerbs[tf.TFMap.directionModeBike],
            modesSVGsClassName, tf.TFMap.directionModeBike);
        modeButtons = [driveButton, walkButton, bikeButton];
        if (useBusDirections) {
            busButton = createSVGButton(buttonSettings, appContent.GetAppStyles().GetBusSVG(),
                modeButtonClassName, tf.TFMap.UserFriendlyModeVerbs[tf.TFMap.directionModeBus],
                modesSVGsClassName, tf.TFMap.directionModeBus);
            modeButtons.push(busButton);
        }
        buttonSettings.toolTipClass = "*start";
        closeButton = createSVGButton(tf.js.ShallowMerge(buttonSettings, { wrapper: contentWrapper }),
            appStyles.GetXMarkSVG(), ls.sidePanelCloseButtonClassName, "Close directions", undefined);
        directionsCaptionToolBar.AddContent(backButton.GetButton(), driveButton.GetButton(), walkButton.GetButton(), bikeButton.GetButton());
        if (useBusDirections) { directionsCaptionToolBar.AddContent(busButton.GetButton()); }
        caption.AddContent(directionsCaptionToolBar);
        var allWayPointAddressesWrapper = new tf.dom.Div({ cssClass: allWayPointAddressesWrapperClassName });
        startAddress = createWayPointAddress(tf.TFMap.StartLocationName, appStyles.GetFromImage());
        endAddress = createWayPointAddress(tf.TFMap.EndLocationName, appStyles.GetToImage());
        allWayPointAddressesWrapper.AddContent(startAddress.GetWrapper(), endAddress.GetWrapper());
        var switchStartEndWrapper = new tf.dom.Div({ cssClass: switchStartEndWrapperClassName });
        buttonSettings.delayMillis = tf.TFMap.toolTipDelayMillis;
        buttonSettings.offsetX = -10;
        buttonSettings.wrapper = switchStartEndWrapper;
        buttonSettings.toolTipClass = "end";
        buttonSettings.toolTipArrowClass = "right";
        switchStartEndButton = createSVGButton(buttonSettings, appContent.GetAppStyles().GetUpDownArrowSVG(),
            directionsButtonBaseClassName + " " + switchStartEndButtonClassName,
            "Reverse " + tf.TFMap.StartLocationName + " and " + tf.TFMap.EndLocationName,
            switchStartEndSVGsClassName);
        switchStartEndWrapper.AddContent(switchStartEndButton.GetButton());
        disclaimerWrapper = new tf.dom.Div({ cssClass: disclaimerWrapperClassName });
        var disclaimerContent = new tf.dom.Div({ cssClass: disclaimerContentClassName });
        var disclaimerStr = "Use TerraFly directions as a trip planning aid; you are responsible for observing applicable laws and local ordinances at all times."
        disclaimerContent.GetHTMLElement().innerHTML = disclaimerStr;
        disclaimerWrapper.AddContent(disclaimerContent);
        var contentTopWrapper = new tf.dom.Div({ cssClass: ls.sidePaneContentFixedHeightClassName });
        contentBotWrapper = new tf.dom.Div({ cssClass: ls.sidePaneContentVariableHeightClassName + " " + customizedScrollBarClassName });
        contentBotWrapperFadeTop = new tf.dom.Div({ cssClass: contentBotFadeTopClassName + " " + itemHiddenClassName });
        contentBotWrapperFadeBot = new tf.dom.Div({ cssClass: contentBotFadeBotClassName + " " + itemHiddenClassName });
        directionsResults = new tf.TFMap.DirectionsResults({
            onFoundOutCanSearch: onFoundOutCanSearch,
            appContent: settings.appContent, layer: settings.layer, pinLayer: settings.pinLayer, itemsLayer: settings.itemsLayer, modeOfTransportation: getSelModeFromContext(),
            wayPointsLayer: settings.wayPointsLayer,
            scrollerWrapper: contentBotWrapper,
            itemVisibleClassName: itemVisibleClassName, itemHiddenClassName: itemHiddenClassName,
            contentBotWrapperFadeTop: contentBotWrapperFadeTop, contentBotWrapperFadeBot: contentBotWrapperFadeBot
        });
        showDisclaimer();
        contentTopWrapper.AddContent(caption, allWayPointAddressesWrapper, switchStartEndWrapper, contentBotWrapperFadeTop);
        contentBotWrapper.AddContent(directionsResults.GetWrapper());
        contentWrapper.AddContent(closeButton.GetButton(), contentTopWrapper, contentBotWrapper);
        contentWrapper.AddContent(contentBotWrapperFadeBot);
        wrapper.AddContent(contentWrapper, disclaimerWrapper);
        setSelectedMode();
    }
    var cssTag, captionClassName, captionToolBarClassName, modesSVGsClassName,
        captionButtonSelectedClassName, captionButtonUnSelectedClassName, modeButtonClassName, allWayPointAddressesWrapperClassName, wayPointAddressWrapperClassName,
        directionsButtonBaseClassName, switchStartEndWrapperClassName, switchStartEndSVGsClassName, switchStartEndButtonClassName,
        disclaimerWrapperClassName, disclaimerWrapperVisibleClassName, disclaimerWrapperHiddenClassName, disclaimerContentClassName, contentWithDisclaimerClassName,
        itemVisibleClassName, itemHiddenClassName,
        contentBotFadeTopClassName, contentBotFadeBotClassName;
    function createCSSClassNames() {
        itemVisibleClassName = tf.TFMap.CreateClassName(cssTag, "ItemVisible");
        itemHiddenClassName = tf.TFMap.CreateClassName(cssTag, "ItemHidden");
        captionClassName = tf.TFMap.CreateClassName(cssTag, "Caption");
        captionToolBarClassName = tf.TFMap.CreateClassName(cssTag, "CaptionToolBar");
        modesSVGsClassName = tf.TFMap.CreateClassName(cssTag, "ModeSVGs");
        captionButtonSelectedClassName = tf.TFMap.CreateClassName(cssTag, "CBSelected");
        captionButtonUnSelectedClassName = tf.TFMap.CreateClassName(cssTag, "CBUnselected");
        modeButtonClassName = tf.TFMap.CreateClassName(cssTag, "ModeButton");
        allWayPointAddressesWrapperClassName = tf.TFMap.CreateClassName(cssTag, "AllWayPointAddressesWrapper");
        directionsButtonBaseClassName = tf.TFMap.CreateClassName(cssTag, "DirectionsButtonBase");
        switchStartEndWrapperClassName = tf.TFMap.CreateClassName(cssTag, "SwitchStartEndWrapper");
        switchStartEndButtonClassName = tf.TFMap.CreateClassName(cssTag, "SwitchStartEndButton");
        switchStartEndSVGsClassName = tf.TFMap.CreateClassName(cssTag, "SwitchStartEndSVGs");
        disclaimerWrapperClassName = tf.TFMap.CreateClassName(cssTag, "DisclaimerWrapper");
        disclaimerWrapperVisibleClassName = tf.TFMap.CreateClassName(cssTag, "DisclaimerWrapperVisible");
        disclaimerWrapperHiddenClassName = tf.TFMap.CreateClassName(cssTag, "DisclaimerWrapperHidden");
        contentWithDisclaimerClassName = tf.TFMap.CreateClassName(cssTag, "ContentWithDisclaimer");
        disclaimerContentClassName = tf.TFMap.CreateClassName(cssTag, "DisclaimerContent");
        contentBotFadeTopClassName = tf.TFMap.CreateClassName(cssTag, "ContentBotFadeTop");
        contentBotFadeBotClassName = tf.TFMap.CreateClassName(cssTag, "ContentBotFadeBot");
    }
    function createCSSClasses() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var cssClasses = [];
        var ls = tf.TFMap.LayoutSettings;
        var darkTextColor = ls.darkTextColor, darkTextShadow = ls.darkTextShadow;
        var sidePanelWidthInt = ls.sidePanelWidthInt, sidePaneWidthPx = sidePanelWidthInt + 'px';
        var directionsCaptionPaddingTopInt = ls.directionsCaptionPaddingTopInt;
        var directionsCaptionPaddingBotInt = 2;
        var directionsCaptionPaddingTopPx = directionsCaptionPaddingTopInt + 'px';
        var directionsCaptionContentHeightInt = ls.directionsCaptionContentHeightInt;
        var directionsCaptionContentHeightPx = directionsCaptionContentHeightInt + 'px';
        var directionsCaptionHeightInt = directionsCaptionContentHeightInt + directionsCaptionPaddingTopInt + directionsCaptionPaddingBotInt;
        var directionsCaptionHeightPx = directionsCaptionHeightInt + 'px';
        var directionsCaptionBigContentHeightInt = directionsCaptionHeightInt - directionsCaptionPaddingBotInt;
        var directionsCaptionBigContentHeightPx = directionsCaptionBigContentHeightInt + 'px';
        var directionsCaptionSVGHeightInt = directionsCaptionBigContentHeightInt - 8;
        var directionsCaptionSVGHeightPx = directionsCaptionSVGHeightInt + 'px';
        var directionsCaptionToolBarPaddingLeft = 30;
        var directionsCaptionButtonSeparationInt = 24;
        var directionsCaptionButtonSeparationPx = directionsCaptionButtonSeparationInt + 'px';;
        var paddingDirectionsDisclaimerContentInt = 4;
        var paddingDirectionsDisclaimerContentPx = paddingDirectionsDisclaimerContentInt + 'px';
        var directionsDisclaimerContentSubDimFromPaddingInt = 2 * paddingDirectionsDisclaimerContentInt;
        var directionsDisclaimerContentSubDimFromPaddingPx = directionsDisclaimerContentSubDimFromPaddingInt + 'px';
        var directionsDisclaimerDimCalcStr = "calc(100% - " + directionsDisclaimerContentSubDimFromPaddingPx + ")";
        var directionsDisclaimerWrapperHeightInt = ls.directionsDisclaimerWrapperHeightInt, directionsDisclaimerWrapperHeightPx = directionsDisclaimerWrapperHeightInt + 'px';
        var directionsContentBotWrapperFadeHeightInt = ls.directionsContentBotWrapperFadeHeightInt;
        var backgroundLivelyStyle = { backgroundColor: ls.backgroundLivelyColor };
        cssClasses[itemVisibleClassName] = { inherits: [CSSClasses.displayBlock] };
        cssClasses[itemHiddenClassName] = { inherits: [CSSClasses.displayNone] };
        cssClasses[captionClassName] = {
            inherits: [CSSClasses.positionRelative, CSSClasses.noMarginNoBorderNoPadding, CSSClasses.WOneHundred, backgroundLivelyStyle,
                CSSClasses.displayFlex, CSSClasses.flexFlowRowNoWrap],
            paddingTop: (directionsCaptionPaddingTopInt / 2) + 'px',
            paddingBottom: (directionsCaptionPaddingTopInt / 2) + 'px',
            marginBottom: ls.directionsCaptionMarginBottomInt + "px",
            height: directionsCaptionHeightPx
        };
        cssClasses[captionToolBarClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.positionRelative],
            height: "100%", paddingLeft: (directionsCaptionToolBarPaddingLeft) + 'px'
        };
        cssClasses[modesSVGsClassName] = {
            width: directionsCaptionSVGHeightPx, height: directionsCaptionSVGHeightPx, fill: "rgba(255, 255, 255, 0.9)", stroke: "rgba(0, 0, 0, 0.3)", strokeWidth: "0.1px"
        };
        var captionButton = {
            inherits: [CSSClasses.transparentImageButton, CSSClasses.overflowHidden, CSSClasses.positionAbsolute, CSSClasses.displayBlock, CSSClasses.flexGrowZero],
            width: directionsCaptionContentHeightPx, height: directionsCaptionContentHeightPx
        };
        var bigCaptionButton = {
            stroke: "darkgray", strokeWidth: "0.2px", position: 'relative', display: 'inline-block',
            borderRadius: "50%", marginRight: directionsCaptionButtonSeparationPx,
            width: directionsCaptionBigContentHeightPx, height: directionsCaptionBigContentHeightPx
        };
        cssClasses[captionButtonSelectedClassName] = { backgroundColor: darkTextColor };
        cssClasses[captionButtonUnSelectedClassName] = { inherits: [CSSClasses.backgroundColorTransparent] };
        cssClasses[modeButtonClassName] = { inherits: [captionButton, bigCaptionButton] };
        cssClasses[allWayPointAddressesWrapperClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, backgroundLivelyStyle, CSSClasses.overflowVisible, CSSClasses.positionRelative], paddingBottom: '8px'
        };
        cssClasses[directionsButtonBaseClassName] = {
            inherits: [CSSClasses.transparentImageButton, CSSClasses.overflowHidden, CSSClasses.displayBlock],
            fill: "rgba(255,255,255,0.5)", background: 'transparent'
        };
        cssClasses[directionsButtonBaseClassName + ":hover"] = { fill: "white" };
        cssClasses[switchStartEndWrapperClassName] = {
            inherits: [CSSClasses.overflowVisible, CSSClasses.positionAbsolute, CSSClasses.noBorderNoPadding],
            background: 'transparent',
            top: ls.directionsSwitchStartEndTopInt + 'px',
            right: "4px", width: "40px", height: "40px"
        };
        cssClasses[switchStartEndButtonClassName] = { inherits: [CSSClasses.positionRelative], borderRadius: "50%", width: "40px", height: "40px" };
        cssClasses[switchStartEndSVGsClassName] = { width: "24px", height: "24px", strokeWidth: "0" };
        cssClasses[disclaimerWrapperClassName] = {
            inherits: [CSSClasses.positionAbsolute, CSSClasses.leftBotZero, CSSClasses.overflowHidden],
            height: directionsDisclaimerWrapperHeightPx, background: "white", width: "100%"
        };
        cssClasses[disclaimerWrapperVisibleClassName] = { inherits: [CSSClasses.displayFlex] };
        cssClasses[disclaimerWrapperHiddenClassName] = { inherits: [CSSClasses.displayNone] };
        cssClasses[contentWithDisclaimerClassName] = { height: "calc(100% - " + (directionsDisclaimerWrapperHeightInt) + "px)" };
        cssClasses[disclaimerContentClassName] = {
            inherits: [CSSClasses.cursorDefault, CSSClasses.displayBlock, CSSClasses.overflowHidden, CSSClasses.marginAuto],
            textOverflow: "ellipsis", padding: paddingDirectionsDisclaimerContentPx,
            textAlign: "center", width: directionsDisclaimerDimCalcStr,
            fontSize: ls.directionsDisclaimerFontSizeInt + "px",
            lineHeight: ls.directionsDisclaimerLineHeightInt + "px",
            //fontSize: "11px",
            //lineHeight: "normal",
            fontWeight: "300", color: "black"
        };
        var contentBotFadeCommon = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.pointerEventsNone, CSSClasses.positionAbsolute, CSSClasses.overflowVisible],
            left: "0px",
            zIndex: '' + (ls.rootDivZIndex + ls.listFadeWrapperZIndexAdd),
            width: "calc(100% - 18px)", paddingLeft: "6px", height: (directionsContentBotWrapperFadeHeightInt - 0) + 'px !important'
        };
        cssClasses[contentBotFadeTopClassName] = {
            inherits: [contentBotFadeCommon], bottom: "-" + directionsContentBotWrapperFadeHeightInt + "px",
            background: "linear-gradient(to bottom, " + "rgba(255,255,255,1)" + "," + "rgba(255,255,255,0)" + ")"
        };
        cssClasses[contentBotFadeBotClassName] = {
            inherits: [contentBotFadeCommon],
            bottom: "0px", background: "linear-gradient(to top, " + "rgba(255,255,255,1)" + "," + "rgba(255,255,255,0)" + ")"
        };
        return cssClasses;
    }
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function onLayoutChange(notification) { registerCSSClasses(); }
    function initialize() {
        cssTag = 'directionsPanel';
        wayPoints = [];
        wayPointMapFeatures = [];
        canSearch = false;
        isShowing = undefined;
        currentMode = undefined;
        createCSSClassNames();
        registerCSSClasses();
        createControl();
        theThis.UpdateVisibility();
        settings.appContent.GetAppStyles().AddOnLayoutChangeListener(onLayoutChange);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: overmapcanvas.js
tf.TFMap.OverMapCanvas = function(settings) {
    var theThis, cssTag, wrapper, canvas;
    var ocmTypeLine;
    var modified, nextId, features, nFeatures;
    var lastCenterDraw;
    this.Clear = function () {
        var ctx = canvas.getContext("2d");
        var sizeCanvas = getCheckCanvasSize();
        //ctx.strokeRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.clearRect(0, 0, sizeCanvas[0], sizeCanvas[1]);
        return sizeCanvas;
    }
    this.DrawCircle = function (center, radius, color) {
        var pixelRatio = tf.browser.GetDevicePixelRatio();
        var ctx = canvas.getContext("2d");
        ctx.save();
        ctx.beginPath();
        ctx.fillStyle = color;
        //ctx.strokeStyle = undefined;
        ctx.beginPath();
        ctx.arc(center[0] * pixelRatio, center[1] * pixelRatio, radius * pixelRatio, 0, 2 * Math.PI, false);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }
    this.GetIsModified = function() { return checkIsModified(); }
    this.Draw = function() { return draw(); }
    this.GetCount = function() { return nFeatures; }
    this.AddOMCLine = function(startCoord, endCoord, startPixelCoord) {
        var omcKey = getNextOMCKey();
        var omcLine = { key: omcKey, type: ocmTypeLine, startCoord: startCoord, endCoord: endCoord, startPixelCoord: startPixelCoord };
        features[omcKey] = omcLine;
        setModified();
        ++nFeatures;
        return omcLine;
    }
    this.DelOMCLine = function(omcLine) {
        if (tf.js.GetIsValidObject(omcLine)) {
            if (features[omcLine.key] != undefined) {
                --nFeatures;
                delete features[omcLine.key];
                setModified();
            }
        }
    }
    this.GetWrapper = function() { return wrapper; }
    function checkIsModified() {
        if (!modified) {
            if (nFeatures > 0) {
                var nowCenter = settings.appContent.GetMap().GetCenter();
                modified = lastCenterDraw == undefined || lastCenterDraw[0] != nowCenter[0] || lastCenterDraw[1] != nowCenter[1];
            }
        }
        return modified;
    }
    function clearModified() { modified = false; }
    function setModified() { modified = true; }
    function getNextOMCKey() { return '' + (nextId++); }
    function roundCoord(coord) { return [Math.round(coord[0]), Math.round(coord[1])]; }
    function drawLine(ctx, sizeCanvas, feature) {
        var appContent = settings.appContent, map = appContent.GetMap();
        var startPixelCoord = roundCoord(feature.startPixelCoord);
        var endPixelCoord = roundCoord(map.MapToPixelCoords(feature.endCoord));
        var lineWidth = 3;
        var radius = 10, radiusStart = lineWidth + 2;
        var lineDX = endPixelCoord[0] - startPixelCoord[0], lineDY = endPixelCoord[1] - startPixelCoord[1];
        var lineLen = Math.sqrt(lineDX * lineDX + lineDY * lineDY) - radius - 1;
        var newLineLen = lineLen - radius - 1;
        if (newLineLen < 0) { newLineLen = 0; }
        var lineRatio = newLineLen / lineLen;
        var lineEndCoords = roundCoord([startPixelCoord[0] + lineDX * lineRatio, startPixelCoord[1] + lineDY * lineRatio]);
        var theColor = tf.TFMap.LayoutSettings.backgroundLivelyColor;
        var pixelRatio = tf.browser.GetDevicePixelRatio();
        ctx.save();
        ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
        ctx.beginPath();
        ctx.strokeStyle = theColor;
        ctx.lineWidth = lineWidth;
        ctx.lineCap = "round";
        ctx.lineDashOffset = 0;
        //ctx.setLineDash([10, 10]);
        ctx.moveTo(startPixelCoord[0] * pixelRatio, startPixelCoord[1] * pixelRatio);
        ctx.lineTo(lineEndCoords[0] * pixelRatio, lineEndCoords[1] * pixelRatio);
        ctx.closePath();
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(endPixelCoord[0] * pixelRatio, endPixelCoord[1] * pixelRatio, radius * pixelRatio, 0, 2 * Math.PI, false);
        ctx.closePath();
        ctx.stroke();
        ctx.fill();
        ctx.beginPath();
        ctx.fillStyle = theColor;
        ctx.arc(startPixelCoord[0] * pixelRatio, startPixelCoord[1] * pixelRatio, radiusStart * pixelRatio, 0, 2 * Math.PI, false);
        ctx.closePath();
        ctx.stroke();
        ctx.fill();
        ctx.restore();
    }
    function getCheckCanvasSize() {
        var sizeCanvas = [Math.round(canvas.clientWidth), Math.round(canvas.clientHeight)];
        if (canvas.width != sizeCanvas[0] || canvas.height != sizeCanvas[1]) {
            canvas.width = sizeCanvas[0];
            canvas.height = sizeCanvas[1];
        }
        return sizeCanvas;
    }
    function draw() {
        if (modified || true) {
            lastCenterDraw = settings.appContent.GetMap().GetCenter();
            var sizeCanvas = theThis.Clear();
            var ctx = canvas.getContext("2d");
            for (var i in features) {
                var feature = features[i];
                switch (feature.type) {
                    case ocmTypeLine:
                        drawLine(ctx, sizeCanvas, feature);
                        break;
                    default:
                        break;
                }
            }
            //console.log('nFeatures: ' + nFeatures);
            clearModified();
        }
    }
    function createControl() {
        wrapper = new tf.dom.Div({ cssClass: wrapperClassName });
        canvas = document.createElement('canvas');
        canvas.className = canvasClassName;
        wrapper.AddContent(canvas);
    }
    var wrapperClassName, canvasClassName;
    function createCSSClassNames() {
        wrapperClassName = tf.TFMap.CreateClassName(cssTag, "Wrapper");
        canvasClassName = tf.TFMap.CreateClassName(cssTag, "Canvas");
    }
    function createCSSClasses() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var ls = tf.TFMap.LayoutSettings;
        var cssClasses = [];
        cssClasses[wrapperClassName] = {
            inherits: [CSSClasses.displayBlock, CSSClasses.overflowHidden, CSSClasses.backgroundColorTransparent, CSSClasses.cursorDefault, CSSClasses.noMarginNoBorderNoPadding,
            CSSClasses.positionAbsolute, CSSClasses.leftTopZero, CSSClasses.pointerEventsNone],
            zIndex: '' + (ls.rootDivZIndex + ls.overMapCanvasZIndexAdd),
            height: "100%", width: "100%"
        };
        cssClasses[canvasClassName] = {
            inherits: [CSSClasses.displayBlock, CSSClasses.overflowHidden, CSSClasses.backgroundColorTransparent, CSSClasses.cursorDefault, CSSClasses.noMarginNoBorderNoPadding,
            CSSClasses.positionAbsolute, CSSClasses.leftTopZero, CSSClasses.zIndex1],
            height: "100%", width: "100%"
        };
        return cssClasses;
    }
    /*function paintCanvas() {
        var ctx = canvas.getContext("2d");
        var sizeCanvas = [canvas.offsetWidth, canvas.offsetHeight];
        var radius = sizeCanvas[1] / 2;
        ctx.canvas.width = sizeCanvas[0];
        ctx.canvas.height = sizeCanvas[1];
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        //ctx.clearRect(0, 0, sizeCanvas[0], sizeCanvas[1]);
        ctx.fillStyle = "rgba(0,0,255,0.3)";
        ctx.strokeStyle = "rgba(0,0,255,1)";
        ctx.strokeWidth = 5;
        ctx.beginPath();
        ctx.arc(radius, radius, radius, 0, 2 * Math.PI, false);
        ctx.closePath();
        ctx.stroke();
        ctx.fill();
    }*/
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function onLayoutChange(notification) { registerCSSClasses(); }
    var lcl;
    function initialize() {
        cssTag = "overMapCanvas";
        ocmTypeLine = 'line';
        nFeatures = 0;
        modified = false;
        nextId = 1;
        features = {};
        createCSSClassNames();
        registerCSSClasses();
        createControl();
        lcl = settings.appContent.GetAppStyles().AddOnLayoutChangeListener(onLayoutChange);
        //setTimeout(function () { paintCanvas(); }, 1000);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: photodisplayer.js
tf.TFMap.PhotoDisplayer = function(settings) {
    var theThis, cssTag, isShowing, wrapper, contentWrapper, content, wheelListener, lastParentContainer, closeButton, clientOnClick, contentToolTipStr;
    var lastPhotoSettings;
    var zoom;
    var hasValidImage, imageDims;
    this.OnClose = function() { if (theThis.GetIsShowing()) { onClose(); } }
    this.GetWrapper = function() { return wrapper; }
    this.GetIsShowing = function() { return isShowing; }
    this.Show = function(parentContainer, photoSettings) {
        //setZoom(1);
        lastPhotoSettings = photoSettings;
        var contentButtonStyle = content.GetButton().style;
        if (!!(clientOnClick = tf.js.GetFunctionOrNull(photoSettings.onClick))) {
            contentButtonStyle.cursor = 'pointer';
            contentToolTipStr = photoSettings.toolTipText;
        }
        else {
            contentButtonStyle.cursor = 'default';
            contentToolTipStr = undefined;
        }
        var fileName = photoSettings.photoName;
        var wE = content.GetButton(), wES = wE.style;
        wE.innerHTML = "";
        wES.backgroundImage = "url(" + fileName + ")";
        setIsShowing(true, parentContainer);
        hasValidImage = false;
        tf.TFMap.ValidateImageOrDisplayMessage(fileName, content.GetButton(), checkIfStillCurrentImage);
    }
    this.Hide = function(parentContainer) {
        var wE = content.GetButton(), wES = wE.style;
        wES.background = undefined;
        setIsShowing(false, parentContainer);
    }
    function checkIfStillCurrentImage(imageSrc, messageContainer, optionalParam, theImage) {
        if (hasValidImage = theImage.GetIsValid()) { imageDims = theImage.GetDimensions(); }
        //console.log(imageDims);
        return isShowing && !!lastPhotoSettings && lastPhotoSettings.photoName == imageSrc;
    }
    /*function setZoom(newZoom) {
        var maxZoom = 8;
        if (newZoom < 1) { newZoom = 1; }
        else if (newZoom > maxZoom) { newZoom = maxZoom; }
        if (newZoom != zoom) {
            zoom = newZoom;
            var contentE = content.GetButton();
            contentE.style.width = contentE.style.height = newZoom + "00%";
        }
    }*/
    function onWheel(notification) {
        //console.log('on mouse wheel ' + cssTag + ' ' + (notification.isUp ? "UP" : "DOWN"));
        var mouseCoords = tf.events.GetMouseEventCoords(notification.event);
        var contentE = content.GetButton();
        console.log(mouseCoords);
        var contentRect = contentWrapper.GetHTMLElement().getBoundingClientRect();
        var percX = 1 - mouseCoords[0] / (contentRect.width + 1);
        var percY = 1 - mouseCoords[1] / (contentRect.height + 1);
        //contentE.style.marginLeft = mouseCoords[0] + 'px';
        //contentE.style.marginTop = mouseCoords[1] + 'px';
        //contentE.style.left = Math.floor(percX * 100) + '%';
        //contentE.style.top = Math.floor(percY * 100) + '%';
        var isUp = notification.isUp, sign = isUp ? 1 : -1;
        var newZoom = zoom + sign;
        //setZoom(newZoom);
    }
    function setIsShowing(showBool, parentContainer) {
        if (isShowing != (showBool = !!showBool)) {
            isShowing = showBool;
            var parentContainerUse = isShowing ? parentContainer : (parentContainer != undefined ? parentContainer : lastParentContainer);
            tf.dom.ReplaceCSSClassCondition(parentContainerUse, isShowing, visibleClassName, hiddenClassName);
            if (isShowing) {
                wrapper.GetHTMLElement().disabled = false;
                lastParentContainer = parentContainer;
            }
            else {
                wrapper.GetHTMLElement().disabled = true;
                lastParentContainer = undefined;
            }
        }
    }
    function onClose(notification) { theThis.Hide(); settings.appContent.OnPhotoDisplayHidden(); }
    function getPhotoToolTip() { return contentToolTipStr; }
    function onNextPrev(trueIfNext) {
        if (!!lastPhotoSettings) {
            if (!!lastPhotoSettings.photoListDisplayer) {
                lastPhotoSettings.photoListDisplayer.OnNextPrev(trueIfNext);
            }
        }
    }
    function onSeeRecord(notification) { if (!!clientOnClick) { clientOnClick({ sender: theThis, photoSettings: lastPhotoSettings }); } }
    function createControl() {
        var offsetY = 8;
        var dimCloseButton = "24px", appContent = settings.appContent, delayMillis = tf.TFMap.toolTipDelayMillis, toolTipClass = "center", toolTipArrowClass = "*right";
        wrapper = new tf.dom.Div({ cssClass: wrapperClassName });
        contentWrapper = new tf.dom.Div({ cssClass: contentWrapperClassName });
        var wrapperE = wrapper.GetHTMLElement();
        wrapperE.disabled = true;
        var buttonSettings = { wrapper: contentWrapper, delayMillis: delayMillis, toolTipClass: toolTipClass, toolTipArrowClass: toolTipArrowClass };
        content = appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, {
            offsetX: 4, buttonClass: contentClassName, toolTipText: getPhotoToolTip, onClick: onSeeRecord, wrapper: contentWrapper, keepOnHoverOutTarget: true
        }));
        var contentButton = content.GetButton();
        contentWrapper.AddContent(contentButton);
        buttonSettings.offsetX = 0; buttonSettings.wrapper = wrapper; buttonSettings.insertWrapper = wrapper;
        buttonSettings.toolTipClass = "end"; buttonSettings.toolTipArrowClass = "top";
        closeButton = appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, {
            offsetY: offsetY,
            svgHTML: appContent.GetAppStyles().GetXMarkSVG(),
            width: dimCloseButton, height: dimCloseButton,
            buttonClass: buttonsClassName + " " + closeClassName + " ripple", toolTipText: "Close viewer", onClick: onClose
        }));
        tf.dom.AddCSSClass(closeButton.GetButton().firstChild, buttonsSVGClassName);
        var prevButton = appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, {
            offsetY: offsetY,
            svgHTML: appContent.GetAppStyles().GetArrowLeftSVGNoColor(),
            width: dimCloseButton, height: dimCloseButton,
            buttonClass: buttonsClassName + " " + prevClassName + " ripple", toolTipText: "View previous photo", onClick: function() { onNextPrev(false); }
        }));
        tf.dom.AddCSSClass(prevButton.GetButton().firstChild, buttonsSVGClassName);
        var nextButton = appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, {
            offsetY: offsetY,
            svgHTML: appContent.GetAppStyles().GetArrowRightSVGNoColor(),
            width: dimCloseButton, height: dimCloseButton,
            buttonClass: buttonsClassName + " " + nextClassName + " ripple", toolTipText: "View next photo", onClick: function() { onNextPrev(true); }
        }));
        tf.dom.AddCSSClass(nextButton.GetButton().firstChild, buttonsSVGClassName);
        //wheelListener = new tf.events.DOMWheelListener({ target: contentWrapper/*content.GetButton()*/, callBack: onWheel, optionalScope: theThis });
        wrapper.AddContent(contentWrapper, closeButton.GetButton(), prevButton.GetButton(), nextButton.GetButton());
    }
    var wrapperClassName, hiddenClassName, visibleClassName, contentWrapperClassName, contentClassName, buttonsClassName, buttonsSVGClassName, closeClassName, prevClassName, nextClassName;
    function createCSSClassNames() {
        wrapperClassName = tf.TFMap.CreateClassName(cssTag, "Wrapper");
        hiddenClassName = tf.TFMap.CreateClassName(cssTag, "WrapperHidden");
        visibleClassName = tf.TFMap.CreateClassName(cssTag, "WrapperVisible");
        contentWrapperClassName = tf.TFMap.CreateClassName(cssTag, "ContentWrapper");
        contentClassName = tf.TFMap.CreateClassName(cssTag, "Content");
        buttonsClassName = tf.TFMap.CreateClassName(cssTag, "Buttons");
        closeClassName = tf.TFMap.CreateClassName(cssTag, "CloseButton");
        prevClassName = tf.TFMap.CreateClassName(cssTag, "PrevButton");
        nextClassName = tf.TFMap.CreateClassName(cssTag, "NextButton");
        buttonsSVGClassName = tf.TFMap.CreateClassName(cssTag, "ButtonSVG");
    }
    function createCSSClasses() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var ls = tf.TFMap.LayoutSettings;
        var bottomListHeight = ls.underBottomPaneHeightInt;
        var cssClasses = [];
        var dimButtonInt = 32, dimButtonPx = dimButtonInt + 'px';
        var svgMarginInt = 2, svgDims = dimButtonInt - 2 * svgMarginInt;
        var imgBkSizeVerb = "contain";
        //contentWrapperClassName, contentClassName, buttonsClassName, closeClassName, prevClassName, nextClassName
        cssClasses[wrapperClassName] = {
            inherits: [CSSClasses.transitionPoint2s, CSSClasses.displayBlock,
            //CSSClasses.overflowHidden,
            CSSClasses.overflowVisible,
            CSSClasses.cursorDefault, CSSClasses.pointerEventsNone,
            CSSClasses.noMarginNoBorderNoPadding, CSSClasses.positionAbsolute],
            top: "0px",
            zIndex: '' + (ls.rootDivZIndex + ls.photoDisplayerWrapperZIndexAdd),
            backgroundColor: "black", height: "100%"
        };
        cssClasses[hiddenClassName + " ." + wrapperClassName] = { left: "100%", width: "0px" };
        cssClasses[visibleClassName + " ." + wrapperClassName] = { left: '0px', width: "100%" };
        var imgDisplayer = {
            "-webkit-background-size": imgBkSizeVerb, "-moz-background-size": imgBkSizeVerb, "-o-background-size": imgBkSizeVerb, backgroundSize: imgBkSizeVerb,
            backgroundRepeat: "no-repeat", backgroundPosition: "center", backgroundColor: "black"//, backgroundAttachment: "fixed",
        };
        cssClasses[contentWrapperClassName] = {
            inherits: [CSSClasses.whiteSpaceNoWrap, CSSClasses.displayBlock,
            CSSClasses.pointerEventsAll,
            //CSSClasses.overflowHidden,
            CSSClasses.overflowVisible,
            CSSClasses.cursorPointer, CSSClasses.noMarginNoBorderNoPadding, CSSClasses.positionRelative],
            marginLeft: "0px", marginRight: "0px",
            zIndex: '' + (ls.rootDivZIndex + ls.photoDisplayerContentWrapperZIndexAdd),
            height: "calc(100% - " + (bottomListHeight + 2) + "px)",
            width: "100%"
        };
        cssClasses[contentClassName] = {
            inherits: [CSSClasses.whiteSpaceNoWrap, CSSClasses.displayBlock,
            CSSClasses.pointerEventsAll,
            //CSSClasses.overflowHidden,
            CSSClasses.overflowVisible,
            CSSClasses.cursorPointer, CSSClasses.noMarginNoBorderNoPadding, CSSClasses.positionAbsolute, CSSClasses.transitionBackground, imgDisplayer],
            color: "white", fontSize: "11px", left: "0px", top: "0px",
            zIndex: '' + (ls.rootDivZIndex + ls.photoDisplayerContentZIndexAdd),
            height: "100%", width: "100%"
        };
        cssClasses[buttonsClassName] = {
            inherits: [CSSClasses.positionAbsolute, CSSClasses.pointerEventsAll, CSSClasses.transparentImageButton,
                CSSClasses.displayFlex, CSSClasses.flexFlowRowNoWrap, CSSClasses.borderRadius2px],
            background: "darkblue", padding: "4px",
            zIndex: '' + (ls.rootDivZIndex + ls.photoDisplayerButtonZIndexAdd),
            width: dimButtonPx, height: dimButtonPx, top: "8px"
        };
        cssClasses[buttonsClassName + " svg"] = {
            fill: "white", stroke: "none"
        };
        cssClasses[buttonsClassName + ":hover"] = {
            background: "white"
        };
        cssClasses[buttonsClassName + ":hover svg"] = {
            fill: ls.darkTextColor, stroke: "none"
        };
        var buttonLeftInt = 8;
        cssClasses[closeClassName] = { left: buttonLeftInt + "px" };
        buttonLeftInt += dimButtonInt * 2 + 6;
        cssClasses[prevClassName] = { left: buttonLeftInt + "px" };
        buttonLeftInt += dimButtonInt + 6;
        cssClasses[nextClassName] = { left: buttonLeftInt + "px" };
        cssClasses[buttonsSVGClassName] = {
            inherits: [CSSClasses.flexGrowOne],
            width: "70%", height: "70%"/*,
            stroke: "white", strokeWidth: "6px"*/
        };
        return cssClasses;
    }
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function onLayoutChange(notification) { registerCSSClasses(); }
    var lcl;
    function initialize() {
        zoom = 1;
        cssTag = "photoDisplay";
        isShowing = undefined;
        createCSSClassNames();
        registerCSSClasses();
        createControl();
        lcl = settings.appContent.GetAppStyles().AddOnLayoutChangeListener(onLayoutChange);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: photolistdisplayer.js
tf.TFMap.PhotoListDisplayer = function(settings) {
    var theThis, cssTag, wrapper, content, itemToolBar, selectRecordButton, wheelListener, buttonSettings, imageItemsCache;
    var clickedItem;
    var clientOnClickCB, clientGetToolTipTextCB;
    var addSelItemPxInt;
    var lastPhotoList, photosToMapCoords, photosToolTips, photoTitles;
    var timerToolBarAttach, lineToPhoto;
    var buttonWithToolBar;
    this.OnNextPrev = function(trueIfNext) {
        if (!!clickedItem) {
            var button = clickedItem.button, buttonSettings = button.GetSettings(), index = buttonSettings.photoIndex;
            var buttons = imageItemsCache.GetObjects();
            var count = imageItemsCache.GetActiveCount();
            var inc = !!trueIfNext ? 1 : -1;
            var nextIndex = index + inc;
            if (nextIndex >= count) { nextIndex = 0; } else if (nextIndex < 0) { nextIndex = count - 1; }
            var newButton = buttons[nextIndex];
            onClickOrSelect(newButton.button, false);
        }
    }
    this.GetWrapper = function() { return wrapper; }
    this.GetLastPhotoList = function() { return lastPhotoList; }
    this.Update = function(photoList) {
        detachItemToolBar();
        content.ClearContent();
        imageItemsCache.Reset();
        clickedItem = undefined;
        buttonWithToolBar = undefined;
        var photoNamesA = photoList.GetPhotoNames(), nPhotoNames = photoNamesA.length;
        clientOnClickCB = tf.js.GetFunctionOrNull(photoList.GetOnClick());
        clientGetToolTipTextCB = tf.js.GetFunctionOrNull(photoList.GetToolTipText());
        lastPhotoList = photoList;
        photosToMapCoords = photoList.GetLastContentSettings().photosToMapCoords;
        photoTitles = photoList.GetLastContentSettings().photoTitles;
        if (!tf.js.GetIsArrayWithLength(photosToMapCoords, nPhotoNames)) { photosToMapCoords = undefined; }
        for (var i = 0; i < nPhotoNames; ++i) {
            var photoName = photoNamesA[i];
            var imageItem = getNextImageItemFromCache();
            var imageItemWrapper = imageItem.wrapper;
            var button = imageItem.button, buttonSettings = button.GetSettings();
            var buttonButton = button.GetButton();
            buttonSettings.photoName = photoName;
            buttonSettings.imageItem = imageItem;
            buttonSettings.photoIndex = i;
            var wE = tf.dom.GetHTMLElementFrom(imageItemWrapper), wES = wE.style;
            buttonButton.innerHTML = "";
            wES.background = tf.TFMap.LayoutSettings.backgroundLivelyColor + " url(" + photoName + ") center/100% no-repeat";
            content.AddContent(imageItemWrapper);
            tf.TFMap.ValidateImageOrDisplayMessage(photoName, buttonButton, function(invalidPhotoName, someWrapper, imageItemParam) {
                return invalidPhotoName == imageItemParam.button.GetSettings().photoName;
            }, imageItem);
        }
    }
    function onWheel(notification) {
        var delta = 100;
        var contentE = content.GetHTMLElement();
        var isUp = notification.isUp, sign = isUp ? -1 : 1;
        contentE.scrollLeft += (delta * sign);
        //console.log('on mouse wheel ' + (isUp ? "UP" : "DOWN"));
    }
    function getButtonSettings() {
        var delayMillis = tf.TFMap.toolTipDelayMillis, toolTipClass = "start", toolTipArrowClass = "bottom";
        return {
            onClick: onButtonClicked, onHover: undefined, wrapper: wrapper, delayMillis: delayMillis, toolTipClass: toolTipClass, toolTipArrowClass: toolTipArrowClass,
            toolTipText: "View Photo", buttonClass: itemWrapperClassName + " ripple"
        };
    }
    function createControl() {
        var customizedScrollBarClassName = tf.TFMap.LayoutSettings.customizedScrollBarClassName;
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles();
        wrapper = new tf.dom.Div({ cssClass: wrapperClassName });
        buttonSettings = getButtonSettings();
        content = new tf.dom.Div({ cssClass: contentClassName + " " + customizedScrollBarClassName });
        itemToolBar = new tf.dom.Div({ cssClass: itemToolBarClassName });
        selectRecordButton = settings.appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, {
            buttonClass: selectRecordButtonClassName + " ripple",
            svgHTML: appStyles.GetMapMarker1SVG(),
            toolTipText: getSelectToolTipText,
            toolTipClass: "end",
            onClick: onSelectRecord
        }));
        var selectRecordButtonSVG = selectRecordButton.GetButton().firstChild;
        tf.dom.AddCSSClass(selectRecordButtonSVG, selectRecordButtonSVGClassName);
        itemToolBar.AddContent(selectRecordButton.GetButton());
        wheelListener = new tf.events.DOMWheelListener({ target: content, callBack: onWheel, optionalScope: theThis });
        wrapper.AddContent(content);
    }
    var wrapperClassName, contentClassName, itemWrapperClassName, itemButtonClassName, itemToolBarClassName, selectRecordButtonClassName, selectRecordButtonSVGClassName;
    function createCSSClassNames() {
        wrapperClassName = tf.TFMap.CreateClassName(cssTag, "Wrapper");
        contentClassName = tf.TFMap.CreateClassName(cssTag, "Content");
        itemWrapperClassName = tf.TFMap.CreateClassName(cssTag, "ItemWrapper");
        itemButtonClassName = tf.TFMap.CreateClassName(cssTag, "ItemButton");
        itemToolBarClassName = tf.TFMap.CreateClassName(cssTag, "ItemToolBar");
        selectRecordButtonClassName = tf.TFMap.CreateClassName(cssTag, "SelectRecordButton");
        selectRecordButtonSVGClassName = tf.TFMap.CreateClassName(cssTag, "SelectRecordButtonSVG");
    }
    function createCSSClasses() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var cssClasses = [];
        var addSelItemPx = addSelItemPxInt + 'px';
        var halfAddSelItemPxInt = addSelItemPxInt / 2;
        var halfAddSelItemPx = halfAddSelItemPxInt + 'px';
        var ls = tf.TFMap.LayoutSettings;
        var livelyColor = ls.backgroundLivelyColor;
        var underBottomPaneHeightInt = ls.underBottomPaneHeightInt;
        var itemWrapperHeightInt = underBottomPaneHeightInt - 30;
        var itemWrapperHeightPx = itemWrapperHeightInt + 'px';
        var itemWrapperDimInt = itemWrapperHeightInt * 9 / 4;
        var itemWrapperDimPx = itemWrapperDimInt + 'px';
        var svgDim = "45%";
        var toolBarWidthInt = Math.floor(itemWrapperDimInt / 3);
        var toolBarWidthPx = toolBarWidthInt + 'px';
        var itemToolBarHeight = "calc(100% + 4px)";
        var horMarginInt = 4, horMarginPx = horMarginInt + 'px';
        var heightToolBarButtonInt = toolBarWidthInt - 2 * horMarginInt;
        cssClasses[wrapperClassName] = {
            inherits: [CSSClasses.transitionPoint2s, CSSClasses.displayBlock, CSSClasses.overflowVisible, CSSClasses.backgroundColorTransparent, CSSClasses.cursorDefault, CSSClasses.pointerEventsNone,
            CSSClasses.noMarginNoBorderNoPadding, CSSClasses.positionAbsolute],
            left: "0px", bottom: "0px",
            zIndex: '' + (ls.rootDivZIndex + ls.photoListDisplayerWrapperZIndexAdd),
            height: underBottomPaneHeightInt + 'px', width: "100%"
        };
        cssClasses[contentClassName] = {
            inherits: [CSSClasses.whiteSpaceNoWrap, CSSClasses.displayBlock, CSSClasses.cursorDefault, CSSClasses.pointerEventsAll, CSSClasses.noMarginNoBorderNoPadding, CSSClasses.positionRelative],
            background: livelyColor, overflowY: 'hidden', overflowX: 'auto',
            zIndex: '' + (ls.rootDivZIndex + ls.photoListDisplayerContentZIndexAdd),
            flexFlow: "row nowrap", height: "100%",
            paddingLeft: halfAddSelItemPx, paddingRight: halfAddSelItemPx,
            width: "calc(100% - " + addSelItemPx + ")"
        };
        cssClasses[itemWrapperClassName] = {
            inherits: [CSSClasses.displayInlineBlock, CSSClasses.overflowVisible, CSSClasses.cursorPointer, CSSClasses.pointerEventsAll, CSSClasses.noMarginNoBorderNoPadding, CSSClasses.positionRelative,
            CSSClasses.whiteSpaceNormal, CSSClasses.verticalAlignMiddle],
            marginLeft: "0px", marginRight: "0px", height: "calc(100% - 12px)", marginTop: "4px", width: itemWrapperDimPx,
            borderRadius: "2px",
            border: "2px solid transparent"
        };
        cssClasses[itemButtonClassName] = {
            inherits: [CSSClasses.displayBlock, CSSClasses.overflowHidden, CSSClasses.cursorPointer, CSSClasses.pointerEventsAll, CSSClasses.noMarginNoBorderNoPadding,
            CSSClasses.positionRelative, CSSClasses.whiteSpaceNormal],
            left: "0px", top: "0px",
            background: "transparent",
            height: "100%", width: "100%",
            color: "white",
            fontSize: "11px"
        };
        cssClasses[itemToolBarClassName] = {
            inherits: [CSSClasses.transitionPoint2s, CSSClasses.displayBlock, CSSClasses.overflowVisible, CSSClasses.cursorDefault, CSSClasses.pointerEventsNone,
            CSSClasses.noMarginNoBorderNoPadding, CSSClasses.positionAbsolute, CSSClasses.whiteSpaceNormal],
            left: "-2px",
            top: "-2px",
            background: "rgba(0, 0, 0, 0.5)",
            height: itemToolBarHeight,
            width: toolBarWidthPx,
            borderRadius: "0px",
            color: "white",
            fontSize: "11px",
            borderRight: "2px solid rgba(0, 0, 0, 0.2)"
        };
        cssClasses[selectRecordButtonClassName] = {
            inherits: [CSSClasses.positionAbsolute, CSSClasses.pointerEventsAll, CSSClasses.transparentImageButton,
            CSSClasses.directionsCloseSVG, CSSClasses.backgroundColorTransparent],
            zIndex: '' + (ls.rootDivZIndex + ls.photoListDisplayerSelectRecordButtonZIndexAdd),
            width: "100%",
            height: itemToolBarHeight,
            left: "0px",
            top: "0px"
        };
        cssClasses[selectRecordButtonSVGClassName] = { width: svgDim, height: svgDim };
        return cssClasses;
    }
    function resizeItems() {
        var count = imageItemsCache.GetActiveCount();
        if (count > 0) {
            var layoutSettings = tf.TFMap.LayoutSettings;
            var underBottomPaneHeightInt = layoutSettings.underBottomPaneHeightInt;
            var itemWrapperHeightInt = underBottomPaneHeightInt - 30;
            var itemWrapperDimInt = itemWrapperHeightInt * 9 / 4;
            var itemWrapperDimPx = itemWrapperDimInt + 'px';
            var imageItems = imageItemsCache.GetObjects();
            for (var i = 0; i < count; ++i) {
                var imageItem = imageItems[i];
                var itemWrapper = imageItem.wrapper;
                var S = tf.dom.GetHTMLElementFrom(itemWrapper).style;
                S.width = itemWrapperDimPx;
            }
        }
    }
    function setClickedStyle(item, bool) {
        var S = tf.dom.GetHTMLElementFrom(item.wrapper).style;
        var layoutSettings = tf.TFMap.LayoutSettings;
        var underBottomPaneHeightInt = layoutSettings.underBottomPaneHeightInt;
        var itemWrapperHeightInt = underBottomPaneHeightInt - 30;
        var itemWrapperDimInt = itemWrapperHeightInt * 9 / 4;
        var itemWrapperDimPx = itemWrapperDimInt + 'px';
        var colorSelect = "white";
        if (!!bool) {
            S.border = "2px solid " + colorSelect;
            S.width = (itemWrapperDimInt + addSelItemPxInt) + 'px';
            //S.marginLeft = (- addSelItemPxInt / 2) + 'px';
        }
        else {
            S.border = "2px solid transparent";
            S.width = itemWrapperDimPx;
            S.marginLeft = "0px";
        }
    }
    function setClickedItem(item) {
        if (!!clickedItem) {
            if (clickedItem != item) {
                setClickedStyle(clickedItem, false);
                clickedItem = item;
            }
        }
        else {
            clickedItem = item;
        }
        if (!!clickedItem) {
            setClickedStyle(clickedItem, true);
        }
    }
    function makeButtonNotification(button, isSelect) {
        var buttonSettings = button.GetSettings();
        var photoName = buttonSettings.photoName;
        return { sender: theThis, photoName: photoName, index: buttonSettings.photoIndex, button: button, photoList: lastPhotoList, isSelect: isSelect }
    }
    function onClickOrSelect(button, isSelect) {
        var buttonSettings = button.GetSettings();
        //detachItemToolBar();
        setClickedItem(buttonSettings.imageItem);
        if (!!clientOnClickCB) {
            clientOnClickCB(makeButtonNotification(button, isSelect));
        }
        else {
            settings.appContent.ShowPhoto({ photoName: buttonSettings.photoName }, sender.GetButton());
        }
    }
    function onSelectRecord(notification) {
        if (!!buttonWithToolBar) { onClickOrSelect(buttonWithToolBar, true); }
    }
    function onButtonClicked(notification) {
        var sender = notification.sender;
        if (tf.js.GetIsValidObject(sender) && tf.js.GetFunctionOrNull(sender.GetButton)) { onClickOrSelect(sender, false); }
    }
    function getToolTipOrSelectText(button, isSelect) {
        var viewSelectStr = "click to " + (isSelect ? "select" : "view");
        var toolTipText;
        if (!!photoTitles) {
            var buttonSettings = button.GetSettings();
            toolTipText = tf.TFMap.MapTwoLineSpan(viewSelectStr, photoTitles[buttonSettings.photoIndex]);
        }
        else {
            toolTipText = viewSelectStr;
        }
        return toolTipText;
    }
    function getSelectToolTipText(button) { return getToolTipOrSelectText(buttonWithToolBar, true); }
    function getToolTipText(button) { return getToolTipOrSelectText(button, false); }
    function getButtonSettings() {
        var delayMillis = tf.TFMap.toolTipDelayMillis, toolTipClass = "start", toolTipArrowClass = "bottom";
        return {
            onClick: onButtonClicked, onHover: undefined, wrapper: wrapper, delayMillis: delayMillis, toolTipClass: toolTipClass, toolTipArrowClass: toolTipArrowClass,
            toolTipText: getToolTipText, buttonClass: itemButtonClassName + " ripple"
        };
    }
    function onFocusImageItem(notification) {
        var hasFocus = notification.hasFocus;
        var target = notification.event.target;
        var targetIsImageItem = target == notification.callBackSettings.wrapper;
        if (targetIsImageItem) { if (hasFocus) { tf.dom.ScrollHorizontallyToEnsureVisible(content, target); } }
    }
    function unDrawLine() {
        if (!!lineToPhoto) {
            var overMapCanvas = settings.appContent.GetOverMapCanvas();
            overMapCanvas.DelOMCLine(lineToPhoto);
            lineToPhoto = undefined;
            overMapCanvas.Draw();
        }
    }
    function detachItemToolBar() {
        if (!!timerToolBarAttach) { clearTimeout(timerToolBarAttach); timerToolBarAttach = undefined; }
        unDrawLine();
        itemToolBar.GetHTMLElement().style.opacity = "0";
        buttonWithToolBar = undefined;
        itemToolBar.RemoveFromParent();
    }
    function attachItemToolBar(button) {
        var buttonSettings = button.GetSettings();
        var imageItem = buttonSettings.imageItem;
        var wrapper = imageItem.wrapper;
        buttonWithToolBar = button;
        itemToolBar.AppendTo(wrapper);
        timerToolBarAttach = setTimeout(function() {
            var appContent = settings.appContent, map = appContent.GetMap(), overMapCanvas = appContent.GetOverMapCanvas();
            var buttonIndex = buttonSettings.photoIndex;
            var imgCoords = photosToMapCoords[buttonIndex];
            var buttonRect = button.GetButton().getBoundingClientRect();
            var buttonPixelCoord = [buttonRect.left + buttonRect.width / 2, buttonRect.top - 4];
            var buttonMapCoord = map.PixelToMapCoords(buttonPixelCoord);
            lineToPhoto = overMapCanvas.AddOMCLine(buttonMapCoord, imgCoords, buttonPixelCoord);
            itemToolBar.GetHTMLElement().style.opacity = "1";
            settings.appContent.GetOverMapCanvas().Draw();
        }, 400);
    }
    function onHoverImageItem(notification) {
        if (!!lastPhotoList && !!photosToMapCoords) {
            var target = notification.event.target;
            var targetIsImageItem = target == tf.dom.GetHTMLElementFrom(notification.callBackSettings.wrapper);
            if (targetIsImageItem) {
                var imgButton = notification.callBackSettings.imgButton;
                detachItemToolBar();
                if (notification.isInHover) { attachItemToolBar(imgButton); }
                //else { console.log('hovered out'); }
            }
        }
    }
    function getNextImageItemFromCache() {
        var nextItem = imageItemsCache.GetNext();
        setClickedStyle(nextItem, false);
        return nextItem;
    }
    function createNewImageItem() {
        var imgButton = settings.appContent.CreateButton(tf.js.ShallowMerge(buttonSettings));
        var imgButtonButton = imgButton.GetButton();
        var itemWrapper = new tf.dom.Div({ cssClass: itemWrapperClassName });
        var blurListener = new tf.events.DOMFocusBlurListener({ target: itemWrapper, callBack: onFocusImageItem, optionalScope: theThis, callBackSettings: { imgButton: imgButton, wrapper: itemWrapper } });
        var hoverListener = new tf.events.DOMMouseEnterLeaveListener({ target: itemWrapper, callBack: onHoverImageItem, optionalScope: theThis, callBackSettings: { imgButton: imgButton, wrapper: itemWrapper } });
        itemWrapper.AddContent(imgButtonButton);
        return { wrapper: itemWrapper, button: imgButton, blurListener: blurListener, hoverListener: hoverListener };
    }
    function deleteImageItem(notification) { }
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function onLayoutChange(notification) { registerCSSClasses(); resizeItems(); }
    var lcl;
    function initialize() {
        addSelItemPxInt = 16;
        cssTag = "photoListDisplayer";
        createCSSClassNames();
        registerCSSClasses();
        createControl();
        imageItemsCache = new tf.js.ObjectCache({ createNew: createNewImageItem, onDelete: deleteImageItem });
        lcl = settings.appContent.GetAppStyles().AddOnLayoutChangeListener(onLayoutChange);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: photolist.js
tf.TFMap.PhotoList = function(settings) {
    var theThis, photoNames, onClick, toolTipText;
    var lastContentSettings;
    this.GetLastContentSettings = function() { return lastContentSettings; }
    this.GetPhotoNames = function() { return photoNames; }
    this.GetOnClick = function() { return onClick; }
    this.GetToolTipText = function() { return toolTipText; }
    this.SetContent = function(contentSettings) {
        makeEmpty();
        lastContentSettings = contentSettings;
        var photoNamesA, nPhotoNames;
        if (tf.js.GetIsNonEmptyString(contentSettings.photoNamesStr)) {
            photoNamesA = contentSettings.photoNamesStr.split(' ');
        }
        else if (tf.js.GetIsNonEmptyArray(contentSettings.photoNames)) {
            photoNamesA = contentSettings.photoNames;
        }
        nPhotoNames = tf.js.GetIsNonEmptyArray(photoNamesA) ? photoNamesA.length : 0;
        for (var i = 0; i < nPhotoNames; ++i) {
            var photoName = photoNamesA[i].trim();
            if (photoName.length > 0) { photoNames.push(photoName); }
        }
        onClick = contentSettings.onClick;
        toolTipText = contentSettings.toolTipText;
    }
    function makeEmpty() { lastContentSettings = undefined; photoNames = []; }
    function initialize() {
        makeEmpty();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: lsed.js
tf.TFMap.LSEd = function (settings) {
    var theThis, map, layer, fillLayer, isActive;
    var allEventDispatchers, geomUpdateEventName, activationEventName;
    var minZIndexVertex, indexZIndexStep, minLineStringZIndex, minCloseAreaZIndex;
    var lineString, lineStringFeature, areaFeature, closePolyEdgeFeature, vertexFeatures, vertexInfos, lsHoverFeature;
    var vertexMapFeatureCache;
    var coordsLSHover;
    var showMapFeatureToolTipCB, onDoubleClickFeatureCB, onLayoutChangeCB;
    var maxPoints;
    var getVertexStyleCB;
    var getLineStringStyleCB;
    var getAreaStyleCB;
    var getClosePolyEdgeStyleCB;
    var showArea, showIntermediateLenghts;
    var featuresInLayer, closeAreaInLayer;
    var onPostComposeCB, onClearCB, requestCloseCB;
    var requestCloseSender;
    var showMeasures, showExtent;
    var colorTicNormalMap, colorTicNormalHybrid;
    var distances3Units;
    var scaleExtent;
    var lastDrawResult;
    var myInterface;
    var geomUpdated;
    var lastExtentDrawResult;
    function canAdd() { return lineString.length < maxPoints; }
    function showMapFeatureToolTip(mapFeature, atCoords) { if (!!showMapFeatureToolTipCB) { showMapFeatureToolTipCB(mapFeature, atCoords); } }
    function hideMapFeatureToolTip() { return showMapFeatureToolTip(undefined, undefined); }
    function getMinZIndexForIndex(index, isHover) {
        var indexUse = index == undefined ? (maxPoints + 1) : (isHover ? (maxPoints + 2) : index);
        return indexUse * indexZIndexStep + minZIndexVertex;
    }
    function getMinZIndexForMapFeature(mapFeature, isHover) {
        var editProps = getEditProps(mapFeature);
        var index = !!editProps ? editProps.index : undefined;
        return getMinZIndexForIndex(index, isHover);
    }
    function getDefaultLineStringStyle(mapFeature) {
        var minZIndex = minLineStringZIndex;
        return [{ line: true, line_width: 12, line_color: "#fff", line_opacity: 1, zindex: minZIndex++ }, { line: true, line_width: 8, line_color: "#aaf", zindex: minZIndex++ }];
    }
    function getLineStringStyle(mapFeature) {
        return !!getLineStringStyleCB ?
            getLineStringStyleCB({ sender: theThis, minZIndex: minLineStringZIndex, mapFeature: mapFeature, isHover: mapFeature.GetIsDisplayingInHover() }) :
            getDefaultLineStringStyle(mapFeature);
    }
    function getClosePolyEdgeStyle(keyedFeature, mapFeature) {
        var style;
        if (!!getClosePolyEdgeStyleCB) {
            style = getClosePolyEdgeStyleCB({ sender: theThis, minZIndex: minCloseAreaZIndex, mapFeature: mapFeature, isHover: mapFeature.GetIsDisplayingInHover() })
        }
        else {
            style = getDefaultLineStringStyle(keyedFeature, mapFeature);
            style[1].line_dash = [10, 20];
            style[1].line_width -= 2;
            style[1].zindex = minCloseAreaZIndex;
            style = style[1];
        }
        return style;
    }
    function getAreaStyle(mapFeature) {
        var style;
        var minZIndex = 1;
        if (!!getAreaStyleCB) {
            style = getAreaStyleCB({ sender: theThis, minZIndex: minZIndex, mapFeature: mapFeature, isHover: mapFeature.GetIsDisplayingInHover() });
        }
        else {
            style = { zindex: minZIndex++, fill: true, fill_color: "#fff", fill_opacity: 35 };
        }
        return style;
    }
    function getVertexStyle(keyedFeature, mapFeature) {
        var editProps = getEditProps(mapFeature);
        var isHover = mapFeature.GetIsDisplayingInHover();
        var index = editProps.index;
        var zindex = getMinZIndexForIndex(index, isHover);
        var style;
        if (!!getVertexStyleCB) {
            style = getVertexStyleCB({ sender: theThis, mapFeature: mapFeature, minZIndex: zindex, index: index, isVertex: index != undefined, isHover: isHover });
        }
        else {
            var radius = 18;
            var snaptopixel = false;
            var fontFamily = "px Roboto";
            style = [{
                snaptopixel: snaptopixel, zindex: zindex++,
                circle: true, circle_radius: radius, line: true, fill: true, fill_color: "#fdfdff", line_color: "#026", line_width: 2, line_opacity: 70, fill_opacity: 100
            }];
            var textStyle = {
                snaptopixel: snaptopixel, font: "400 " + (2 * radius) + fontFamily,
                zindex: zindex++, text: true, fill: true, fill_color: "#026", line: true, line_opacity: 30, line_color: "#bfbfbf", line_width: 1,
                label: '+'
            };
            if (index != undefined) { textStyle.font = "600 " + (radius) + fontFamily; textStyle.label = '#' + (1 + index); }
            style.push(textStyle);
        }
        return style;
    }
    function createVertexMapFeature() {
        var mapFeature = new tf.map.Feature({ type: 'point', coordinates: [0, 0], style: getVertexStyle, hoverStyle: getVertexStyle, LSEdSettings: { isVertex: true, index: undefined }, showToolTip: true });
        return mapFeature;
    }
    function getEditProps(mapFeature) { return mapFeature.GetSettings().LSEdSettings; }
    function deleteVertexMapFeature(notification) { }
    function getNextVertexMapFeature() {
        var mapFeature = vertexMapFeatureCache.GetNext(), editProps = getEditProps(mapFeature);
        editProps.index = undefined;
        var toolTipText = tf.TFMap.MapTwoLineSpan("Add point", "click or drag");
        tf.TFMap.SetMapFeatureToolTipProps(mapFeature, { toolTipText: toolTipText, offsetX: 20, delayMillis: tf.TFMap.AddWayPointToolTipDelayMillis });
        return mapFeature;
    }
    function getLineStringGeom() { return lineString.length >= 2 ? { type: "linestring", coordinates: lineString.slice(0) } : undefined; }
    function getPolygonGeom() {
        if (lineString.length >= 3) {
            var coordsUse = lineString.slice(0);
            coordsUse.push(coordsUse[0]);
            return { type: "polygon", coordinates: [coordsUse] };
        }
    }
    function calcGeom(forArea, forClosePolyEdge) {
        var coordsUse, type, styleFunction;
        if (forArea) {
            type = 'polygon';
            styleFunction = getAreaStyle;
            coordsUse = lineString.slice(0);
            if (coordsUse.length > 0) { coordsUse.push(coordsUse[0]); }
            coordsUse = [coordsUse];
        }
        else {
            type = 'linestring';
            if (forClosePolyEdge) {
                var lineStringLen = lineString.length;
                if (lineStringLen > 0) { coordsUse = [lineString[0]]; coordsUse.push(lineString[lineStringLen - 1]); } else { coordsUse = []; }
                styleFunction = getClosePolyEdgeStyle;
            }
            else { coordsUse = lineString; styleFunction = getLineStringStyle; }
        }
        return { type: type, coordinates: coordsUse, style: styleFunction, hoverStyle: styleFunction, LSEdSettings: { isLineString: !forArea, isArea: forArea } };
    }
    function checkCloseAreaInLayer() {
        if (!!closePolyEdgeFeature) {
            var lineStringLen = lineString.length;
            if (lineStringLen > 2) {
                //tf.TFMap.SetMapFeatureToolTipProps(areaFeature, { toolTipText: "Area", offsetX: 20, delayMillis: tf.TFMap.AddWayPointToolTipDelayMillis });
                var firstCoords = lineString[0], lastCoords = lineString[lineStringLen - 1];
                var midCoords = [firstCoords[0] + (lastCoords[0] - firstCoords[0]) / 2, firstCoords[1] + (lastCoords[1] - firstCoords[1]) / 2];
                areaFeature.GetSettings().toolTipCoords = midCoords;
                if (!closeAreaInLayer) {
                    if (showArea) {
                        closeAreaInLayer = true;
                        layer.AddMapFeature(closePolyEdgeFeature);
                    }
                }
                else {
                    if (!showArea) {
                        closeAreaInLayer = false;
                        layer.DelMapFeature(closePolyEdgeFeature);
                    }
                }
            }
            else { if (closeAreaInLayer) { closeAreaInLayer = false; layer.DelMapFeature(closePolyEdgeFeature); } }
        }
    }
    function removeFaturesFromLayer() {
        if (featuresInLayer) {
            layer.DelMapFeature(lineStringFeature);
            if (showArea) {
                fillLayer.DelMapFeature(areaFeature);
                if (closeAreaInLayer) { layer.DelMapFeature(closePolyEdgeFeature); closeAreaInLayer = false; }
            }
            featuresInLayer = false;
        }
    }
    function addFeaturesToLayer() {
        if (!featuresInLayer) {
            layer.AddMapFeature(lineStringFeature);
            if (showArea) { fillLayer.AddMapFeature(areaFeature); checkCloseAreaInLayer(); }
            featuresInLayer = true;
        }
        else { checkCloseAreaInLayer(); }
    }
    function setShowArea(newShowArea) {
        if (showArea != (newShowArea = !!newShowArea)) {
            showArea = newShowArea;
            geomUpdated = true;
            if (featuresInLayer) {
                if (showArea) {
                    fillLayer.AddMapFeature(areaFeature);
                }
                else {
                    fillLayer.DelMapFeature(areaFeature);
                }
                checkCloseAreaInLayer();
            }
            else {
                checkNotifyGeomUpdated();
            }
        }
    }
    function getShowArea() { return showArea; }
    function checkFeaturesInLayer() { if (lineString.length > 1) { addFeaturesToLayer(); } else { removeFaturesFromLayer(); } }
    function updateGeom() {
        var geom = calcGeom(false, false);
        var areaGeom = calcGeom(true, false);;
        var closePolyEdgeGeom = calcGeom(false, true);
        if (!!lineStringFeature) {
            lineStringFeature.SetGeom(new tf.map.FeatureGeom(geom));
            closePolyEdgeFeature.SetGeom(new tf.map.FeatureGeom(closePolyEdgeGeom))
            areaFeature.SetGeom(new tf.map.FeatureGeom(areaGeom));
        }
        else {
            lineStringFeature = new tf.map.Feature(geom);
            areaFeature = new tf.map.Feature(areaGeom);
            var toolTipText = tf.TFMap.MapTwoLineSpan("Add point", "click or drag");
            closePolyEdgeFeature = new tf.map.Feature(closePolyEdgeGeom);
        }
        calcVertexInfos();
        checkFeaturesInLayer();
        geomUpdated = true;
    }
    function calcVertexInfos() {
        var areaGeom = !!areaFeature ? areaFeature.GetGeom() : undefined;
        var area = !!areaGeom ? areaGeom.GetArea() : undefined;
        //console.log(area);
        vertexInfos = tf.js.CalcVertexInfos(lineString, area);
    }
    function addLineStringPoint(index, pointCoordsToCopyFrom, skipNotifications) {
        var pointCoords = pointCoordsToCopyFrom.slice(0);
        lineString.splice(index, 0, pointCoords);
        setCoordsLSHover(undefined);
        var vertexFeature = getNextVertexMapFeature(), editProps = getEditProps(vertexFeature);
        vertexFeatures.splice(index, 0, vertexFeature);
        editProps.index = lineString.length - 1;
        vertexFeature.SetPointCoords(pointCoords);
        var toolTipText = tf.TFMap.MapTwoLineSpan("drag to move", "click to delete");
        tf.TFMap.GetMapFeatureToolTipProps(vertexFeature).toolTipText = toolTipText;
        layer.AddMapFeature(vertexFeature);
        vertexFeature.RefreshStyle();
        updateGeom();
        if (!skipNotifications) {
            hideMapFeatureToolTip();
            map.Render();
        }
    }
    function renumVertexFeatures() {
        var nf = vertexFeatures.length; for (var i = 0; i < nf; ++i) { var vf = vertexFeatures[i], editProps = getEditProps(vf); editProps.index = i; vf.RefreshStyle(); }
    }
    function onHoverFeature(notification) {
        var handled = false;
        var mapFeature = notification.mapFeature, editProps = getEditProps(mapFeature);
        if (!!editProps) {
            if (editProps.isLineString) {
                var needsRender;
                if (notification.isInHover && mapFeature == lineStringFeature && lineString.length > 1) {
                    needsRender = setCoordsLSHover(notification.eventCoords);
                }
                else { needsRender = setCoordsLSHover(undefined); }
                if (needsRender) { map.Render(); }
            }
            //handled = true;
        }
        return handled;
    }
    function setCoordsLSHover(newCoords) {
        var modified = false;
        if (newCoords != undefined) {
            if (canAdd()) {
                var hitTestAddWayPoint = tf.helpers.HitTestMapCoordinatesArray(lineString, newCoords, undefined, undefined, undefined);
                if (hitTestAddWayPoint.closestPoint != undefined) {
                    var newCoords = hitTestAddWayPoint.closestPoint;
                    if (coordsLSHover == undefined || (newCoords[0] != coordsLSHover[0] || newCoords[1] != coordsLSHover[1])) {
                        lsHoverFeature.SetPointCoords(coordsLSHover = newCoords);
                        showMapFeatureToolTip(lsHoverFeature, undefined);
                        modified = true;
                    }
                }
            }
        }
        else if (coordsLSHover != undefined) {
            coordsLSHover = undefined;
            hideMapFeatureToolTip();
            modified = true;
        }
        return modified;
    }
    function onMouseMoveFeature(notification) {
        var pointCoords = notification.mapFeature == lineStringFeature ? notification.eventCoords : undefined;
        if (setCoordsLSHover(pointCoords)) { map.Render(); }
    }
    function appendPoint(pointCoords, skipNotifications) { addLineStringPoint(lineString.length, pointCoords, skipNotifications); }
    function AddPointAtCoords(isDrag, coordsToAddPoint) {
        if (!!coordsToAddPoint) {
            var hitTestAddWayPoint = tf.helpers.HitTestMapCoordinatesArray(lineString, coordsToAddPoint, undefined, undefined, undefined);
            if (hitTestAddWayPoint.closestPoint != undefined) {
                var indexAdd = hitTestAddWayPoint.minDistanceIndex;
                if (indexAdd < lineString.length - 1) { ++indexAdd; }
                //console.log('adding at: ' + indexAdd + 'isDrag: ' + isDrag);
                addLineStringPoint(indexAdd, coordsToAddPoint);
                renumVertexFeatures();
            }
        }
    }
    function addPointAtCoordsLSHover(isDrag) { AddPointAtCoords(isDrag, coordsLSHover); }
    function delLineStringPoint(index) {
        if (lineString.length > 1) {
            lineString.splice(index, 1);
            layer.DelMapFeature(vertexFeatures[index]);
            vertexFeatures.splice(index, 1);
            renumVertexFeatures();
            updateGeom();
        }
        else { clear(); }
    }
    function onClickMap(notification) {
        var handled = canAdd();
        if (handled) { appendPoint(notification.eventCoords); }
        return handled;
    }
    function onDragFeature(notification) {
        var handled = false, mapFeature = notification.mapFeature, editProps = getEditProps(mapFeature);
        if (handled = !!editProps) { if (editProps.index == undefined) { addPointAtCoordsLSHover(true); } }
        return handled;
    }
    function onClickFeature(notification) {
        var handled = false, mapFeature = notification.mapFeature, editProps = getEditProps(mapFeature);
        if (handled = !!editProps) {
            if (editProps.index == undefined) {
                if (mapFeature == lineStringFeature) {
                    addPointAtCoordsLSHover(false);
                }
                else {
                    //AddPointAtCoords(false, notification.eventCoords);
                    appendPoint(notification.eventCoords);
                }
            }
            else { delLineStringPoint(editProps.index); }
        }
        return handled;
    }
    function onDrag(notification) {
        if (notification.dragProps.editorProps.isVertex) {
            lineString[notification.dragProps.editorProps.index] = notification.mapFeatureToDrag.GetPointCoords();
            updateGeom();
        }
    }
    function checkCanStartDrag(notification) {
        var dragProps, mapFeature = notification.mapFeature, editProps = getEditProps(mapFeature);
        if (!!editProps) { if (editProps.isVertex && editProps.index != undefined) { return { isVertex: true, index: editProps.index }; } }
        return dragProps;
    }
    function getIsShowingHybrid() { return map.GetMapType() != tf.consts.typeNameMap; }
    function drawLineSeg(map, ctx, startPoint, endPoint) {
        var startPointPx = map.MapToPixelCoords(startPoint), endPointPx = map.MapToPixelCoords(endPoint);
        ctx.moveTo(startPointPx[0], startPointPx[1]);
        ctx.lineTo(endPointPx[0], endPointPx[1]);
    }
    function drawLineString(map, ctx, lsPoints, close) {
        var nPoints = lsPoints.length;
        if (nPoints > 1) {
            for (var i = 0; i < nPoints - 1; ++i) { drawLineSeg(map, ctx, lsPoints[i], lsPoints[i + 1]); }
            if (close && nPoints > 2) { drawLineSeg(map, ctx, lsPoints[nPoints - 1], lsPoints[0]); }
        }
    }
    function drawExtent(map, ctx, extent, lineWidth, strokeColor) {
        var topLeft = [extent[0], extent[1]], topRight = [extent[2], extent[1]], bottomRight = [extent[2], extent[3]], bottomLeft = [extent[0], extent[3]];
        ctx.lineWidth = lineWidth != undefined ? lineWidth : 20;
        ctx.strokeStyle = strokeColor != undefined ? strokeColor : "#f00";
        ctx.beginPath();
        drawLineString(map, ctx, [topLeft, topRight, bottomRight, bottomLeft], true);
        ctx.closePath();
        ctx.stroke();
        return extent;
    }
    function drawClippedEdge(map, ctx, startPoint, endPoint, extent) {
        var lineClip = tf.js.ClipMapLineSegment(extent, startPoint, endPoint);
        if (lineClip.intersects) {
            ctx.line_width = 20;
            ctx.strokeStyle = "#fc0";
            ctx.beginPath();
            drawLineSeg(map, ctx, lineClip.startCoord, lineClip.endCoord);
            ctx.closePath(); ctx.stroke();
        }
    }
    function drawClippedEdges(map, ctx, vertexInfos, extent) {
        var nPoints = vertexInfos.length;
        if (nPoints >= 2) {
            for (var i = 0; i < nPoints; ++i) {
                var thisVertex = vertexInfos[i], thisPoint = thisVertex.coords, nextPoint = thisVertex.nextCoords;
                drawClippedEdge(map, ctx, thisPoint, nextPoint, extent);
            }
        }
    }
    function drawMeasuredExtent(map, ctx, extentToCalc, extentToDraw) {
        var left = extentToDraw[0], top = extentToDraw[1], right = extentToDraw[2], bottom = extentToDraw[3];
        var v1 = [left, top], v2 = [right, top], v3 = [right, bottom], v4 = [left, bottom];
        var extentPoly = [v4, v3, v2, v1];
        var extentArea = tf.js.CalcPolyAreaInSquareMeters(extentPoly);
        var polyVertexInfos = tf.js.CalcVertexInfos(extentPoly, extentArea);
        var showingHybrid = getIsShowingHybrid();
        var colorTic = showingHybrid ? colorTicNormalHybrid : colorTicNormalMap;
        var colorSeg = showingHybrid ? settings.optionalExtentColorSegHybrid : settings.optionalExtentColorSegMap;
        var textStyle = showingHybrid ? settings.optionalHybridTextStyle : settings.optionalMapTextStyle;
        lastExtentDrawResult = tf.js.DrawMeasuredVertices({
            map: map, ctx: ctx, distances3Units: distances3Units, vertexInfos: polyVertexInfos, showArea: true, showingHybrid: showingHybrid,
            colorTic: colorTic, colorSeg: colorSeg, extent: extentToDraw, showIntermediateLenghts: true, textStyle: textStyle,
            lineWidth: settings.optionalExtentSegWidth
        });
    }
    function onPostCompose(notification) {
        if (!!coordsLSHover) { notification.showFeatureImmediately(lsHoverFeature); }
        if (!!onPostComposeCB) { onPostComposeCB({ sender: theThis, notification: notification }); }
        if (showMeasures) {
            var canvas = notification.canvas, ctx = canvas.getContext("2d");
            var extent = map.GetVisibleExtent();
            var extentScale = scaleExtent;
            if (extentScale != 1) {
                extent = tf.js.ScaleMapExtent(extent, extentScale);
                drawExtent(map, ctx, extent, 3, "#00f");
                drawClippedEdges(map, ctx, vertexInfos, extent);
            }
            var nPoints = vertexInfos.length;
            if (nPoints >= 2) {
                var showingHybrid = getIsShowingHybrid();
                var colorTic = showingHybrid ? colorTicNormalHybrid : colorTicNormalMap;
                var colorSeg = showingHybrid ? settings.optionalColorSegHybrid : settings.optionalColorSegMap;
                var textStyle = showingHybrid ? settings.optionalHybridTextStyle : settings.optionalMapTextStyle;
                lastDrawResult = tf.js.DrawMeasuredVertices({
                    map: map, ctx: ctx, distances3Units: distances3Units, vertexInfos: vertexInfos, showArea: showArea, showingHybrid: showingHybrid,
                    colorTic: colorTic, colorSeg: colorSeg, extent: extent, showIntermediateLenghts: showIntermediateLenghts, textStyle: textStyle,
                    lineWidth: settings.optionalSegWidth
                });
                if (showExtent && lastDrawResult.vertexExtent != undefined) { drawMeasuredExtent(map, ctx, extent, lastDrawResult.vertexExtent); }
                if (extentScale != 1) { console.log('nTics: ' + lastDrawResult.nTics + ' drawn: ' + lastDrawResult.nTicsDrawn); }
            }
        }
        checkNotifyGeomUpdated();
    }
    function checkNotifyGeomUpdated() { if (geomUpdated) { geomUpdated = false; notify(geomUpdateEventName, {}); } }
    function clear(skipRender) {
        layer.RemoveAllFeatures();
        vertexMapFeatureCache.Reset();
        lsHoverFeature = getNextVertexMapFeature();
        closeAreaInLayer = false;
        lineString = [];
        vertexFeatures = [];
        vertexInfos = [];
        featuresInLayer = false;
        if (!!onClearCB) { onClearCB({ sender: theThis }); }
        geomUpdated = true;
        if (!skipRender) {
            map.Render();
        }
        //if (!!requestCloseCB) { requestCloseCB({ sender: requestCloseSender }); }
    };
    function getLineString() { return lineString; }
    function getVertexInfos() { return vertexInfos; }
    function onMapScaleUnit() { hideMapFeatureToolTip(); geomUpdated = true; map.Render(); }
    function notifyActivation() { notify(activationEventName, {}); }
    function activate() {
        if (isActive) { console.log('double activation') }
        else {
            isActive = true;
            refreshStyles();
            settings.fillLayer.SetVisible(true);
            settings.layer.SetVisible(true);
            geomUpdated = true;
            map.Render();
            notifyActivation();
        }
    }
    function deActivate() {
        if (!isActive) { console.log('double deactivation'); }
        else {
            isActive = false;
            settings.fillLayer.SetVisible(false);
            settings.layer.SetVisible(false);
            notifyActivation();
        }
    }
    function getIsActive() { return isActive; }
    function getShowMeasures() { return showMeasures; }
    function setShowMeasures(newShowMeasures) {
        if (showMeasures != (newShowMeasures = !!newShowMeasures)) {
            showMeasures = newShowMeasures;
            map.Render();
        }
    }
    function getShowExtent() { return showExtent; }
    function setShowExtent(newShowExtent) {
        if (showExtent != (newShowExtent = !!newShowExtent)) {
            showExtent = newShowExtent;
            map.Render();
        }
    }
    function getDistance3Units() { return distances3Units; }
    var notifyTimeout;
    function notify2(eventName, props) {
        if (notifyTimeout != undefined) { clearTimeout(notifyTimeout); }
        notifyTimeout = setTimeout(function () {
            allEventDispatchers.Notify(eventName, tf.js.ShallowMerge(props, { sender: theThis, senderI: myInterface, eventName: eventName }));
        }, 100);
    }
    function notify(eventName, props) {
        //return;
        allEventDispatchers.Notify(eventName, tf.js.ShallowMerge(props, { sender: theThis, senderI: myInterface, eventName: eventName }));
    }
    function addUpdateGeomListener(callBack) { allEventDispatchers.AddListener(geomUpdateEventName, callBack); }
    function addActivationListener(callBack) { allEventDispatchers.AddListener(activationEventName, callBack); }
    function getInfo() {
        var lengthOpen, lengthClosed, area;
        var nPoints = vertexInfos.length;
        if (nPoints >= 2) {
            var lastVertex = vertexInfos[nPoints - 1];
            lengthOpen = lastVertex.totalDistance;
            if (nPoints > 2) {
                lengthClosed = lengthOpen + lastVertex.distanceToNext;
                area = lastVertex.area;
            }
        }
        return {
            lineString: lineString, lastExtentDrawResult: lastExtentDrawResult, lastDrawResult: lastDrawResult, nPoints: nPoints,
            lengthOpen: lengthOpen, lengthClosed: lengthClosed, area: area
        };
    }
    function setShowIntermediateLengths(newShow) {
        if (showIntermediateLenghts != (newShow = !!newShow)) {
            showIntermediateLenghts = newShow;
            map.Render();
        }
    }
    function getShowIntermediateLengths() { return showIntermediateLenghts; }
    function onDoubleClickFeature(notification) {
        if (!!onDoubleClickFeatureCB) {
            var editProps = getEditProps(notification.mapFeature);
            onDoubleClickFeatureCB({ sender: theThis, notification: notification, isEditorFeature: editProps != undefined });
        }
    }
    function refreshStyles() {
        if (!!lineStringFeature) { lineStringFeature.RefreshStyle(); }
        if (!!areaFeature) { areaFeature.RefreshStyle(); }
        if (!!closePolyEdgeFeature) { closePolyEdgeFeature.RefreshStyle(); }
        for (var i in vertexFeatures) { vertexFeatures[i].RefreshStyle(); }
    }
    function onLayoutChange(notification) {
        refreshStyles();
        if (!!onLayoutChangeCB) { onLayoutChangeCB({ sender: theThis, notification: notification }); }
    }
    function setLineString(newLineString) {
        if (tf.js.GetLooksLikeLineStringCoords(newLineString)) {
            clear(true);
            var nPoints = newLineString.length;
            if (nPoints > maxPoints) { nPoints = maxPoints; }
            //console.log('appending ' + nPoints + ' points out of ' + newLineString.length);
            for (var i = 0; i < nPoints ; ++i) { appendPoint(newLineString[i], true); }
            hideMapFeatureToolTip();
            map.Render();
        }
    }
    function initialize() {
        if (tf.js.GetFunctionOrNull(settings.setInterface)) {
            allEventDispatchers = new tf.events.MultiEventNotifier({
                eventNames: [
                    geomUpdateEventName = "geomUpdate",
                    activationEventName = "actvation"
                ]
            });
            var maxMaxPoints = 1000;
            var defMaxPoints = maxMaxPoints;
            minCloseAreaZIndex = 20;
            minLineStringZIndex = 50;
            minZIndexVertex = 100;
            indexZIndexStep = 5;
            maxPoints = tf.js.GetIntNumberInRange(settings.maxPoints, 2, maxMaxPoints, defMaxPoints);
            map = settings.map;
            layer = settings.layer;
            fillLayer = settings.fillLayer;
            lineString = [];
            vertexFeatures = [];
            vertexInfos = [];
            showMapFeatureToolTipCB = tf.js.GetFunctionOrNull(settings.showMapFeatureToolTip);
            onPostComposeCB = tf.js.GetFunctionOrNull(settings.onPostCompose);
            onClearCB = tf.js.GetFunctionOrNull(settings.onClear);
            requestCloseCB = tf.js.GetFunctionOrNull(settings.requestClose);
            onDoubleClickFeatureCB = tf.js.GetFunctionOrNull(settings.onDoubleClickFeature);
            vertexMapFeatureCache = new tf.js.ObjectCache({ createNew: createVertexMapFeature, onDelete: deleteVertexMapFeature });
            colorTicNormalMap = settings.colorTicNormalMap != undefined ? settings.colorTicNormalMap : "#1E90FF";
            colorTicNormalHybrid = settings.colorTicNormalHybrid != undefined ? settings.colorTicNormalHybrid : "#fff";
            distances3Units = tf.js.GetIsValidObject(settings.distances3Units) ? settings.distances3Units : tf.js.CalcDistances3Units();
            if (!settings.useNativeMapFeatureStyles) {
                getVertexStyleCB = tf.js.GetFunctionOrNull(settings.getVertexStyle);
                getLineStringStyleCB = tf.js.GetFunctionOrNull(settings.getLineStringStyle);
                getAreaStyleCB = tf.js.GetFunctionOrNull(settings.getAreaStyle);
                getClosePolyEdgeStyleCB = tf.js.GetFunctionOrNull(settings.getClosePolyEdgeStyle);
            }
            scaleExtent = settings.scaleExtent != undefined ? settings.scaleExtent : 1;
            showMeasures = !!settings.showMeasures;
            showExtent = !!settings.showExtent;
            showArea = !!settings.showArea;
            //showIntermediateLenghts = false;
            showIntermediateLenghts = true;
            featuresInLayer = closeAreaInLayer = false;
            lsHoverFeature = getNextVertexMapFeature();
            requestCloseSender = !!settings.requestCloseSender ? settings.requestCloseSender : theThis;
            settings.layer.SetVisible(false);
            onLayoutChangeCB = tf.js.GetFunctionOrNull(settings.onLayoutChange);
            isActive = false;
            myInterface = {
                sender: theThis,
                onLayoutChange: onLayoutChange,
                activate: activate,
                deActivate: deActivate,
                getIsActive: getIsActive,
                getInfo: getInfo,
                setShowArea: setShowArea,
                getShowArea: getShowArea,
                setShowExtent: setShowExtent,
                getShowExtent: getShowExtent,
                getShowMeasures: getShowMeasures,
                setShowMeasures: setShowMeasures,
                setShowIntermediateLengths: setShowIntermediateLengths,
                getShowIntermediateLengths: getShowIntermediateLengths,
                getDistance3Units: getDistance3Units,
                getAreaFeature: function () { return areaFeature; },
                getLineStringFeature: function () { return lineStringFeature; },
                getClosePolyEdgeFeature: function () { return closePolyEdgeFeature; },
                getLineString: getLineString,
                setLineString: setLineString,
                getVertexInfos: getVertexInfos,
                getLineStringGeom: getLineStringGeom,
                getPolygonGeom: getPolygonGeom,
                addActivationListener: addActivationListener,
                addUpdateGeomListener: addUpdateGeomListener,
                canAdd: canAdd,
                clear: clear,
                onDrag: onDrag,
                onClickMap: onClickMap,
                onHoverFeature: onHoverFeature,
                onMouseMoveFeature: onMouseMoveFeature,
                onDragFeature: onDragFeature,
                onClickFeature: onClickFeature,
                onDoubleClickFeature: onDoubleClickFeature,
                onPostCompose: onPostCompose,
                checkCanStartDrag: checkCanStartDrag,
                getMinZIndexForMapFeature: getMinZIndexForMapFeature,
                onMapScaleUnit: onMapScaleUnit
            };
            settings.setInterface(myInterface);
            /*setTimeout(function () {
                var sc = [-80.28971178737089, 25.70438683086026];
                var ec = [-80.19309489139326, 25.768850196037747];
                appendPoint(sc);
                appendPoint(ec);
            }, 1000);*/
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: mapfeaturedrag.js
tf.TFMap.MapFeatureDrag = function (settings) {
    var theThis, map, isDragging, mapFeatureToDrag, deltaPixDrag, curDragProps, checkCanStartDragCB, checkCanDragToCB, onStartDragCB, onDragCB, onEndDragCB;
    function makeVerbProps(verb) { return { verb: verb }; }
    function makeNotifyProps() { return { sender: theThis, isDragging: isDragging, dragProps: curDragProps, mapFeatureToDrag: mapFeatureToDrag }; }
    function notify(CB, props) { if (!!CB) { CB(tf.js.ShallowMerge(props, makeNotifyProps())); } }
    function checkCanStartDrag(mapFeature) { return !!checkCanStartDragCB ? checkCanStartDragCB({ sender: theThis, mapFeature: mapFeature }) : {}; }
    function getIsDragging() { return isDragging; }
    function startDrag(mapFeature, pointCoords, dragProps, skipNotify) {
        onEndDrag();
        if (!!mapFeature && tf.js.GetIsValidObject(dragProps)) {
            curDragProps = dragProps;
            mapFeatureToDrag = mapFeature;
            map.RemoveDragPan();
            //console.log('removed drag pan');
            var dragDownPixelCoords = map.MapToPixelCoords(pointCoords);
            var dragDownStartCoords = map.MapToPixelCoords(mapFeatureToDrag.GetPointCoords());
            deltaPixDrag = [dragDownPixelCoords[0] - dragDownStartCoords[0], dragDownPixelCoords[1] - dragDownStartCoords[1]];
            isDragging = true;
            if (!skipNotify) { notify(onStartDragCB, makeVerbProps("start")); }
        }
        return isDragging;
    }
    function onDrag(notification) {
        var mapFeatureCandidate = notification.mapFeature, pointCoords = notification.eventCoords;
        if (!isDragging) { startDrag(mapFeatureCandidate, pointCoords, checkCanStartDrag(mapFeatureCandidate), false); }
        return isDragging;
    }
    function onDragMove(notification) {
        if (isDragging) {
            var pointCoords = notification.eventCoords;
            var canDrag = !!checkCanDragToCB ? checkCanDragToCB(tf.js.ShallowMerge(makeNotifyProps(), { pointCoords: pointCoords })) : true;
            if (canDrag) {
                var draggingPixelCoords = map.ActualMapToPixelCoords(pointCoords);
                draggingPixelCoords[0] -= deltaPixDrag[0];
                draggingPixelCoords[1] -= deltaPixDrag[1];
                var newCoords = map.ActualPixelToMapCoords(draggingPixelCoords);
                mapFeatureToDrag.SetPointCoords(newCoords);
                notify(onDragCB, makeVerbProps("drag"));
            }
        }
        return isDragging;
    }
    function onEndDrag() {
        var wasDragging = isDragging;
        if (isDragging) {
            isDragging = false; mapFeatureToDrag = undefined; map.AddDragPan(); notify(onEndDragCB, makeVerbProps("end"));
        }
        return wasDragging;
    }
    function initialize() {
        if (tf.js.GetFunctionOrNull(settings.setInterface)) {
            checkCanStartDragCB = tf.js.GetFunctionOrNull(settings.checkCanStartDrag);
            onStartDragCB = tf.js.GetFunctionOrNull(settings.onStartDrag);
            onDragCB = tf.js.GetFunctionOrNull(settings.onDrag);
            onEndDragCB = tf.js.GetFunctionOrNull(settings.onEndDrag);
            checkCanDragToCB = tf.js.GetFunctionOrNull(settings.checkCanDragTo);
            map = settings.map;
            isDragging = false;
            settings.setInterface({ sender: theThis, getIsDragging: getIsDragging, onDrag: onDrag, onDragMove: onDragMove, onEndDrag: onEndDrag, startDrag: startDrag });
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: measuretool.js
tf.TFMap.MapMeasureTool = function (settings) {
    var theThis, lsEdI;
    var lastShowingHybrid;
    var colorTicNormalMap, colorTicNormalHybrid;
    var onClearCB;
    function getIsShowingHybrid() { return settings.map.GetMapType() != tf.consts.typeNameMap; }
    function getVertexStyle(notification) {
        var minZIndex = notification.minZIndex;
        var isVertex = notification.isVertex;
        var isHover = notification.isHover;
        var radius = tf.TFMap.LayoutSettings.measureToolVertexRadiusInt;
        if (isHover) { ++radius; }
        var snaptopixel = false;
        var lineColor = isVertex ? "#026" : "#cc4422";
        var style = [{
            snaptopixel: snaptopixel, zindex: minZIndex++,
            circle: true, circle_radius: radius + 8, fill: true, fill_color: "#fff", fill_opacity: 1
        }, {
            snaptopixel: snaptopixel, zindex: minZIndex++,
            circle: true, circle_radius: radius, line: true, fill: true, fill_color: "#fdfdff", line_color: lineColor, line_width: 2, line_opacity: 70, fill_opacity: 100
        }];
        return style;
    }
    function getLineStringStyle(notification) {
        var minZIndex = notification.minZIndex;
        var isHover = notification.isHover;
        var lineVisibleWidth = tf.TFMap.LayoutSettings.measureToolEdgeWidthInt;
        var lineInvisibleWidthInc = isHover ? 6 : 4;
        var lineColor = getIsShowingHybrid() ? colorTicNormalHybrid : colorTicNormalMap;
        var style = [
            { line: true, line_width: lineVisibleWidth + lineInvisibleWidthInc, line_color: "#000", line_opacity: 5, zindex: minZIndex++ },
            { line: true, line_width: lineVisibleWidth, line_color: lineColor, zindex: minZIndex++ }
        ];
        return style;
    }
    function getClosePolyEdgeStyle(notification) {
        var minZIndex = notification.minZIndex;
        var lineVisibleWidth = 3;
        var lineColor = getIsShowingHybrid() ? "#ddd" : "#777";
        var dashGap = 5;
        var style = { line: true, line_width: lineVisibleWidth, line_color: lineColor, zindex: minZIndex++, line_dash: [dashGap, dashGap], line_opacity: 70 };
        return style;
    }
    function getAreaStyle(notification) {
        var isHover = notification.isHover;
        var minZIndex = notification.minZIndex;
        var fillColor, fillOpacity = isHover ? 35 : 25;
        if (getIsShowingHybrid()) { fillColor = "#bebebe"; }
        else { fillColor = "#fff"; }
        var style = { zindex: minZIndex++, fill: true, fill_color: fillColor, fill_opacity: fillOpacity };
        return style;
    }
    function onPostCompose(notification) {
        //var vertexInfos = lsEdI.getVertexInfos(), nPoints = vertexInfos.length;
        var showingHybrid = getIsShowingHybrid();
        if (lastShowingHybrid != undefined && showingHybrid != lastShowingHybrid) {
            var areaFeature = lsEdI.getAreaFeature(); if (!!areaFeature) { areaFeature.RefreshStyle(); }
            var lineStringFeature = lsEdI.getLineStringFeature(); if (!!lineStringFeature) { lineStringFeature.RefreshStyle(); }
            var closePolyEdgeFeature = lsEdI.getClosePolyEdgeFeature(); if (!!closePolyEdgeFeature) { closePolyEdgeFeature.RefreshStyle(); }
        }
        lastShowingHybrid = showingHybrid;
    }
    function updateForMapType() { settings.map.Render(); }
    function onClear(notification) {
        if (!!onClearCB) { onClearCB({ sender: theThis } ) }
        //console.log('cleared');
    }
    function onLSEdInited(notification) {
        var myInterface = {
            sender: theThis,
            updateForMapType: updateForMapType
        };
        settings.setInterface(tf.js.ShallowMerge(lsEdI = notification, myInterface));
    }
    function onDoubleClickFeature(notification) {
        if (notification.isEditorFeature) {
            var lineStringGeom = lsEdI.getLineStringGeom();
            if (lineStringGeom != undefined) {
                var info = lsEdI.getInfo();
                var lengthOpen = info.lengthOpen != undefined ? info.lengthOpen : 0;
                var geoJSON = {
                    type: "FeatureCollection",
                    features: []
                };
                var lineStringFeature = {
                    type: "Feature",
                    geometry: lineStringGeom,
                    properties: {
                        name: "measure distance linestring",
                        lengthInMeters: lengthOpen
                    }
                };
                geoJSON.features.push(lineStringFeature);
                var polyGeom = lsEdI.getPolygonGeom();
                if (polyGeom != undefined) {
                    var lengthClosed = info.lengthClosed != undefined ? info.lengthClosed : 0;
                    var area = info.area != undefined ? info.area : 0;
                    var polyStringFeature = {
                        type: "Feature",
                        geometry: polyGeom,
                        properties: {
                            name: "measure area polygon",
                            lengthInMeters: lengthClosed,
                            areaInSqMeters: area
                        }
                    };
                    geoJSON.features.push(polyStringFeature);
                }
                var geoJSONWindow = window.open(null, "_blank");
                if (!!geoJSONWindow) {
                    var geoJSONDoc = geoJSONWindow.document;
                    geoJSONDoc.write(JSON.stringify(geoJSON));
                    geoJSONDoc.title = "Measure Tool GeoJSON";
                    geoJSONWindow.focus();
                }
            }
        }
    }
    function initialize() {
        if (tf.js.GetFunctionOrNull(settings.setInterface)) {
            onClearCB = tf.js.GetFunctionOrNull(settings.onClear);
            colorTicNormalMap = "#1E90FF";
            colorTicNormalHybrid = "#fff";
            var textShowSettingsHybrid = { fontFamily: "Roboto", lineWidth: 4, textFill: "#fff", textLine: "rgba(0, 0, 0, 0.7)", fontSize: "12px", fontWeight: "400" };
            var textShowSettingsMap = { fontFamily: "Roboto", lineWidth: 1, textFill: "rgba(30, 144, 255, 1)", textLine: "rgba(0, 0, 0, 0.7)", fontSize: "11px", fontWeight: "300" };
            var commonSettings = tf.js.ShallowMerge(settings, {
                //scaleExtent: 0.7,
                onDoubleClickFeature: onDoubleClickFeature,
                optionalMapTextStyle: textShowSettingsMap,
                optionalHybridTextStyle: textShowSettingsHybrid,
                colorTicNormalMap: colorTicNormalMap,
                colorTicNormalHybrid: colorTicNormalHybrid,
                showMeasures: true,
                requestCloseSender: theThis,
                onClear: onClear,
                onPostCompose: onPostCompose,
                useNativeMapFeatureStyles: false,
                showArea: true,
                getVertexStyle: getVertexStyle,
                getLineStringStyle: getLineStringStyle,
                getAreaStyle: getAreaStyle,
                getClosePolyEdgeStyle: getClosePolyEdgeStyle,
                setInterface: onLSEdInited
            });
            new tf.TFMap.LSEd(commonSettings);
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: downloadtool.js
tf.TFMap.MapDownloadTool = function (settings) {
    var theThis, lsEdI;
    var lastShowingHybrid;
    var colorTicNormalMap, colorTicNormalHybrid;
    var onClearCB;
    function getIsShowingHybrid() { return settings.map.GetMapType() != tf.consts.typeNameMap; }
    function getVertexStyle(notification) {
        var minZIndex = notification.minZIndex;
        var isVertex = notification.isVertex;
        var isHover = notification.isHover;
        var radius = tf.TFMap.LayoutSettings.measureToolVertexRadiusInt;
        if (isHover) { ++radius; }
        var snaptopixel = false;
        var lineColor = isVertex ? "#026" : "#cc4422";
        var style = [{
            snaptopixel: snaptopixel, zindex: minZIndex++,
            circle: true, circle_radius: radius + 8, fill: true, fill_color: "#fff", fill_opacity: 1
        }, {
            snaptopixel: snaptopixel, zindex: minZIndex++,
            circle: true, circle_radius: radius, line: true, fill: true, fill_color: "#fdfdff", line_color: lineColor, line_width: 2, line_opacity: 70, fill_opacity: 100
        }];
        return style;
    }
    function getLineStringStyle(notification) {
        var minZIndex = notification.minZIndex;
        var isHover = notification.isHover;
        var lineVisibleWidth = 7;
        var lineInvisibleWidthInc = isHover ? 6 : 4;
        var lineColor = getIsShowingHybrid() ? colorTicNormalHybrid : colorTicNormalMap;
        var style = [
            { line: true, line_width: lineVisibleWidth + lineInvisibleWidthInc, line_color: "#000", line_opacity: 5, zindex: minZIndex++ },
            { line: true, line_width: lineVisibleWidth, line_color: lineColor, zindex: minZIndex++ }
        ];
        return style;
    }
    function onPostCompose(notification) {
        var vertexInfos = lsEdI.getVertexInfos(), nPoints = vertexInfos.length;
        var showingHybrid = getIsShowingHybrid();
        if (lastShowingHybrid != undefined && showingHybrid != lastShowingHybrid) {
            var areaFeature = lsEdI.getAreaFeature(); if (!!areaFeature) { areaFeature.RefreshStyle(); }
            var lineStringFeature = lsEdI.getLineStringFeature(); if (!!lineStringFeature) { lineStringFeature.RefreshStyle(); }
            var closePolyEdgeFeature = lsEdI.getClosePolyEdgeFeature(); if (!!closePolyEdgeFeature) { closePolyEdgeFeature.RefreshStyle(); }
        }
        lastShowingHybrid = showingHybrid;
    }
    function updateForMapType() { settings.map.Render(); }
    function onClear(notification) {
        if (!!onClearCB) { onClearCB({ sender: theThis }) }
        //console.log('cleared');
    }
    function onLSEdInited(notification) {
        var myInterface = { sender: theThis, updateForMapType: updateForMapType };
        settings.setInterface(tf.js.ShallowMerge(lsEdI = notification, myInterface));
    }
    function initialize() {
        if (tf.js.GetFunctionOrNull(settings.setInterface)) {
            var ls = tf.TFMap.LayoutSettings;
            onClearCB = tf.js.GetFunctionOrNull(settings.onClear);
            colorTicNormalMap = "#1E90FF";
            colorTicNormalHybrid = "#fff";
            var textShowSettingsHybrid = { fontFamily: "Roboto", lineWidth: 4, textFill: "#fff", textLine: "rgba(0, 0, 0, 0.5)", fontSize: "12px", fontWeight: "400" };
            var textShowSettingsMap = { fontFamily: "Roboto", lineWidth: 1, textFill: "rgba(30, 144, 255, 1)", textLine: "rgba(0, 0, 0, 0.7)", fontSize: "11px", fontWeight: "300" };
            var colorSegHybrid = ls.lightTextColor;
            var colorSegMap = ls.darkTextColor;
            var commonSettings = tf.js.ShallowMerge(settings, {
                //scaleExtent: 0.7,
                optionalColorSegMap: ls.backgroundLivelyColor,
                optionalColorSegHybrid: "#fff",
                optionalSegWidth: 3,
                optionalExtentColorSegMap: colorSegMap,
                optionalExtentColorSegHybrid: colorSegHybrid,
                optionalExtentSegWidth: 2,
                optionalMapTextStyle: textShowSettingsMap,
                optionalHybridTextStyle: textShowSettingsHybrid,
                colorTicNormalMap: colorTicNormalMap,
                colorTicNormalHybrid: colorTicNormalHybrid,
                maxPoints: 2,
                showMeasures: true,
                requestCloseSender: theThis,
                onClear: onClear,
                onPostCompose: onPostCompose,
                useNativeMapFeatureStyles: false,
                showArea: false,
                showExtent: true,
                getVertexStyle: getVertexStyle,
                getLineStringStyle: getLineStringStyle,
                setInterface: onLSEdInited
            });
            new tf.TFMap.LSEd(commonSettings);
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: moremaptools.js
tf.TFMap.MoreMapTools = function (settings) {
    var theThis, cssTag, wrapper;
    var measureButton, distanceAreaButton, measureGeomUpdateListener;
    var mainMeasureToolTipText;
    var clearMeasurePointsButton;
    var measureButtonAndToolBar;
    var downloadButton, downloadButtonAndToolBar, downloadGeomUpdateListener;
    var downloadInformationAreaButton, downloadMapExtent, clearDownloadPointsButton;
    this.UpdateToolsVisibility = function () {
        if (settings.measure) {
            var isOn = isMeasureToolOn();
            if (isOn) {
                if (measureGeomUpdateListener == undefined) {
                    var measureTool = getMeasureToolFromContent();
                    if (!!measureTool) { measureGeomUpdateListener = measureTool.addUpdateGeomListener(onMeasureGeomUpdated); } else { isOn = false; }
                }
            }
            tf.dom.ReplaceCSSClassCondition(measureButtonAndToolBar.infoWrapper, isOn, infoContentVisibleClassName, infoContentHiddenClassName);
        }
        if (settings.download) {
            var isOn = isDownloadToolOn();
            if (isOn) {
                if (downloadGeomUpdateListener == undefined) {
                    var downloadTool = getDownloadToolFromContent();
                    if (!!downloadTool) { downloadGeomUpdateListener = downloadTool.addUpdateGeomListener(onDownloadGeomUpdated); } else { isOn = false; }
                }
            }
            tf.dom.ReplaceCSSClassCondition(downloadButtonAndToolBar.infoWrapper, isOn, infoContentVisibleClassName, infoContentHiddenClassName);
        }
    }
    this.GetWrapper = function () { return wrapper; }
    function getMeasureToolFromContent() { return settings.appContent.GetMeasureToolInterface(); }
    function getDownloadToolFromContent() { return settings.appContent.GetDownloadToolInterface(); }
    function updateMeasureContent(measureTool) {
        var distanceAreaButtonText = "";
        var contentText = "";
        var hintText = "click map to add points";
        var showClearPoints = true;
        if (!!measureTool) {
            var info = measureTool.getInfo();
            var showsArea = measureTool.getShowArea();
            distanceAreaButtonText = showsArea ? "Distance<br />and Area" : " Distance<br />only";
            if (info.nPoints >= 2) {
                var distances = info.lastDrawResult.distances;
                if (showsArea && info.nPoints > 2 && info.lengthClosed != undefined) {
                    var lengthClosedStr = tf.js.FormatDistanceText(info.lengthClosed, distances.distanceUnitText, false);
                    var areaStr = tf.js.FormatDistanceText(info.area, distances.distanceUnitText, true);
                    contentText += lengthClosedStr + " : " + areaStr;
                }
                else {
                    if (info.lengthOpen != undefined) {
                        var lengthOpenStr = tf.js.FormatDistanceText(info.lengthOpen, distances.distanceUnitText, false);
                        contentText += lengthOpenStr;
                    }
                }
                hintText = "click map to add more points";
                //var vertexInfos = measureTool.getVertexInfos(), vi = vertexInfos[0];
                //console.log(tf.units.GetHaversineDistance(vi.coords, vi.nextCoords));
            }
            else if (info.nPoints >= 1) {
                contentText = "additional point needed";
            }
            else {
                showClearPoints = false;
                contentText = "two points needed";
            }
        }
        clearMeasurePointsButton.GetButton().style.display = showClearPoints ? "block" : "none";
        distanceAreaButton.GetButton().innerHTML = distanceAreaButtonText;
        setContent(measureButtonAndToolBar.infoContentTop, contentText);
        setContent(measureButtonAndToolBar.infoContentBottom, hintText);
    }
    function onMeasureGeomUpdated(notification) { updateMeasureContent(notification.senderI); }
    function updateDownloadContent(downloadTool) {
        var distanceAreaButtonText = "";
        var contentText = "";
        var hasPoints = false;
        var hintText = "click map to add points";
        downloadMapExtent = undefined;
        if (!!downloadTool) {
            var info = downloadTool.getInfo();
            if (info.nPoints >= 2) {
                var lastExtentDrawResult = info.lastExtentDrawResult;
                var distances = lastExtentDrawResult.distances;
                var area = lastExtentDrawResult.area;
                var lengthStr = tf.js.FormatDistanceText(lastExtentDrawResult.totalDistance, distances.distanceUnitText, false);
                var areaStr = tf.js.FormatDistanceText(area, distances.distanceUnitText, true);
                downloadMapExtent = (area != 0 && lastExtentDrawResult.vertexExtent != undefined) ? lastExtentDrawResult.vertexExtent.slice(0) : undefined;
                contentText += lengthStr + " : " + areaStr;
                hintText = "drag points to adjust area";
                hasPoints = true;
            }
            else if (info.nPoints >= 1) {
                contentText = "additional point needed";
                hasPoints = true;
            }
            else {
                contentText = "two points needed";
            }
        }
        var displayDownloadStr = downloadMapExtent != undefined ? "block" : "none";
        var displayClearStr = hasPoints ? "block" : "none";
        clearDownloadPointsButton.GetButton().style.display = displayClearStr;
        downloadInformationAreaButton.GetButton().style.display = displayDownloadStr;
        setContent(downloadButtonAndToolBar.infoContentTop, contentText);
        setContent(downloadButtonAndToolBar.infoContentBottom, hintText);
    }
    function onDownloadGeomUpdated(notification) { updateDownloadContent(notification.senderI); }
    function doDownload() {
        if (downloadMapExtent != undefined) {
            var appContent = settings.appContent, map = appContent.GetMap();
            var passthroughParam = settings.appContent.GetVidPassThrough().passThrough;
            if (!passthroughParam) { passthroughParam = ''; }
            var strUrl =
                "http://vn4.cs.fiu.edu/cgi-bin/tfrectdisp.cgi?" +
                passthroughParam +
                "&dt=51306.25" +
                "&X1l=" + downloadMapExtent[0] +
                "&Y1l=" + downloadMapExtent[3] +
                "&X2l=" + downloadMapExtent[2] +
                "&Y2l=" + downloadMapExtent[1] +
                "&Source=best_available" +
                "&Res=" + map.GetResolution() +
                "&Overlay=wcity";
            window.open(strUrl, "_blank");
        }
    }
    function onButtonClicked(notification) {
        var appContent = settings.appContent;
        var measureTool = getMeasureToolFromContent();
        var downloadTool = getDownloadToolFromContent();
        switch (notification.sender) {
            case downloadInformationAreaButton:
                doDownload();
                break;
            case clearDownloadPointsButton:
                if (!!downloadTool) { downloadTool.clear(); }
                break;
            case downloadButton:
                appContent.ToggleDownloadTool();
                break;
            case clearMeasurePointsButton:
                if (!!measureTool) { measureTool.clear(); }
                break;
            case distanceAreaButton:
                if (!!measureTool) { measureTool.setShowArea(!measureTool.getShowArea()); }
                break;
            case measureButton:
                appContent.ToggleMeasureTool();
                break;
        }
    }
    function isMeasureToolOn() { return settings.appContent.IsMeasureToolOn(); }
    function isDownloadToolOn() { return settings.appContent.IsDownloadToolOn(); }
    function getMeasureToolToolTipText() { return isMeasureToolOn() ? "Hide measurements" : mainMeasureToolTipText; }
    function getDownloadToolToolTipText() { return isDownloadToolOn() ? "Hide download information area" : "Download information"; }
    function getDistanceAreaToolTipText() {
        var toolTipText;
        var measureTool = getMeasureToolFromContent();
        if (!!measureTool) {
            var showArea = measureTool.getShowArea();
            var areasAndDistancesStr = "distance <u>and</u> area";
            var distancesOnlyStr = "distance <u>only</u>";
            var topLineStr = "Measuring " + (showArea ? areasAndDistancesStr : distancesOnlyStr);
            var newSettingsStr = showArea ? distancesOnlyStr : areasAndDistancesStr;
            return tf.TFMap.MapTwoLineSpan(topLineStr, "Switch to " + newSettingsStr);
        }
        else { toolTipText = mainMeasureToolTipText; }
        return toolTipText;
    }
    function setContent(contentContainer, contentText) { contentContainer.GetHTMLElement().innerHTML = contentText; }
    function createButtonAndToolBar(buttonSettings, svgHTML, toolTipText, toolBarButtonsElems, toolBarPostButtonsElems, addMarginLeft) {
        var ls = tf.TFMap.LayoutSettings;
        var appContent = settings.appContent;
        var infoWrapper = new tf.dom.Div({ cssClass: infoWrapperClassName });
        var infoContentWrapper = new tf.dom.Div({ cssClass: infoContentWrapperClassName });
        var infoContentTop = new tf.dom.Div({ cssClass: infoContentClassName });
        var infoContentBottom = new tf.dom.Div({ cssClass: infoBottomClassName });
        var buttonFullClassName = ls.aerialOrMapColorScheme + " " + buttonSVGClassName + " " + buttonClassName;
        if (addMarginLeft) { buttonFullClassName += " " + marginLeftClassName; }
        var button = appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, {
            svgHTML: svgHTML, buttonClass: buttonFullClassName + " ripple", toolTipText: toolTipText
        }));
        infoContentWrapper.AddContent(infoContentTop, infoContentBottom);
        for (var i in toolBarButtonsElems) { infoWrapper.AddContent(toolBarButtonsElems[i]); }
        infoWrapper.AddContent(infoContentWrapper);
        for (var i in toolBarPostButtonsElems) { infoWrapper.AddContent(toolBarPostButtonsElems[i]); }
        return { infoWrapper: infoWrapper, infoContentWrapper: infoContentWrapper, infoContentTop: infoContentTop, infoContentBottom: infoContentBottom, button: button };
    }
    function createClearPointsButton(buttonSettings) {
        var cpb = settings.appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, {
            toolTipClass: "*start", buttonClass: textButtonClassName + " ripple", toolTipText: "Remove all points from the map"
        }));
        var cpbButton = cpb.GetButton();
        cpbButton.innerHTML = "Clear<br />Points";
        return cpb;
    }
    function createControl() {
        var ls = tf.TFMap.LayoutSettings;
        wrapper = new tf.dom.Div({ cssClass: wrapperClassName + " " + ls.aerialOrMapColorScheme });
        var appContent = settings.appContent;
        var delayMillis = tf.TFMap.toolTipDelayMillis;
        var toolTipClass = "*start";
        var toolTipArrowClass = "bottom";
        var buttonSettings = {
            onClick: onButtonClicked, onHover: undefined, wrapper: wrapper, delayMillis: delayMillis, toolTipClass: toolTipClass, toolTipArrowClass: toolTipArrowClass
        };
        var buttonWasAdded = false;
        var buttonClassNameUse = ls.aerialOrMapColorScheme + " " + textButtonClassName + " ripple";
        if (settings.measure) {
            clearMeasurePointsButton = createClearPointsButton(buttonSettings);
            distanceAreaButton = appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, {
                buttonClass: buttonClassNameUse, toolTipText: getDistanceAreaToolTipText
            }));
            measureButtonAndToolBar = createButtonAndToolBar(buttonSettings, appContent.GetAppStyles().GetMeasureSVG(), getMeasureToolToolTipText,
                [distanceAreaButton.GetButton()], [clearMeasurePointsButton.GetButton()], buttonWasAdded);
            measureButton = measureButtonAndToolBar.button;
            wrapper.AddContent(measureButton.GetButton(), measureButtonAndToolBar.infoWrapper);
            buttonWasAdded = true;
        }
        if (settings.download) {
            clearDownloadPointsButton = createClearPointsButton(buttonSettings);
            downloadInformationAreaButton = appContent.CreateButton(tf.js.ShallowMerge(buttonSettings, {
                toolTipClass: "*start", buttonClass: buttonClassNameUse, toolTipText: "Download information from selected area"
            }));
            var downloadInformationAreaButtonButton = downloadInformationAreaButton.GetButton();
            downloadInformationAreaButtonButton.innerHTML = "Download<br />Information";
            downloadButtonAndToolBar = createButtonAndToolBar(buttonSettings, appContent.GetAppStyles().GetDownloadSVG(), getDownloadToolToolTipText,
                [downloadInformationAreaButtonButton], [clearDownloadPointsButton.GetButton()], buttonWasAdded);
            downloadButton = downloadButtonAndToolBar.button;
            wrapper.AddContent(downloadButton.GetButton(), downloadButtonAndToolBar.infoWrapper);
            buttonWasAdded = true;
        }
        theThis.UpdateToolsVisibility();
    }
    var wrapperClassName, buttonClassName, buttonSVGClassName, infoBottomClassName, textButtonClassName, marginLeftClassName;
    var infoWrapperClassName, infoContentClassName, infoContentWrapperClassName, infoContentVisibleClassName, infoContentHiddenClassName;
    function createCSSClassNames() {
        wrapperClassName = tf.TFMap.CreateClassName(cssTag, "Wrapper");
        buttonClassName = tf.TFMap.CreateClassName(cssTag, "Button");
        buttonSVGClassName = tf.TFMap.CreateClassName(cssTag, "ButtonSVG");
        textButtonClassName = tf.TFMap.CreateClassName(cssTag, "textButton");
        infoWrapperClassName = tf.TFMap.CreateClassName(cssTag, "InfoWrapper");
        infoContentWrapperClassName = tf.TFMap.CreateClassName(cssTag, "InfoContentWrapper");
        infoContentClassName = tf.TFMap.CreateClassName(cssTag, "InfoContent");
        infoBottomClassName = tf.TFMap.CreateClassName(cssTag, "InfoContentBottom");
        infoContentVisibleClassName = tf.TFMap.CreateClassName(cssTag, "InfoContentVisible");
        infoContentHiddenClassName = tf.TFMap.CreateClassName(cssTag, "InfoContentHidden");
        marginLeftClassName = tf.TFMap.CreateClassName(cssTag, "MarginRight");
    }
    function createCSSClasses() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var cssClasses = [];
        var ls = tf.TFMap.LayoutSettings;
        var darkTextColor = ls.darkTextColor;
        var widthMapToolBarInt = ls.widthMapToolBarInt, widthMapToolBarPx = widthMapToolBarInt + 'px';
        var scaleLineHeightInt = ls.scaleLineHeightInt;
        cssClasses[wrapperClassName] = {
            inherits: [CSSClasses.whiteSpaceNoWrap, CSSClasses.boxShadow002003, CSSClasses.pointerEventsAll, CSSClasses.positionAbsolute,
                CSSClasses.displayFlex, CSSClasses.flexFlowRowNoWrap],
            borderRadius: "4px",
            //bottom: ls.topMarginInt + 'px',
            bottom: "0px",  // anchored to other toolbar
            //right: ls.moreMapToolsRightInt + 'px',
            //right: (ls.widthMapToolBarInt + ls.leftMarginInt + ls.toolBarToToolBarHorSpacingInt) + "px",
            //left: "calc(-100%)",
            right: "calc(100% + " + (ls.toolBarToToolBarHorSpacingInt) + "px)",
            padding: "2px"
        };
        cssClasses[buttonSVGClassName] = { inherits: [CSSClasses.boxShadow002003, CSSClasses.displayInlineBlock] };
        cssClasses[buttonSVGClassName + " svg"] = { width: "calc(100% - 1px)", height: "calc(100% - 1px)", margin: "auto" };
        //cssClasses[buttonSVGClassName + ":hover"] = { border: "none" };
        cssClasses[buttonClassName] = {
            inherits: [CSSClasses.baseImageButton, CSSClasses.verticalAlignMiddle],
            width: widthMapToolBarPx, height: widthMapToolBarPx,
            borderRadius: "2px",
            border: "1px solid transparent"
        };
        cssClasses[buttonClassName + ":hover"] = {
            border: "none"
        }
        var marginLeftDisplace = "-2px";
        var fontSizePx = ls.moreMapToolsFontSizeInt + 'px';
        var lineHeightPx = ls.moreMapToolsLineHeightInt + 'px';
        var fontSizeLineHeight = { fontSize: fontSizePx, lineHeight: lineHeightPx };
        cssClasses[textButtonClassName] = {
            inherits: [CSSClasses.transparentImageButton, fontSizeLineHeight],
            borderRadius: "0px",
            border: "1px solid",
            borderLeft: "0px", borderRight: "0px",
            fontWeight: "600", paddingLeft: "4px", paddingRight: "4px",
            height: widthMapToolBarPx, marginLeft: marginLeftDisplace
        };
        cssClasses[infoWrapperClassName] = {
            inherits: [CSSClasses.transitionWithColor, CSSClasses.displayFlex, CSSClasses.flexFlowRowNoWrap]
        };
        cssClasses[infoContentWrapperClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.displayFlex, CSSClasses.flexFlowColumnNoWrap, CSSClasses.lightBackground, CSSClasses.darkTextShadow,
            fontSizeLineHeight],
            marginLeft: "4px", marginRight: "1px", paddingTop: "1px", paddingBottom: "1px", paddingLeft: "5px", paddingRight: "5px",
            borderLeft: "1px solid", borderRight: "1px solid",
            zIndex: '' + (ls.rootDivZIndex + ls.moreMapToolsInfoContentWrapperZIndexAdd),
            borderRadius: "8px",
            fontWeight: "600",
            marginLeft: marginLeftDisplace
        };
        cssClasses[infoContentClassName] = {
            inherits: [CSSClasses.overflowHidden, CSSClasses.whiteSpaceNoWrap, CSSClasses.displayBlock, CSSClasses.flexFlowRowNoWrap, CSSClasses.flexGrowOne, CSSClasses.flexShrinkZero],
            textAlign: "center",
            marginTop: "1px", marginBottom: "0px"
        };
        cssClasses[infoBottomClassName] = {
            inherits: [cssClasses[infoContentClassName], CSSClasses.flexGrowZero, CSSClasses.flexShrinkOne, fontSizeLineHeight],
            fontWeight: "500", textAlign: "left", marginTop: "0px", marginBottom: "1px"
        };
        cssClasses[infoContentVisibleClassName] = { inherits: [CSSClasses.overflowVisible], width: "initial", opacity: "1" };
        cssClasses[infoContentHiddenClassName] = { inherits: [CSSClasses.overflowHidden], width: "1px", opacity: "0" };
        cssClasses[infoContentVisibleClassName + " ." + infoContentClassName] = { color: darkTextColor };
        cssClasses[infoContentHiddenClassName + " ." + infoContentClassName] = { color: "white" };
        cssClasses[infoContentVisibleClassName + " ." + infoBottomClassName] = { color: "black" };
        cssClasses[infoContentHiddenClassName + " ." + infoBottomClassName] = { color: "white" };
        cssClasses[marginLeftClassName] = { marginLeft: "8px" };
        return cssClasses;
    }
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function onLayoutChange(notification) { registerCSSClasses(); }
    var lcl;
    function initialize() {
        cssTag = 'mapMoreTools';
        mainMeasureToolTipText = "Measure distance and area";
        createCSSClassNames();
        registerCSSClasses();
        createControl();
        lcl = settings.appContent.GetAppStyles().AddOnLayoutChangeListener(onLayoutChange);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: customappcontent.js
tf.TFMap.KeyedListItemContentStartVerb = "start";
tf.TFMap.KeyedListItemContentEndVerb = "end";
tf.TFMap.KeyedListItemContentAddVerb = "add";
tf.TFMap.KeyedListItemContentDelVerb = "del";
tf.TFMap.KeyedListItemContentUpdateVerb = "upd";
tf.TFMap.KeyedListContent = function (settings) {
    var theThis, contentInItemAttributeName, itemInContentAttributeName, spareContents;
    this.GetItemFromContent = function (content) { return !!content ? content[itemInContentAttributeName] : undefined; }
    this.GetContentFromItem = function (item) { return !!item ? item[contentInItemAttributeName] : undefined; }
    this.OnKLChange = function (notification) {
        addContents(notification.addedItems);
        updateContents(notification.updatedItems);
        deleteContents(notification.deletedItems);
        sortIfNeeded();
    }
    this.UpdateContentForItem = function (item) {
        return settings.updateContentForItem(item);
    }
    function sortAndCheckIfChanged(compareFnc) {
        var isSorted = true, sortedContent;
        if (tf.js.GetFunctionOrNull(compareFnc)) {
            var KL = settings.KL, count = KL.GetItemCount();
            if (count > 1) {
                var items = settings.KL.GetKeyedItemList();
                var itemsToSort = [];
                sortedContent = [];
                for (var i in items) {
                    var item = items[i], content = theThis.GetContentFromItem(item);
                    if (!!content) { itemsToSort.push(item); sortedContent.push({ item: item, itemData: item.GetData(), content: content }); }
                }
                if ((count = itemsToSort.length) > 0) {
                    sortedContent.sort(compareFnc);
                    for (var i = 0; i < count && isSorted ; ++i) {
                        isSorted = sortedContent[i].item == itemsToSort[i];
                    }
                }
            }
        }
        return { isSorted: isSorted, sortedContent: sortedContent };
    }
    function sortIfNeeded() {
        var checkResult = sortAndCheckIfChanged(settings.compareContent);
        if (!checkResult.isSorted) {
            var sortedContent = checkResult.sortedContent, count = sortedContent.length;
            var contentWrapper = settings.contentWrapper;
            var wrapperE = contentWrapper.GetHTMLElement(), wrapperES = wrapperE.style;
            var visibleVerb = tf.js.GetNonEmptyString(settings.contentWrapperDisplayVisibleVerb, "block");
            wrapperES.display = 'none';
            settings.contentWrapper.ClearContent();
            for (var i = 0; i < count ; ++i) { contentWrapper.AddContent(sortedContent[i].content.wrapper); }
            wrapperES.display = visibleVerb;
            //console.log('sorted');
        }
    }
    function createNewContent(item) {
        return settings.createNewContent(item);
    }
    function setContentToItem(item, content) {
        if (!!item && !!content) {
            item[contentInItemAttributeName] = content;
            content[itemInContentAttributeName] = item;
            settings.contentWrapper.AddContent(content.wrapper);
        }
    }
    function delContentFromItem(item) {
        var content = theThis.GetContentFromItem(item);
        if (!!content) {
            settings.contentWrapper.RemoveContent(content.wrapper);
            delete item[contentInItemAttributeName];
            delete content[itemInContentAttributeName];
            spareContents.push(content);
        }
    }
    function createOrGetSpareContent(item) {
        var newOrSpareContent;
        if (spareContents.length > 0) {
            newOrSpareContent = spareContents.pop();
            if (tf.js.GetFunctionOrNull(settings.prepareSpareContent)) {
                newOrSpareContent = settings.prepareSpareContent(newOrSpareContent, item);
            }
        }
        else {
            newOrSpareContent = createNewContent(item);
        }
        return newOrSpareContent;
    }
    function createContentForItem(item) { if (!!item) { setContentToItem(item, createOrGetSpareContent(item)); theThis.UpdateContentForItem(item); }; }
    function addContents(items) { for (var i in items) { createContentForItem(items[i]); } }
    function updateContents(items) { for (var i in items) { theThis.UpdateContentForItem(items[i]); } }
    function deleteContents(items) { for (var i in items) { delContentFromItem(items[i]); } }
    function initialize() {
        contentInItemAttributeName = tf.js.GetNonEmptyString(settings.contentInItemAttributeName, "contentInItem");
        itemInContentAttributeName = tf.js.GetNonEmptyString(settings.itemInContentAttributeName, "itemInContent");
        spareContents = [];
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.TFMap.KeyedListPointFeatures = function (settings) {
    var theThis, mapFeatureInItemAttributeName, itemInMapFeatureAttributeName, selectedMapFeature, getOptionalSettingsCB;
    this.RefreshStyles = function (KL) {
        if (!!KL) {
            var items = KL.GetKeyedItemList();
            for (var i in items) {
                var item = items[i], mapFeature = theThis.GetMapFeatureFromItem(item);
                if (!!mapFeature) { mapFeature.RefreshStyle(); }
            }
        }
    }
    this.RefreshPositions = function (KL) {
        if (!!KL) {
            var items = KL.GetKeyedItemList();
            for (var i in items) {
                var item = items[i], mapFeature = theThis.GetMapFeatureFromItem(item);
                if (!!mapFeature) {
                    var itemData = item.GetData();
                    mapFeature.SetPointCoords(itemData.coords);
                }
            }
        }
    }
    this.GetSelectedMapFeature = function () { return selectedMapFeature; }
    this.SetSelectedMapFeature = function (newSelectedMapFeature) {
        if (newSelectedMapFeature != selectedMapFeature) {
            if (!!selectedMapFeature) { selectedMapFeature.SetIsAlwaysInHover(false); }
            if (selectedMapFeature = newSelectedMapFeature) { selectedMapFeature.SetIsAlwaysInHover(true); }
        }
    }
    this.OnKLChange = function (notification) {
        addMapFeatures(notification.addedItems);
        updateMapFeatures(notification.updatedItems);
        deleteMapFeatures(notification.deletedItems);
    }
    this.GetMapFeatureFromItem = function (item) { return getMapFeatureFromItem(item); }
    this.GetItemFromMapFeature = function (mapFeature) { return getItemFromMapFeature(mapFeature); }
    function getItemFromMapFeature(mapFeature) { return !!mapFeature ? mapFeature[itemInMapFeatureAttributeName] : undefined; }
    function getMapFeatureFromItem(item) { return !!item ? item[mapFeatureInItemAttributeName] : undefined; }
    function setMapFeatureToItem(item, mapFeature) { if (!!item && !!mapFeature) { item[mapFeatureInItemAttributeName] = mapFeature; mapFeature[itemInMapFeatureAttributeName] = item } }
    function delMapFeatureFromItem(item) { var mapFeature = getMapFeatureFromItem(item); if (!!mapFeature) { delete item[mapFeatureInItemAttributeName]; delete mapFeature[itemInMapFeatureAttributeName]; } }
    function createMapFeatureForItem(item) {
        var mapFeature;
        if (!!item) {
            var itemData = item.GetData();
            var mapFeatureGeom = { type: 'point', coordinates: itemData.coords.slice(0) };
            var optionalSettings = !!getOptionalSettingsCB ? getOptionalSettingsCB({ sender: theThis, item: item, itemData: itemData }) : undefined;
            mapFeature = new tf.map.Feature(tf.js.ShallowMerge(settings.styles, mapFeatureGeom, optionalSettings, { onCustomAppClick: settings.onClick }));
            setMapFeatureToItem(item, mapFeature);
        }
        return mapFeature;
    }
    function addMapFeatures(items) {
        var layer = settings.layer, toolTipProps = settings.toolTipProps;
        for (var i in items) {
            var item = items[i], mapFeature = createMapFeatureForItem(item);
            if (!!toolTipProps) { tf.TFMap.SetMapFeatureToolTipProps(mapFeature, toolTipProps); }
            layer.AddMapFeature(mapFeature, true);
        }
        layer.AddWithheldFeatures();
    }
    function updateMapFeatures(items) {
        for (var i in items) {
            var item = items[i], mapFeature = getMapFeatureFromItem(item);
            if (!!mapFeature) {
                var itemData = item.GetData();
                mapFeature.SetPointCoords(itemData.coords);
                if (!!settings.refreshStyleOnUpdate) { mapFeature.RefreshStyle(); }
            }
        }
    }
    function deleteMapFeatures(items) {
        var layer = settings.layer;
        var appCtx = settings.appContent.GetAppCtx();
        var curToolTipSender = appCtx.GetCtxAttribute(tf.TFMap.CAN_selectedToolTipSender);
        var ndel = 0;
        for (var i in items) {
            var item = items[i], mapFeature = getMapFeatureFromItem(item);
            if (!!mapFeature) {
                if (selectedMapFeature == mapFeature) { selectedMapFeature = undefined; }
                if (curToolTipSender == mapFeature) {
                    appCtx.SetCtxAttribute(tf.TFMap.CAN_selectedToolTipSender, undefined);
                    //console.log('deselected deleted custom map feature tooltip');
                }
                layer.DelMapFeature(mapFeature, true);
                delMapFeatureFromItem(item);
                ++ndel;
            }
        }
        layer.DelWithheldFeatures();
    }
    function initialize() {
        getOptionalSettingsCB = tf.js.GetFunctionOrNull(settings.getOptionalSettings);
        mapFeatureInItemAttributeName = tf.js.GetNonEmptyString(settings.mapFeatureInItemAttributeName, "mapFeatureInItem");
        itemInMapFeatureAttributeName = tf.js.GetNonEmptyString(settings.itemInMapFeatureAttributeName, "itemInMapFeature");
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.TFMap.CustomAppContent = function (settings) {
    var theThis, cssTag, isVisible, sidePanelWidthInt, sidePanelWidthSmallInt;
    var wrapper, contentWrapper, toggleButton;
    var adjustingStyles;
    var toggleButtonWrapper, toggleButtonHidden;
    var classNames;
    var mainToolBarButtonDimInt, vertListWithFadePaddingTopBotInt;
    var onMapPostComposeCB;
    this.OnMapPostCompose = function (notification) { if (!!onMapPostComposeCB) { onMapPostComposeCB(notification); } }
    this.UpdateForMapType = function () {
        if (tf.js.GetFunctionOrNull(settings.updateForMapType)) {
            settings.updateForMapType({ sender: theThis });
        }
    }
    function getToggleButtonHidden() { return toggleButtonHidden; }
    function setToggleButtonHidden(newHidden) {
        if (toggleButtonHidden != (newHidden = !!newHidden)) {
            toggleButtonHidden = newHidden;
            toggleButtonWrapper.GetHTMLElement().style.display = toggleButtonHidden ? "none" : "block";
        }
    }
    function getWrapper() { return wrapper; }
    function getContentWrapper() { return contentWrapper; }
    function getSettings () { return settings; }
    function getWidthInt() { return sidePanelWidthInt; }
    function getWidthIntSmall() { return sidePanelWidthSmallInt; }
    function getCurrentWidthInt() { return settings.appContent.GetAppStyles().GetIsSmallScreen() ? sidePanelWidthSmallInt : sidePanelWidthInt; }
    function getIsVisible() { return isVisible; }
    function setVisible(isVisibleSet) {
        if (isVisible != (isVisibleSet = !!isVisibleSet)) {
            isVisible = isVisibleSet;
            tf.dom.ReplaceCSSClassCondition(wrapper, isVisible, classNames.visibleClassName, classNames.collapsedClassName);
            toggleButton.SetIsToggled(isVisible);
            adjustStyles();
            if (tf.js.GetFunctionOrNull(settings.onVisibilityChange)) {
                settings.onVisibilityChange({ sender: theThis, isVisible: isVisible });
            }
        }
    }
    function adjustStyles() {
        var appContent = settings.appContent, rootDiv = appContent.GetRootDiv(), rootDivE = rootDiv.GetHTMLElement(), rootDivS = rootDivE.style;
        var desiredWidth = isVisible ? "calc(100% - " + (getCurrentWidthInt()) + "px)" : "100%";
        if (!adjustingStyles && desiredWidth != rootDivS.width) {
            adjustingStyles = true;
            rootDivS.width = desiredWidth;
            appContent.OnLayoutChange();
            adjustingStyles = false;
        }
    }
    function onToggleButtonClick(notification) { setVisible(!isVisible); }
    function getToggleButtonToolTipText() {
        var toolTipText;
        if (tf.js.GetFunctionOrNull(settings.toggleButtonToolTipText)) { toolTipText = settings.toggleButtonToolTipText(); }
        else if (tf.js.GetIsNonEmptyString(settings.toggleButtonToolTipText)) { toolTipText = settings.toggleButtonToolTipText; }
        else { toolTipText = isVisible ? "Collapse application panel" : "Expand application panel"; }
        return toolTipText;
    }
    function createControl() {
        var delayMillis = 0, toolTipClass = "center", toolTipArrowClass = "right", toolTipStyle = undefined;
        var ls = tf.TFMap.LayoutSettings;
        var appContent = settings.appContent;
        var shouldBeVisible = !!settings.visible;
        toggleButtonWrapper = new tf.dom.Div({ cssClass: classNames.toggleButtonWrapperClassName });
        wrapper = new tf.dom.Div({ cssClass: classNames.wrapperClassName });
        var buttonSettings = {
            onHover: undefined, wrapper: toggleButtonWrapper, delayMillis: delayMillis, toolTipClass: toolTipClass, toolTipArrowClass: toolTipArrowClass, toolTipStyle: toolTipStyle
        };
        toggleButton = appContent.CreateToggleButton(tf.js.ShallowMerge(buttonSettings, {
            offsetX: 4,
            onClick: onToggleButtonClick,
            buttonClass: classNames.toggleButtonClassName + " ripple", classToggled: ls.arrowRightBackgroundClassName, classNotToggled: ls.arrowLeftBackgroundClassName,
            isToggled: shouldBeVisible, toolTipText: getToggleButtonToolTipText
        }));
        toggleButtonWrapper.AddContent(toggleButton.GetButton());
        setToggleButtonHidden(!!settings.toggleButtonHidden);
        contentWrapper = createContentWrapper();
        wrapper.AddContent(toggleButtonWrapper, contentWrapper);
        setVisible(shouldBeVisible);
        appContent.GetAppDiv().AddContent(wrapper);
    }
    function createCSSClassNames() {
        classNames = {
            wrapperClassName: tf.TFMap.CreateClassName(cssTag, "Wrapper"),
            collapsedClassName: tf.TFMap.CreateClassName(cssTag, "Collapsed"),
            visibleClassName: tf.TFMap.CreateClassName(cssTag, "Visible"),
            toggleButtonWrapperClassName: tf.TFMap.CreateClassName(cssTag, "ToggleButtonWrapper"),
            toggleButtonClassName: tf.TFMap.CreateClassName(cssTag, "ToggleButton"),
            topCaptionClassName: tf.TFMap.CreateClassName(cssTag, "TopCaption"),
            fullWidthClassName: tf.TFMap.CreateClassName(cssTag, "FullWidthNoOverflow"),
            captionLogoClassName: tf.TFMap.CreateClassName(cssTag, "CaptionLogo"),
            captionTitleClassName: tf.TFMap.CreateClassName(cssTag, "CaptionTitle"),
            captionDescClassName: tf.TFMap.CreateClassName(cssTag, "CaptionDesc"),
            captionTitleDescWrapperClassName: tf.TFMap.CreateClassName(cssTag, "TitleDescWrapper"),
            footerWrapperClassName: tf.TFMap.CreateClassName(cssTag, "FooterWrapper"),
            footerContentClassName: tf.TFMap.CreateClassName(cssTag, "FooterContent"),
            fullWidthWithPaddingClassName: tf.TFMap.CreateClassName(cssTag, "FullWidthWithPadding"),
            toolBarWrapperClassName: tf.TFMap.CreateClassName(cssTag, "ToolBarWrapper"),
            toolBarContentClassName: tf.TFMap.CreateClassName(cssTag, "ToolBarContent"),
            mainToolBarContentClassName: tf.TFMap.CreateClassName(cssTag, "MainToolBarContent"),
            toolBarButtonClassName: tf.TFMap.CreateClassName(cssTag, "ToolBarButton"),
            mainToolBarButtonClassName: tf.TFMap.CreateClassName(cssTag, "MainToolBarButton"),
            variableFontSizeClassName: tf.TFMap.CreateClassName(cssTag, "variableFontSize"),
            nonScrollVariableHeightClassName: tf.TFMap.CreateClassName(cssTag, "NonScroll"),
            toolBarSpanClasses: tf.TFMap.CreateClassName(cssTag, "ToolBarSpan"),
            mainToolBarSpanClasses: tf.TFMap.CreateClassName(cssTag, "MainToolBarSpan"),
            borderTopClassName: tf.TFMap.CreateClassName(cssTag, "BorderTop"),
            fadeTopClassName: tf.TFMap.CreateClassName(cssTag, "FadeTop"),
            fadeBotClassName: tf.TFMap.CreateClassName(cssTag, "FadeBot"),
            minHeightPaneClassName: tf.TFMap.CreateClassName(cssTag, "MinHeightPane"),
            minHeightListClassName: tf.TFMap.CreateClassName(cssTag, "MinHeightList")
        };
    }
    function createCSSClasses() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var cssClasses = [];
        var ls = tf.TFMap.LayoutSettings;
        var isSmallScreen = appStyles.GetIsSmallScreen();
        var toggleButtonHeightPx = ls.toggleButtonHeightInt + 'px';
        var sidePanelTopMarginInt = ls.topMarginInt, sidePanelTopMarginPx = sidePanelTopMarginInt + 'px';
        var sidePanelWidthIntUse = isSmallScreen ? sidePanelWidthSmallInt : sidePanelWidthInt;
        var sidePanelWidthPx = sidePanelWidthIntUse + 'px';
        var logoBorderColor = ls.darkTextColor;
        var footerContentPaddingInt = isSmallScreen ? 2 : 4, footerContentPaddingPx = footerContentPaddingInt + 'px';
        var backgroundLivelyStyle = { backgroundColor: ls.backgroundLivelyColor };
        var paddingCaptionVerHorInt = 6;
        var paddingCaptionVerHorPx = paddingCaptionVerHorInt + 'px';
        var directionsSelectedColor = ls.directionsSelectedColor;
        var largeVertPaddingInt = ls.baseLayersPaneTopCaptionVerPaddingInt * 0.5;
        var largeVertPaddingPx = largeVertPaddingInt + 'px';
        var largePaddingInt = isSmallScreen ? 6 : 10;
        var descFontSizeInt = ls.directionsSummarySmallFontSizeInt;
        var requiredWrapperStyles = {
            inherits: [CSSClasses.transitionPoint2s, CSSClasses.HOneHundred, CSSClasses.displayBlock, CSSClasses.overflowVisible,
            CSSClasses.boxShadow002003, CSSClasses.cursorDefault, CSSClasses.pointerEventsAll, CSSClasses.noMarginNoBorderNoPadding, CSSClasses.positionAbsolute],
            right: 0, top: "0px",
            zIndex: '' + (ls.rootDivZIndex + ls.customAppContentWrapperZIndexAdd),
            width: sidePanelWidthPx
        };
        var defaultWrapperStyles = { backgroundColor: ls.backgroundLivelyColor };
        cssClasses[classNames.wrapperClassName] = tf.js.ShallowMerge(defaultWrapperStyles, settings.wrapperStyles, requiredWrapperStyles);
        cssClasses[classNames.collapsedClassName] = {
            transform: "translateX(" + (sidePanelWidthIntUse) + "px)",
            "-webkit-transform": "translateX(" + (sidePanelWidthIntUse) + "px)"
        };
        cssClasses[classNames.visibleClassName] = {
            transform: "translateX(0px)",
            "-webkit-transform": "translateX(0px)"
        };
        cssClasses[classNames.toggleButtonWrapperClassName] = {
            inherits: [CSSClasses.borderRadius2px, CSSClasses.pointerEventsAll, CSSClasses.whiteSpaceNoWrap, CSSClasses.displayBlock, CSSClasses.overflowVisible, CSSClasses.cursorDefault,
            CSSClasses.noMargin, CSSClasses.noPadding, CSSClasses.positionAbsolute, CSSClasses.zIndex1, CSSClasses.lightBackground],
            right: "calc(100% + 1px)",
            //top: sidePanelTopMarginPx
            top: "calc(50% - " + (ls.toggleButtonHeightInt / 2) + "px)"
        };
        cssClasses[classNames.toggleButtonClassName] = {
            inherits: [CSSClasses.borderRadius2px, CSSClasses.baseImageButton, CSSClasses.borderLeftD4, CSSClasses.boxShadow01403, CSSClasses.overflowHidden],
            width: "23px", height: toggleButtonHeightPx
        };
        cssClasses[classNames.toggleButtonClassName + ":hover"] = {
            border: "1px solid rgba(0,48,118,0.4)"
        };
        cssClasses[classNames.topCaptionClassName] = {
            inherits: [CSSClasses.positionRelative, CSSClasses.noMarginNoBorderNoPadding, backgroundLivelyStyle,
                CSSClasses.robotoFontFamily, CSSClasses.displayFlex, CSSClasses.flexFlowRowNoWrap],
            width: "calc(100% - " + (0) + "px)",
            color: "white",
            borderTop: "2px solid " + ls.backgroundLivelyColor,
            borderBottom: "2px solid " + ls.backgroundLivelyColor,
            fontSize: ls.baseLayersPaneTopCaptionFontSizeInt + 'px',
            lineHeight: ls.baseLayersPaneTopCaptionLineHeightInt + 'px'
        };
        cssClasses[classNames.captionLogoClassName] = {
            inherits: [CSSClasses.positionRelative, CSSClasses.flexGrowZero, CSSClasses.displayFlex, CSSClasses.flexFlowColumnNoWrap],
            //minHeight: "0px",
            margin: "auto",
            backgroundColor: "white",
            padding: "2px",
            borderRadius: "2px",
            marginRight: isSmallScreen ? "4px" : "8px",
            border: "1px solid " + logoBorderColor,
            width: (largeVertPaddingInt * 2 + ls.baseLayersPaneTopCaptionLineHeightInt + descFontSizeInt) + 'px'
        };
        cssClasses[classNames.captionLogoClassName + " svg"] = {
            width: "100%",
            height: "initial",
            margin: "auto"
        };
        cssClasses[classNames.captionTitleDescWrapperClassName] = {
            inherits: [CSSClasses.positionRelative, CSSClasses.flexFlowColumnNoWrap, CSSClasses.flexGrowZero, CSSClasses.displayFlex],
            alignItems: "flex-start",
            paddingLeft: largePaddingInt + 'px',
            paddingRight: largePaddingInt + 'px',
            margin: "0px"
        };
        cssClasses[classNames.captionTitleClassName] = {
            inherits: [CSSClasses.positionRelative, CSSClasses.flexGrowOne, CSSClasses.displayFlex],
            padding: paddingCaptionVerHorPx,
            paddingLeft: "0px",
            paddingTop: largeVertPaddingPx,
            paddingBottom: '0px',
            margin: "0px"
        };
        cssClasses[classNames.captionDescClassName] = {
            inherits: [CSSClasses.positionRelative, CSSClasses.flexGrowOne, CSSClasses.displayFlex],
            padding: paddingCaptionVerHorPx,
            paddingLeft: isSmallScreen ? "2px" : "4px",
            borderTop: "1px solid white",
            paddingTop: '4px',
            paddingBottom: largeVertPaddingPx,
            fontSize: descFontSizeInt + 'px',
            lineHeight: (descFontSizeInt + 2) + 'px',
            margin: "0px"
        };
        var dimButtonInt = ls.widthMapToolBarInt, dimButtonIntPx = dimButtonInt + 'px';
        cssClasses[classNames.toolBarWrapperClassName] = {
            inherits: [CSSClasses.positionRelative, CSSClasses.noMarginNoBorderNoPadding, , CSSClasses.displayBlock],
            fontSize: ls.baseLayersPaneDefaultFontSizeInt + 'px',
            lineHeight: ls.baseLayersPaneDefaultLineHeightInt + 'px',
            //margin: "4px", marginLeft: "6px", marginRight: "6px",
            width: "100%"
            //width: "calc(100% - 16px)"//, margin: "auto"
        };
        cssClasses[classNames.toolBarContentClassName] = {
            inherits: [CSSClasses.positionRelative, CSSClasses.displayFlex, CSSClasses.flexFlowRowWrap, CSSClasses.overflowHidden, CSSClasses.darkTextShadow],
            //alignItems: "flex-start",
            textAlign: "left",
            fontSize: ls.baseLayersPaneDefaultFontSizeInt + 'px',
            lineHeight: ls.baseLayersPaneDefaultLineHeightInt + 'px',
            margin: "auto",
            padding: "2px",
            width: "calc(100% - 4px)"
        };
        cssClasses[classNames.mainToolBarContentClassName] = {
            background: "navajowhite",
            //alignItems: "flex-start",
            fontSize: ls.baseLayersPaneTopCaptionFontSizeInt + 'px',
            lineHeight: ls.baseLayersPaneTopCaptionLineHeightInt + 'px'
        };
        var addButtonDimInt = isSmallScreen ? 6 : -2;
        cssClasses[classNames.toolBarButtonClassName] = {
            inherits: [CSSClasses.positionRelative, CSSClasses.transparentImageButton, CSSClasses.backgroundColorTransparent, CSSClasses.displayFlex,
                CSSClasses.flexFlowRowNoWrap, CSSClasses.flexGrowZero, CSSClasses.flexShrinkZero],
            height: (ls.baseLayersPaneDefaultLineHeightInt + addButtonDimInt) + 'px',
            width: (ls.baseLayersPaneDefaultLineHeightInt + addButtonDimInt) + 'px',
            color: ls.backgroundLivelyColor,
            fontSize: isSmallScreen ? "11px" : "18px",
            marginLeft: "2px",
            marginRight: "2px",
            margin: "auto"
        };
        cssClasses[classNames.toolBarButtonClassName + " svg"] = { width: "100%", height: "100%", fill: ls.backgroundLivelyColor };
        var addMainButtonDimInt = isSmallScreen ? 4 : 4;
        mainToolBarButtonDimInt = ls.baseLayersPaneTopCaptionLineHeightInt + addMainButtonDimInt;
        cssClasses[classNames.mainToolBarButtonClassName] = {
            inherits: [CSSClasses.transitionPoint2s, cssClasses[classNames.toolBarButtonClassName]],
            height: (mainToolBarButtonDimInt) + 'px',
            width: (mainToolBarButtonDimInt) + 'px',
            //fontSize: (mainToolBarButtonDimInt) + 'px',
            backgroundColor: "rgba(255, 255, 255, 0.5)",
            borderRadius: "2px",
            border: "1px solid " + ls.darkTextColor,
            lineHeight: (mainToolBarButtonDimInt) + 'px',
            padding: "1px",
            margin: "auto"
        };
        cssClasses[classNames.mainToolBarButtonClassName + " svg"] = { width: "100%", height: "100%", fill: /*ls.backgroundLivelyColor /**/ls.darkTextColor/**/ };
        cssClasses[classNames.toolBarSpanClasses] = {
            inherits: [CSSClasses.positionRelative, CSSClasses.displayFlex,
                CSSClasses.flexFlowColumnNoWrap, CSSClasses.flexGrowOne, CSSClasses.flexShrinkOne],
            fontSize: ls.baseLayersPaneDefaultFontSizeInt + 'px',
            lineHeight: (ls.baseLayersPaneDefaultLineHeightInt - 6)+ 'px',
            padding: "2px",
            margin: "auto"
        };
        var mainToolBarSpanPaddingInt = isSmallScreen ? 2 : 4;
        var mainToolBarSpanHorPaddingInt = isSmallScreen ? 4 : 8;
        cssClasses[classNames.mainToolBarSpanClasses] = {
            inherits: [CSSClasses.positionRelative, CSSClasses.displayFlex,
                CSSClasses.flexFlowColumnNoWrap, CSSClasses.flexGrowOne, CSSClasses.flexShrinkOne],
            fontSize: (ls.baseLayersPaneTopCaptionFontSizeInt - 0) + 'px',
            lineHeight: ls.baseLayersPaneTopCaptionLineHeightInt + 'px',
            padding: mainToolBarSpanPaddingInt + "px",
            paddingLeft: mainToolBarSpanHorPaddingInt + 'px',
            paddingRight: mainToolBarSpanHorPaddingInt + 'px'
        };
        cssClasses[classNames.footerWrapperClassName] = {
            inherits: [CSSClasses.positionRelative, CSSClasses.noMarginNoBorderNoPadding, backgroundLivelyStyle,
                CSSClasses.robotoFontFamily, CSSClasses.displayBlock]
        };
        cssClasses[classNames.footerContentClassName] = {
            inherits: [CSSClasses.displayFlex, CSSClasses.flexFlowColumnNoWrap, CSSClasses.lightTextShadow],
            minHeight: "0px",
            width: "calc(100% - " + (2 * footerContentPaddingInt) + "px)",
            textAlign: "center",
            padding: footerContentPaddingPx,
            color: "white",
            fontSize: ls.directionsSummarySmallFontSizeInt + 'px',
            lineHeight: ls.directionsSummarySmallLineHeightInt + 'px'
        }
        cssClasses[classNames.variableFontSizeClassName] = {
            fontSize: ls.baseLayersPaneDefaultFontSizeInt + 'px',
            lineHeight: ls.baseLayersPaneDefaultLineHeightInt + 'px'
        };
        cssClasses[classNames.fullWidthClassName] = {
            width: "100%"
        };
        cssClasses[classNames.fullWidthWithPaddingClassName] = {
            width: "100%"
            /*width: "calc(100% - 10px)",
            paddingLeft: "10px"*/
        };
        cssClasses[classNames.nonScrollVariableHeightClassName] = {
            inherits: [CSSClasses.displayFlex, CSSClasses.flexFlowColumnNoWrap, CSSClasses.flexGrowOne, CSSClasses.flexShrinkOne],
            //height: "100%",
            minHeight: "0px"
        };
        var minHeightListInt = isSmallScreen ? 100 : 200;
        vertListWithFadePaddingTopBotInt = isSmallScreen ? 4 : 8;
        var vertListWithFadePaddingTopBotPx = vertListWithFadePaddingTopBotInt + 'px';
        var topBotFadeBorder = "1px solid " + ls.listBorderColor;
        var topBotFadeCommon = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.pointerEventsNone, CSSClasses.positionAbsolute, CSSClasses.overflowVisible],
            left: "0px",
            zIndex: '' + (ls.rootDivZIndex + ls.listFadeWrapperZIndexAdd),
            width: "100%",
            height: vertListWithFadePaddingTopBotInt + 'px !important'
        };
        cssClasses[classNames.borderTopClassName] = { borderTop: topBotFadeBorder };
        cssClasses[classNames.fadeTopClassName] = {
            inherits: [topBotFadeCommon], top: "0px",
            borderTop: topBotFadeBorder, background: "linear-gradient(to bottom, " + "rgba(255,255,255,1)" + "," + "rgba(255,255,255,0)" + ")"
        };
        cssClasses[classNames.fadeBotClassName] = {
            inherits: [topBotFadeCommon],
            borderBottom: topBotFadeBorder, bottom: "0px", background: "linear-gradient(to top, " + "rgba(255,255,255,1)" + "," + "rgba(255,255,255,0)" + ")"
        };
        cssClasses[classNames.minHeightPaneClassName] = { minHeight: minHeightListInt + 'px' };
        cssClasses[classNames.minHeightListClassName] = {
            backgroundColor: "#f0f0ff", paddingTop: vertListWithFadePaddingTopBotPx, paddingBottom: vertListWithFadePaddingTopBotPx, minHeight: minHeightListInt + 'px'
        };
        return cssClasses;
    }
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function onLayoutChange(notification) {
        registerCSSClasses();
        //settings.appContent.GetAppStyles().SetMinNonSmallScreenWidthAddValue(isVisible ? sidePanelWidthInt : 0);
        adjustStyles();
    }
    function createContentWrapper() { var ls = tf.TFMap.LayoutSettings; return new tf.dom.Div({ cssClass: ls.sidePanelContentWrapperClassName + " " + ls.sidePaneFullHeightContentWrapperClassName }); }
    function createNonScrollContent() {
        var ls = tf.TFMap.LayoutSettings;
        return new tf.dom.Div({ cssClass: ls.sidePaneContentFixedHeightClassName + " " + classNames.variableFontSizeClassName + " " + classNames.fullWidthClassName });
    }
    function createNonScrollVariableHeightContent(additionalClassNames) {
        var ls = tf.TFMap.LayoutSettings;
        var classNamesUse = ls.sidePaneContentFixedHeightClassName + " " + classNames.variableFontSizeClassName +
            " " + classNames.nonScrollVariableHeightClassName + " " + classNames.fullWidthClassName;
        if (tf.js.GetIsNonEmptyString(additionalClassNames)) { classNamesUse += ' ' + additionalClassNames; }
        return new tf.dom.Div({ cssClass: classNamesUse });
    }
    function createScrollContent(additionalClassNames) {
        var ls = tf.TFMap.LayoutSettings;
        var classNamesUse = ls.sidePaneContentVariableHeightClassName + " " + classNames.fullWidthWithPaddingClassName + " " + classNames.variableFontSizeClassName
            + " " + ls.customizedScrollBarClassName;
        if (tf.js.GetIsNonEmptyString(additionalClassNames)) { classNamesUse += ' ' + additionalClassNames; }
        return new tf.dom.Div({ cssClass: classNamesUse });
    }
    function createWrapperContent(wrapperClassName, contentClassName, additionalWrapperClassNames, additionalContentClassNames) {
        var wrapperClassNameUse = wrapperClassName, contentClassNameUse = contentClassName;
        if (tf.js.GetIsNonEmptyString(additionalWrapperClassNames)) { wrapperClassNameUse += " " + additionalWrapperClassNames; }
        if (tf.js.GetIsNonEmptyString(additionalContentClassNames)) { contentClassNameUse += " " + additionalContentClassNames; }
        var wrapper = new tf.dom.Div({ cssClass: wrapperClassNameUse }), content = new tf.dom.Div({ cssClass: contentClassNameUse });
        wrapper.AddContent(content);
        return { wrapper: wrapper, content: content };
    }
    function createMainToolBar() {
        return createWrapperContent(classNames.toolBarWrapperClassName, classNames.toolBarContentClassName + " " + classNames.mainToolBarContentClassName);
    }
    function createToolBar(additionalWrapperClassNames, additionalContentClassNames) {
        return createWrapperContent(classNames.toolBarWrapperClassName, classNames.toolBarContentClassName, additionalWrapperClassNames, additionalContentClassNames);
    }
    function createFooter() { return createWrapperContent(classNames.footerWrapperClassName, classNames.footerContentClassName); }
    function createVertScrollWrapperAndContentWithFade() {
        var ls = tf.TFMap.LayoutSettings;
        var scrollWrapper = createNonScrollVariableHeightContent();
        var fadeTop = new tf.dom.Div({ cssClass: classNames.fadeTopClassName });
        var fadeBot = new tf.dom.Div({ cssClass: classNames.fadeBotClassName });
        var scrollContent = createScrollContent(classNames.minHeightListClassName);
        scrollWrapper.AddContent(fadeTop, fadeBot, scrollContent);
        scrollWrapper.GetHTMLElement().style.overflow = "hidden";
        return { scrollWrapper: scrollWrapper, scrollContent: scrollContent }
    }
    function getToolBarButtonClasses() { return classNames.toolBarButtonClassName; }
    function getMainToolBarButtonClasses() { return getToolBarButtonClasses() + " " + classNames.mainToolBarButtonClassName; }
    function getClassNames() { return classNames; }
    function getVerListWithFadePaddingTopBotInt() { return classNames.vertListWithFadePaddingTopBotInt; }
    function createTitleDescSVGLogo(titleStr, descStr, logoSVGHTML) {
        var wrapper = new tf.dom.Div({ cssClass: classNames.topCaptionClassName });
        var titleDescWrapper = new tf.dom.Div({ cssClass: classNames.captionTitleDescWrapperClassName });
        var title = new tf.dom.Div({ cssClass: classNames.captionTitleClassName });
        var desc = new tf.dom.Div({ cssClass: classNames.captionDescClassName });
        var logo = new tf.dom.Div({ cssClass: classNames.captionLogoClassName });
        title.GetHTMLElement().innerHTML = titleStr;
        desc.GetHTMLElement().innerHTML = tf.js.GetNonEmptyString(descStr, "A TerraFly application");
        titleDescWrapper.AddContent(title, desc);
        logo.GetHTMLElement().innerHTML = logoSVGHTML;
        wrapper.AddContent(titleDescWrapper, logo);
        return { wrapper: wrapper, titleDescWrapper: titleDescWrapper, title: title, desc: desc, logo: logo };
    }
    function getToolBarSpanClasses() { return classNames.toolBarSpanClasses; }
    function getMainToolBarSpanClasses() { return getToolBarSpanClasses() + " " + classNames.mainToolBarSpanClasses; }
    function setOnMapPostCompose(callBack) { onMapPostComposeCB = tf.js.GetFunctionOrNull(callBack); }
    function setInterface() {
        if (tf.js.GetFunctionOrNull(settings.setInterface)) {
            var myInterface = {
                sender: theThis,
                setOnMapPostCompose: setOnMapPostCompose,
                getMainToolBarButtonDimInt: function() { return mainToolBarButtonDimInt; },
                createTitleDescSVGLogo: createTitleDescSVGLogo,
                createNonScrollContent: createNonScrollContent,
                createNonScrollVariableHeightContent: createNonScrollVariableHeightContent,
                createVertScrollWrapperAndContentWithFade: createVertScrollWrapperAndContentWithFade,
                createScrollContent: createScrollContent,
                createMainToolBar: createMainToolBar,
                createToolBar: createToolBar,
                createFooter: createFooter,
                getClassNames: getClassNames,
                getVerListWithFadePaddingTopBotInt: getVerListWithFadePaddingTopBotInt,
                getToolBarSpanClasses: getToolBarSpanClasses,
                getMainToolBarSpanClasses: getMainToolBarSpanClasses,
                getToolBarButtonClasses: getToolBarButtonClasses,
                getMainToolBarButtonClasses: getMainToolBarButtonClasses,
                getToggleButtonHidden: getToggleButtonHidden,
                setToggleButtonHidden: setToggleButtonHidden,
                getWrapper: getWrapper,
                getContentWrapper: getContentWrapper,
                getSettings: getSettings,
                getWidthInt: getWidthInt,
                getWidthIntSmall: getWidthIntSmall,
                getCurrentWidthInt: getCurrentWidthInt,
                getIsVisible: getIsVisible,
                setVisible: setVisible
            };
            settings.setInterface(myInterface);
        }
    }
    function initialize() {
        cssTag = 'customAppContent';
        sidePanelWidthInt = tf.js.GetFloatNumberInRange(settings.widthInt, 0, 99999999, 400);
        sidePanelWidthSmallInt = tf.js.GetFloatNumberInRange(settings.widthIntSmall, 0, 99999999, 300);
        //settings.appContent.GetAppStyles().SetMinNonSmallScreenWidthAddValue(sidePanelWidthInt);
        createCSSClassNames();
        registerCSSClasses();
        createControl();
        var appStyles = settings.appContent.GetAppStyles();
        appStyles.AddOnLayoutChangeListener(onLayoutChange);
        setInterface();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.TFMap.CustomApp = function (settings) {
    var theThis, appName, tfMapApp, customAppContent, customAppContentI;
    var slideAppStartVerb, collapsedAppStartVerb, expandedAppStartVerb;
    var startVisible, slideVisible;
    var onParametersParsedCB, onCreatedCB;
    var customAppContent, customAppContentI;
    this.GetTFMapApp = function () { return tfMapApp; }
    function onCreated(notification) {
        if (startVisible && slideVisible) {
            customAppContentI.setVisible(true);
            customAppContentI.setToggleButtonHidden(false);
        }
        if (!!onCreatedCB) { onCreatedCB(notification); }
    }
    function toggleButtonToolTipText() {
        var toolTipText;
        if (!!customAppContentI) {
            var expandCollapse = customAppContentI.getIsVisible() ? "Collapse " : "Expand ";
            toolTipText = expandCollapse + appName + " panel";
        }
        return toolTipText;
    }
    function onAddComponents(notification) {
        var appContent = tfMapApp.GetContent();
        customAppContent = appContent.CreateCustomAppContent({
            onVisibilityChange: settings.onVisibilityChange,
            updateForMapType: settings.updateForMapType,
            widthInt: settings.widthInt, widthIntSmall: settings.widthIntSmall,
            visible: startVisible && !slideVisible,
            toggleButtonHidden: startVisible && slideVisible,
            toggleButtonToolTipText: toggleButtonToolTipText,
            wrapperStyles: { background: "transparent" },
            setInterface: function (theInterface) {
                customAppContentI = theInterface;
                if (tf.js.GetFunctionOrNull(settings.onContentSetInterface)) {
                    settings.onContentSetInterface(theInterface);
                }
            }
        });
    }
    function startCollapsed() { startVisible = slideVisible = false; }
    function startExpanded() { startVisible = true; slideVisible = false; }
    function startSlideExpand() { startVisible = slideVisible = true; }
    function onParametersParsed(notification) {
        var params = notification.params;
        var appStart = tf.js.GetIsValidObject(params) ? params[tf.consts.appStartParamName] : undefined;
        appStart = tf.js.GetNonEmptyString(appStart, slideAppStartVerb);
        switch (appStart.toLowerCase()) {
            default: case slideAppStartVerb: startExpanded();/*startSlideExpand();*/ break;
            case collapsedAppStartVerb: startCollapsed(); break;
            case expandedAppStartVerb: startExpanded(); break;
        }
        if (!!onParametersParsedCB) { onParametersParsedCB(notification); }
    }
    function initialize() {
        appName = tf.js.GetNonEmptyString(settings.appName, "TerraFly App");
        slideAppStartVerb = "slide";
        collapsedAppStartVerb = tf.consts.appStartCollapsedValue;
        expandedAppStartVerb = tf.consts.appStartExpandedValue;
        onCreatedCB = tf.js.GetFunctionOrNull(settings.onCreated);
        onParametersParsedCB = tf.js.GetFunctionOrNull(settings.onParametersParsed);
        settings.sidePanelWidthInt = tf.js.GetFloatNumberInRange(settings.sidePanelWidthInt, 0, 99999999, 400);
        settings.sidePanelWidthSmallInt = tf.js.GetFloatNumberInRange(settings.sidePanelWidthSmallInt, 0, 99999999, 300);
        settings.onCreated = onCreated;
        settings.onAddComponents = onAddComponents;
        settings.onParametersParsed = onParametersParsed;
        settings.appTitle = appName;
        tfMapApp = new tf.TFMap.App(settings);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: content.js
tf.TFMap.Content = function (settings) {
    var customAppMinZIndex;
    var theThis, appStyles, appCtx, appSizer, map, mapTypeAuxMap, lastCtx, clusterZIndex;
    var toaster, scaleElem;
    var multiMenus, toolTipDisplayer, appDiv, rootDiv, mapDiv, mapMapDiv;
    var sidePane, bottomPane, searchBar, mapFeaturePropsDisplayer, directionsPanel;
    var mapToolBar, mapCompass, mapMoreTools, dataSetSearches, dataSetsBar, overMapCanvas, mapTypeAuxMapWrapper;
    var mapClickedLocation, mapUserLocation, mapSearchLocation, pinMapFeature;
    var photoList, photoListDisplayer, photoDisplayer;
    var mapClickedLocationLayer, mapUserLocationLayer, mapPinsLayer, mapDirectionsLayer, mapDirectionsPinsLayer, mapDirectionItemsLayer, mapDirectionWayPointsLayer;
    var measureToolLayer, downloadToolLayer, bottomCustomAppLayer, bottomFillLayerMeasureLayer, bottomFillLayerDownloadLayer;
    var additionalFeaturesLayer, searchLayerHybridB, searchLayerMapB;
    var showingAerial, isUsingClusters, isBottomPaneUp, skipFirstMapFeatureProps, diffLevelMapTypeAux;
    var lastClusterFeatures, centerMapOnToolTipOpen;
    var baseLayersPanel, baseLayersToolBar;
    var decodedLegendH, decodedLegendM;
    var mapFeatureWayPointCache, coordsDirectionRouteHover, mapFeatureAddWayPoint;
    var perspectiveMap;
    var mapListeners;
    var photoDisplayerParentDiv;
    var mapFeatureDragI;
    var lsEdI;
    var mapMeasureToolI, mapDownloadToolI;
    var currentEditorI;
    var hasSidePanelFullContent;
    var customAppContent;
    var inLayoutChange;
    var mapCenterDiv, mapLogoDiv;
    var usePerspectiveMap, perspectiveMapIsInitiallyVisible;
    var useBusDirections;
    this.GetDirectionsPanel = function () { return directionsPanel; }
    this.GetPerspectiveMap = function () { return perspectiveMap; }
    this.GetBottomCustomAppLayer = function () { return bottomCustomAppLayer; }
    this.StartLayoutChange = function() {
        if (!inLayoutChange) {
            inLayoutChange = true;
            appDiv.GetHTMLElement().style.display = 'none';
            //document.body.removeChild(appDiv.GetHTMLElement());
        }
    }
    this.EndLayoutChange = function () {
        if (inLayoutChange) {
            inLayoutChange = false;
            appDiv.GetHTMLElement().style.display = 'block';
            //document.body.appendChild(appDiv.GetHTMLElement());
            appSizer.OnResize();
        }
    }
    this.CreateCustomMapLayer = function (layerSettings, usePerspective) {
        var zIndex = tf.js.GetIntNumberInRange(layerSettings.zIndex, 0, 99999999, 0);
        layerSettings.zIndex = zIndex + customAppMinZIndex;
        var layer;
        //usePerspective = false;
        if (usePerspective && usePerspectiveMap) {
            layerSettings.overrideClass = tf.webgl.PerspectiveLayer;
            layerSettings.appContent = theThis;
        }
        return map.AddFeatureLayer(layerSettings);
    }
    this.GetCustomAppMinMapLayerZIndex = function() { return customAppMinZIndex; }
    this.CreateCustomAppContent = function (customAppContentSettings) {
        if (customAppContent == undefined) {
            customAppContent = new tf.TFMap.CustomAppContent(tf.js.ShallowMerge(customAppContentSettings, { appContent: theThis }));
        }
    }
    this.SetHasSidePanelFullContent = function (hasSidePanelFullContentSet) {
        if (hasSidePanelFullContent != (hasSidePanelFullContentSet = !!hasSidePanelFullContentSet)) {
            hasSidePanelFullContent = hasSidePanelFullContentSet;
            setBottomPaneWidth();
        }
    }
    this.GetHasSidePanelFullContent = function () { return hasSidePanelFullContent; }
    this.GetHasEffectiveSidePanelFullContent = function() {
        return lastCtx[tf.TFMap.CAN_sidePanelVisible] ? (theThis.GetHasSidePanelFullContent() || lastCtx[tf.TFMap.CAN_showingDirections]) : false;
    }
    this.GetBaseLayersPanel = function () { return baseLayersPanel; }
    this.GetMeasureToolInterface = function () { return mapMeasureToolI; }
    this.GetDownloadToolInterface = function () { return mapDownloadToolI; }
    this.IsMeasureToolOn = function () { return mapMeasureToolI != undefined && currentEditorI == mapMeasureToolI; }
    this.ToggleMeasureTool = function () { if (theThis.IsMeasureToolOn()) { deActivateCurrentEditor(); } else { activateEditor(mapMeasureToolI); } }
    this.IsDownloadToolOn = function () { return mapDownloadToolI != undefined && currentEditorI == mapDownloadToolI; }
    this.ToggleDownloadTool = function () { if (theThis.IsDownloadToolOn()) { deActivateCurrentEditor(); } else { activateEditor(mapDownloadToolI); } }
    this.OnDirectionWayPointsDiscarded = function () { mapDirectionWayPointsLayer.RemoveAllFeatures(); mapFeatureWayPointCache.Reset(); mapFeatureAddWayPoint = getNextFeatureWayPoint(); }
    function initWayPoints() {
        mapFeatureWayPointCache = new tf.js.ObjectCache({ createNew: createMapFeatureAddWayPoint, onDelete: deleteMapFeatureAddWayPoint });
        mapFeatureAddWayPoint = getNextFeatureWayPoint();
    }
    function getMapFeatureWayPointStyle(keyedFeature, mapFeature) {
        var isHover = mapFeature.GetIsDisplayingInHover();
        var radius = 10 * tf.TFMap.DirectionsFeatureDimMult;
        var zindex = isHover ? 40 : 20;
        var snaptopixel = false;
        var style = [{
            snaptopixel: snaptopixel,
            zindex: zindex++,
            circle: true, circle_radius: radius, line: true, fill: true, fill_color: "#fdfdff", line_color: "#026", line_width: 2, line_opacity: 70, fill_opacity: 100
        }];
        var mapFeatureSettings = mapFeature.GetSettings();
        if (mapFeatureSettings.wayPointIndex != undefined) {
            var textStyle = {
                snaptopixel: snaptopixel,
                font: "600 " + (radius) + "px Roboto",
                zindex: zindex++, text: true, fill: true, fill_color: "#026", line: true, line_opacity: 30, line_color: "#bfbfbf", line_width: 1,
                label: '#' + (1 + mapFeatureSettings.wayPointIndex)
            }
            style.push(textStyle);
        }
        else {
            var plusStyle = {
                snaptopixel: snaptopixel,
                font: "400 " + (2 * radius) + "px Roboto",
                zindex: zindex++, text: true, fill: true, fill_color: "#026", line: true, line_opacity: 30, line_color: "#bfbfbf", line_width: 1,
                label: '+'
            }
            style.push(plusStyle);
        }
        return style;
    }
    function createMapFeatureAddWayPoint() {
        var mapFeature = new tf.map.Feature({ type: 'point', coordinates: [0, 0], style: getMapFeatureWayPointStyle, hoverStyle: getMapFeatureWayPointStyle });
        var toolTipText = tf.TFMap.MapTwoLineSpan("Add via location", "click or drag");
        tf.TFMap.SetMapFeatureToolTipProps(mapFeature, { toolTipText: toolTipText, offsetX: 20, delayMillis: tf.TFMap.AddWayPointToolTipDelayMillis });
        var mapFeatureSettings = mapFeature.GetSettings();
        mapFeatureSettings.wayPointIsInLayer = false;
        mapFeatureSettings.wayPointIndex = undefined;
        return mapFeature;
    }
    function deleteMapFeatureAddWayPoint(notification) { }
    function getNextFeatureWayPoint() {
        var mapFeature = mapFeatureWayPointCache.GetNext();
        var mapFeatureSettings = mapFeature.GetSettings();
        mapFeatureSettings.wayPointIsInLayer = false;
        mapFeatureSettings.wayPointIndex = undefined;
        return mapFeature;
    }
    function addWayPoint(notification, isDrag) {
        //console.log('adding waypoint from ' + (isDrag ? 'drag' : 'click'));
        var toolTipText = tf.TFMap.MapTwoLineSpan("drag to move", "click to delete");
        tf.TFMap.GetMapFeatureToolTipProps(mapFeatureAddWayPoint).toolTipText = toolTipText;
        directionsPanel.AddWayPoint(mapFeatureAddWayPoint);
        mapDirectionWayPointsLayer.AddMapFeature(mapFeatureAddWayPoint);
        mapFeatureAddWayPoint.GetSettings().wayPointIsInLayer = true;
        coordsDirectionRouteHover = undefined;
        if (isDrag && !!mapFeatureDragI) { mapFeatureDragI.startDrag(mapFeatureAddWayPoint, notification.eventCoords, {}, true); }
        mapFeatureAddWayPoint = getNextFeatureWayPoint();
        deselectToolTipSender();
        map.Render();
    }
    function showMapFeatureToolTip(mapFeature, atCoords) {
        deselectToolTipSender();
        if (!!mapFeature) {
            if (atCoords == undefined) { atCoords = mapFeature.GetPointCoords(); }
            var toolTipProps = getMapFeatureToolTipProps(mapFeature, atCoords);
            appCtx.SetCtxAttribute(tf.TFMap.CAN_selectedToolTipSender, toolTipProps);
        }
    }
    function checkUpdateDirectionsHover(notification) {
        var updatedDirectionsHover = false;
        if (coordsDirectionRouteHover != undefined) {
            updatedDirectionsHover = true;
            if (notification.eventCoords != undefined) {
                coordsDirectionRouteHover = notification.eventCoords;
                var hitTestAddWayPoint = tf.helpers.HitTestMapCoordinatesArray(directionsPanel.GetRouteCoordinates(), coordsDirectionRouteHover, undefined, undefined, undefined);
                if (hitTestAddWayPoint.closestPoint != undefined) {
                    var newCoords = hitTestAddWayPoint.closestPoint;
                    mapFeatureAddWayPoint.SetPointCoords(newCoords);
                    var toolTipProps = getMapFeatureToolTipProps(mapFeatureAddWayPoint, newCoords);
                    deselectToolTipSender();
                    appCtx.SetCtxAttribute(tf.TFMap.CAN_selectedToolTipSender, toolTipProps);
                }
            }
            //map.Render();
        }
        return updatedDirectionsHover;
    }
    function onMapPostCompose(notification) {
        updatePinMapFeature();
        if (checkUpdateDirectionsHover(notification)) { notification.showFeatureImmediately(mapFeatureAddWayPoint); }
        mapFeaturePropsDisplayer.OnPostCompose(notification);
        if (!!customAppContent) { customAppContent.OnMapPostCompose(notification); }
        if (!!currentEditorI) { if (!!tf.js.GetFunctionOrNull(currentEditorI.onPostCompose)) { currentEditorI.onPostCompose(notification); } }
        if (overMapCanvas.GetIsModified()) { overMapCanvas.Draw(); }
    }
    function onMapFeatureMouseMove(notification) {
        if (!!mapFeatureDragI && mapFeatureDragI.getIsDragging()) { return; }
        if (!!currentEditorI) { if (!!tf.js.GetFunctionOrNull(currentEditorI.onMouseMoveFeature)) { currentEditorI.onMouseMoveFeature(notification); } }
        if (checkUpdateDirectionsHover(notification)) { map.Render(); }
    }
    function onMapFeatureHover(notification) {
        if (!!mapFeatureDragI && mapFeatureDragI.getIsDragging()) { return; }
        if (!!currentEditorI && !!tf.js.GetFunctionOrNull(currentEditorI.onHoverFeature) && currentEditorI.onHoverFeature(notification)) { return; }
        var notificationMapFeature = notification.mapFeature;
        var notificationMapFeatureSettings = notificationMapFeature.GetSettings();
        if (notificationMapFeatureSettings.isDirectionRoute) {
            if (notification.isInHover) { if (directionsPanel.GetCanAddWayPoint()) { coordsDirectionRouteHover = notification.eventCoords; } }
            else { coordsDirectionRouteHover = undefined; deselectToolTipSender(); }
            return;
        }
        //return;
        if (!!tf.TFMap.GetMapFeatureToolTipProps(notificationMapFeature)) {
            var toolTipProps;
            var needChange = true;
            if (notification.isInHover) {
                lastClusterFeatures = [];
                if (tf.js.GetIsValidObject(notification.featureCluster) && tf.js.GetIsNonEmptyArray(notification.featureCluster.clusterFeatures)) {
                    var clusterFeatures = notification.featureCluster.clusterFeatures;
                    var clusterCoords = notification.featureCluster.clusterCoords;
                    var mapFeature = clusterFeatures[0];
                    toolTipProps = getMapFeatureToolTipProps(mapFeature, clusterCoords);
                    toolTipProps.offsetX = 8;
                    if (!!toolTipProps) {
                        //lastClusterFeatures = clusterFeatures;
                        var nFeatures = clusterFeatures.length;
                        toolTipProps.toolTipText = [];
                        var toolTipInfos = [];
                        for (var i = 0; i < nFeatures; ++i) {
                            var thisMapFeature = clusterFeatures[i];
                            var thisMapFeatureTTP = getMapFeatureToolTipProps(thisMapFeature, clusterCoords);
                            var thisToolTip = /*(i + 1) + ": " + */(tf.js.GetFunctionOrNull(thisMapFeatureTTP.toolTipText) ? thisMapFeatureTTP.toolTipText(thisMapFeatureTTP) : thisMapFeatureTTP.toolTipText);
                            toolTipInfos.push({ toolTipText: thisToolTip, mapFeature: thisMapFeature });
                        }
                        toolTipInfos.sort(function(a, b) { return a.toolTipText < b.toolTipText ? -1 : a.toolTipText > b.toolTipText ? 1 : -1; });
                        for (var i = 0; i < toolTipInfos.length; ++i) { toolTipProps.toolTipText.push(toolTipInfos[i].toolTipText); }
                        lastClusterFeatures = toolTipInfos
                        toolTipProps.onClick = onClickMapFeatureToolTip;
                    }
                }
                else {
                    var willShow = true;
                    var notificationMapFeatureSettings = notificationMapFeature.GetSettings();
                    var searchProps = tf.TFMap.GetSearchProps(notificationMapFeature);
                    if (!!searchProps) { willShow = notificationMapFeatureSettings.showToolTip; }
                    if (willShow) {
                        var notificationMapFeatureSettingsToolTipCoords = notificationMapFeatureSettings.toolTipCoords;
                        toolTipProps = getMapFeatureToolTipProps(notificationMapFeature,
                            notificationMapFeatureSettingsToolTipCoords != undefined ?
                                notificationMapFeatureSettingsToolTipCoords : notificationMapFeature.GetPointCoords());
                    }
                }
            }
            else {
                var curToolTipSender = appCtx.GetCtxAttribute(tf.TFMap.CAN_selectedToolTipSender);
                if (!!curToolTipSender) {
                    if (curToolTipSender.keepOnHoverOutTarget) {
                        needChange = !toolTipDisplayer.GetIsInHover();
                    }
                }
            }
            if (needChange) {
                appCtx.SetCtxAttribute(tf.TFMap.CAN_selectedToolTipSender, toolTipProps);
            }
        }
    }
    function onMapMouseDrag(notification) { if (!!mapFeatureDragI && mapFeatureDragI.getIsDragging()) { if (mapFeatureDragI.onDragMove(notification)) { return; } } }
    function onMapDragEnd(notification) { if (!!mapFeatureDragI && mapFeatureDragI.getIsDragging()) { if (mapFeatureDragI.onEndDrag()) { return; } } }
    function onMapFeatureMouseDrag(notification) {
        if (!!mapFeatureDragI) {
            if (mapFeatureDragI.getIsDragging()) { if (mapFeatureDragI.onDragMove(notification)) { return; } }
            else {
                if (mapFeatureDragI.onDrag(notification)) { return; }
            }
        }
        if (!!currentEditorI && !!tf.js.GetFunctionOrNull(currentEditorI.onDragFeature) && currentEditorI.onDragFeature(notification)) { return; }
        if (coordsDirectionRouteHover != undefined) { addWayPoint(notification, true); return; }
    }
    function onMapFeatureDoubleClick(notification) {
        if (!!currentEditorI && !!tf.js.GetFunctionOrNull(currentEditorI.onDoubleClickFeature) && currentEditorI.onDoubleClickFeature(notification)) { return; }
    }
    function onMapFeatureClick(notification) {
        if (!!currentEditorI && !!tf.js.GetFunctionOrNull(currentEditorI.onClickFeature) &&  currentEditorI.onClickFeature(notification)) { return; }
        if (coordsDirectionRouteHover != undefined) { addWayPoint(notification, false); return; }
        var mapFeature = notification.mapFeature;
        var searchFeature = !!tf.TFMap.GetSearchFeature(mapFeature) ? mapFeature : undefined;
        appCtx.SetCtxAttribute(tf.TFMap.CAN_selectedSearch, searchFeature);
        if (!!searchFeature) {
            theThis.ShowMapFeatureProps(searchFeature);
        }
        if (mapFeature == mapUserLocation.GetMapFeature() || mapFeature == mapClickedLocation.GetMapFeature() || mapFeature == mapSearchLocation.GetMapFeature()) {
            mapFeaturePropsDisplayer.ShowProps(mapFeature);
        }
        else if (mapFeature == pinMapFeature.GetMapFeature()) {
            theThis.SetDirectionsTargetToMapFeature(pinMapFeature.GetLastToMapFeature(), true);
        }
        else {
            var settings = mapFeature.GetSettings();
            if (settings.directionsAddressItem != undefined) {
                directionsPanel.SelectAddressItem(settings.directionsAddressItem);
            }
            else if (settings.directionsResultsItem != undefined) {
                directionsPanel.SelectResultItem(settings.directionsResultsItem);
            }
            else if (settings.wayPointIsInLayer) {
                directionsPanel.DeleteWayPoint(mapFeature);
                mapDirectionWayPointsLayer.DelMapFeature(mapFeature);
            }
            else if (tf.js.GetFunctionOrNull(settings.onCustomAppClick)) {
                settings.onCustomAppClick(notification);
            }
        }
    }
    function onMapClick(notification) {
        if (!!currentEditorI && !!tf.js.GetFunctionOrNull(currentEditorI.onClickMap) &&  currentEditorI.onClickMap(notification)) { return; }
        mapClickedLocation.Show(notification.eventCoords);
    }
    this.GetMapFeaturePropsDisplayer = function () { return mapFeaturePropsDisplayer; }
    this.GetOverMapCanvas = function () { return overMapCanvas; }
    this.SetBottomContent = function (bottomContentType, bottomContent) {
        var underBottomWrapper = bottomPane.GetUnderBottomWrapper();
        underBottomWrapper.ClearContent();
        switch (bottomContentType) {
            case tf.TFMap.BottomContentTypes.photos:
                photoList.SetContent(bottomContent);
                photoListDisplayer.Update(photoList);
                underBottomWrapper.AddContent(photoListDisplayer.GetWrapper());
                break;
        }
        theThis.SetBottomPaneUp(true);
    }
    this.GetIsBottomPaneUp = function() { return isBottomPaneUp; }
    this.SetBottomPaneUp = function(isUp) { if (isBottomPaneUp != (isUp = !!isUp)) { isBottomPaneUp = isUp; setBottomPaneUpDownStyle(); } }
    this.ToggleBottomPaneUp = function () { theThis.SetBottomPaneUp(!theThis.GetIsBottomPaneUp()); }
    this.ShowPhoto = function (photoSettings, setFocusElement) {
        if (!photoDisplayer.GetIsShowing()) {
            var photoListWrapper = photoListDisplayer.GetWrapper();
            theThis.SetBottomPaneUp(false);
            var underBottomWrapper = bottomPane.GetUnderBottomWrapper();
            underBottomWrapper.RemoveContent(photoListWrapper);
            photoDisplayer.GetWrapper().AddContent(photoListWrapper);
        }
        photoDisplayer.Show(photoDisplayerParentDiv, photoSettings);
        if (!!setFocusElement) { setTimeout(function () { setFocusElement.focus(); }, 500); }
    }
    this.GetIsShowingPhoto = function () { return photoDisplayer.GetIsShowing(); }
    this.GetPhotoDisplayer = function () { return photoDisplayer; }
    this.OnPhotoDisplayHidden = function () {
        var photoListWrapper = photoListDisplayer.GetWrapper();
        var underBottomWrapper = bottomPane.GetUnderBottomWrapper();
        photoDisplayer.GetWrapper().RemoveContent(photoListWrapper);
        underBottomWrapper.AddContent(photoListWrapper);
        theThis.SetBottomPaneUp(true);
    }
    this.RefreshDataSetFeatures = function () {
        for (var i in dataSetSearches) {
            var tfs = dataSetSearches[i], tfss = tfs.GetSettings(), smf = tfss.searchMapFeatures;
            smf.RefreshStyles();
        }
    }
    this.GetUsesClusters = function () { return isUsingClusters; }
    this.ToggleClusters = function () { isUsingClusters = !isUsingClusters; searchLayerHybridB.SetUseClusters(isUsingClusters); searchLayerMapB.SetUseClusters(isUsingClusters); }
    function getCoordsExtent() {
        var mapDims = map.GetPixelSize(), w = mapDims[0], h = mapDims[1];
        var lt = [0, 0], rt = [w, 0], rb = [w, h], lb = [0, h];
        var pixCoords = [lt, rt, rb, lb];
        var mapCoords = [];
        for (var i = 0; i < pixCoords.length; ++i) {
            mapCoords.push(map.PixelToMapCoords(pixCoords[i]));
        }
        var wt = tf.units.GetHaversineDistance(mapCoords[0], mapCoords[1]);
        var wb = tf.units.GetHaversineDistance(mapCoords[2], mapCoords[3]);
        //console.log('wt ' + wt + ' wb ' + wb);
    }
    this.MakeSureMapCoordsAreVisible = function (coords, marginPxInt, useSetCenter) {
        if (!useSetCenter) { return theThis.AnimatedSetCenterIfDestVisible(coords); }
        //getCoordsExtent();
        if (marginPxInt == undefined) { marginPxInt = 50; }
        var mapDims = map.GetPixelSize();
        var marginPxHorInt = marginPxInt;
        var marginPxVerInt = marginPxInt;
        if (marginPxHorInt > mapDims[0] / 2) { marginPxHorInt = mapDims[0] / 2; }
        if (marginPxVerInt > mapDims[1] / 2) { marginPxVerInt = mapDims[1] / 2; }
        var pixelCoords = map.MapToPixelCoords(coords);
        var marginLeft = pixelCoords[0] - marginPxHorInt;
        var marginRight = pixelCoords[0] + marginPxHorInt;
        var marginTop = pixelCoords[1] - marginPxVerInt;
        var marginBot = pixelCoords[1] + marginPxVerInt;
        var diffPixelX = 0, diffPixelY = 0;
        var minLeft = 0, minTop = 0, maxRight = mapDims[0], maxBottom = mapDims[1];
        var layoutSettings = tf.TFMap.LayoutSettings;
        var underBottomPaneHeightInt = layoutSettings.underBottomPaneHeightInt;
        if (theThis.GetHasEffectiveSidePanelFullContent()) {
            //if (lastCtx[tf.TFMap.CAN_showingDirections] && lastCtx[tf.TFMap.CAN_sidePanelVisible]) {
            minLeft = layoutSettings.sidePanelWidthInt;
        }
        if (isBottomPaneUp) { maxBottom -= underBottomPaneHeightInt; }
        if (marginLeft < minLeft) { diffPixelX = marginLeft - minLeft; }
        else if (marginRight > maxRight) { diffPixelX = marginRight - maxRight; }
        if (marginTop < minTop) { diffPixelY = marginTop - minTop; }
        else if (marginBot > maxBottom) { diffPixelY = marginBot - maxBottom; }
        if (diffPixelX != 0 || diffPixelY != 0) {
            var mapCenter = map.GetCenter();
            var mapCenterPixel = map.ActualMapToPixelCoords(mapCenter);
            //var mapCenterPixel = map.MapToPixelCoords(mapCenter);
            var newCoordsPixel = [mapCenterPixel[0] + diffPixelX, mapCenterPixel[1] + diffPixelY];
            var newCoords = map.ActualPixelToMapCoords(newCoordsPixel);
            //var newCoords = map.PixelToMapCoords(newCoordsPixel);
            if (!!useSetCenter) {
                map.SetCenter(newCoords);
            }
            else {
                map.SetCenter(newCoords);
                //map.AnimatedSetCenterIfDestVisible(newCoords, undefined, undefined, undefined, tf.units.EaseLinear);
            }
        }
    };
    this.IsPerspectiveMapShowing = function () { return !!perspectiveMap && perspectiveMap.GetIsVisible(); }
    this.SetMapExtent = function (extent, keepDirectionsOpen) {
        var extentScale = theThis.IsPerspectiveMapShowing() ? 2 : 1.5;
        extent = tf.js.ScaleMapExtent(extent, extentScale);
        /*if (theThis.GetHasEffectiveSidePanelFullContent()) {
            var layoutSettings = tf.TFMap.LayoutSettings;
            var minLeft = layoutSettings.sidePanelWidthInt;
            var res = map.GetResolution();
            var off = - res / minLeft;
            extent[0] += off;
            extent[2] += off;
        }*/
        if (!keepDirectionsOpen) {
            if (appCtx.GetCtxAttribute(tf.TFMap.CAN_showingDirections)) { appCtx.SetCtxAttribute(tf.TFMap.CAN_showingDirections, false) }
        }
        map.SetVisibleExtent(extent);
        //theThis.AnimatedSetCenterIfDestVisible([extent[0] + (extent[2] - extent[0]) / 2, extent[1] + (extent[3] - extent[1]) / 2]);
    }
    this.EnsureDirectionsVisible = function () {
        if (!appCtx.GetCtxAttribute(tf.TFMap.CAN_sidePanelVisible) || !appCtx.GetCtxAttribute(tf.TFMap.CAN_showingDirections)) {
            //if (!!currentEditorI) { deActivateCurrentEditor(); }
            var ctx = appCtx.GetCtx();
            ctx[tf.TFMap.CAN_sidePanelVisible] = ctx[tf.TFMap.CAN_showingDirections] = true;
            appCtx.SetCtx(ctx);
        }
    }
    this.AnimatedSetCenterIfDestVisible = function (coords) {
        if (theThis.GetHasEffectiveSidePanelFullContent()){
            //if (lastCtx[tf.TFMap.CAN_showingDirections] && lastCtx[tf.TFMap.CAN_sidePanelVisible]) {
            var pixelCoords = map.ActualMapToPixelCoords(coords);
            pixelCoords[0] -= tf.TFMap.LayoutSettings.sidePanelWidthInt / 2;
            coords = map.ActualPixelToMapCoords(pixelCoords);
        }
        map.AnimatedSetCenterIfDestVisible(coords, undefined, undefined, undefined, tf.units.EaseLinear);
    }
    this.SetDirectionsTargetToCoords = function (pointCoords, forceEnd, skipEnsureVisible) { directionsPanel.SetDirectionsTargetToCoords(pointCoords, forceEnd, skipEnsureVisible); }
    this.SetDirectionsTargetToMapFeature = function (mapFeature, forceEnd, skipEnsureVisible) { theThis.SetDirectionsTargetToCoords(mapFeature.GetPointCoords(), forceEnd, skipEnsureVisible); }
    this.OnCloseMapFeatureProps = function () { updatePinMapFeature(); }
    this.GetVidPassThrough = function () { var urlMapSettings = settings.mapSettings; return { vid: urlMapSettings.vidParam, passThrough: urlMapSettings.passThroughString }; }
    this.GoDB = function (pointCoords) {
        //console.log('went DB on ' + JSON.stringify(pointCoords));
        var longitude = tf.js.GetLongitudeFrom(pointCoords[0]);
        var latitude = tf.js.GetLatitudeFrom(pointCoords[1]);
        if (latitude != 0 && longitude != 0) {
            var res = map.GetResolution();
            var strURL = "http://vn4.cs.fiu.edu/cgi-bin/gnis.cgi?Res=" + res + "&Lat=" + latitude + "&Long=" + longitude;
            var vidParam = map.GetVIDParamStr();
            var passthroughParam = map.GetTFPassThroughString();
            if (vidParam) { strURL += "&vid=" + vidParam; }
            if (passthroughParam) { if (passthroughParam.charAt(0) == "&") { strURL += passthroughParam; } else { strURL += "&" + passthroughParam; } }
            window.open(strURL, '_top');
        }
    }
    this.GetToaster = function () { return toaster; }
    this.GetAppCtx = function () { return appCtx; }
    this.GetAppStyles = function () { return appStyles; }
    this.GetMap = function () { return map; }
    this.GetMultiMenus = function () { return multiMenus; }
    this.OnLayoutChange = function () { return onLayoutChange(); }
    this.GetLastCtx = function () { return lastCtx; }
    this.GetAppDiv = function () { return appDiv; }
    this.GetRootDiv = function () { return rootDiv; }
    this.GetMapDiv = function () { return mapDiv; }
    this.GetMapMapDiv = function () { return mapMapDiv; }
    this.GetSidePane = function () { return sidePane; }
    this.GetBottomPane = function () { return bottomPane; }
    this.GetToolTipDisplayer = function () { return toolTipDisplayer; }
    this.ShowUserLocation = function () { mapUserLocation.Show(); mapUserLocation.PanToMapFeature(); }
    this.RefreshProps = function (mapFeature) { mapFeaturePropsDisplayer.RefreshProps(mapFeature); checkSendPropsMapFeatureToDirections(mapFeature); }
    this.ShowMapFeatureProps = function (mapFeature) {
        if (skipFirstMapFeatureProps) { skipFirstMapFeatureProps = false; }
        else { mapFeaturePropsDisplayer.ShowProps(mapFeature); }
        skipFirstMapFeatureProps = false;
        checkSendPropsMapFeatureToDirections(mapFeature);
    }
    this.SearchAddress = function (searchText) { mapSearchLocation.SearchAddress(searchText); }
    this.Search = function () {
        for (var i in dataSetSearches) {
            var tfs = dataSetSearches[i]; if (!tfs.GetIsSearching()) { var tfss = tfs.GetSettings(), smf = tfss.searchMapFeatures; if (smf.GetIsVisible()) { tfs.Search(); } }
        }
    }
    this.CreateDataSetListButton = function (insertWrapper, wrapper, buttonClasses, tfs) {
        var buttonSettings = {
            buttonClass: buttonClasses, wrapper: wrapper, insertWrapper: insertWrapper, keepOnHoverOutTarget: true, offsetX: -8, offsetY: 0,
            delayMillis: tf.TFMap.dataSetListButtonToolTipDelayMillis
        };
        var button = theThis.CreateButton(tf.js.ShallowMerge(buttonSettings, getDataSetToolTip(wrapper, tfs)));
        return button;
    }
    this.CreateButton = function (buttonSettings) {
        var button = new tf.TFMap.IconButton({ onClick: onButtonClicked, cssClass: buttonSettings.buttonClass, onHover: onHoverButton, buttonSettings: buttonSettings, svgHTML: buttonSettings.svgHTML });
        button.onClick = buttonSettings.onClick;
        button.onHover = buttonSettings.onHover;
        tf.TFMap.SetButtonToolTipInfo(button, buttonSettings.toolTipText, buttonSettings.wrapper, buttonSettings.delayMillis, buttonSettings.toolTipClass,
            buttonSettings.toolTipArrowClass, buttonSettings.toolTipStyle, buttonSettings.keepOnHoverOutTarget,
            buttonSettings.toolTipFunction, buttonSettings.insertWrapper,
            buttonSettings.offsetX, buttonSettings.offsetY);
        return button;
    }
    this.CreateToggleButton = function (buttonSettings) {
        var button = new tf.TFMap.ToggleButton({
            svgHTML: buttonSettings.svgHTML,
            onClick: onButtonClicked, onHover: onHoverButton,
            buttonClassName: buttonSettings.buttonClass, classToggled: buttonSettings.classToggled, classNotToggled: buttonSettings.classNotToggled,
            isToggled: buttonSettings.isToggled,
            autoToggle: buttonSettings.autoToggle != undefined ? buttonSettings.autoToggle : true
        });
        button.onClick = buttonSettings.onClick;
        button.onHover = buttonSettings.onHover;
        tf.TFMap.SetButtonToolTipInfo(button, buttonSettings.toolTipText, buttonSettings.wrapper, buttonSettings.delayMillis, buttonSettings.toolTipClass,
            buttonSettings.toolTipArrowClass, buttonSettings.toolTipStyle, buttonSettings.keepOnHoverOutTarget,
            buttonSettings.toolTipFunction, buttonSettings.insertWrapper,
            buttonSettings.offsetX, buttonSettings.offsetY);
        return button;
    }
    this.OnMapLevelChange = function () { return onMapLevelChange(); }
    this.GetIsShowingAerial = function () { return showingAerial; }
    this.GetSwitchToMapTypeName = function () { return showingAerial ? "Map" : "Aerial"; }
    this.SwitchMapType = function () {
        var mapType, auxMapType;
        if (showingAerial = !showingAerial) { mapType = tf.consts.typeNameHybrid; auxMapType = tf.consts.typeNameMap; }
        else { mapType = tf.consts.typeNameMap; auxMapType = tf.consts.typeNameAerial; }
        updateAppDivForMapType();
        updateScaleElemForMapType();
        if (!!baseLayersPanel) { baseLayersPanel.UpdateForMapType(); }
        map.SetMapType(mapType);
        if (!!mapTypeAuxMap) { mapTypeAuxMap.SetMapType(auxMapType); }
        appStyles.SetIsShowingAerial(showingAerial);
        updateSearchLayersVisibility();
        if (!!currentEditorI && tf.js.GetFunctionOrNull(currentEditorI.updateForMapType)) { currentEditorI.updateForMapType(); }
        if (!!customAppContent) { customAppContent.UpdateForMapType(); }
        //map.Render();
    }
    function updateAppDivForMapType() {
        var ls = tf.TFMap.LayoutSettings;
        var isShowingAerial = theThis.GetIsShowingAerial();
        tf.dom.ReplaceCSSClassCondition(appDiv, isShowingAerial, ls.showingAerialClassName, ls.showingMapClassName);
    }
    function updateSearchLayersVisibility() {
        searchLayerHybridB.SetVisible(showingAerial);
        searchLayerMapB.SetVisible(!showingAerial);
    }
    function updateScaleElemForMapType() {
        var ls = tf.TFMap.LayoutSettings;
        var isShowingAerial = theThis.GetIsShowingAerial();
        if (!!scaleElem) {
            tf.dom.ReplaceCSSClassCondition(scaleElem.element.firstChild, isShowingAerial, ls.wrapperAerialModeClassName, ls.wrapperMapModeClassName);
        }
    }
    function checkSendPropsMapFeatureToDirections(mapFeature) {
        if (!!mapFeature && mapFeature != pinMapFeature) {
            if (lastCtx[tf.TFMap.CAN_showingDirections]) {
                if (directionsPanel.GetNeedsAddress()) {
                    theThis.SetDirectionsTargetToMapFeature(mapFeature, false);
                }
            }
        }
        //else { console.log('here'); }
    }
    function onButtonClicked(notification) {
        var button = notification.sender;
        if (tf.js.GetFunctionOrNull(button.onClick)) { button.onClick(notification); }
        toolTipDisplayer.RefreshToolTip();
    }
    function onHoverButton(notification) {
        var hoverNotification = notification.notification, button = notification.sender;
        var nextToolTipSender = hoverNotification.isInHover ? button : button.keepOnHoverOutTarget ? button : undefined;
        var needChange = true;
        var curToolTipSender = appCtx.GetCtxAttribute(tf.TFMap.CAN_selectedToolTipSender);
        if (!!curToolTipSender) { if (curToolTipSender.keepOnHoverOutTarget) { needChange = !toolTipDisplayer.GetIsInHover(); } }
        if (needChange) { appCtx.SetCtxAttribute(tf.TFMap.CAN_selectedToolTipSender, nextToolTipSender); }
        if (tf.js.GetFunctionOrNull(button.onHover)) { button.onHover(notification); }
    }
    function getDataSetToolTipContent(tfs) {
        var searchMapFeatures = tfs.GetSettings().searchMapFeatures;
        var searchFeatures = searchMapFeatures.GetSearchFeaturesForToolTip();
        var toolTipInfos = [];
        var toolTipText = [];
        lastClusterFeatures = [];
        for (var i in searchFeatures) {
            var thisMapFeature = searchFeatures[i];
            var thisMapFeatureTTP = getMapFeatureToolTipProps(thisMapFeature, thisMapFeature.GetPointCoords());
            var thisToolTip = /*(i + 1) + ": " + */(tf.js.GetFunctionOrNull(thisMapFeatureTTP.toolTipText) ? thisMapFeatureTTP.toolTipText(thisMapFeatureTTP) : thisMapFeatureTTP.toolTipText);
            toolTipInfos.push({ toolTipText: thisToolTip, mapFeature: thisMapFeature });
        }
        if (toolTipInfos.length > 0) {
            toolTipInfos.sort(function (a, b) { return a.toolTipText < b.toolTipText ? -1 : a.toolTipText > b.toolTipText ? 1 : -1; });
            for (var i = 0; i < toolTipInfos.length; ++i) {
                toolTipText.push(toolTipInfos[i].toolTipText);
            }
            lastClusterFeatures = toolTipInfos;
        }
        else {
            toolTipText = "'" + tfs.GetDataSetTitle() + "' dataset";
        }
        return toolTipText;
    }
    function getDataSetToolTip(wrapper, tfs) {
        var toolTipProps = {
            wrapper: wrapper, onClick: onClickMapFeatureToolTip,
            toolTipFunction: function (sender) { return getDataSetToolTipContent(tfs) },
            toolTipClass: "*start", toolTipArrowClass: "left"
        };
        return toolTipProps;
    };
    function getMapFeatureToolTipProps(mapFeature, coords) {
        var sidePanelWidthInt = theThis.GetHasEffectiveSidePanelFullContent() ? tf.TFMap.LayoutSettings.sidePanelWidthInt : 0;
        //var sidePanelWidthInt = lastCtx[tf.TFMap.CAN_showingDirections] && lastCtx[tf.TFMap.CAN_sidePanelVisible] ? tf.TFMap.LayoutSettings.sidePanelWidthInt : 0;
        var toolTipProps = tf.TFMap.GetDynamicMapFeatureToolTipProps(map, mapFeature, coords, sidePanelWidthInt);
        if (!!toolTipProps) {
            var toolTipParentDiv = theThis.GetMapDiv();
            //var toolTipParentDiv = rootDiv;   // root div would be better to overlap floating panels, but there's an issue with hover out
            toolTipProps = tf.TFMap.GetMapFeatureToolTipInfo(mapFeature, map, toolTipProps.toolTipText, toolTipParentDiv, toolTipProps.delayMillis,
                toolTipProps.toolTipClass, toolTipProps.toolTipArrowClass, toolTipProps.toolTipStyle, coords, toolTipProps.offsetX, toolTipProps.offsetY, toolTipProps.onClick,
                toolTipProps.keepOnHoverOutTarget);
        }
        return toolTipProps;
    }
    function onClickMapFeatureToolTip(notification) {
        //console.log('clicked tool tip button ' + notification.order);
        if (notification.toolTipSender != undefined) {
            if (notification.order != undefined) {
                if (lastClusterFeatures != undefined) {
                    if (notification.order < lastClusterFeatures.length) {
                        var mapFeature = lastClusterFeatures[notification.order].mapFeature;
                        if (tf.TFMap.GetSearchFeature(mapFeature)) {
                            appCtx.SetCtxAttribute(tf.TFMap.CAN_selectedSearch, mapFeature);
                            theThis.ShowMapFeatureProps(mapFeature);
                        }
                    }
                }
            }
        }
    }
    //var testPMapFeatureActualPixelCoords, testPMapFeaturePixelCoords;
    function onMapMouseMove(notification) {
        if (notification.nMapFeatures == 0) { deselectToolTipSender(); }
        /*testPMapFeatureActualPixelCoords = notification.actualPixelCoords;
        testPMapFeaturePixelCoords = notification.pixelCoords;
        testPMapFeature.SetPointCoords(notification.eventCoords);*/
    }
    function reCenterMapTypeAux() { if (!!mapTypeAuxMap) { mapTypeAuxMap.SetCenter(map.GetCenter()); } }
    function onMapMoveEnd(notification) {
        theThis.Search();
    }
    function onMapMoveStart(notification) {
        //console.log('move start');
    }
    function updatePinMapFeature() { pinMapFeature.Update(mapFeaturePropsDisplayer.GetLastMapFeature()); }
    function onMapPreCompose(notification) {
        var mapCenter = map.GetCenter();
        if (appCtx.GetCtxAttribute(tf.TFMap.CAN_selectedToolTipSender) != undefined) {
            if (mapCenter[0] != centerMapOnToolTipOpen[0] || mapCenter[1] != centerMapOnToolTipOpen[1]) { deselectToolTipSender(); }
        }
        if (!!mapTypeAuxMap) {
            var mapTypeCenter = mapTypeAuxMap.GetCenter();
            if (mapCenter[0] != mapTypeCenter[0] || mapCenter[1] != mapTypeCenter[1]) { reCenterMapTypeAux(); }
            var mapRotationRad = map.GetRotationRad();
            if (mapRotationRad != mapTypeAuxMap.GetRotationRad()) { mapTypeAuxMap.SetRotationRad(mapRotationRad); }
        }
    }
    function onMapScaleUnit(notification) {
        directionsPanel.UpdateDistances();
        if (!!currentEditorI && tf.js.GetFunctionOrNull(currentEditorI.onMapScaleUnit)) { currentEditorI.onMapScaleUnit(notification); }
        map.Render();
    }
    function notifyBaseLayersResChange() { if (!!baseLayersPanel) { baseLayersPanel.OnMapResolutionChange(); } }
    function onMapResolutionChange(notification) {
        notifyBaseLayersResChange();
    }
    function onMapLevelChange(notification) {
        if (!!mapTypeAuxMap) { mapTypeAuxMap.SetLevel(map.GetLevel() - diffLevelMapTypeAux); }
        notifyBaseLayersResChange();
    }
    function onLayoutChange() { appSizer.OnResize(); }
    var hadAppResized;
    function onAppResize() {
        /*var winDims = tf.dom.GetWindowDims();
        rootDiv.GetHTMLElement().style.width = winDims[0] + "px";
        rootDiv.GetHTMLElement().style.height = winDims[1] + "px";*/
        if (appStyles == undefined) {
            if (!hadAppResized) {
                hadAppResized = true;
                appStyles = new tf.TFMap.Styles({ appContent: theThis, onLoaded: onStylesLoaded, sidePanelWidthInt: settings.sidePanelWidthInt });
                appStyles.AddOnLayoutChangeListener(onLayoutChangeFromStyles);
            }
        }
        if (appStyles != undefined) {
            appStyles.CheckLayoutChange();
            if (!!map) {
                map.OnResize();
                if (!!mapTypeAuxMap) { mapTypeAuxMap.OnResize(); }
                updateMenuPositions();
                if (!!directionsPanel) { directionsPanel.OnResize(); }
                deselectToolTipSender();
            }
        }
        //console.log('app resize');
    }
    function onFullResize() { updateMenuPositions(); }
    function updateMenuPositions() { multiMenus.UpdateMenuPositions(); }
    function onContextChange(notification) {
        var newCtx = notification.ctx;
        var lastDirectionsMode = lastCtx[tf.TFMap.CAN_directionsMode];
        var newDirectionsMode = newCtx[tf.TFMap.CAN_directionsMode];
        var changedDirectionsMode = lastDirectionsMode != newDirectionsMode;
        var lastInDirectionsMode = lastCtx[tf.TFMap.CAN_showingDirections];
        var newInDirectionsMode = newCtx[tf.TFMap.CAN_showingDirections];
        var changedInDirectionsMode = lastInDirectionsMode != newInDirectionsMode;
        var lastToolTipSender = lastCtx[tf.TFMap.CAN_selectedToolTipSender];
        var newToolTipSender = newCtx[tf.TFMap.CAN_selectedToolTipSender];
        var changedToolTipSender = lastToolTipSender != newToolTipSender;
        var lastSidePaneVisible = lastCtx[tf.TFMap.CAN_sidePanelVisible];
        var newSidePaneVisible = newCtx[tf.TFMap.CAN_sidePanelVisible];
        var changedSidePaneVisible = lastSidePaneVisible != newSidePaneVisible;
        var lastSearchingAddress = lastCtx[tf.TFMap.CAN_isSearchingAddress];
        var newSearchingAddress = newCtx[tf.TFMap.CAN_isSearchingAddress];
        var changedSearchingAddress = lastSearchingAddress != newSearchingAddress;
        var lastDataSetsPaneVisible = lastCtx[tf.TFMap.CAN_dataSetsPanelVisible];
        var newDataSetsPaneVisible = newCtx[tf.TFMap.CAN_dataSetsPanelVisible];
        var changedDataSetsPaneVisible = lastDataSetsPaneVisible != newDataSetsPaneVisible;
        var updatedSearches = [], changedStateSearches = [], changedVisibilitySearches = [];
        for (var i in dataSetSearches) {
            var tfs = dataSetSearches[i], tfsSettings = tfs.GetSettings(), updateVerb = tfsSettings.updateVerb, visibilityVerb = tfsSettings.visibilityVerb,
                autoRefreshVerb = tfsSettings.autoRefreshVerb;
            var lastIsSearching = lastCtx[updateVerb];
            var newIsSearching = newCtx[updateVerb];
            var changedIsSearching = lastIsSearching != newIsSearching;
            var lastIsVisible = lastCtx[visibilityVerb];
            var newIsVisible = newCtx[visibilityVerb];
            var changedIsVisible = lastIsVisible != newIsVisible;
            var lastAutoRefresh = lastCtx[autoRefreshVerb];
            var newAutoRefresh = newCtx[autoRefreshVerb];
            var changedAutoRefresh = lastAutoRefresh != newAutoRefresh;
            if (changedIsSearching) { if (!newIsSearching) { updatedSearches.push(tfs); } changedStateSearches.push(tfs); }
            if (changedIsVisible || changedAutoRefresh) { if (!changedIsSearching) { changedStateSearches.push(tfs); } if (changedIsVisible) { changedVisibilitySearches.push(tfs); } }
        }
        lastCtx = tf.js.ShallowMerge(newCtx);
        if (changedToolTipSender) { centerMapOnToolTipOpen = map.GetCenter(); toolTipDisplayer.Show(newToolTipSender); }
        if (updatedSearches.length > 0) { for (var i in updatedSearches) { var tfs = updatedSearches[i]; tfs.GetSettings().searchMapFeatures.UpdateSearchFeatures(tfs.GetAddedAndDeletedSearchResults()); } }
        if (changedStateSearches.length > 0) { for (var i in changedStateSearches) { var tfs = changedStateSearches[i]; dataSetsBar.Update(tfs.GetTitle()); } }
        if (changedVisibilitySearches.length > 0) {
            for (var i in changedVisibilitySearches) {
                var tfs = changedVisibilitySearches[i], tfss = tfs.GetSettings(), smf = tfss.searchMapFeatures;
                smf.UpdateVisibility();
                if (smf.GetIsVisible() && !tfs.GetIsSearching()) { tfs.Search(); }
            }
        }
        if (changedSidePaneVisible) { toolTipDisplayer.Show(undefined); sidePane.CheckIsVisible(); }
        if (changedDataSetsPaneVisible) { toolTipDisplayer.Show(undefined); dataSetsBar.CheckIsVisible(); }
        if (changedSearchingAddress) { searchBar.CheckSearchActive(); }
        if (changedInDirectionsMode || changedSidePaneVisible) { setBottomPaneWidth(); if (changedInDirectionsMode) { setDirectionsMode(); } }
        if (changedDirectionsMode) { directionsPanel.UpdateMode(); }
    }
    function setBottomPaneWidth() {
        var bottomPanePositionClasses = bottomPane.GetPositionClasses();
        //var inDirectionsMode = lastCtx[tf.TFMap.CAN_showingDirections];
        //var sidePaneVisible = lastCtx[tf.TFMap.CAN_sidePanelVisible];
        //tf.dom.ReplaceCSSClassCondition(rootDiv, inDirectionsMode && sidePaneVisible, bottomPanePositionClasses.widthWithSidePanelClassName, bottomPanePositionClasses.fullWidthClassName);
        tf.dom.ReplaceCSSClassCondition(rootDiv, theThis.GetHasEffectiveSidePanelFullContent(),
            bottomPanePositionClasses.widthWithSidePanelClassName, bottomPanePositionClasses.fullWidthClassName);
    }
    function deselectToolTipSender() {
        if (lastCtx[tf.TFMap.CAN_selectedToolTipSender] != undefined) {
            appCtx.SetCtxAttribute(tf.TFMap.CAN_selectedToolTipSender, undefined);
        }
        toolTipDisplayer.Show(undefined); 
    }
    function setDirectionsMode() {
        deselectToolTipSender(); directionsPanel.UpdateVisibility();
    }
    function getMapSettings(mapContainer, mapType, useScale) {
        var urlMapSettings = settings.mapSettings;
        var mapSettings = {
            vidParam: urlMapSettings.vidParam,
            passThroughString: urlMapSettings.passThroughString,
            container: mapContainer,
            mapEngine: urlMapSettings.mapEngine,
            legendH: urlMapSettings.legendH,
            legendM: urlMapSettings.legendM,
            decodedLegendH: decodedLegendH,
            decodedLegendM: decodedLegendM,
            fullScreenContainer: rootDiv,
            center: urlMapSettings.center,
            mapType: mapType,
            panels: undefined,
            noScaleLine: !useScale,
            panOnClick: false,
            goDBOnDoubleClick: false,
            level: urlMapSettings.level,
            resolution: urlMapSettings.resolution
        };
        return mapSettings;
    }
    function createMap(mapDiv, mapType, useScale, useInteractions, enableRotation) {
        var ls = tf.TFMap.LayoutSettings;
        var mapSettings = getMapSettings(mapDiv, mapType, useScale);
        mapSettings.noNativePopups = true;
        mapSettings.noNativeControls = true;
        mapSettings.showMapCenter = false;
        if (useScale) { mapSettings.scaleElemTarget = bottomPane.GetContentPane().GetHTMLElement(); }
        mapSettings.mapCenterSVG = appStyles.GetMapCenterSVG();
        var createdMap = new tf.map.Map(mapSettings);
        if (!!useInteractions) { createdMap.SetView({ minLevel: tf.TFMap.MinMapLevel, maxLevel: tf.TFMap.MaxMapLevel, enableRotation: enableRotation }); }
        else { createdMap.SetView({ minLevel: tf.TFMap.MinMapLevel, maxLevel: tf.TFMap.MaxMapLevel }); }
        createdMap.SetFractionalZoomInteraction(true);
        createdMap.SetGoDBOnDoubleClick(false);
        createdMap.SetHasInteractions(useInteractions);
        createdMap.SetIsUSScaleUnits(true);
        if (useScale) {
            scaleElem = createdMap.GetPanelElement(tf.consts.panelNameMapScale);
            calcScaleElemLayout();
            updateScaleElemForMapType();
        }
        return createdMap;
    }
    /*function calcLogoElemLayout() {
        if (!!logoElem) {
            var isSmallScreen = appStyles.GetIsSmallScreen();
            var logoHTMLElem = logoElem.GetHTMLElement(), logoS = logoHTMLElem.style;
            logoS.left = "initial";
            if (isSmallScreen) {
                logoS.top = logoS.right = "0.5rem";
                logoS.width = logoS.height = "3rem";
            }
            else {
                logoS.top = logoS.right = "3rem";
                logoS.width = logoS.height = "5rem";
            }
        }
    }*/
    function calcScaleElemLayout() {
        if (!!scaleElem) {
            var isSmallScreen = appStyles.GetIsSmallScreen();
            var scaleButton = scaleElem.element.firstChild;
            tf.dom.AddCSSClass(scaleButton, "ripple");
            var scaleElemStyle = scaleElem.element.style, buttonStyle = scaleButton.style;
            scaleElemStyle.pointerEvents = "all";
            scaleElemStyle.left = "initial";
            if (isSmallScreen) {
                scaleElemStyle.fontSize = "10px";
                scaleElemStyle.height = "12px";
                buttonStyle.height = "12px";
                buttonStyle.marginTop = "0px";
                scaleElemStyle.bottom = (2 - tf.TFMap.LayoutSettings.marginBottomBottomPaneWrapperInt) + "px";
            }
            else {
                scaleElemStyle.fontSize = "11px";
                scaleElemStyle.bottom = (4 - tf.TFMap.LayoutSettings.marginBottomBottomPaneWrapperInt) + "px";
            }
            //scaleElemStyle.right = (ls.widthMapToolBarInt + ls.leftMarginInt + ls.toolBarToToolBarHorSpacingInt + 2) + "px";
            scaleElemStyle.left = "2px";
            scaleElemStyle.zIndex = "0";
        }
    }
    function adjustMapFeatureClustersForLayout() {
        var ls = tf.TFMap.LayoutSettings;
        var clusterStyle = getClusterStyle();
        if (!!searchLayerHybridB) {
            searchLayerHybridB.SetClusterFeatureDistance(ls.clusterFeatureDistance);
            searchLayerHybridB.SetClusterStyle(clusterStyle);
        }
        if (!!searchLayerMapB) {
            searchLayerMapB.SetClusterFeatureDistance(ls.clusterFeatureDistance);
            searchLayerMapB.SetClusterStyle(clusterStyle);
        }
    }
    function getClusterStyle() {
        var ls = tf.TFMap.LayoutSettings;
        return {
            zindex: clusterZIndex, circle: true, circle_radius: ls.clusterCircleRadius, fill: true, fill_color: "#037",
            line: true, line_color: "#fff", line_width: 2, line_opacity: 30
        }
    }
    function createMapLayers(onMap, searchSettings, startZIndex) {
        var ls = tf.TFMap.LayoutSettings;
        var layerSettings = { name: "", isVisible: true, isHidden: true, useClusters: false, zIndex: startZIndex };
        layerSettings.name = "bottomCustomAppLayer";
        bottomCustomAppLayer = onMap.AddFeatureLayer(layerSettings);
        ++layerSettings.zIndex;
        layerSettings.name = "bfme";
        bottomFillLayerMeasureLayer = onMap.AddFeatureLayer(layerSettings);
        ++layerSettings.zIndex;
        layerSettings.name = "bfdl";
        bottomFillLayerDownloadLayer = onMap.AddFeatureLayer(layerSettings);
        ++layerSettings.zIndex;
        layerSettings.name = "additionalFeatures";
        additionalFeaturesLayer = onMap.AddFeatureLayer(layerSettings);
        ++layerSettings.zIndex;
        var clusterSearchLayers = isUsingClusters;
        var searchLayerSettings = {
            useClusters: clusterSearchLayers,
            clusterFeatureDistance: ls.clusterFeatureDistance,
            clusterStyle: getClusterStyle(),
            clusterLabelStyle: {
                font: "600 12px Roboto",
                zindex: clusterZIndex + 1, text: true, fill: true, fill_color: "#fff", line: true, line_opacity: 70, line_color: "#000", line_width: 2
            }
        };
        searchLayerHybridB = map.AddFeatureLayer(tf.js.ShallowMerge(layerSettings, searchLayerSettings, { name: "slHB", isVisible: showingAerial }));
        ++layerSettings.zIndex;
        searchLayerMapB = map.AddFeatureLayer(tf.js.ShallowMerge(layerSettings, searchLayerSettings, { name: "slMB", isVisible: !showingAerial }));
        ++layerSettings.zIndex;
        layerSettings.name = "clickedLocation";
        mapClickedLocationLayer = onMap.AddFeatureLayer(layerSettings);
        ++layerSettings.zIndex;
        layerSettings.zIndex = 2000;
        layerSettings.name = "userLocation";
        mapUserLocationLayer = onMap.AddFeatureLayer(layerSettings);
        ++layerSettings.zIndex;
        layerSettings.name = "directions";
        mapDirectionsLayer = onMap.AddFeatureLayer(layerSettings);
        ++layerSettings.zIndex;
        layerSettings.name = "pins";
        mapPinsLayer = onMap.AddFeatureLayer(layerSettings);
        ++layerSettings.zIndex;
        layerSettings.name = "directionItems";
        mapDirectionItemsLayer = onMap.AddFeatureLayer(layerSettings);
        ++layerSettings.zIndex;
        layerSettings.name = "directionWaypoints";
        mapDirectionWayPointsLayer = onMap.AddFeatureLayer(layerSettings);
        ++layerSettings.zIndex;
        layerSettings.name = "directionPins";
        mapDirectionsPinsLayer = onMap.AddFeatureLayer(layerSettings);
        ++layerSettings.zIndex;
        layerSettings.name = "measureToolLayer";
        measureToolLayer = onMap.AddFeatureLayer(layerSettings);
        ++layerSettings.zIndex;
        layerSettings.name = "downloadToolLayer";
        downloadToolLayer = onMap.AddFeatureLayer(layerSettings);
        ++layerSettings.zIndex;
    }
    function createSearches(searchSettings, nDLayerExtent) {
        var searches = {};
        var nSearchSettings = searchSettings.length;
        var preClick = settings.mapSettings.dlayerPreClick;
        //for (var i = nSearchSettings - 1; i >= 0; --i) {
        for (var i = 0; i < nSearchSettings ; ++i) {
            var searchSetting = searchSettings[i];
            var zIndex = (nSearchSettings - i - 1) * 10 + 1;
            var searchTitle = searchSetting.title;
            var nDLayerExtentUse = i == 0 ? nDLayerExtent : undefined;
            var preClickUse = i == 0 ? preClick : false;
            if (searches[searchTitle] == undefined) {
                searches[searchTitle] = new tf.TFMap.DataSetSearch({
                    appContent: theThis,
                    title: searchTitle,
                    updateVerb: searchSetting.updateVerb,
                    visibilityVerb: searchSetting.visibilityVerb,
                    markerNameField: searchSetting.markerNameField,
                    autoRefreshVerb: searchSetting.autoRefreshVerb,
                    maxRecords: searchSetting.maxRecords,
                    nDLayerExtent: nDLayerExtentUse,
                    urlStart: searchSetting.urlStart,
                    searchMapFeatures: new tf.TFMap.SearchMapFeatures({
                        appContent: theThis,
                        minZIndex: zIndex,
                        visibilityVerb: searchSetting.visibilityVerb,
                        addStyles: appStyles.AddSearchFeatureStyles,
                        color: searchSetting.color,
                        nDLayerExtent: nDLayerExtentUse,
                        dlayerPreClick: preClickUse,
                        layerMapB: searchLayerMapB,
                        layerHybridB: searchLayerHybridB
                    })
                });
            }
            else {
                console.log('duplicate search title: ' + searchTitle);
            }
        }
        return searches;
    }
    function createSearchSettings(useFake) {
        var maxRecords = 100;
        var searchSettings;
        if (tf.js.GetIsNonEmptyArray(settings.dlayerParams)) {
            var nDLayers = settings.dlayerParams.length;
            var defaultColors = ["#f00", "#44f", "#0a0", "#d3d", "#3dd", "#b63", "#f80", "#08f", "#80f", "#8f0", "#0f8", "#f08"];
            for (var i in defaultColors) { defaultColors[i] = appStyles.GetLighterColor(defaultColors[i]); }
            searchSettings = [];
            for (var i = 0; i < nDLayers; ++i) {
                var dlayerSetting = settings.dlayerParams[i];
                var searchSetting = {
                    title: dlayerSetting.dLayerLegend,
                    urlStart: dlayerSetting.dLayerData,// + "&numfind=20",
                    isVisible: dlayerSetting.dLayerSelect,
                    markerNameField: dlayerSetting.dLayerField,
                    color: defaultColors[i % defaultColors.length],
                    maxRecords: maxRecords
                };
                searchSettings.push(searchSetting);
            }
        }
        else if (useFake) {
            var ITPASearchSetting = {
                title: "Businesses2",
                //urlStart: "http://acorn.cs.fiu.edu/cgi-bin/arquery.cgi?category=itpall&vid=itpa&numfind=20&tfaction=shortdisplayflash",
                urlStart: "http://n00.cs.fiu.edu/cgi-bin/arquery1.cgi?vid=ramb&y1=25.787794538070614&x1=-80.362932146016&category=callreal",
                isVisible: true,
                markerNameField: "L",
                color: "#f00",
                maxRecords: maxRecords
            };
            var restaurantsSearchSetting = {
                title: "Restaurants",
                urlStart: "http://n00.cs.fiu.edu/cgi-bin/arquery.cgi?category=us_companies_2013&tfaction=shortdisplayflash&arcriteria=1&Industry=Eating&numfind=20",
                isVisible: true,
                markerNameField: "L",
                color: "#00f",
                maxRecords: maxRecords
            };
            var storesSearchSetting = {
                title: "Stores",
                urlStart: "http://n00.cs.fiu.edu/cgi-bin/arquery.cgi?category=us_companies_2013&tfaction=shortdisplayflash&numfind=20&arcriteria=1&SIC_CODE_Description|=store+stores",
                isVisible: true,
                markerNameField: "L",
                color: "#0c0",
                maxRecords: maxRecords
            };
            var sideViewSearchSetting = {
                title: "SideView",
                urlStart: "http://acorn.cs.fiu.edu/cgi-bin/arquery.cgi?tester=&category=alta&vid=&tfaction=shortdisplayflash&numfind=20",
                isVisible: true,
                markerNameField: "L",
                color: "#0cf",
                maxRecords: maxRecords
            };
            searchSettings = [ITPASearchSetting, restaurantsSearchSetting, storesSearchSetting/*, sideViewSearchSetting*/];
        }
        else {
            searchSettings = [];
        }
        var nSearches = searchSettings.length;
        for (var i = 0; i < nSearches; ++i) {
            var searchSetting = searchSettings[i];
            searchSetting.updateVerb = "sIsSearching" + i;
            searchSetting.visibilityVerb = "sIsVisible" + i;
            searchSetting.autoRefreshVerb = "sAutoRefreshes" + i;
        }
        return searchSettings;
    }
    function createInitialContext(searchSettings, dataSetsPaneVisible, initialDirectionsMode) {
        var initialContext = {};
        var contextAttributeNames = [
            tf.TFMap.CAN_directionsMode,
            tf.TFMap.CAN_showingDirections,
            tf.TFMap.CAN_isSearchingAddress,
            tf.TFMap.CAN_sidePanelVisible,
            tf.TFMap.CAN_dataSetsPanelVisible,
            tf.TFMap.CAN_selectedSearch,
            tf.TFMap.CAN_selectedToolTipSender,
            tf.TFMap.CAN_userLocation,
            tf.TFMap.CAN_clickLocation,
            tf.TFMap.CAN_searchAddressLocation
        ];
        for (var i in contextAttributeNames) { initialContext[contextAttributeNames[i]] = undefined; }
        initialContext[tf.TFMap.CAN_sidePanelVisible] = true;
        initialContext[tf.TFMap.CAN_dataSetsPanelVisible] = dataSetsPaneVisible != undefined ? !!dataSetsPaneVisible : true;
        initialContext[tf.TFMap.CAN_showingDirections] = false;
        initialContext[tf.TFMap.CAN_directionsMode] = initialDirectionsMode;//tf.TFMap.directionModeDrive;
        for (var i in searchSettings) {
            var searchSetting = searchSettings[i];
            initialContext[searchSetting.updateVerb] = false;
            initialContext[searchSetting.visibilityVerb] = searchSetting.isVisible;
            initialContext[searchSetting.autoRefreshVerb] = true;
        }
        return initialContext;
    }
    function setBottomPaneUpDownStyle() {
        var bottomPanePositionClasses = bottomPane.GetPositionClasses();
        tf.dom.ReplaceCSSClassCondition(rootDiv, isBottomPaneUp, bottomPanePositionClasses.upClassName, bottomPanePositionClasses.downClassName);
        if (!isBottomPaneUp) {
            var underBottomWrapper = bottomPane.GetUnderBottomWrapper();
            underBottomWrapper.ClearContent();
        }
    }
    function createToaster(container) {
        var toasterStyle = { zIndex: 20, position: "absolute", right: "0px", top: "0px" };
        var toaster = new tf.ui.Toaster({
            container: container, timeout: 2000, className: "", style: toasterStyle, toastClassName: toastClassName, toastStyle: {
                display: "inline-block", margin: "6px", boxShadow: "3px 3px 6px rgba(0,0,0,0.5)"
            }, addBefore: true
        });
        return toaster;
    }
    function requestEditorClose(notification) { if (!!currentEditorI && notification.sender == currentEditorI.sender) { deActivateCurrentEditor(); } }
    function deActivateCurrentEditor() {
        if (!!currentEditorI) {
            var isMoreToolsTool = (theThis.IsMeasureToolOn() || theThis.IsDownloadToolOn());
            if (!!tf.js.GetFunctionOrNull(currentEditorI.deActivate)) { currentEditorI.deActivate(); }
            currentEditorI = undefined;
            if (isMoreToolsTool && !!mapMoreTools) { mapMoreTools.UpdateToolsVisibility(); }
            map.Render();
        }
    }
    function activateEditor(editorI) {
        deActivateCurrentEditor();
        if (!!editorI) {
            currentEditorI = editorI;
            if (!!tf.js.GetFunctionOrNull(currentEditorI.activate)) { currentEditorI.activate(); }
            if ((theThis.IsMeasureToolOn() || theThis.IsDownloadToolOn()) && !!mapMoreTools) { mapMoreTools.UpdateToolsVisibility(); }
            map.Render();
        }
    }
    function initMapLegend() {
        var urlMapSettings = settings.mapSettings;
        var isM2 = urlMapSettings.mapEngine != tf.consts.mapnikEngine;
        decodedLegendH = tf.js.DecodeLegend(urlMapSettings.legendH);
        decodedLegendM = isM2 ? tf.js.DecodeLegend(urlMapSettings.legendM) : decodedLegendH
    }
    function createControl() {
        initMapLegend();
        //var customizedScrollBarClassName = tf.TFMap.LayoutSettings.customizedScrollBarClassName;
        tf.TFMap.LayoutSettings.distances3Units = tf.js.CalcDistances3Units();
        photoList = new tf.TFMap.PhotoList({ appContent: theThis });
        photoListDisplayer = new tf.TFMap.PhotoListDisplayer({ appContent: theThis });
        photoDisplayer = new tf.TFMap.PhotoDisplayer({ appContent: theThis });
        overMapCanvas = new tf.TFMap.OverMapCanvas({ appContent: theThis });
        //underBottomWrapper = new tf.dom.Div({ cssClass: "underBottomPaneWrapper" });
        var urlMapSettings = settings.mapSettings;
        var strPanels = urlMapSettings.panels;
        var useMeasureTool = false, useDownloadTool = false;
        var createAuxTypeMap = false, createBaseLayers = false;
        var dataSetsPaneVisible = true;
        var userLocationButton = true;
        var zoomButtons = false;
        var compassButtons = true;
        var useMapCenter = true;
        var useMapLogo = false;
        usePerspectiveMap = perspectiveMapIsInitiallyVisible = false;
        useBusDirections = settings.params[tf.consts.paramNameDirectionsUseBus] != undefined;
        var webGL = tf.webgl.GetWebGL();
        if (webGL.GetHasWebGL()) {
            if((usePerspectiveMap = settings.params[tf.consts.paramNamePerspectiveMap]) != undefined) {
                perspectiveMapIsInitiallyVisible = tf.js.GetBoolFromValue(usePerspectiveMap);
                usePerspectiveMap = true;
            }
        }
        if (tf.js.GetIsNonEmptyString(strPanels)) {
            strPanels = strPanels.split(tf.consts.charSplitStrings);
            var nPanels = strPanels.length;
            for (var i = 0; i < nPanels; ++i) {
                var panelStr = strPanels[i].toLowerCase();
                switch (panelStr) {
                    case tf.consts.panelNameTFLogo:
                        useMapLogo = true;
                        break;
                    case tf.consts.panelNameNoMapCenter:
                        useMapCenter = false;
                        break;
                    case tf.consts.panelNameNoMapRotate:
                        compassButtons = false;
                        break;
                    case tf.consts.panelNameZoom:
                        zoomButtons = true;
                        break;
                    case tf.consts.panelNameNoUserLocation:
                        userLocationButton = false;
                        break;
                    case tf.consts.panelNameLayers:
                        createBaseLayers = true;
                        break;
                    case tf.consts.panelNameType:
                        createAuxTypeMap = true;
                        break;
                    case tf.consts.panelNameMeasure:
                        useMeasureTool = true;
                        break;
                    case tf.consts.panelNameDownload:
                        useDownloadTool = true;
                        break;
                    case tf.consts.markersPanelCollapsed:
                        dataSetsPaneVisible = false;
                        break;
                }
            }
        }
        tf.TFMap.LayoutSettings.createAuxTypeMap = createAuxTypeMap;
        isUsingClusters = true;
        initWayPoints();
        settings.appContent = theThis;
        showingAerial = urlMapSettings.mapType != tf.consts.typeNameMap;
        appStyles.SetIsShowingAerial(showingAerial);
        var searchSettings = createSearchSettings(false);
        var initialDirectionsMode = tf.services.GetDirectionModeFrom(settings.params[tf.consts.paramNameDirectionsMode], tf.consts.routingServiceModeCar, useBusDirections);
        lastCtx = createInitialContext(searchSettings, dataSetsPaneVisible, initialDirectionsMode);
        appCtx = new tf.js.Context({ appContent: theThis, ctx: lastCtx });
        appCtx.AddListener(onContextChange);
        settings.multiMenus = multiMenus = new tf.ui.MultiMenus();
        toolTipDisplayer = new tf.TFMap.ToolTipDisplayer({ appContent: theThis });
        mapDiv = new tf.dom.Div({ cssClass: mapClassName });
        mapMapDiv = new tf.dom.Div({ cssClass: mapMapClassName });
        mapDiv.AddContent(mapMapDiv);
        bottomPane = new tf.TFMap.BottomPane({ appContent: theThis });
        map = createMap(mapMapDiv, showingAerial ? tf.consts.typeNameHybrid : tf.consts.typeNameMap, true, true, compassButtons);
        createMapLayers(map, searchSettings, 1);
        mapDiv.AddContent(overMapCanvas.GetWrapper());
        diffLevelMapTypeAux = 3;
        if (createAuxTypeMap) {
            mapTypeAuxMapWrapper = new tf.TFMap.AuxMapWrapper({ appContent: theThis });
            mapTypeAuxMap = createMap(mapTypeAuxMapWrapper.GetMapWrapper(), showingAerial ? tf.consts.typeNameMap : tf.consts.typeNameAerial, false, false, false);
            onMapLevelChange();
        }
        mapListeners = {};
        mapListeners[tf.consts.mapFeatureHoverInOutEvent] = map.AddListener(tf.consts.mapFeatureHoverInOutEvent, onMapFeatureHover);
        mapListeners[tf.consts.mapFeatureClickEvent] = map.AddListener(tf.consts.mapFeatureClickEvent, onMapFeatureClick);
        mapListeners[tf.consts.mapFeatureDblClickEvent] = map.AddListener(tf.consts.mapFeatureDblClickEvent, onMapFeatureDoubleClick);
        mapListeners[tf.consts.mapFeatureMouseMoveEvent] = map.AddListener(tf.consts.mapFeatureMouseMoveEvent, onMapFeatureMouseMove);
        mapListeners[tf.consts.mapFeatureMouseDragEvent] = map.AddListener(tf.consts.mapFeatureMouseDragEvent, onMapFeatureMouseDrag);
        mapListeners[tf.consts.mapEndDragEvent] = map.AddListener(tf.consts.mapEndDragEvent, onMapDragEnd);
        mapListeners[tf.consts.mapClickEvent] = map.AddListener(tf.consts.mapClickEvent, onMapClick);
        mapListeners[tf.consts.mapMouseMoveEvent] = map.AddListener(tf.consts.mapMouseMoveEvent, onMapMouseMove);
        mapListeners[tf.consts.mapMouseDragEvent] = map.AddListener(tf.consts.mapMouseDragEvent, onMapMouseDrag);
        mapListeners[tf.consts.mapMoveEndEvent] = map.AddListener(tf.consts.mapMoveEndEvent, onMapMoveEnd);
        mapListeners[tf.consts.mapMoveStartEvent] = map.AddListener(tf.consts.mapMoveStartEvent, onMapMoveStart);
        mapListeners[tf.consts.mapLevelChangeEvent] = map.AddListener(tf.consts.mapLevelChangeEvent, onMapLevelChange);
        mapListeners[tf.consts.mapResolutionChangeEvent] = map.AddListener(tf.consts.mapResolutionChangeEvent, onMapResolutionChange);
        mapListeners[tf.consts.mapPostComposeEvent] = map.AddListener(tf.consts.mapPostComposeEvent, onMapPostCompose);
        mapListeners[tf.consts.mapPreComposeEvent] = map.AddListener(tf.consts.mapPreComposeEvent, onMapPreCompose);
        mapListeners[tf.consts.mapToggleScaleUnitEvent] = map.AddListener(tf.consts.mapToggleScaleUnitEvent, onMapScaleUnit);
        mapClickedLocation = new tf.TFMap.MapClickedLocation({ appContent: theThis, layer: mapClickedLocationLayer });
        mapUserLocation = new tf.TFMap.MapUserLocation({ appContent: theThis, layer: mapUserLocationLayer });
        mapSearchLocation = new tf.TFMap.MapSearchLocation({ appContent: theThis, layer: mapClickedLocationLayer });
        mapFeaturePropsDisplayer = new tf.TFMap.MapFeaturePropsDisplayer({ appContent: theThis, additionalFeaturesLayer: additionalFeaturesLayer });
        var mapFeaturePropsDisplayerCSSClassNames = mapFeaturePropsDisplayer.GetCSSClasseNames();
        var nDLayerExtent = settings.mapSettings.nDLayerExtent;
        var directionsDest = tf.js.GetNonEmptyString(settings.params[tf.consts.paramNameDirectionsDest], undefined);
        if (directionsDest != undefined) {
            var dd = directionsDest;
            directionsDest = undefined;
            try {
                dd = tf.js.JSONParse("[" + dd + "]");
                if (tf.js.GetIsArrayWithMinLength(dd, 2)) {
                    directionsDest = tf.js.GetMapCoordsFrom(dd);
                }
            }
            catch (e) {
                directionsDest = undefined;
            }
        }
        if (directionsDest != undefined) { nDLayerExtent = 0; }
        dataSetSearches = createSearches(searchSettings, nDLayerExtent);
        appDiv = new tf.dom.Div({ cssClass: appClassName });
        updateAppDivForMapType();
        rootDiv = new tf.dom.Div({ cssClass: rootClassName + " " + mapFeaturePropsDisplayerCSSClassNames.hiddenClassName });
        toaster = createToaster(rootDiv);
        sidePane = new tf.TFMap.SidePane({ appContent: theThis });
        if (searchSettings.length > 0) {
            dataSetsBar = new tf.TFMap.DataSetsBar({ appContent: theThis, searchSettings: searchSettings, getDataSet: function getDataSet(name) { return dataSetSearches[name] } });
        }
        var initialAddress = settings.mapSettings.addressBarText;
        //var initialAddress = appStyles.GetIsSmallScreen() ? "SMALL" : "LARGE";
        searchBar = new tf.TFMap.SearchBar({
            appContent: theThis, placeHolder: /*"Search " + settings.documentTitle*/ "Type an address or a place",
            initialText: initialAddress
        });
        sidePane.GetContentPane().AddContent(searchBar.GetWrapper()/*, mapFeaturePropsDisplayer.GetWrapper()*/);
        var bottomContentPane = bottomPane.GetContentPane();
        //photoDisplayerParentDiv = rootDiv;
        photoDisplayerParentDiv = appDiv;
        photoDisplayerParentDiv.AddContent(photoDisplayer.GetWrapper());
        photoDisplayer.Hide(photoDisplayerParentDiv);
        rootDiv.AddContent(mapFeaturePropsDisplayer.GetWrapper());
        if (!!dataSetsBar) {
            sidePane.GetContentPane().AddContent(dataSetsBar.GetWrapper());
        }
        mapToolBar = new tf.TFMap.MapToolBar({ appContent: theThis, userLocation: userLocationButton, zoom: zoomButtons });
        mapCompass = new tf.TFMap.Compass({ appContent: theThis, compassButtons: compassButtons });
        mapToolBar.GetWrapper().AddContent(mapCompass.GetWrapper());
        if (useMeasureTool || useDownloadTool) {
            mapMoreTools = new tf.TFMap.MoreMapTools({ appContent: theThis, measure: useMeasureTool, download: useDownloadTool });
            //mapToolBar.GetWrapper().AddContent(mapMoreTools.GetWrapper());
            mapCompass.GetWrapper().AddContent(mapMoreTools.GetWrapper());
        }
        bottomContentPane.AddContent(mapToolBar.GetWrapper());
        if (createBaseLayers) {
            baseLayersPanel = new tf.TFMap.BaseLayersPanel({
                appContent: theThis, mapEngine: settings.mapSettings.mapEngine, legendH: settings.mapSettings.legendH, legendM: settings.mapSettings.legendM, allowChangeType: createAuxTypeMap
            });
        }
        if (createAuxTypeMap) {
            bottomContentPane.AddContent(mapTypeAuxMapWrapper.GetWrapper());
        }
        setBottomPaneUpDownStyle();
        rootDiv.AddContent(mapDiv, sidePane.GetWrapper(), bottomPane.GetWrapper());
        setBottomPaneWidth();
        pinMapFeature = new tf.TFMap.PinMapFeature({ appContent: theThis, layer: mapPinsLayer, addStyles: appStyles.AddMapMarker1Style });
        directionsPanel = new tf.TFMap.DirectionsPanel({
            useBusDirections: useBusDirections,
            appContent: theThis, layer: mapDirectionsLayer,
            pinLayer: mapDirectionsPinsLayer, itemsLayer: mapDirectionItemsLayer, wayPointsLayer: mapDirectionWayPointsLayer
        });
        sidePane.GetContentPane().AddContent(directionsPanel.GetWrapper());
        if (createBaseLayers) { sidePane.GetContentPane().AddContent(baseLayersPanel.GetWrapper()); }
        new tf.TFMap.MapFeatureDrag({
            map: map, checkCanStartDrag: checkCanStartDrag, checkCanDragTo: checkCanDragTo, onStartDrag: onStartDrag, onDrag: onDrag, onEndDrag: onEndDrag,
            setInterface: function(notification) { mapFeatureDragI = notification; }
        });
        var edSettings = { map: map, showMapFeatureToolTip: showMapFeatureToolTip, requestClose: requestEditorClose };
        new tf.TFMap.MapMeasureTool(tf.js.ShallowMerge(edSettings, {
            fillLayer: bottomFillLayerMeasureLayer,
            layer: measureToolLayer,
            setInterface: function (notification) { mapMeasureToolI = notification; }, distances3Units: tf.TFMap.LayoutSettings.distances3Units
        }));
        new tf.TFMap.MapDownloadTool(tf.js.ShallowMerge(edSettings, {
            fillLayer: bottomFillLayerDownloadLayer,
            layer: downloadToolLayer,
            setInterface: function (notification) { mapDownloadToolI = notification; }, distances3Units: tf.TFMap.LayoutSettings.distances3Units
        }));
        var overRootDiv = new tf.dom.Div({ cssClass: overRootClassName });
        appDiv.AddContent(rootDiv);
        if (tf.js.GetFunctionOrNull(settings.onAddComponents)) { settings.onAddComponents({ sender: theThis }); }
        if (usePerspectiveMap) { perspectiveMap = new tf.webgl.PerspectiveMap({ map: map, isVisible: perspectiveMapIsInitiallyVisible, appContent: theThis }); }
        if (createBaseLayers || usePerspectiveMap) {
            baseLayersToolBar = new tf.TFMap.BaseLayersToolBar({ appContent: theThis, useBaseLayers: createBaseLayers, usePerspectiveMap: usePerspectiveMap });
            bottomContentPane.AddContent(baseLayersToolBar.GetWrapper());
        }
        if (useMapCenter) {
            mapCenterDiv = new tf.dom.Div({ cssClass: mapCenterClassName });
            mapCenterDiv.GetHTMLElement().innerHTML = appStyles.GetMapCenterSVG();
            mapDiv.AddContent(mapCenterDiv);
        }
        if (useMapLogo) {
            mapLogoDiv = new tf.dom.Div({ cssClass: mapLogoClassName });
            mapLogoDiv.GetHTMLElement().innerHTML = appStyles.GetPoweredByTerraFlySVGForMap();
            mapDiv.AddContent(mapLogoDiv);
        }
        document.body.appendChild(overRootDiv.GetHTMLElement());
        document.body.appendChild(appDiv/*rootDiv*/.GetHTMLElement());
        appSizer.OnResize();
        document.addEventListener("contextmenu", function onContextMenu(e) {
            deselectToolTipSender();
            if (!!mapFeatureDragI && mapFeatureDragI.getIsDragging()) {
                mapFeatureDragI.onEndDrag();
                //console.log('ended drag');
            }
            if (!!e.preventDefault) { e.preventDefault(); }
            e.cancelBubble = true;
            return false;
        });
        if (skipFirstMapFeatureProps = tf.js.GetIsNonEmptyString(initialAddress)) {
            mapSearchLocation.SetAddress(initialAddress, map.GetCenter());
            theThis.SetDirectionsTargetToCoords(map.GetCenter(), false, true);
        }
        if (directionsDest != undefined) {
            theThis.SetDirectionsTargetToCoords(directionsDest, true, true);
            directionsPanel.SetAutoSetNextExtent();
            theThis.EnsureDirectionsVisible();
        }
        if (!!settings.splashScreen) {
            setTimeout(function () {
                var splashStyle = settings.splashScreen.GetHTMLElement().style;
                splashStyle.opacity = "0";
                //splashStyle.left = "100%";
                splashStyle.pointerEvents = "none";
                setTimeout(function () {
                    document.body.removeChild(settings.splashScreen.GetHTMLElement());
                }, 1000);
            }, 1000);
        }
        setTimeout(function() {
            document.body.removeChild(overRootDiv.GetHTMLElement());
            if (tf.js.GetFunctionOrNull(settings.onCreated)) { settings.onCreated({ sender: theThis }); }
            //console.log('removed');
        }, 2500);
        //console.log(tf.TFMap.CompressClassNames);
    }
    var cssTag, bodyClassName, overRootClassName, appClassName, rootClassName, mapClassName, mapMapClassName, toastClassName, customizedScrollBarClassName, defaultHorMarginsClassName,
        smallerTextClassName, hrDivClassName, redFontColorShadowClassName, wrapperAerialModeClassName, wrapperMapModeClassName,
        arrowLeftBackgroundClassName, arrowRightBackgroundClassName, mapCenterClassName, mapLogoClassName;
    function createCSSClassNames() {
        bodyClassName = tf.TFMap.CreateClassName(cssTag, "Body");
        overRootClassName = tf.TFMap.CreateClassName(cssTag, "OverRoot");
        rootClassName = tf.TFMap.CreateClassName(cssTag, "Root");
        mapClassName = tf.TFMap.CreateClassName(cssTag, "Map");
        mapMapClassName = tf.TFMap.CreateClassName(cssTag, "MapMap");
        appClassName = tf.TFMap.CreateClassName(cssTag, "App");
        toastClassName = tf.TFMap.CreateClassName(cssTag, "Toast");
        customizedScrollBarClassName = tf.TFMap.CreateClassName(cssTag, "CustScroll");
        defaultHorMarginsClassName = tf.TFMap.CreateClassName(cssTag, "HorMargins");
        smallerTextClassName = tf.TFMap.CreateClassName(cssTag, "SmallerText");
        hrDivClassName = tf.TFMap.CreateClassName(cssTag, "hrDiv");
        redFontColorShadowClassName = tf.TFMap.CreateClassName(cssTag, "redFontCS");
        
        wrapperMapModeClassName = tf.TFMap.CreateClassName(cssTag, "MapMode");
        wrapperAerialModeClassName = tf.TFMap.CreateClassName(cssTag, "AerialMode");
        arrowLeftBackgroundClassName = tf.TFMap.CreateClassName(cssTag, "alb");
        arrowRightBackgroundClassName = tf.TFMap.CreateClassName(cssTag, "arb");
        mapCenterClassName = tf.TFMap.CreateClassName(cssTag, "mccn");
        mapLogoClassName = tf.TFMap.CreateClassName(cssTag, "mlcn");
        var ls = tf.TFMap.LayoutSettings;
        ls.sidePanelWrapperClassName = tf.TFMap.CreateClassName(cssTag, "SidePanelWrapper");
        ls.sidePanelWrapperCollapsedClassName = tf.TFMap.CreateClassName(cssTag, "SidePanelWrapperCollapsed");
        ls.sidePanelWrapperVisibleClassName = tf.TFMap.CreateClassName(cssTag, "SidePanelWrapperVisible");
        ls.sidePanelContentWrapperClassName = tf.TFMap.CreateClassName(cssTag, "SidePanelContentWrapper");
        ls.sidePaneFullHeightContentWrapperClassName = tf.TFMap.CreateClassName(cssTag, "SidePaneFullHeightContentWrapper");
        ls.sidePanelCloseButtonClassName = tf.TFMap.CreateClassName(cssTag, "SidePanelCloseButton");
        ls.sidePaneContentFixedHeightClassName = tf.TFMap.CreateClassName(cssTag, "SidePaneContentFixedHeight");
        ls.sidePaneContentVariableHeightClassName = tf.TFMap.CreateClassName(cssTag, "SidePaneContentVariableHeight");
        ls.aerialOrMapColorScheme = tf.TFMap.CreateClassName(cssTag, "AerialOrMapColorScheme");
        ls.showingAerialClassName = tf.TFMap.CreateClassName(cssTag, "ShowingAerial");
        ls.showingMapClassName = tf.TFMap.CreateClassName(cssTag, "ShowingMap");
    }
    function createCSSClasses() {
        var appContent = theThis, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var cssClasses = [];
        var ls = tf.TFMap.LayoutSettings;
        var darkTextColor = ls.darkTextColor;
        cssClasses[ls.showingAerialClassName] = {};
        cssClasses[ls.showingMapClassName] = {};
        var commonStyles1 = {
            inherits: [CSSClasses.robotoFontFamily, CSSClasses.fontSize16px, CSSClasses.overflowHidden, CSSClasses.backgroundColorTransparent, CSSClasses.noMarginNoBorderNoPadding]
        };
        var commonStyles2 = {
            inherits: [commonStyles1, CSSClasses.WHOneHundred, CSSClasses.displayBlock, CSSClasses.cursorDefault, CSSClasses.positionAbsolute,
                CSSClasses.leftTopZero, CSSClasses.zIndex1],
            color: darkTextColor
        };
        var nonSelectStyles = {
            "-webkit-touch-callout": "none", "-webkit-user-select": "none", "-khtml-user-select": "none", "-moz-user-select": "none",
            "-ms-user-select": "none", "user-select": "none", "-webkit-tap-highlight-color": "transparent"
        };
        cssClasses[bodyClassName] = { inherits: [commonStyles1] };
        cssClasses[overRootClassName] = {
            inherits: [commonStyles2, nonSelectStyles],
            zIndex: '' + (ls.rootDivZIndex + ls.overRootZIndexAdd)
            /*, background: "rgba(0,0,255,0.5)"*/
        };
        cssClasses[rootClassName] = { inherits: [commonStyles2, nonSelectStyles] };
        cssClasses[mapClassName] = { inherits: [commonStyles2, CSSClasses.transitionPoint2s] };
        cssClasses[mapMapClassName] = { inherits: [commonStyles2] };
        cssClasses[appClassName] = { inherits: [commonStyles2, nonSelectStyles] };
        cssClasses[toastClassName] = {
            inherits: [CSSClasses.lightBackground, CSSClasses.darkTextColor],
            maxWidth: "16rem", textAlign: "center", border: "2px solid red", borderRadius: "6px", padding: "8px",
            fontSize: "1rem", lineHeight: "1rem", textShadow: "2px 2px 3px white", cursor: "default",
            zIndex: '' + (ls.rootDivZIndex + ls.toastZIndexAdd)
        };
        cssClasses[customizedScrollBarClassName + "::-webkit-scrollbar"] = { width: "8px", height: "8px", backgroundColor: "#aaa" };
        cssClasses[customizedScrollBarClassName + "::-webkit-scrollbar-thumb"] = { background: "#000" };
        cssClasses[defaultHorMarginsClassName] = { marginLeft: "4px", marginRight: "4px" };
        cssClasses[smallerTextClassName] = { fontSize: "90%" };
        cssClasses[hrDivClassName] = {
            inherits: [CSSClasses.overflowHidden, CSSClasses.displayBlock],
            border: 'none !important', padding: '0 !important', marginTop: "0.5em !important",
            marginBottom: "0.5em !important", width: "100% !important", height: "2px !important",
            backgroundColor: "navajowhite !important"
        };
        cssClasses[redFontColorShadowClassName] = { inherits: [CSSClasses.lightTextShadow], color: "red" };
        cssClasses[ls.aerialOrMapColorScheme] = {};
        cssClasses[wrapperMapModeClassName] = {
            inherits: [CSSClasses.lightBackground, CSSClasses.darkTextShadow, CSSClasses.fillActiveSVGColor, CSSClasses.darkTextColor],
            borderColor: darkTextColor
        };
        cssClasses[wrapperAerialModeClassName] = {
            inherits: [CSSClasses.toolTipBackground, CSSClasses.lightTextShadow], fill: "white", color: "white",
            borderColor: "white"
        };
        cssClasses[ls.showingMapClassName + " ." + ls.aerialOrMapColorScheme] = { inherits: [cssClasses[wrapperMapModeClassName]] };
        cssClasses[ls.showingAerialClassName + " ." + ls.aerialOrMapColorScheme] = { inherits: [cssClasses[wrapperAerialModeClassName]] };
        cssClasses[arrowLeftBackgroundClassName] = { inherits: [CSSClasses.arrowLeftBackground] };
        cssClasses[arrowRightBackgroundClassName] = { inherits: [CSSClasses.arrowRightBackground] };
        cssClasses[ls.sidePanelWrapperClassName] = {
            inherits: [CSSClasses.transitionPoint2s, CSSClasses.positionAbsolute, CSSClasses.overflowVisible, CSSClasses.pointerEventsAll, CSSClasses.robotoFontFamily,
            CSSClasses.boxShadow002003, CSSClasses.noMarginNoBorderNoPadding, CSSClasses.leftTopZero, CSSClasses.WHOneHundred, CSSClasses.backgroundColorWhite],
            zIndex: '' + (ls.rootDivZIndex + ls.sidePanelWrapperZIndexAdd)
        };
        cssClasses[ls.sidePanelWrapperCollapsedClassName] = {
            //width: "0px",
            //display: "none",
            inherits: [CSSClasses.visibilityHidden], transform: "translateX(-100%)", "-webkit-transform": "translateX(-100%)"
        };
        cssClasses[ls.sidePanelWrapperVisibleClassName] = {
            //width: "initial",
            inherits: [CSSClasses.visibilityVisible],
            transform: "translateX(0px)", "-webkit-transform": "translateX(0px)"
        };
        cssClasses[ls.sidePanelContentWrapperClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.overflowVisible, CSSClasses.displayFlex, CSSClasses.positionRelative, CSSClasses.flexFlowColumnNoWrap],
            background: 'white'
        };
        cssClasses[ls.sidePaneFullHeightContentWrapperClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.overflowVisible, CSSClasses.displayFlex, CSSClasses.positionRelative, CSSClasses.flexFlowColumnNoWrap],
            minHeight: "0px",
            height: "100%"
        };
        var sidePanelCloseButtonDimInt = ls.sidePanelCloseButtonDimInt;
        var sidePanelCloseButtonDimPx = sidePanelCloseButtonDimInt + 'px';
        cssClasses[ls.sidePanelCloseButtonClassName] = {
            inherits: [CSSClasses.transparentImageButton, CSSClasses.overflowHidden, CSSClasses.positionAbsolute, CSSClasses.displayBlock, CSSClasses.flexGrowZero,
            CSSClasses.backgroundColorTransparent],
            top: ls.sidePanelCloseButtonTopInt + "px", right: "12px", width: sidePanelCloseButtonDimPx, height: sidePanelCloseButtonDimPx,
            zIndex: '' + (ls.rootDivZIndex + ls.sidePanelCloseButtonZIndexAdd)
        };
        cssClasses[ls.sidePanelCloseButtonClassName + " svg"] = {
            //stroke: "white", fill: "transparent", strokeWidth: "6px",
            fill: "white", stroke: "none",
            width: "calc(100% - 1px)", height: "calc(100% - 1px)", margin: "auto"
        };
        //cssClasses[ls.sidePanelCloseButtonClassName + " svg:hover"] = { stroke: "black" };
        var sidePanelWidthInt = ls.sidePanelWidthInt, sidePaneWidthPx = sidePanelWidthInt + 'px';
        cssClasses[ls.sidePaneContentFixedHeightClassName] = {
            //inherits: [CSSClasses.positionRelative, CSSClasses.displayFlex, CSSClasses.flexFlowColumnNoWrap, CSSClasses.flexGrowZero, CSSClasses.flexShrinkZero], width: sidePaneWidthPx
            inherits: [CSSClasses.positionRelative, CSSClasses.displayBlock], width: sidePaneWidthPx
        };
        cssClasses[ls.sidePaneContentVariableHeightClassName] = {
            inherits: [CSSClasses.positionRelative, CSSClasses.displayBlock, CSSClasses.flexGrowOne],
            overflowY: "auto", overflowX: "hidden", background: 'transparent', width: sidePaneWidthPx
        };
        cssClasses[mapCenterClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.displayBlock, CSSClasses.pointerEventsNone, CSSClasses.absoluteCenter],
            width: ls.mapCenterDimStr, height: ls.mapCenterDimStr,
            zIndex: '' + (ls.rootDivZIndex + ls.mapLogoAndCenterZIndexAdd)
        };
        cssClasses[ls.showingAerialClassName + " ." + mapCenterClassName] = {
            fill: "rgba(255, 255, 255, 0.22)", stroke: "rgba(0, 0, 0, 0.4)"
        };
        cssClasses[ls.showingMapClassName + " ." + mapCenterClassName] = {
            fill: "rgba(50, 100, 200, 0.075)", stroke: "rgba(100, 149, 237, 0.4)"
        };
        cssClasses[mapLogoClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.displayBlock, CSSClasses.positionAbsolute, CSSClasses.pointerEventsNone],
            right: ls.mapLogoRightStr,
            top: ls.mapLogoTopStr,
            width: ls.mapLogoDimStr,
            height: ls.mapLogoDimStr,
            borderRadius: "50%",
            paddingLeft: ls.mapLogoPaddingLeftStr,
            paddingTop: ls.mapLogoPaddingTopStr,
            paddingRight: ls.mapLogoPaddingRightStr,
            paddingBottom: ls.mapLogoPaddingBottomStr,
            backgroundColor: "rgba(255,255,255,0.5)",
            zIndex: '' + (ls.rootDivZIndex + ls.mapLogoAndCenterZIndexAdd),
            strokeWidth: "0.3px"
        };
        cssClasses[ls.showingAerialClassName + " ." + mapLogoClassName] = {
            //border: "1px solid rgba(255, 255, 255, 0.5)",
            opacity: "0.8",
            border: "1px solid rgba(0, 0, 0, 0.3)",
            //stroke: "rgba(240, 255, 255, 0.8)"
            stroke: "white"
        };
        cssClasses[ls.showingMapClassName + " ." + mapLogoClassName] = {
            //border: "1px solid rgba(0, 0, 0, 0.1)",
            opacity: "0.6",
            border: "1px solid rgba(100, 149, 237, 0.3)",
            stroke: "darkgoldenrod"
        };
        return cssClasses;
    }
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function recalcMapElems() {
        calcScaleElemLayout();
        adjustMapFeatureClustersForLayout();
    }
    function onLayoutChangeFromStyles(notification) {
        //console.log('content: onLayoutChangeFromStyles');
        registerCSSClasses();
        recalcMapElems();
        if (!!currentEditorI && tf.js.GetFunctionOrNull(currentEditorI.onLayoutChange)) { currentEditorI.onLayoutChange(notification); }
    }
    function onStylesLoaded() {
        cssTag = 'content';
        createCSSClassNames();
        registerCSSClasses();
        document.body.className = bodyClassName;
        var layoutSettings = tf.TFMap.LayoutSettings;
        layoutSettings.arrowLeftBackgroundClassName = arrowLeftBackgroundClassName;
        layoutSettings.arrowRightBackgroundClassName = arrowRightBackgroundClassName;
        layoutSettings.customizedScrollBarClassName = customizedScrollBarClassName;
        layoutSettings.defaultHorMarginsClassName = defaultHorMarginsClassName;
        layoutSettings.smallerTextClassName = smallerTextClassName;
        layoutSettings.hrDivClassName = hrDivClassName;
        layoutSettings.redFontColorShadowClassName = redFontColorShadowClassName;
        layoutSettings.wrapperAerialModeClassName = wrapperAerialModeClassName;
        layoutSettings.wrapperMapModeClassName = wrapperMapModeClassName;
        createControl();
    }
    function onStartDrag(notification) {
        deselectToolTipSender();
    }
    function onDrag(notification) {
        var mapFeatureToDrag = notification.mapFeatureToDrag;
        var pointCoords = mapFeatureToDrag.GetPointCoords();
        theThis.MakeSureMapCoordsAreVisible(pointCoords, undefined, true);
        if (!!notification.dragProps.editorProps) {
            if (!!currentEditorI && !!tf.js.GetFunctionOrNull(currentEditorI.onDrag)) { currentEditorI.onDrag(notification); }
        }
        else {
            var settings = mapFeatureToDrag.GetSettings();
            if (settings.directionsAddressItem != undefined) { directionsPanel.OnAddressMapFeatureChangedCoords(settings.directionsAddressItem, pointCoords); }
            else if (settings.wayPointIsInLayer) { directionsPanel.OnWayPointChangedCoords(mapFeatureToDrag); }
        }
    }
    function onEndDrag(notification) { if (!!notification.editorProps) { if (!!currentEditorI && !!tf.js.GetFunctionOrNull(currentEditorI.onEndDrag)) { currentEditorI.onEndDrag(notification); } } }
    function checkCanStartDrag(notification) {
        var dragFeatureProps;
        var editorDragFeatureProps = !!currentEditorI && tf.js.GetFunctionOrNull(currentEditorI.checkCanStartDrag) ? currentEditorI.checkCanStartDrag(notification) : undefined;
        if (!editorDragFeatureProps) {
            var mapFeature = notification.mapFeature, mapFeatureSettings = mapFeature.GetSettings();
            var canDragFeature = mapFeatureSettings.directionsAddressItem != undefined || !!mapFeatureSettings.wayPointIsInLayer;
            if (canDragFeature) { dragFeatureProps = { }; }
        }
        else {
            dragFeatureProps = { editorProps: editorDragFeatureProps };
        }
        return dragFeatureProps;
    }
    function checkCanDragTo(notification) {
        return !!notification.editorProps ? (!!currentEditorI && tf.js.GetFunctionOrNull(currentEditorI.checkCanDragTo) ? currentEditorI.checkCanDragTo(notification) : true) : true;
    }
    function initialize() {
        customAppMinZIndex = 500;
        clusterZIndex = 100;
        if (tf.TFMap.CompressClassNames == -1) {
            console.log('*** full css class names');
        }
        document.title = settings.documentTitle;
        isBottomPaneUp = false;
        if (tf.js.GetFunctionOrNull(settings.onParametersParsed)) {
            settings.onParametersParsed({
                sender: theThis, params: settings.params, mapSettings: settings.mapSettings, dlayerParams: settings.dlayerParams
            });
        }
        appSizer = new tf.TFMap.AppSizer({ onResize: onAppResize });
        appSizer.OnResize();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: tfmapapp.js
tf.TFMap.App = function (settings) {
    var theThis, dlayerParams, mapSettings, params, onCreatedCB;
    this.GetContent = function () { return settings.appContent; }
    function onContentCreated() { if (!!onCreatedCB) { onCreatedCB({ sender: theThis }); } }
    function onCreated(notification) {
        //testLegend(notification.mapSettings.legendH);
        settings.appContent = new tf.TFMap.Content(tf.js.ShallowMerge({
            mapSettings: notification.mapSettings,
            dlayerParams: dlayerParams,
            params: params,
            onCreated: onContentCreated
        }, settings));
    }
    function getMapSettings (settings) {
        if (tf.js.GetIsValidObject(settings)) {
            var onCreatedCallBack = tf.js.GetFunctionOrNull(settings.onCreated);
            if (!!onCreatedCallBack) {
                var parameters = settings.parameters;
                if (!tf.js.GetIsValidObject(parameters)) { if (tf.js.GetIsString(parameters)) { parameters = tf.urlapi.ParseURLAPIParameters(parameters); } else { parameters = {}; } }
                var dlayerPreClick = parameters[tf.consts.paramNameDLPreClick] != undefined;
                var nDLayerExtent = tf.js.GetIntNumberInRange(parameters[tf.consts.paramNameDLExtent], 0, 999, 0);
                if (dlayerPreClick || nDLayerExtent == 0) { nDLayerExtent = undefined; }
                var viewCenterLat = tf.js.GetLatitudeFrom(parameters[tf.consts.paramNameLat]);
                var viewCenterLon = tf.js.GetLongitudeFrom(parameters[tf.consts.paramNameLon]);
                if (!parameters[tf.consts.paramNamePanels]) { parameters[tf.consts.paramNamePanels] = tf.consts.defaultPanels; }
                if (parameters[tf.consts.paramNameTFLogo] === tf.consts.tfLogoOffStr) { parameters[tf.consts.paramNameTFLogo] = false; } else { parameters[tf.consts.paramNameTFLogo] = true; }
                var panelParams = tf.js.GetNonEmptyString(parameters[tf.consts.paramNamePanels], '');
                var mapEngine = tf.map.GetMapEngineFrom(parameters[tf.consts.paramNameFMap]);
                if (parameters[tf.consts.paramNameTFLogo]) { panelParams += tf.consts.charSplitStrings + tf.consts.paramNameTFLogo; }
                var useMapNik2 = mapEngine == tf.consts.mapnik2Engine;
                if (useMapNik2) { delete parameters[tf.consts.paramNameLegend]; } else { delete parameters[tf.consts.paramNameLegendH]; }
                var linkTargetStr = parameters[tf.consts.paramLinkTargetStr];
                tf.urlapi.LoadRemoteParameters(parameters, createMapSettings);
            }
        }
        function createMapSettings() {
            var mapLegendStr = useMapNik2 ? tf.urlapi.RemovePlugInPhotoFromLegend(parameters[tf.consts.paramNameLegendM]).legendStr : null;
            var hybridLegendStr = useMapNik2 ? parameters[tf.consts.paramNameLegendH] : parameters[tf.consts.paramNameLegend];
            var legendAndPlugInPhoto = tf.urlapi.RemovePlugInPhotoFromLegend(hybridLegendStr);
            hybridLegendStr = legendAndPlugInPhoto.legendStr;
            var messageTimeout = tf.js.GetFloatNumberInRange(parameters[tf.consts.paramNameMessageTimeout], tf.consts.minMessageTimeout, tf.consts.maxMessageTimeout, tf.consts.defaultMessageTimeout);
            var mapSettings = {
                dlayerPreClick: dlayerPreClick,
                nDLayerExtent: nDLayerExtent,
                center: [viewCenterLon, viewCenterLat],
                mapType: parameters[tf.consts.paramNameType],
                mapAerialSource: parameters[tf.consts.paramNameSource],
                mapLayerSourceURL: parameters[tf.consts.mapLayerSourceName],
                mapEngine: mapEngine,
                panels: panelParams,
                addressBarText: parameters[tf.consts.paramNameAddress],
                addressBarHelp: parameters[tf.consts.paramNameHelp],
                panOnClick: true,
                goDBOnDoubleClick: true,
                legendH: hybridLegendStr,
                legendM: mapLegendStr,
                messageTimeout: messageTimeout,
                vidParam: parameters[tf.consts.paramNameVid],
                passThroughString: parameters[tf.consts.paramNamePassThrough],
                level: parameters[tf.consts.paramNameLevel],
                resolution: parameters[tf.consts.paramNameRes],
                linkTargetStr: linkTargetStr
            };
            //setTimeout(function () { onCreatedCallBack.call(settings.optionalScope, { mapSettings: mapSettings } ); }, 0);
            onCreatedCallBack.call(settings.optionalScope, { mapSettings: mapSettings });
        }
    };
    function initialize() {
        onCreatedCB = tf.js.GetFunctionOrNull(settings.onCreated);
        document.addEventListener("keydown", function (e) {
            var keycode1 = (e.keyCode ? e.keyCode : e.which);
            if (keycode1 == 0 || keycode1 == 9) { try { e.preventDefault(); e.stopPropagation(); } catch (exception) { } }
        }, false);
        var defaultServerURL = "http://131.94.133.212/api/v1/";
        //var defaultServerURL = "http://192.168.0.81/api/v1/";
        //var defaultServerURL = "http://131.94.133.208/api/v1/";
        settings.app = theThis;
        settings.documentTitle = tf.js.GetNonEmptyString(settings.appTitle, "TerraFly Maps");
        settings.serverURL = tf.js.GetNonEmptyString(settings.serverURL, defaultServerURL);
        params = tf.urlapi.ParseURLAPIParameters(settings.fullURL);
        dlayerParams = tf.urlapi.GetDLayersInfoFromURLParameters(params);
        getMapSettings({ onCreated: onCreated, parameters: params });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: transit.js
tf.Transit = {};
tf.Transit.BusLineDirectionsCount = 0;
tf.Transit.BusLineDirections = {
    "eastbound": { ab: "EB", order: ++tf.Transit.BusLineDirectionsCount },
    "westbound": { ab: "WB", order: ++tf.Transit.BusLineDirectionsCount },
    "northbound": { ab: "NB", order: ++tf.Transit.BusLineDirectionsCount },
    "southbound": { ab: "SB", order: ++tf.Transit.BusLineDirectionsCount },
    "clockwise": { ab: "CW", order: ++tf.Transit.BusLineDirectionsCount },
    "cntrclockwise": { ab: "CC", order: ++tf.Transit.BusLineDirectionsCount },
    "loop": { ab: "LP", order: ++tf.Transit.BusLineDirectionsCount }
};
tf.Transit.BusLineDirectionUnknown = { ab: "??", order: ++tf.Transit.BusLineDirectionsCount };
tf.Transit.GetLineDirection = function (lineDirectionStr) {
    var direction;
    if (tf.js.GetIsNonEmptyString(lineDirectionStr)) { direction = tf.Transit.BusLineDirections[lineDirectionStr.toLowerCase()]; }
    if (direction == undefined) { direction = tf.Transit.BusLineDirectionUnknown; }
    return direction;
};
tf.Transit.BackendService = function (settings) {
    var theThis, autoRefreshes, jsonGet, refreshCounter, refreshTimeout;
    var serverURL, controllerStr, agencyPrefix, serviceName;
    this.GetSettings = function () { return settings; }
    this.SetServiceURL = function (serviceURL) { settings.serviceURL = serviceURL; }
    this.SetAutoRefreshes = function (autoRefreshSet) { return setAutoRefreshes(autoRefreshSet); }
    this.GetAutoRefreshes = function () { return autoRefreshes; }
    this.GetIsRefreshing = function () { return jsonGet != undefined; }
    this.RefreshNow = function (urlParams) { return unscheduledRefreshNow(urlParams); }
    this.Cancel = function () { cancelFutureRefreshCall(); cancelOngoingRefreshCall(); }
    function setAutoRefreshes(autoRefreshSet) {
        if (autoRefreshes != (autoRefreshSet = !!autoRefreshSet)) {
            if (!(autoRefreshes = autoRefreshSet)) { theThis.Cancel(); } else { refreshNow(); }
        }
    }
    function onRefreshed(data) {
        refreshTimeout = undefined;
        if (tf.js.GetFunctionOrNull(settings.preProcessServiceData)) { data = settings.preProcessServiceData(data); }
        if (!!settings.KL) { if (tf.js.GetIsArray(data)) { settings.KL.UpdateFromNewData(data); } }
        if (autoRefreshes) { if (!!settings.refreshTimeoutMillis) { refreshTimeout = setTimeout(refreshNow, settings.refreshTimeoutMillis); } else { refreshNow(); } }
    }
    function cancelFutureRefreshCall() { if (refreshTimeout != undefined) { clearTimeout(refreshTimeout); refreshTimeout = undefined; /*console.log('future refresh cancelled');*/ } }
    function cancelOngoingRefreshCall() { if (jsonGet != undefined) { jsonGet.Cancel(); jsonGet = undefined; /*console.log('ongoing refresh cancelled');*/ } }
    function unscheduledRefreshNow(urlParams) { cancelFutureRefreshCall(); refreshNow(urlParams); }
    function onJSONGot(notification) {
        jsonGet = undefined;
        var data;
        if (tf.js.GetIsValidObject(notification) && tf.js.GetIsValidObject(notification.requestProps)) { if (notification.requestProps.refreshCounter == refreshCounter) { data = notification.data; } }
        onRefreshed(data);
        if (tf.js.GetFunctionOrNull(settings.onPostRefresh)) { settings.onPostRefresh({ sender: theThis }); }
    }
    function refreshNow(urlParams) {
        refreshTimeout = undefined;
        cancelOngoingRefreshCall();
        if (settings.clearBeforeRefresh) { settings.KL.UpdateFromNewData([]); }
        jsonGet = new tf.ajax.JSONGet();
        if (tf.js.GetFunctionOrNull(settings.onPreRefresh)) { settings.onPreRefresh({ sender: theThis }); }
        var serviceURL = makeServiceURL(urlParams);
        jsonGet.Request(serviceURL, onJSONGot, theThis, { refreshCounter: ++refreshCounter }, false, undefined, undefined, undefined);
    }
    function makeServiceURL(urlParams) {
        var paramStr = '?agency=' + agencyPrefix;
        if (!tf.js.GetIsString(urlParams) && tf.js.GetIsValidObject(urlParams)) { urlParams = tf.js.ObjectToURLParams(urlParams); }
        if (tf.js.GetIsNonEmptyString(urlParams)) { paramStr += "&" + urlParams; }
        return serverURL + controllerStr + serviceName + paramStr;
    }
    function initialize() {
        var defaultServerURL = "http://131.94.133.212/api/v1/";
        //var defaultServerURL = "http://192.168.0.81/api/v1/";
        //var defaultServerURL = "http://131.94.133.208/api/v1/";
        serverURL = tf.js.GetNonEmptyString(settings.serverURL, defaultServerURL);
        agencyPrefix = tf.js.GetNonEmptyString(settings.agencyPrefix, "MDT");
        serviceName = settings.serviceName;
        controllerStr = 'transit/';
        refreshCounter = 0;
        setAutoRefreshes(settings.autoRefreshes);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: transitbus.js
tf.Transit.IsBusUpdated = function (d1, d2) { return d1.coords[0] != d2.coords[0] || d1.coords[1] != d2.coords[1] || d1.updated.getTime() != d2.updated.getTime(); }
tf.Transit.CompareBuses = function (a, b) {
    var da = a.itemData, db = b.itemData;
    var aRouteIdInFleet = parseInt(da.route_id_in_feed, 10), bRouteIdInFleet = parseInt(db.route_id_in_feed, 10);
    if (aRouteIdInFleet != bRouteIdInFleet) { return aRouteIdInFleet - bRouteIdInFleet; }
    var aDir = da.lineDirection.order, bDir = db.lineDirection.order;
    if (aDir != bDir) { return aDir - bDir; }
    var aBusId = parseInt(da.name, 10), bBusId = parseInt(db.name, 10);
    if (aBusId != bBusId) { return aBusId - bBusId; }
    return 0;
};
tf.Transit.PreProcessBusItemData = function (data) {
    var toRad = Math.PI / 180.0;
    data.key = data.id + '|' + data.trip_id
    data.coords = [data.lon, data.lat];
    data.direction_rad = data.heading != -1 ? data.heading * toRad : undefined;
    data.updated = tf.js.GetDateFromTimeStamp(data.position_updated);
    data.lineDirection = tf.Transit.GetLineDirection(data.direction);
    return data;
};
tf.Transit.PreProcessHistoryBusData = function (data) {
    var newData = [];
    var nEvents = 0, startDate, totalSeconds = 0;
    var firstEventMillis = undefined;
    function extractHistoryEvent(data) {
        return {
            position_updated: data.position_updated,
            updated: data.updated,
            updatedMillis: data.updated.getTime(),
            updated_hms: data.updated_hms,
            offset_hms: data.offset_hms,
            coords: [data.lon, data.lat],
            direction_rad: data.direction_rad,
            dist_to_shape: data.dist_to_shape,
            stop_index: data.stop_index,
            stop_id: data.stop_id,
            next_stop_index: data.next_stop_index,
            next_stop_id: data.next_stop_id,
            is_finished: data.is_finished
        };
    };
    if (!!data) {
        var events = data.events;
        nEvents = tf.js.GetIsArray(events) ? events.length : 0;
        if (nEvents > 0) {
            var existingItems = {};
            startDate = new Date(data.baseDate);
            totalSeconds = data.nsecs;
            for (var i = 0; i < nEvents; ++i) {
                var d = events[i];
                tf.Transit.PreProcessBusItemData(d);
                var dKey = d.key;
                var existingItem = existingItems[dKey], existingItemData;
                var needCreate = !existingItem;
                if (needCreate) { d.events = []; newData.push(existingItem = existingItems[dKey] = d); }
                var thisEvent = extractHistoryEvent(d);
                if (firstEventMillis == undefined) { firstEventMillis = thisEvent.updatedMillis; }
                existingItem.events.push(thisEvent);
            }
        }
    }
    return { newData: newData, props: { nEvents: nEvents, firstEventMillis: firstEventMillis, totalSeconds: totalSeconds, startDate: startDate } };
};
tf.Transit.BusKL = function (settings) {
    var theThis, KL;
    this.GetKL = function () { return KL; }
    function createKL() {
        KL = new tf.js.KeyedList({
            name: tf.js.GetNonEmptyString(settings.KLName, "transitBusKL"),
            getKeyFromItemData: function (itemData) { return itemData.key; },
            needsUpdateItemData: function (updateObj) { return tf.Transit.IsBusUpdated(updateObj.itemData, updateObj.itemDataSet); },
            filterAddItem: function (itemData) {
                //return true;
                return itemData.trip_id >= 0;
            }
        });
    }
    function initialize() { createKL(); }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.Transit.BusService = function (settings) {
    var theThis;
    function preProcessServiceData(dataArray) {
        var preProcessCall = tf.js.GetFunctionOrNull(settings.preProcessServiceDataItem) ? settings.preProcessServiceDataItem : tf.Transit.PreProcessBusItemData;
        if (tf.js.GetIsArray(dataArray)) {
            var nDataItems = dataArray.length;
            for (var i = 0; i < nDataItems ; ++i) { dataArray[i] = preProcessCall(dataArray[i]); }
        }
        return dataArray;
    }
    function initialize() {
        var serviceName = !!settings.isRT ? "rtbuses" : "bushistory2";
        tf.Transit.BackendService.call(theThis, tf.js.ShallowMerge({ serviceName: serviceName, preProcessServiceData: preProcessServiceData }, settings)); }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.Transit.BusService, tf.Transit.BackendService);
tf.Transit.BusPointFeatures = function (settings) {
    var theThis, pointFeatures;
    this.GetFlashBusSelectStyle = function(elapsed01) {
        var color = settings.appContent.GetIsShowingAerial() ? "#fff" : "#c30";
        return getFlashBusStyleAtTime(elapsed01, color);
    }
    function getFlashBusStyleAtTime(elapsed01, color) {
        var radius = 4 + Math.pow(elapsed01, 1 / 2) * 32, opacity = 1 - Math.pow(elapsed01, 2), line_width = (12 - elapsed01);
        var flashStyle = { circle: true, circle_radius: radius, snapToPixel: false, line: true, line_width: line_width, line_color: color, line_opacity: opacity * 100 };
        return flashStyle;
    }
    this.GetPointFeatures = function () { return pointFeatures; }
    this.UpdateForMapType = function (KL) { pointFeatures.RefreshStyles(KL); }
    function getBusStyles() {
        function getBusStyle(keyedFeature, mapFeature) {
            var appContent = settings.appContent, appStyles = appContent.GetAppStyles();
            var isAerial = appContent.GetIsShowingAerial();
            var isHover = mapFeature.GetIsDisplayingInHover();
            var zindex = isHover ? 200 : 100;
            var bottomMargin = 0;
            var iconAnchor = [0.5, 0.5];
            var colorStroke = isHover ? "rgba(255, 0, 0, 0.8)" : (isAerial ? "rgba(0, 0, 0, 0.9)" : "rgba(128, 160, 0, 0.7)");
            var colorFill = isAerial ? "rgba(255, 255, 255, 0.35)" : "rgba(255, 255, 255, 0.15)";
            var imageDim = isHover ? 16 : 14;
            var addImageDimHeight = isHover ? 3 : 2;
            var imageSize = [imageDim, imageDim + addImageDimHeight];
            //var imageUse = appStyles.GetBusImage();
            var imageUse = appStyles.GetBusPNGImage();
            //var lineWidth = isAerial ? (isHover ? 3 : 2) : (isHover ? 2 : 1);
            var lineWidth = isHover ? 2 : 1;
            return appStyles.GetSVGMapMarkerWithFrameStyle(zindex, imageUse, [imageSize[0], imageSize[1]], imageDim + 18, colorStroke, iconAnchor, bottomMargin,
                colorFill, lineWidth);
        }
        return { style: getBusStyle, hoverStyle: getBusStyle };
    }
    function getBusToolTip(notification) {
        var toolTipText = "Bus";
        var mapFeature = notification.mapFeature, item = pointFeatures.GetItemFromMapFeature(mapFeature);
        if (!!item) {
            var data = item.GetData();
            var topLine = data.lineDirection.ab + ' ' + data.headsign;
            var botLine = 'updated ' + tf.js.GetAMPMHourWithSeconds(data.updated);
            toolTipText = tf.TFMap.MapTwoLineSpan(topLine, botLine);
        }
        return toolTipText;
    }
    function onClickBusMapFeature(notification) { if (tf.js.GetFunctionOrNull(settings.onClick)) { settings.onClick(notification); } }
    function initialize() {
        var mapFeatureInItemAttributeName = "busMapFeature";
        var itemInMapFeatureAttributeName = "busItem";
        pointFeatures = new tf.TFMap.KeyedListPointFeatures({
            refreshStyleOnUpdate: false,
            onClick: onClickBusMapFeature,
            mapFeatureInItemAttributeName: mapFeatureInItemAttributeName,
            itemInMapFeatureAttributeName: itemInMapFeatureAttributeName,
            styles: getBusStyles(),
            toolTipProps: { toolTipText: getBusToolTip, keepOnHoverOutTarget: false, offsetX: 24 },
            layer: settings.layer,
            appContent: settings.appContent
        });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.Transit.BusListItemContentClasses = function (settings) {
    var theThis, cssTag, classNames, layoutChangeListener;
    this.GetClassNames = function () { return classNames; }
    function createCSSClassNames() {
        classNames = {
            itemWrapperClassName: tf.TFMap.CreateClassName(cssTag, "ItemWrapper"),
            itemWrapperSelectedClassName: tf.TFMap.CreateClassName(cssTag, "ItemWrapperSelected"),
            itemContentWrapperClassName: tf.TFMap.CreateClassName(cssTag, "ItemContentWrapper"),
            itemTitleClassName: tf.TFMap.CreateClassName(cssTag, "ItemTitle"),
            itemNameClassName: tf.TFMap.CreateClassName(cssTag, "ItemName"),
            itemDirectionColorClassName: tf.TFMap.CreateClassName(cssTag, "ItemDirectionColor"),
            itemButtonClassName: tf.TFMap.CreateClassName(cssTag, "ItemButton")
        };
    }
    function createCSSClasses() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var isSmallScreen = appStyles.GetIsSmallScreen();
        var cssClasses = [];
        var ls = tf.TFMap.LayoutSettings;
        var paddingHorTitleInt = 2;//isSmallScreen ? 4 : 8, paddingHorTitlePx = paddingHorTitleInt + 'px';
        var widthDirectionDivInt = isSmallScreen ? 20 : 30;
        var marginLeftTitleDivInt = widthDirectionDivInt + 2;
        var stdTextOverflow = { inherits: [CSSClasses.pointerEventsNone], overflow: "hidden", whiteSpace: "nowrap", textOverflow: "ellipsis", verticalAlign: "middle" };
        var maxWidthNameInt = isSmallScreen ? 36 : 56;
        var widthTitleSubInt = isSmallScreen ? 108 : 158;
        cssClasses[classNames.itemWrapperClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.positionRelative, CSSClasses.displayBlock, CSSClasses.overflowHidden],
            padding: "1px", borderRadius: "0px", width: "calc(100% - 2px)"
        };
        cssClasses[classNames.itemWrapperClassName + ":hover"] = { backgroundColor: "rgba(0, 0, 0, 0.1)" };
        cssClasses[classNames.itemWrapperSelectedClassName] = { backgroundColor: "red" };
        cssClasses[classNames.itemWrapperSelectedClassName + ":hover"] = { backgroundColor: "red" };
        cssClasses[classNames.itemContentWrapperClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.positionRelative, CSSClasses.transparentImageButton, CSSClasses.backgroundColorTransparent,
                CSSClasses.displayBlock, CSSClasses.pointerEventsNone],
            marginLeft: "2px", marginRight: "2px",
            borderRadius: "2px", lineHeight: "0px", width: "calc(100% - 0px)"
        };
        cssClasses[classNames.itemButtonClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.transparentImageButton, CSSClasses.backgroundColorTransparent, CSSClasses.displayBlock,
            CSSClasses.positionAbsolute],
            borderRadius: "0px",
            left: "0px", top: "0px",
            width: "100%",
            height: "100%"
        };
        var displayType = CSSClasses.displayInlineBlock;
        cssClasses[classNames.itemDirectionColorClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.positionRelative, CSSClasses.lightTextShadow, stdTextOverflow, displayType],
            //margin: "auto",
            borderRadius: "2px",
            textAlign: "center",
            width: widthDirectionDivInt + "px",
            color: "white",
            borderLeft: "1px solid darkgoldenrod",
            fontSize: ls.itemInListTitletFontSizeInt + 'px',
            lineHeight: ls.itemInListTitleLineHeightInt + 'px'
        };
        cssClasses[classNames.itemTitleClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.positionRelative, displayType, CSSClasses.darkTextShadow, stdTextOverflow],
            textAlign: "left",
            paddingLeft: "4px",
            //margin: "auto",
            width: "calc(100% - " + (widthTitleSubInt) + "px)",
            color: "#444",
            background: "white",
            fontSize: ls.itemInListTitletFontSizeInt + 'px',
            lineHeight: ls.itemInListTitleLineHeightInt + 'px'
        };
        cssClasses[classNames.itemNameClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.positionRelative, displayType, CSSClasses.darkTextShadow, stdTextOverflow],
            borderLeft: "1px solid #ebebeb",
            textAlign: "center",
            paddingLeft: "2px",
            fontWeigth: "500",
            //margin: "auto",
            width: maxWidthNameInt + 'px',
            color: "black",
            background: "white",
            fontSize: (ls.itemInListTitletFontSizeInt * 0.8) + 'px',
            lineHeight: ls.itemInListTitleLineHeightInt + 'px'
        };
        return cssClasses;
    }
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function onLayoutChange(notification) { registerCSSClasses(); }
    function initialize() {
        cssTag = 'busListItemContent';
        createCSSClassNames();
        registerCSSClasses();
        layoutChangeListener = settings.appContent.GetAppStyles().AddOnLayoutChangeListener(onLayoutChange);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.Transit.BusListContent = function (settings) {
    var theThis, keyedListContent, selectedContent;
    this.OnKLChange = function (notification) {
        keyedListContent.OnKLChange(notification);
        if (!!selectedContent) {
            if (!keyedListContent.GetItemFromContent(selectedContent)) {
                selectedContent = undefined;
                //console.log('bus kl content: deselected deleted content');
            }
        }
    }
    this.GetSelectedContent = function () { return selectedContent; }
    this.SetSelectedContent = function (newSelectedContent) {
        if (newSelectedContent != selectedContent) {
            if (!!selectedContent) { setSelectedStyle(selectedContent, false); }
            if (!!(selectedContent = newSelectedContent)) { setSelectedStyle(selectedContent, true); }
        }
    }
    this.EnsureContentVisible = function (content) {
        if (!!content) {
            tf.dom.ScrollVerticallyToEnsureVisible(settings.contentWrapper, content.wrapper, settings.customAppContentI.getVerListWithFadePaddingTopBotInt());
        }
    }
    this.GetKeyedListContent = function () { return keyedListContent; }
    function onItemClick(notification) {
        var clickCB = tf.js.GetFunctionOrNull(settings.onItemClick);
        if (!!clickCB) {
            var button = !!notification ? notification.domObj : undefined;
            if (!!button) {
                var content = button.content;
                var item = keyedListContent.GetItemFromContent(content);
                if (!!item) { clickCB({ sender: theThis, item: item }); }
            }
        }
    }
    function updateContentForItem(item) {
        var content = keyedListContent.GetContentFromItem(item);
        if (!!content) {
            var isRT = settings.isRT;
            var itemData = item.GetData();
            //content.wrapper.GetHTMLElement().innerHTML = itemData.lineDirection.ab + ' ' + itemData.headsign + ' updated ' + tf.js.GetAMPMHourWithSeconds(itemData.updated);
            var routeColor = "#" + itemData.route_color;
            var nameStr = itemData.name;
            var titleStr = itemData.headsign;
            var titleE = content.title.GetHTMLElement(), titleES = titleE.style;
            var nameE = content.name.GetHTMLElement();
            var updatedE = content.updated.GetHTMLElement();
            titleE.innerHTML = titleStr /*+ " " + titleStr*/;
            nameE.innerHTML = nameStr;
            updatedE.innerHTML = isRT ? tf.js.GetAMPMHourWithMinutes(itemData.updated) : itemData.events.length;
            //titleES.borderBottom = "1px solid " + routeColor;
            var dcE = content.directionColor.GetHTMLElement(), dcES = dcE.style;
            dcES.backgroundColor = routeColor;
            dcE.innerHTML = itemData.lineDirection.ab;
        }
    }
    function setSelectedStyle(content, isSelected) {
        if (isSelected) { tf.dom.AddCSSClass(content.wrapper, settings.busListItemClassNames.itemWrapperSelectedClassName); }
        else { tf.dom.RemoveCSSClass(content.wrapper, settings.busListItemClassNames.itemWrapperSelectedClassName); }
    }
    function prepareSpareContent(content) { setSelectedStyle(content, false); return content; }
    function createNewContent() {
        var isRT = settings.isRT;
        var wrapper = new tf.dom.Div({ cssClass: settings.busListItemClassNames.itemWrapperClassName });
        var contentWrapper = new tf.dom.Div({ cssClass: settings.busListItemClassNames.itemContentWrapperClassName });
        var button = new tf.dom.Button({ cssClass: settings.busListItemClassNames.itemButtonClassName, onClick: onItemClick });
        var title = new tf.dom.Div({ cssClass: settings.busListItemClassNames.itemTitleClassName });
        var name = new tf.dom.Div({ cssClass: settings.busListItemClassNames.itemNameClassName });
        var updated = new tf.dom.Div({ cssClass: settings.busListItemClassNames.itemNameClassName });
        var directionColor = new tf.dom.Div({ cssClass: settings.busListItemClassNames.itemDirectionColorClassName });
        contentWrapper.AddContent(directionColor, title, name, updated);
        wrapper.AddContent(button, contentWrapper);
        directionColor.GetHTMLElement().title = 'route direction';
        title.GetHTMLElement().title = 'bus headsign';
        updated.GetHTMLElement().title = isRT ? 'last updated' : 'number of events';
        name.GetHTMLElement().title = 'bus name';
        var content = { wrapper: wrapper, button: button, contentWrapper: contentWrapper, title: title, directionColor: directionColor, name: name, updated: updated };
        button.content = content;
        return content;
    }
    function createKLContent() {
        var contentInItemAttributeName = tf.js.GetNonEmptyString(settings.contentInItemAttributeName, "busContent");
        var itemInContentAttributeName = tf.js.GetNonEmptyString(settings.itemInContentAttributeName, "busItem");
        keyedListContent = new tf.TFMap.KeyedListContent({
            KL: settings.KL, wrapper: settings.wrapper, contentWrapper: settings.contentWrapper,
            contentWrapperDisplayVisibleVerb: settings.busListClasses.GetContentWrapperDisplayVisibleVerb(),
            contentInItemAttributeName: contentInItemAttributeName, itemInContentAttributeName: itemInContentAttributeName,
            createNewContent: createNewContent, prepareSpareContent: prepareSpareContent, updateContentForItem: updateContentForItem, compareContent: settings.compareContent
        });
    }
    function initialize() {
        createKLContent();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.Transit.BusListClasses = function (settings) {
    var theThis, cssTag, classNames, layoutChangeListener;
    this.GetClassNames = function () { return classNames; }
    this.GetContentWrapperDisplayVisibleVerb = function () { return "block"; }
    this.CreateToolBarListFooter = function(forHistory) {
        var ls = tf.TFMap.LayoutSettings;
        var customAppContentI = settings.customAppContentI;
        var customAppClassNames = customAppContentI.getClassNames();
        var wrapper = customAppContentI.createNonScrollVariableHeightContent(customAppClassNames.minHeightPaneClassName);
        var toolBar = customAppContentI.createMainToolBar();
        var footer = customAppContentI.createFooter();
        var scrollWrapperAndContent = customAppContentI.createVertScrollWrapperAndContentWithFade();
        var replay = !!forHistory ? customAppContentI.createToolBar(undefined, classNames.rangeClassName) : undefined;
        wrapper.AddContent(toolBar.wrapper);
        if (!!replay) {
            tf.dom.AddCSSClass(replay.wrapper, customAppContentI.getClassNames().borderTopClassName);
            wrapper.AddContent(replay.wrapper);
        }
        wrapper.AddContent(scrollWrapperAndContent.scrollWrapper, footer.wrapper);
        return {
            wrapper: wrapper, toolBar: toolBar, replay: replay,
            scrollWrapper: scrollWrapperAndContent.scrollWrapper, scrollContent: scrollWrapperAndContent.scrollContent, footer: footer
        };
    }
    this.SetListVisible = function (busTLF, isVisible) {
        if (!!busTLF) {
            var verbVisible = 'flex', verbHidden = 'none';
            busTLF.wrapper.GetHTMLElement().style.display = !!isVisible ? verbVisible : verbHidden;
        }
    }
    this.CreateList = function(listSettings) {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles();
        var customAppContentI = settings.customAppContentI;
        var isRT = listSettings.isRT;
        var ls = tf.TFMap.LayoutSettings;
        var delayMillis = 0;
        var toolTipClass = "*start";
        var toolTipArrowClass = "top";
        var buttonSettings = {
            offsetY: 0, onClick: undefined, onHover: undefined, delayMillis: delayMillis, toolTipClass: toolTipClass, toolTipArrowClass: toolTipArrowClass
        };
        //isRT = false;
        var busTLF = theThis.CreateToolBarListFooter(!isRT);
        var toolBarButtonClassNames = customAppContentI.getToolBarButtonClasses();
        var toolBarSpanClassNames = customAppContentI.getToolBarSpanClasses();
        var mainToolBarButtonClassNames = customAppContentI.getMainToolBarButtonClasses();
        var mainToolBarSpanClassNames = customAppContentI.getMainToolBarSpanClasses();
        busTLF.busTitleButton = tf.TFMap.CreateSVGButton(appContent, tf.js.ShallowMerge(buttonSettings, {
            wrapper: busTLF.toolBar.wrapper,
            onClick: listSettings.onClickBusTitleButton
        }), appStyles.GetBusSVG(), mainToolBarButtonClassNames, listSettings.busTitleButtonToolTipText, undefined, "busButton");
        busTLF.busListTitleSpan = document.createElement('span');
        busTLF.busListTitleSpan.className = mainToolBarSpanClassNames;
        busTLF.busLoadingDiv = new tf.dom.Div({ cssClass: classNames.loadingDivClassName });
        busTLF.toolBar.content.AddContent(busTLF.busTitleButton.GetButton(), busTLF.busListTitleSpan, busTLF.busLoadingDiv);
        if (!isRT) {
            busTLF.busTitleRefreshButton = tf.TFMap.CreateSVGButton(appContent, tf.js.ShallowMerge(buttonSettings, {
                toolTipClass: "*start",
                wrapper: busTLF.toolBar.wrapper,
                onClick: listSettings.onClickRefreshButton
            }), appStyles.GetRefreshSVG(), mainToolBarButtonClassNames, "Refresh list", undefined, "refreshButton");
            busTLF.toolBar.content.AddContent(busTLF.busTitleRefreshButton.GetButton());
            busTLF.replaySlider = document.createElement('input');
            busTLF.replaySlider.type = 'range';
            busTLF.replay.content.AddContent(busTLF.replaySlider);
            var playerSVGs = appStyles.GetPlayerSVGs();
            busTLF.replayStopButton = tf.TFMap.CreateSVGButton(appContent, tf.js.ShallowMerge(buttonSettings, {
                wrapper: busTLF.replay.wrapper,
                onClick: listSettings.onClickReplayStop
            }), playerSVGs.stop, toolBarButtonClassNames, listSettings.replayStopToolTipText, undefined, "playButton");
            busTLF.replayPlayButton = tf.TFMap.CreateSVGButton(appContent, tf.js.ShallowMerge(buttonSettings, {
                wrapper: busTLF.replay.wrapper,
                onClick: listSettings.onClickReplayPlay
            }), playerSVGs.play, toolBarButtonClassNames, listSettings.replayPlayToolTipText, undefined, "playButton");
            busTLF.replayLabelSpan = tf.TFMap.CreateSVGButton(appContent, tf.js.ShallowMerge(buttonSettings, {
                wrapper: busTLF.replay.wrapper,
                onClick: listSettings.onClickReplaySpan
            }), "", toolBarButtonClassNames + " " + classNames.textAlignCenterClassName,
            listSettings.replaySpanToolTipText, undefined, "labelButton");
            var replayLabelSpanE = busTLF.replayLabelSpan.GetButton(), replayLabelSpanES = replayLabelSpanE.style;
            replayLabelSpanES.display = 'block';
            replayLabelSpanES.width = "50%";
            busTLF.replaySpeedButton = tf.TFMap.CreateSVGButton(appContent, tf.js.ShallowMerge(buttonSettings, {
                wrapper: busTLF.replay.wrapper,
                onClick: listSettings.onClickReplaySpeed
            }), "100x", toolBarButtonClassNames + " " + classNames.textAlignCenterClassName, listSettings.replaySpeedToolTipText, undefined, "speedButton");
            busTLF.replayAutoRepeatButton = tf.TFMap.CreateSVGButton(appContent, tf.js.ShallowMerge(buttonSettings, {
                wrapper: busTLF.replay.wrapper,
                onClick: listSettings.onClickReplayAutoRepeat
            }), playerSVGs.noAutoRepeat, toolBarButtonClassNames, listSettings.replayAutoRepeatToolTipText, undefined, "autoRepeatButton");
            busTLF.replay.content.AddContent(busTLF.replayStopButton.GetButton(), busTLF.replayPlayButton.GetButton(), busTLF.replayLabelSpan.GetButton(),
                busTLF.replaySpeedButton.GetButton(), busTLF.replayAutoRepeatButton.GetButton());
        }
        customAppContentI.getContentWrapper().AddContent(busTLF.wrapper);
        return new tf.Transit.BusList(tf.js.ShallowMerge(listSettings, {
            busListClasses: theThis,
            appContent: appContent,
            customAppContentI: customAppContentI,
            busTLF: busTLF
        }));
    }
    function createCSSClassNames() {
        classNames = {
            loadingDivClassName: tf.TFMap.CreateClassName(cssTag, "LoadingDiv"),
            textAlignCenterClassName: tf.TFMap.CreateClassName(cssTag, "TextAlign"),
            rangeClassName: tf.TFMap.CreateClassName(cssTag, "Range")
        };
    }
    function createCSSClasses() {
        var customAppContentI = settings.customAppContentI;
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var isSmallScreen = appStyles.GetIsSmallScreen();
        var cssClasses = [];
        var ls = tf.TFMap.LayoutSettings;
        var mainToolBarButtonDimInt = customAppContentI.getMainToolBarButtonDimInt();
        var mainToolBarButtonDimPx = mainToolBarButtonDimInt + 'px';
        cssClasses[classNames.loadingDivClassName] = {
            inherits: [CSSClasses.positionRelative, CSSClasses.transparentImageButton, CSSClasses.backgroundColorTransparent,
                CSSClasses.displayNone, CSSClasses.loadingBackgroundTransparent, CSSClasses.cursorDefault],
            height: mainToolBarButtonDimPx,
            width: mainToolBarButtonDimPx,
            margin: "auto"
        };
        var textMarginHorInt = 4;
        var textMarginHorPx = textMarginHorInt + 'px';
        cssClasses[classNames.textAlignCenterClassName] = {
            marginLeft: textMarginHorPx,
            marginRight: textMarginHorPx,
            width: 'initial',
            textAlign: "center",
            justifyContent: "center"
        };
        cssClasses[classNames.textAlignCenterClassName + ":hover"] = { textDecoration: "underline" };
        var rangeHeightInt = isSmallScreen ? 20 : 30, thumbBorderInt = 1, trackHeightInt = 4, thumbWidthInt = 4, thumbHeightInt = rangeHeightInt / 2;
        appStyles.AddRangeClasses({
            cssClasses: cssClasses,
            className: classNames.rangeClassName,
            thumbHeightInt: thumbHeightInt,
            thumbBorderInt: thumbBorderInt,
            rangeSettings: {
                inherits: [CSSClasses.noMarginNoBorderNoPadding],
                width: "100%", height: rangeHeightInt + "px", background: "transparent", cursor: "pointer",
                marginLeft: "4px", marginRight: "4px"
            },
            trackSettings: {
                inherits: [CSSClasses.noMarginNoBorderNoPadding],
                width: "100%", height: trackHeightInt + "px", cursor: "pointer", background: ls.backgroundLivelyColor,
                borderColor: "transparent", color: "transparent"
            },
            thumbSettings: {
                inherits: [CSSClasses.noMarginNoBorderNoPadding],
                border: thumbBorderInt + "px solid " + ls.darkTextColor,
                height: thumbHeightInt + "px", width: thumbWidthInt + "px",
                borderRadius: "0px", background: "#ffffff", cursor: "pointer",
                boxShadow: "0px 0px 1px " + ls.backgroundLivelyColor + ", 0px 0px 1px " + ls.backgroundLivelyColor
            }
        });
        cssClasses[classNames.rangeClassName] = tf.js.ShallowMerge(cssClasses[classNames.rangeClassName], { overflow: "hidden" });
        return cssClasses;
    }
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function onLayoutChange(notification) { registerCSSClasses(); }
    function initialize() {
        cssTag = 'busListClasses';
        createCSSClassNames();
        registerCSSClasses();
        layoutChangeListener = settings.appContent.GetAppStyles().AddOnLayoutChangeListener(onLayoutChange);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.Transit.BusList = function (settings) {
    var theThis, isVisible, listContent;
    this.GetBusTLF = function () { return settings.busTLF; }
    this.GetListContent = function () { return listContent; }
    this.OnServiceRefresh = function (notification) {
        var isRefreshing = notification.sender.GetIsRefreshing();
        var buttonSVG = settings.busTLF.busTitleButton.GetButton().firstChild;
        var loadingDisplayVerb;
        var isRT = settings.isRT;
        if (isRefreshing) {
            loadingDisplayVerb = 'block';
            if (!isRT) {
                settings.busTLF.replay.wrapper.GetHTMLElement().style.display = "none";
                updateFooterText("Retrieving most recent transit activity...");
            }
        }
        else {
            loadingDisplayVerb = 'none';
        }
        settings.busTLF.busLoadingDiv.GetHTMLElement().style.display = loadingDisplayVerb;
        if (!isRT) {
            settings.busTLF.busTitleRefreshButton.GetButton().style.display = isRefreshing ? "none" : "block";
        }
    }
    this.OnKLChange = function (notification) {
        listContent.OnKLChange(notification);
        updateFooterTotals();
    }
    function updateFooterTotals() {
        if (settings.isRT) {
            updateFooter(" currently", "");
        }
        else {
            var replayVisibilityVerb = settings.getHistoryNEvents() > 0 ? 'block' : 'none';
            settings.busTLF.replay.wrapper.GetHTMLElement().style.display = replayVisibilityVerb;
            updateFooter("", " during the past hour");
        }
    }
    this.SetVisible = function (newIsVisible) {
        if (isVisible != (newIsVisible = !!newIsVisible)) {
            isVisible = newIsVisible;
            settings.busListClasses.SetListVisible(settings.busTLF, isVisible);
        }
    }
    this.GetIsVisible = function () { return isVisible; }
    this.GetListContent = function () { return listContent; }
    function updateFooterText(theText) { settings.busTLF.footer.content.GetHTMLElement().innerHTML = theText; }
    function updateFooter(prefixStr, suffixStr) {
        var footerStr;
        var count = settings.KL.GetItemCountAfterUpdate();
        if (count == 0) { footerStr = "No bus activity found" }
        else {
            var busBuses = count == 1 ? "bus" : "buses";
            footerStr = count + " " + busBuses + prefixStr + " in circulation" + suffixStr;
        }
        updateFooterText(footerStr);
    }
    function initialize() {
        var busTLF = settings.busTLF;
        theThis.SetVisible(!!settings.isVisible);
        var titleStr = settings.isRT ? "Real time activity" : "Recent activity";
        busTLF.busListTitleSpan.innerHTML = titleStr;
        listContent = new tf.Transit.BusListContent(tf.js.ShallowMerge(settings, {
            wrapper: busTLF.scrollWrapper, contentWrapper: busTLF.scrollContent
        }));
        if (settings.isRT) { updateFooterTotals(); }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.Transit.BusServiceFeaturesContent = function (settings) {
    var theThis, KL, service, layer, busPointFeatures, busList, isVisible, serviceWasRefreshed, serviceWasLoaded, nextAvailableZIndex, historyReplayProps;
    var minIntervalPositionMillis, lastTimePositionedAt;
    var postComposeListener;
    var historyTimer;
    var historyReplayAutoRepeats, historyReplayCurrentSpeed;
    var useLongTimeStampFormat;
    var inPauseWhenVisible;
    var allEventDispatchers, updateNameEvent;
    var klListener;
    this.GetKL = function () { return KL.GetKL(); }
    this.GetLayer = function () { return layer; }
    this.AddUpdateListener = function (callBack) { allEventDispatchers.AddListener(updateNameEvent, callBack); }
    this.RefreshNow = function () {
        //var busTLF = getBusTLF();
        //firstEventMillis: firstEventMillis, totalSeconds: totalSeconds
        //busTLF.replaySlider.value = 100;
        service.RefreshNow();
    }
    this.GetNextAvailableZIndex = function () { return nextAvailableZIndex; }
    this.UpdateForMapType = function () { if (!!busPointFeatures) { busPointFeatures.UpdateForMapType(KL.GetKL()); } }
    this.GetIsVisible = function () { return isVisible; }
    this.SetVisible = function (newIsVisible) {
        if (isVisible != (newIsVisible = !!newIsVisible)) {
            isVisible = newIsVisible;
            layer.SetVisible(isVisible);
            busList.SetVisible(isVisible);
            if (settings.isRT) {
                service.SetAutoRefreshes(isVisible);
            }
            else {
                if (isVisible) {
                    if (inPauseWhenVisible != undefined) {
                        historyTimer.Pause(inPauseWhenVisible);
                    }
                    forceMapRender();
                    if (!serviceWasRefreshed) { serviceWasRefreshed = true; service.RefreshNow(); }
                    //else { theThis.ClearHistory(); }
                }
                else {
                    inPauseWhenVisible = historyTimer.GetIsPaused();
                    historyTimer.Pause(true);
                }
            }
        }
    }
    this.ClearHistory = function () { historyReplayProps = undefined; KL.GetKL().UpdateFromNewData([]); }
    this.PositionAtTimeMillis = function (atTimeMillis) {
        var changed = false;
        var KLKL = KL.GetKL(), count = KLKL.GetItemCount();
        if (count > 0) {
            if (lastTimePositionedAt == undefined || Math.abs(lastTimePositionedAt - atTimeMillis) >= minIntervalPositionMillis) {
                var items = KLKL.GetKeyedItemList();
                lastTimePositionedAt = atTimeMillis;
                for (var i in items) { var item = items[i]; positionItemAtTime(item, atTimeMillis); }
                //console.log('positionedAtTime');
                busPointFeatures.GetPointFeatures().RefreshPositions(KL.GetKL());
                changed = true;
            }
        }
        if (changed) { notifyUpdate(); }
        return changed;
    }
    this.GetHistoryStartDate = function () { return !!historyReplayProps ? historyReplayProps.startDate : undefined; }
    this.GetHistoryNEvents = function () { return !!historyReplayProps ? historyReplayProps.nEvents : 0; }
    function forceMapRender() {
        settings.appContent.GetMap().Render();
    }
    function positionItemAtTime(item, atTimeMillis) {
        var isExcluded = false;
        var itemData = item.GetData(), events = itemData.events;
        var len = events.length, coords, direction_rad, posSeg01 = 0, offsetHMS, nextStopIndex, updated;
        var startDate = theThis.GetHistoryStartDate();
        if (!!startDate) { atTimeMillis += startDate.getTime(); }
        var searchIndex = tf.js.BinarySearch(events, atTimeMillis, function (key, item) { return key - item.updatedMillis; });
        var exactIndex;
        if (searchIndex < 0) {
            var insertIndex = -(searchIndex + 1);
            if (insertIndex == 0 || insertIndex >= len) { isExcluded = true; }
            if (insertIndex == 0) { exactIndex = 0; }
            else if (insertIndex >= len - 1) { exactIndex = len - 1; posSeg01 = 1; }
            else {
                var prevIndex = insertIndex - 1, prevEntry = events[prevIndex], prevMillis = prevEntry.updatedMillis;
                var nextIndex = insertIndex, nextEntry = events[nextIndex], nextMillis = nextEntry.updatedMillis;
                var diffMillis = nextMillis - prevMillis;
                var dMilis01 = diffMillis > 0 ? (atTimeMillis - prevMillis) / diffMillis : 0;
                posSeg01 = dMilis01;
                nextStopIndex = prevEntry.next_stop_index;
                if (dMilis01 > 0) {
                    var prevCoords = prevEntry.coords;
                    var prevHeading = prevEntry.direction_rad;
                    var prevHMS = prevEntry.offset_hms;
                    var nextCoords = nextEntry.coords;
                    var nextHeading = nextEntry.direction_rad;
                    var nextHMS = nextEntry.offset_hms;
                    var dlon = nextCoords[0] - prevCoords[0];
                    var dlat = nextCoords[1] - prevCoords[1];
                    coords = [prevCoords[0] + dlon * dMilis01, prevCoords[1] + dlat * dMilis01];
                    var deltaRotation = tf.units.GetShortestArcBetweenAngles(prevHeading, nextHeading)
                    direction_rad = prevHeading + deltaRotation * dMilis01;
                    if (prevHMS != undefined && nextHMS != undefined) {
                        var dHMS = nextHMS - prevHMS;
                        offsetHMS = Math.floor(prevHMS + dMilis01 * dHMS);
                    }
                    else {
                        offsetHMS = 0;
                    }
                    updated = prevEntry.updated;
                }
                else {
                    exactIndex = prevIndex;
                }
            }
        }
        else { exactIndex = searchIndex; }
        //if (isExcluded) { console.log('excluded'); } else { console.log("included"); }
        if (exactIndex != undefined) {
            var exactEntry = events[exactIndex];
            coords = exactEntry.coords; direction_rad = exactEntry.direction_rad; offsetHMS = exactEntry.offset_hms;
            nextStopIndex = exactEntry.next_stop_index;
            updated = exactEntry.updated;
        }
        if (isNaN(offsetHMS) && offsetHMS != undefined) { isExcluded = true; }
        itemData.isExcluded = isExcluded;
        itemData.coords = coords;
        itemData.direction_rad = direction_rad;
        itemData.posSeg01 = posSeg01;
        itemData.offset_hms = offsetHMS;
        itemData.next_stop_index = nextStopIndex;
        itemData.updated = updated;
        //tf.Transit.SetBusItemDataLabels(itemData);
        return isExcluded;
    }
    function createLayer() {
        nextAvailableZIndex = settings.layerZIndex;
        var layerSettings = { name: settings.layerName, isVisible: true, isHidden: true, useClusters: false, zIndex: nextAvailableZIndex++ };
        var use3D = false;
        //var use3D = true;
        layer = settings.appContent.CreateCustomMapLayer(layerSettings, use3D);
    }
    function onKLChange(notification) {
        busList.OnKLChange(notification);
        busPointFeatures.GetPointFeatures().OnKLChange(notification);
        if (!settings.isRT) {
            lastTimePositionedAt = undefined;
            theThis.PositionAtTimeMillis(0);
        }
    }
    function getSelectedMapFeature() { return busPointFeatures.GetPointFeatures().GetSelectedMapFeature(); }
    function setSelectedMapFeature(mapFeature) { busPointFeatures.GetPointFeatures().SetSelectedMapFeature(mapFeature); }
    function getMapFeatureFromItem(item) { return busPointFeatures.GetPointFeatures().GetMapFeatureFromItem(item); }
    function getItemFromMapFeature(mapFeature) { return busPointFeatures.GetPointFeatures().GetItemFromMapFeature(mapFeature); }
    function getSelectedContent() { return busList.GetListContent().GetSelectedContent(); }
    function setSelectedContent(content) { busList.GetListContent().SetSelectedContent(content); }
    function getContentFromItem(item) { return busList.GetListContent().GetKeyedListContent().GetContentFromItem(item); }
    function getItemFromContent(content) { return busList.GetListContent().GetKeyedListContent().GetItemFromContent(content); }
    function onListBusItemClick(notification) {
        var mapFeature = getMapFeatureFromItem(notification.item);
        if (!!mapFeature) {
            var coords = mapFeature.GetPointCoords();
            settings.appContent.MakeSureMapCoordsAreVisible(coords, 150);
            if (getSelectedMapFeature() != mapFeature) {
                setSelectedMapFeature(mapFeature);
                new tf.map.PointsStyleAnimator({ maps: [settings.appContent.GetMap()], pointProviders: [coords], duration: 1000, getStyle: busPointFeatures.GetFlashBusSelectStyle });
            }
            else { setSelectedMapFeature(undefined); }
        }
        var content = getContentFromItem(notification.item);
        if (!!content) {
            if (getSelectedContent() != content) { setSelectedContent(content); }
            else { setSelectedContent(undefined); }
        }
    }
    function onBusMapFeatureClick(notification) {
        if (getSelectedMapFeature() != notification.mapFeature) {
            var item = getItemFromMapFeature(notification.mapFeature);
            if (!!item) { setSelectedMapFeature(notification.mapFeature); }
        }
        else { setSelectedMapFeature(undefined); }
        var item = getItemFromMapFeature(notification.mapFeature);
        if (!!item) {
            var content = getContentFromItem(item);
            if (!!content) {
                if (getSelectedContent() != content) {
                    setSelectedContent(content);
                    busList.GetListContent().EnsureContentVisible(content);
                }
                else { setSelectedContent(undefined); }
            }
        }
    }
    function hasHistoryEvents() { return theThis.GetHistoryNEvents() > 0; }
    function onMapPostCompose(notification) {
        //console.log('bus post compose');
        if (isVisible && !settings.isRT) {
            if (theThis.GetHistoryNEvents() > 0) {
                if (!historyTimer.GetIsPaused()) {
                    var nextTimeMillis = historyTimer.GetElapsedTime();
                    if (theThis.PositionAtTimeMillis(nextTimeMillis)) { setHistoryReplayPosMillis(nextTimeMillis); }
                    notification.continueAnimation();
                }
            }
        }
    }
    function preProcessHistoryBusData(data) {
        //firstEventMillis: firstEventMillis, totalSeconds: totalSeconds
        var results = tf.Transit.PreProcessHistoryBusData(data);
        var busTLF = getBusTLF();
        historyReplayProps = results.props;
        var totalMillis = historyReplayProps.totalSeconds * 1000;
        busTLF.replaySlider.min = 0;
        busTLF.replaySlider.max = totalMillis;
        //busTLF.replaySlider.value = 0;
        historyTimer.SetLimit(totalMillis);
        setHistoryReplayPosMillis(0);
        if (!serviceWasLoaded) { serviceWasLoaded = true; if (theThis.GetHistoryNEvents() > 0) { setHistoryPlayPaused(false); } }
        return results.newData;
    }
    function setHistoryPlayPaused(isPaused) {
        historyTimer.Pause(isPaused);
        updatePlayButton(isPaused);
    }
    function onHistorySliderChange(evt, pos) {
        //console.log(pos);
        var posMillis = parseInt(pos.current, 10);
        theThis.PositionAtTimeMillis(posMillis);
        setHistoryReplayPosMillis(posMillis, false);
    }
    function onServiceRefresh(notification) {
        var isRefreshing = notification.sender.GetIsRefreshing();
        if (isRefreshing) {
            if (!settings.isRT) {
                historyReplayProps = undefined;
                stopAnimation();
            }
        }
        busList.OnServiceRefresh(notification);
    }
    function stopAnimation() {
        setHistoryPlayPaused(true);
        setHistoryReplayPosMillis(0);
    }
    function getBusTLF() { return busList.GetBusTLF(); }
    function updatePlayButton(isPaused) {
        var busTLF = getBusTLF();
        if (!!busTLF.replayPlayButton) {
            var playerSVGs = settings.appContent.GetAppStyles().GetPlayerSVGs();
            var svgUse = isPaused ? playerSVGs.play : playerSVGs.pause;
            var button = busTLF.replayPlayButton.GetButton();
            button.innerHTML = svgUse;
        }
    }
    function onClickReplayPlay() { if (hasHistoryEvents()) { if (historyTimer.GetIsPaused()) { setHistoryPlayPaused(false); forceMapRender(); } else { setHistoryPlayPaused(true); } } }
    function replayPlayToolTipText() { return historyTimer.GetIsPaused() ? "resume replay" : "pause replay"; }
    function onClickReplayStop() { if (hasHistoryEvents()) { stopAnimation(); } }
    function replayStopToolTipText() { return "stop replay"; }
    function setHistoryAutoRepeats(newHistoryAutoRepeats) {
        if (historyReplayAutoRepeats != (newHistoryAutoRepeats = !!newHistoryAutoRepeats)) {
            historyReplayAutoRepeats = newHistoryAutoRepeats;
            if (!settings.isRT) {
                var busTLF = getBusTLF();
                if (!!historyTimer) { historyTimer.SetWrap(historyReplayAutoRepeats); }
                var playerSVGs = settings.appContent.GetAppStyles().GetPlayerSVGs();
                var svgUse = historyReplayAutoRepeats ? playerSVGs.autoRepeat : playerSVGs.noAutoRepeat;
                var button = busTLF.replayAutoRepeatButton.GetButton();
                button.innerHTML = svgUse;
            }
        }
    }
    function setHistoryReplayPosMillis(newPosMillis, skipSetRange) {
        if (!settings.isRT) {
            var busTLF = getBusTLF();
            var timeStampStr;
            var newCurrentTime = new Date();
            updateReplayTimeStamp(newPosMillis);
            historyTimer.SetElapsedTime(newPosMillis);
            if (!skipSetRange) { busTLF.replaySlider.value = newPosMillis; }
        }
    }
    function setHistoryReplaySpeed(newSpeed) {
        if (historyReplayCurrentSpeed != newSpeed) {
            historyReplayCurrentSpeed = newSpeed;
            if (!settings.isRT) {
                var busTLF = getBusTLF();
                if (!!historyTimer) { historyTimer.SetSpeed(historyReplayCurrentSpeed); }
                var button = busTLF.replaySpeedButton.GetButton();
                button.innerHTML = historyReplayCurrentSpeed + 'x';
            }
        }
    }
    function updateReplayTimeStamp(newPosMillis) {
        if (!settings.isRT) {
            var timeStampStr;
            if (historyReplayProps != undefined) {
                var newCurrentTime = new Date();
                newCurrentTime.setTime(historyReplayProps.startDate.getTime() + newPosMillis);
                if (useLongTimeStampFormat) {
                    timeStampStr = tf.js.GetTimeStampFromDate(newCurrentTime);
                    timeStampStr = timeStampStr.substring(0, 19);
                }
                else { timeStampStr = tf.js.GetAMPMHourWithSeconds(newCurrentTime); }
            }
            else { timeStampStr = ""; }
            getBusTLF().replayLabelSpan.GetButton().innerHTML = timeStampStr;
        }
    }
    function onClickReplaySpeed() {
        var newSpeed = historyReplayCurrentSpeed * 10;;
        if (newSpeed > 100) { newSpeed = 1; }
        setHistoryReplaySpeed(newSpeed);
    }
    function replaySpeedToolTipText() {
        var topLine = "replaying at " + (historyReplayCurrentSpeed == 1 ? "normal" : historyReplayCurrentSpeed + " x normal") + " speed";
        var botLine = "click to change";
        return tf.TFMap.MapTwoLineSpan(topLine, botLine);
    }
    function onClickReplayAutoRepeat() { setHistoryAutoRepeats(!historyReplayAutoRepeats); }
    function replayAutoRepeatToolTipText() {
        var topLine = "replay auto repeat is <u>" + (historyReplayAutoRepeats ? "on" : "off") + "</u>";
        var botLine = "switch it " + (historyReplayAutoRepeats ? "off" : "on");
        return tf.TFMap.MapTwoLineSpan(topLine, botLine);
    }
    function onClickReplaySpan() {
        useLongTimeStampFormat = !useLongTimeStampFormat;
        updateReplayTimeStamp(lastTimePositionedAt);
    }
    function replaySpanToolTipText() { return "change time stamp format"; }
    function createComponents() {
        var isRT = settings.isRT;
        var settingsIsVisible = !!settings.isVisible;
        KL = new tf.Transit.BusKL({ KLName: (isRT ? "rtBusKL" : "histBusKL") });
        var KLKL = KL.GetKL();
        busPointFeatures = new tf.Transit.BusPointFeatures({ layer: layer, appContent: settings.appContent, onClick: onBusMapFeatureClick });
        var busListContentSettings = {
            onClickReplayPlay: onClickReplayPlay,
            replayPlayToolTipText: replayPlayToolTipText,
            onClickReplayStop: onClickReplayStop,
            replayStopToolTipText: replayStopToolTipText,
            onClickReplaySpeed: onClickReplaySpeed,
            replaySpeedToolTipText: replaySpeedToolTipText,
            onClickReplayAutoRepeat: onClickReplayAutoRepeat,
            replayAutoRepeatToolTipText: replayAutoRepeatToolTipText,
            onClickReplaySpan: onClickReplaySpan,
            replaySpanToolTipText: replaySpanToolTipText,
            getHistoryNEvents: theThis.GetHistoryNEvents,
            onClickRefreshButton: settings.onClickRefreshButton,
            onClickBusTitleButton: settings.onClickBusTitleButton,
            busTitleButtonToolTipText: settings.busTitleButtonToolTipText,
            isVisible: settingsIsVisible,
            busListClasses: settings.busListClasses,
            busListItemClassNames: settings.busListItemContentClasses.GetClassNames(),
            isRT: isRT,
            compareContent: tf.Transit.CompareBuses,
            KL: KLKL,
            onItemClick: onListBusItemClick
        };
        busList = settings.busListClasses.CreateList(busListContentSettings);
        var busTLF = getBusTLF();
        klListener = KLKL.AddAggregateListener(onKLChange);
        //var serviceURL = isRT ? 'http://131.94.133.212/api/v1/transit/rtbuses?agency=MDT' : 'http://131.94.133.212/api/v1/transit/bushistory2?agency=MDT';
        var busServiceSettings = {
            isRT: isRT,
            autoRefreshes: isRT,
            clearBeforeRefresh: !isRT,
            refreshTimeoutMillis: 10000,
            KL: KLKL,
            onPreRefresh: onServiceRefresh,
            onPostRefresh: onServiceRefresh
        };
        if (!isRT) { busServiceSettings.preProcessServiceData = preProcessHistoryBusData; }
        service = new tf.Transit.BusService(busServiceSettings);
        if (!isRT) {
            postComposeListener = settings.appContent.GetMap().AddListener(tf.consts.mapPostComposeEvent, onMapPostCompose);
            tf.dom.OnRangeChange(busTLF.replaySlider, onHistorySliderChange);
            historyTimer = new tf.helpers.Timer();
            //historyTimer.Pause(true);
            historyTimer.SetLimit(1);
            setHistoryReplayPosMillis(0);
            updatePlayButton(true);
            setHistoryAutoRepeats(true);
            setHistoryReplaySpeed(100);
        }
        theThis.SetVisible(settingsIsVisible);
    };
    function notify(eventName, props) { allEventDispatchers.Notify(eventName, tf.js.ShallowMerge(props, { sender: theThis, eventName: eventName, isRT: settings.isRT })); }
    function notifyUpdate(props) { return notify(updateNameEvent, props); }
    function initialize() {
        allEventDispatchers = new tf.events.MultiEventNotifier({ eventNames: [updateNameEvent = "upd"] });
        minIntervalPositionMillis = 50;
        useLongTimeStampFormat = false;
        createLayer();
        createComponents();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.Transit.BusRTAndHistoryContent = function (settings) {
    var theThis, busListClasses, busListItemContentClasses, showingRT, rtContent, historyContent, nextAvailableZIndex;
    var allEventDispatchers, changeListEventName;
    this.GetRTContent = function () { return rtContent; }
    this.GetHistoryContent = function () { return historyContent; }
    this.GetNextAvailableZIndex = function () { return nextAvailableZIndex; }
    this.UpdateForMapType = function () {
        if (!!rtContent) { rtContent.UpdateForMapType(); }
        if (!!historyContent) { historyContent.UpdateForMapType(); }
    }
    this.OnVisibilityChange = function (notification) {
        if (notification.isVisible) { resetVisibility(); } else {
            if (!!rtContent) { rtContent.SetVisible(false); }
            if (!!historyContent) { historyContent.SetVisible(false); }
        }
    }
    this.AddListChangeListener = function (callBack) { allEventDispatchers.AddListener(changeListEventName, callBack); }
    this.GetIsShowingRT = function () { return showingRT; }
    this.SetShowingRT = function (newShowingRT) {
        if (showingRT != (newShowingRT = !!newShowingRT)) {
            if ((newShowingRT && !!rtContent) || (!newShowingRT && !!historyContent)) {
                showingRT = newShowingRT; resetVisibility();
                notify(changeListEventName);
            }
        }
    }
    function notify(eventName, props) { allEventDispatchers.Notify(eventName, tf.js.ShallowMerge(props, { sender: theThis, eventName: eventName })); }
    function resetVisibility() {
        if (!!rtContent) { rtContent.SetVisible(showingRT); }
        if (!!historyContent) { historyContent.SetVisible(!showingRT); }
    }
    function closePanel() { settings.customAppContentI.setVisible(false); }
    function initialize() {
        allEventDispatchers = new tf.events.MultiEventNotifier({ eventNames: [changeListEventName = "chg"] });
        var createBothLists = false;
        if (!settings.showHistory) { settings.showRT = true; } else if (settings.showRT) { createBothLists = true; }
        showingRT = settings.showRT;
        if (!!settings.showHistory && !!settings.startWithHistory) { showingRT = false; }
        busListClasses = new tf.Transit.BusListClasses(settings);
        busListItemContentClasses = new tf.Transit.BusListItemContentClasses(settings);
        nextAvailableZIndex = settings.layerZIndex;
        if (!!settings.showRT) {
            rtContent = new tf.Transit.BusServiceFeaturesContent(tf.js.ShallowMerge(settings, {
                onClickBusTitleButton: function () { if (createBothLists) { theThis.SetShowingRT(false); } else { closePanel(); } },
                busTitleButtonToolTipText: createBothLists ? "Switch to recent activity" : "Collapse panel",
                isVisible: showingRT,
                isRT: true,
                busListClasses: busListClasses,
                busListItemContentClasses: busListItemContentClasses,
                layerZIndex: nextAvailableZIndex
            }));
            nextAvailableZIndex = rtContent.GetNextAvailableZIndex();
        }
        if (!!settings.showHistory) {
            historyContent = new tf.Transit.BusServiceFeaturesContent(tf.js.ShallowMerge(settings, {
                onClickRefreshButton: function () { historyContent.RefreshNow(); },
                onClickBusTitleButton: function () { if (createBothLists) { theThis.SetShowingRT(true); } else { closePanel(); } },
                busTitleButtonToolTipText: createBothLists ? "Switch to real time activity" : "Collapse panel",
                isVisible: !showingRT,
                isRT: false,
                busListClasses: busListClasses,
                busListItemContentClasses: busListItemContentClasses,
                layerZIndex: nextAvailableZIndex
            }));
            nextAvailableZIndex = historyContent.GetNextAvailableZIndex();
        }
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: transitplan.js
tf.Transit.PlanTripSteps = {
    fromStartLocation: 0,
    walkFromStartToStop: 1,
    takeTripAtStop: 2,
    leaveTripAtStop: 3,
    walkFromStopToNearbyStop: 4,
    walkFromStopToEndLocation: 5,
    arriveAtEndLocation: 1000
};
tf.Transit.WalkCalls = function (settings) {
    var theThis, onCompleteCB, walkCalls, nWalkCallsToMake, nWalkCallsCompleted, isFinished;
    this.GetSettings = function () { return settings; }
    this.Cancel = function () {
        if(!isFinished) {
            isFinished = true;
            if (walkCalls.length > 0) {
                var wc = walkCalls;
                walkCalls = [];
                for (var i in wc) {
                    wc[i].routing.Cancel();
                }
            }
        }
    }
    function checkWalkCallsCompleted() {
        if (!isFinished) {
            if (nWalkCallsCompleted == nWalkCallsToMake) {
                isFinished = true;
                if (!!onCompleteCB) {
                    var occb = onCompleteCB, wcs = walkCalls;
                    onCompleteCB = undefined;
                    walkCalls = [];
                    occb({ sender: theThis, walkCalls: wcs });
                }
            }
        }
    }
    function onWalkCallCompleted(notification) {
        if (!isFinished) {
            ++nWalkCallsCompleted;
            walkCalls[notification.requestProps.index].notification = notification;
            checkWalkCallsCompleted();
        }
    }
    function makeWalkCall(fromTo) {
        var index = walkCalls.length;
        var lineStringCoords = [fromTo.fromCoords.slice(0), fromTo.toCoords.slice(0)];
        var routing =  new tf.services.Routing({
            findAlternatives: false, level: 18, lineStringCoords: lineStringCoords,
            mode: tf.consts.routingServiceModeFoot, optionalScope: theThis, instructions: true,
            callBack: onWalkCallCompleted, requestProps: { index: index }
        });
        walkCalls.push({ routing: routing });
    }
    function initialize() {
        nWalkCallsCompleted = nWalkCallsToMake = 0;
        walkCalls = [];
        isFinished = false;
        if(tf.js.GetIsValidObject(settings) && !!settings.fromToCoords) {
            if (!!(onCompleteCB = tf.js.GetFunctionOrNull(settings.onCompleted))) {
                var fromToCoords = settings.fromToCoords;
                if (!tf.js.GetIsArray(fromToCoords)) { fromToCoords = [fromToCoords]; }
                if ((nWalkCallsToMake = fromToCoords.length) > 0) {
                    for (var i = 0; i < nWalkCallsToMake; ++i) { makeWalkCall(fromToCoords[i]); }
                }
            }
        }
        checkWalkCallsCompleted();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.Transit.PlanService = function (settings) {
    var theThis, planSettings, defaultErrorMessage, instructionsAndRouteGeom, superCancel, onFullDirectionsLoadedCB;
    var walkCalls;
    this.GetInstructionsAndRouteGeom = function () { return instructionsAndRouteGeom; }
    this.GetPlan = function (from, to) {
        var dateRequested = new Date(), dateRequestedTimeStamp = tf.js.GetTimeStampFromDate(dateRequested);
        planSettings.date = dateRequestedTimeStamp;
        planSettings.x1 = from[0];
        planSettings.y1 = from[1];
        planSettings.x2 = to[0];
        planSettings.y2 = to[1];
        theThis.RefreshNow(planSettings);
    }
    function getInstructionsAndRouteGeom(data) {
        var success = false, extent, total_distance = 0, total_time = 0;
        var instructions = [];
        var mapFeatureGeom;
        var message = defaultErrorMessage;
        clearWalkCalls();
        if (tf.js.GetIsValidObject(data) && (data.success)) {
            if (data.nPlans > 0) {
                var plan = data.plans[0], steps = plan.steps, nSteps = steps.length;
                var lastStep = steps[nSteps - 1], prevStep;
                var lastLengthInMeters = 0;
                var routeCoords = [];
                var fromToCoords = [];
                total_time = plan.endHMS - plan.startHMS;
                total_distance = (lastStep.tripkm + lastStep.walkkm) * 1000;
                for (var i = 0; i < nSteps; ++i) {
                    var step = steps[i], coords = step.coords;
                    var lengthInMeters = (step.tripkm + step.walkkm) * 1000;
                    var instructionData = {
                        index: i,
                        step: step,
                        geometry: { type: 'point', coordinates: coords },
                        properties: { instructionCode: step.type, streetName: "", instruction: step.desc, lengthMeters: lengthInMeters - lastLengthInMeters, postTurnDirection: 0 }
                    };
                    lastLengthInMeters = lengthInMeters;
                    var hms = tf.js.TranslateHourMinSec(step.hms);
                    switch (step.type) {
                        case tf.Transit.PlanTripSteps.walkFromStartToStop:
                            instructionData.fromCoords = data.startCoords;
                            instructionData.toCoords = coords;
                            break;
                        case tf.Transit.PlanTripSteps.walkFromStopToNearbyStop:
                            instructionData.fromCoords = prevStep.coords;
                            instructionData.toCoords = coords;
                            break;
                        case tf.Transit.PlanTripSteps.walkFromStopToEndLocation:
                            instructionData.fromCoords = prevStep.coords;
                            instructionData.toCoords = coords;
                            break;
                        case tf.Transit.PlanTripSteps.leaveTripAtStop:
                        case tf.Transit.PlanTripSteps.takeTripAtStop:
                            instructionData.properties.instruction = hms.HM + " - " + instructionData.properties.instruction;
                            break;
                    }
                    if (instructionData.fromCoords != undefined) {
                        fromToCoords.push({ fromCoords: instructionData.fromCoords, toCoords: instructionData.toCoords, instructionData: instructionData });
                    }
                    instructions.push(instructionData);
                    extent = tf.js.UpdateMapExtent(extent, coords);
                    routeCoords.push(coords.slice(0));
                    prevStep = step;
                }
                message = "Found route between points"
                success = true;
                var mapFeatureGeomSettings = { type: 'linestring', coordinates: routeCoords };
                mapFeatureGeom = new tf.map.FeatureGeom(mapFeatureGeomSettings);
                if (fromToCoords.length > 0) {
                    walkCalls = new tf.Transit.WalkCalls({ fromToCoords: fromToCoords, onCompleted: onWalkCallsCompleted });
                }
            }
        }
        return {
            plan: plan, transitInstructions: true, total_distance: total_distance, total_time: total_time,
            instructions: instructions, message: message, routeGeom: mapFeatureGeom, success: success, extent: extent
        };
    };
    function preProcessServiceData(data) {
        instructionsAndRouteGeom = getInstructionsAndRouteGeom(data);
        checkFullDirectionsLoaded();
        return undefined;
    }
    function cancelHook() {
        clearWalkCalls();
        superCancel.apply(theThis, arguments);
    }
    function clearWalkCalls() { if (!!walkCalls) { walkCalls.Cancel(); walkCalls = undefined; } }
    function onWalkCallsCompleted(notification) {
        var wkSettings = notification.sender.GetSettings();
        var fromToCoords = wkSettings.fromToCoords;
        var wc = notification.walkCalls;
        if (fromToCoords.length == wc.length) {
            var totalDiffMeters = 0;
            var nInstructions = instructionsAndRouteGeom.instructions.length;
            for (var i = 0; i < fromToCoords.length; ++i) {
                var fromToItem = fromToCoords[i], instructionData = fromToItem.instructionData;
                var walkNotification = wc[i].notification;
                if (!!walkNotification && tf.js.GetIsValidObject(walkNotification.route_summary)) {
                    var fromMeters = instructionData.properties.lengthMeters;
                    var toMeters = walkNotification.route_summary.total_distance;
                    var thisDiffMeters = toMeters - fromMeters;
                    var thisDiffKM = thisDiffMeters / 1000;
                    totalDiffMeters += thisDiffMeters;
                    instructionData.properties.lengthMeters = toMeters;
                    for (var j = instructionData.index; j < nInstructions; ++j) {
                        var id = instructionsAndRouteGeom.instructions[j], step = id.step;
                        step.walkkm += thisDiffKM;
                    }
                }
            }
            instructionsAndRouteGeom.total_distance += totalDiffMeters;
        }
        walkCalls = undefined;
        checkFullDirectionsLoaded();
    }
    function checkFullDirectionsLoaded() { if (walkCalls == undefined) { onFullDirectionsLoaded(); } }
    function onFullDirectionsLoaded() { if (!!onFullDirectionsLoadedCB) { onFullDirectionsLoadedCB({ sender: theThis }); } }
    function initialize() {
        onFullDirectionsLoadedCB = tf.js.GetFunctionOrNull(settings.onFullDirectionsLoaded);
        defaultErrorMessage = "Transit server not available ";
        planSettings = {
            x1: 0, y1: 0, x2: 0, y2: 0,
            r1: 3,    // km
            r2: 3,    // km
            maxmins: 180,
            maxtrips: 3,
            maxstopr: 2,  //km
            maxplans: 1,
            mintripdist: 0.5    //km
        };
        instructionsAndRouteGeom = getInstructionsAndRouteGeom(undefined);
        tf.Transit.BackendService.call(theThis, tf.js.ShallowMerge({ serviceName: "plans", preProcessServiceData: preProcessServiceData }, settings));
        superCancel = theThis.Cancel;
        theThis.Cancel = cancelHook;
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.Transit.PlanService, tf.Transit.BackendService);

// SOURCE FILE: mdtbusapp.js
tf.MDTBusesApp = {};
tf.MDTBusesApp.Content = function (settings) {
    var theThis, busRTAndHistoryContent;
    this.OnVisibilityChange = function (notification) { if (!!busRTAndHistoryContent) { busRTAndHistoryContent.OnVisibilityChange(notification); } }
    this.UpdateForMapType = function () { if (!!busRTAndHistoryContent) { busRTAndHistoryContent.UpdateForMapType(); } }
    function createControl() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles();
        var customAppContentI = settings.customAppContentI;
        var ls = tf.TFMap.LayoutSettings;
        var topCaption = customAppContentI.createTitleDescSVGLogo(settings.panelName, settings.appDesc, appStyles.GetPoweredByTerraFlySVGForMap());
        var topContent = customAppContentI.createNonScrollContent();
        topContent.AddContent(topCaption.wrapper);
        customAppContentI.getContentWrapper().AddContent(topContent);
    }
    function initialize() {
        createControl();
        busRTAndHistoryContent = new tf.Transit.BusRTAndHistoryContent(tf.js.ShallowMerge(settings, {
            startWithHistory: settings.startWithHistory,
            showRT: settings.showRT,
            showHistory: settings.showHistory,
            layerZIndex: settings.layerZIndex
        }));
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.MDTBusesApp.App = function (settings) {
    var theThis, appName, appDesc, customApp, mdtBusesAppContent;
    function onCreated(notification) {
        //console.log('on created');
    }
    function onParametersParsed(notification) {
        //var params = notification.params; console.log('on parameters parsed');
    }
    function onContentSetInterface(theInterface) {
        mdtBusesAppContent = new tf.MDTBusesApp.Content({
            appContent: customApp.GetTFMapApp().GetContent(), customAppContentI: theInterface, panelName: appName, appDesc: appDesc,
            startWithHistory: settings.startWithHistory, showRT: settings.showRT, showHistory: settings.showHistory
        });
    }
    function updateForMapType() { if (!!mdtBusesAppContent) { mdtBusesAppContent.UpdateForMapType(); } }
    function onVisibilityChange(notification) { if (!!mdtBusesAppContent) { mdtBusesAppContent.OnVisibilityChange(notification); } }
    function initialize() {
        appName = "MDT Buses";
        if (!settings.showHistory) { settings.showRT = true; }
        appDesc = "Miami Dade Transit authority";
        customApp = new tf.TFMap.CustomApp(tf.js.ShallowMerge(settings, {
            onVisibilityChange: onVisibilityChange,
            updateForMapType: updateForMapType,
            appName: appName, sidePanelWidthInt: 340, sidePanelWidthSmallInt: 240,
            onContentSetInterface: onContentSetInterface, onCreated: onCreated, onParametersParsed: onParametersParsed
        }));
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: geofences.js
tf.GeoFences = {};
tf.GeoFences.fenceTypes = {
    //circle: "circle",
    extent: "extent",
    polygon: "polygon"
};
tf.GeoFences.instantFenceKeys = {
    mtInstantFence: "mtInstantFence",
    dtInstantFence: "dtInstantFence",
    propsInstantFence: "propsInstantFence"
};
tf.GeoFences.TargetPointFeatures = function (settings) {
    var theThis, pointFeatures;
    this.GetPointFeatures = function () { return pointFeatures; }
    this.UpdateForMapType = function (KL) { pointFeatures.RefreshStyles(KL); }
    function getStyles() {
        function getStyle(keyedFeature, mapFeature) {
            var isAerial = settings.appContent.GetIsShowingAerial();
            var isHover = mapFeature.GetIsDisplayingInHover();
            var mapFeatureSettings = mapFeature.GetSettings();
            var nFences = mapFeatureSettings.nFences;
            var zindex = isHover ? 50 : 50;
            var colorStroke = isHover ? "#f00" : (isAerial ? "#f00" : "#f00");
            var shapeRadius = nFences > 0 ? (isHover ? 26 : 24) : 0;
            var lineWidth = isHover ? 3 : 2;
            var frameStyle = {
                shape: true, shape_points: 4, shape_radius: shapeRadius, line: true, line_width: lineWidth, line_color: colorStroke, zindex: zindex, rotation_rad: Math.PI / 4
            };
            if (nFences < 2) { return frameStyle; }
            else {
                var textStyle = { marker: true, label: ' ' + nFences + ' ', marker_arrowlength: 20, zindex: zindex + 1 };
                return [frameStyle, textStyle];
            }
        }
        return { style: getStyle, hoverStyle: getStyle };
    }
    function getMapFeatureToolTip(notification) {
        var mapFeature = notification.mapFeature, mapFeatureSettings = mapFeature.GetSettings();
        var nFences = mapFeatureSettings.nFences;
        var fenceFences = nFences == 1 ? "fence" : "fences";
        return "Inside " + nFences + " " + fenceFences;
    }
    function onClickMapFeature(notification) { if (tf.js.GetFunctionOrNull(settings.onClick)) { settings.onClick(notification); } }
    function initialize() {
        var mapFeatureInItemAttributeName = "fenceMapFeature";
        var itemInMapFeatureAttributeName = "pointItem";
        pointFeatures = new tf.TFMap.KeyedListPointFeatures({
            getOptionalSettings: settings.getOptionalSettings,
            refreshStyleOnUpdate: false,
            onClick: onClickMapFeature,
            mapFeatureInItemAttributeName: mapFeatureInItemAttributeName,
            itemInMapFeatureAttributeName: itemInMapFeatureAttributeName,
            styles: getStyles(),
            toolTipProps: { toolTipText: getMapFeatureToolTip, keepOnHoverOutTarget: false, offsetX: 24 },
            layer: settings.layer,
            appContent: settings.appContent
        });
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.GeoFences.TargetList = function (settings) {
    var theThis, pointFeatures, targetUpdateListener, targetsByFence, isCurrent, targetsChangeListener;
    this.SetIsCurrent = function (newIsCurrent) { return isCurrent = !!newIsCurrent; }
    this.GetIsCurrent = function () { return isCurrent; }
    this.UpdateForMapType = function () { if (!!pointFeatures) { pointFeatures.UpdateForMapType(settings.targetList.GetKL()); } }
    this.OnFencesChanged = function () { return calcGeoFenceState(); }
    this.GetTargetsByFence = function () { return targetsByFence; }
    function onTargetsUpdated() { pointFeatures.GetPointFeatures().RefreshPositions(settings.targetList.GetKL()); calcGeoFenceState(); }
    function onTargetsKLChange(notification) { pointFeatures.GetPointFeatures().OnKLChange(notification); calcGeoFenceState(); }
    function calcGeoFenceState() {
        targetsByFence = settings.list.CalcGeoFenceState(settings.targetList.GetKL(), pointFeatures);
        if (isCurrent) { settings.onCurrentCountChange(); }
    }
    function getTargetMapFeatureSettings(notification) { return { nFences: 0, fences: [] }; }
    function initialize() {
        var appContent = settings.appContent;
        var targetList = settings.targetList;
        var layer = targetList.GetLayer();
        var KL = targetList.GetKL();
        pointFeatures = new tf.GeoFences.TargetPointFeatures({
            layer: layer, appContent: appContent,
            //onClick: onMapFeatureClick, 
            getOptionalSettings: getTargetMapFeatureSettings
        });
        targetUpdateListener = settings.targetList.AddUpdateListener(onTargetsUpdated);
        targetsChangeListener = KL.AddAggregateListener(onTargetsKLChange);
        onTargetsUpdated();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.GeoFences.TargetLists = function (settings) {
    var theThis, targets, currentTargetList, changeListener;
    var allEventDispatchers, countChangeEventName;
    this.UpdateForMapType = function () { for (var i in targets) { targets[i].UpdateForMapType(); } }
    this.AddCountChangeListener = function (callBack) { return allEventDispatchers.AddListener(countChangeEventName, callBack); }
    this.GetCurrentTargetsByFence = function () { return currentTargetList ? currentTargetList.GetTargetsByFence() : undefined; }
    this.AddTargetList = function (targetListName, targetListToAdd) {
        if (tf.js.GetIsNonEmptyString(targetListName) && !!targetListToAdd) {
            targets[targetListName] = new tf.GeoFences.TargetList(tf.js.ShallowMerge(settings, { targetList: targetListToAdd, onCurrentCountChange: onCurrentCountChange }));
        }
    }
    this.GetTargetList = function (targetListName) { return targets[targetListName]; }
    this.SetCurrentTargetList = function (targetListName) { 
        var newCurrentTargetList = theThis.GetTargetList(targetListName);
        if (newCurrentTargetList != currentTargetList) {
            if (!!currentTargetList) { currentTargetList.SetIsCurrent(false); }
            if (!!(currentTargetList = newCurrentTargetList)) { currentTargetList.SetIsCurrent(true); }
        }
    }
    this.GetCurrentTargetList = function () { return currentTargetList; }
    function notify(eventName, props) { allEventDispatchers.Notify(eventName, tf.js.ShallowMerge(props, { sender: theThis, eventName: eventName })); }
    function onCurrentCountChange() { notify(countChangeEventName); }
    function onGeoFenceListChanged() { for (var i in targets) { targets[i].OnFencesChanged(); } }
    function initialize() {
        allEventDispatchers = new tf.events.MultiEventNotifier({ eventNames: [countChangeEventName = "cnt"] });
        targets = {};
        changeListener = settings.list.AddChangeListener(onGeoFenceListChanged);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.GeoFences.CompareFences = function (a, b) { return a.itemData.GetOrder() - b.itemData.GetOrder(); }
tf.GeoFences.Fence = function (settings) {
    var theThis, isInList;
    var type, fromStr, order, key, isInstant, editorNameStr;
    this.OnMapPostCompose = function (notification) { return settings.onMapPostCompose(notification); }
    this.GetMapFeature = function () { return settings.getMapFeature(); }
    this.GetKey = function () { return key; }
    this.SetKey = function (newKey) { key = newKey; }
    this.GetType = function () { return type; }
    this.GetIsInstant = function () { return isInstant; }
    this.SetOrder = function(newOrder) { order = newOrder; }
    this.GetOrder = function () { return order; }
    this.GetFromStr = function () { return fromStr; }
    this.GetEditorNameStr = function () { return editorNameStr; }
    this.GetIsInList = function () { return isInList; }
    this.SetIsInList = function (newIsInList) { if (isInList != (newIsInList = !!newIsInList)) { isInList = newIsInList; } }
    this.CreateCopy = function() { return settings.createCopy(); }
    this.CheckCoordsInside = function (coords) { return settings.checkCoordsInside(coords); }
    this.SetMapExtent = function () { return settings.setMapExtent(); }
    function initialize() {
        theThis.SetIsInList(!!settings.isInList);
        type = settings.type;
        fromStr = settings.fromStr;
        order = settings.order;
        key = settings.key;
        isInstant = !!settings.isInstant;
        editorNameStr = settings.editorNameStr;
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.GeoFences.PolyFence = function (settings) {
    var theThis, polyFeature;
    this.GetPolyFeature = function () { return polyFeature; }
    this.SetPolyFeature = function (newPolyFeature) {
        if (theThis.GetIsInstant()) {
            polyFeature = newPolyFeature;
        }
        else if (!!newPolyFeature) {
            var polyFeatureCoords = newPolyFeature.GetGeom().GetCoordinates();
            var lineStringCoords = tf.js.CopyLineStringCoords(polyFeatureCoords[0]);
            var polyFeatureGeom = {
                type: 'polygon',
                coordinates: [lineStringCoords]
            };
            polyFeatureGeom.style = polyFeatureGeom.hoverStyle = settings.getStyle;
            polyFeature = new tf.map.Feature(polyFeatureGeom);
        }
        else {
            polyFeature = undefined;
        }
    }
    function onMapPostCompose(notification) {
        if (!settings.isInstant) {
            if (!!polyFeature) {
                notification.showFeatureImmediately(polyFeature);
            }
        }
    }
    function checkCoordsInside(coords) { return !!polyFeature ? polyFeature.GetGeom().GetContainsCoords(coords) : false; }
    function createCopy() {
        var copy = new tf.GeoFences.PolyFence(tf.js.ShallowMerge(settings, { isInstant: false }));
        copy.SetPolyFeature(polyFeature);
        return copy;
    }
    function setMapExtent() { if (!!polyFeature) { settings.appContent.SetMapExtent(polyFeature.GetGeom().GetExtent()); } }
    function getMapFeature() { return theThis.GetPolyFeature(); }
    function initialize() {
        //console.log('settings.isInstant: ' + settings.isInstant);
        tf.GeoFences.Fence.call(theThis, tf.js.ShallowMerge({
            onMapPostCompose: onMapPostCompose, getMapFeature: getMapFeature,
            checkCoordsInside: checkCoordsInside, type: tf.GeoFences.fenceTypes.polygon, createCopy: createCopy, setMapExtent: setMapExtent
        }, settings));
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.GeoFences.PolyFence, tf.GeoFences.Fence);
tf.GeoFences.ExtentFence = function (settings) {
    var theThis, extent, lineString;
    this.GetLineString = function () { return lineString; }
    this.GetExtent = function () { return extent; }
    this.SetExtent = function (newExtent, newLineString) {
        extent = theThis.GetIsInstant() ? newExtent : (newExtent != undefined ? newExtent.slice(0) : undefined);
        if (!!extent) {
            var polyFeatureGeom = tf.js.GetPolyGeomFromExtent(extent);
            polyFeatureGeom.style = settings.getStyle;
            theThis.SetPolyFeature(new tf.map.Feature(polyFeatureGeom));
            lineString = newLineString != undefined ? tf.js.CopyLineStringCoords(newLineString) : undefined;
        }
        else {
            theThis.SetPolyFeature(undefined);
            lineString = undefined;
        }
    }
    function checkCoordsInside(coords) { return !!extent ? tf.js.GetExtentContainsCoord(extent, coords) : false; }
    function createCopy() {
        var copy = new tf.GeoFences.ExtentFence(tf.js.ShallowMerge(settings, { isInstant: false }));
        copy.SetExtent(extent, lineString);
        return copy;
    }
    function setMapExtent() { if (!!extent) { settings.appContent.SetMapExtent(extent); } }
    function initialize() {
        tf.GeoFences.PolyFence.call(theThis, tf.js.ShallowMerge(settings, {
            checkCoordsInside: checkCoordsInside, type: tf.GeoFences.fenceTypes.extent, createCopy: createCopy, setMapExtent: setMapExtent
        }));
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.js.InheritFrom(tf.GeoFences.PolyFence, tf.GeoFences.Fence);
tf.GeoFences.FenceList = function (settings) {
    var theThis, KL, mtGeomUpdateListener, mtActivationListener, dtGeomUpdateListener, dtActivationListener, propsDisplayerVisivbilityListener;
    var mtInstantFence, dtInstantFence, propsInstantFence;
    var allEventDispatchers, changeEventName;
    var order;
    var nNonInstantFences;
    this.AddChangeListener = function (callBack) { return allEventDispatchers.AddListener(changeEventName, callBack); }
    this.GetKL = function () { return KL; }
    this.AddFence = function (theFence) { addFence(theFence, true); notifyGeoFenceChange(); }
    this.RemoveFence = function (fenceItem) { removeFence(fenceItem); notifyGeoFenceChange(); }
    this.GetHasNonInstantFences = function () { return theThis.GetNonInstantFenceCount() > 0; }
    this.GetNonInstantFenceCount = function () { return nNonInstantFences; }
    this.RemoveNonInstantFences = function () {
        if (theThis.GetHasNonInstantFences()) {
            var fenceItems = KL.GetKeyedItemList();
            for (var i in fenceItems) {
                var fi = fenceItems[i], fiObj = fi.GetData(), isInstant = fiObj.GetIsInstant();
                if (!isInstant) {
                    removeFence(fi);
                }
            }
            notifyGeoFenceChange();
        }
    }
    this.SetMapExtentFromItem = function (item) {
        if (!!item) {
            var itemObj = item.GetData();
            itemObj.SetMapExtent();
        }
    }
    this.CalcGeoFenceState = function (targetKL, targetPointFeatures) {
        var targetsByFence = {};
        if (!!targetKL) {
            var nFencePolys = KL.GetItemCount();
            var pointFeatures = targetPointFeatures.GetPointFeatures();
            var items = targetKL.GetKeyedItemList();
            var fenceItems = KL.GetKeyedItemList();
            //for (var j in fenceItems) { targetsByFence[fenceItems[i].GetKey()] = {}; }
            for (var i in items) {
                var item = items[i];
                var mapFeature = pointFeatures.GetMapFeatureFromItem(item);
                if (!!mapFeature) {
                    var mapFeatureSettings = mapFeature.GetSettings();
                    var nFencesBefore = mapFeatureSettings.nFences;
                    var coordsNow = mapFeature.GetPointCoords();
                    mapFeatureSettings.fences = [];
                    for (var j in fenceItems) {
                        var fenceItem = fenceItems[j], fenceKey = fenceItem.GetKey();
                        var fenceTargets = targetsByFence[fenceKey];
                        if (fenceTargets == undefined) { fenceTargets = targetsByFence[fenceKey] = { count: 0, targets: {} }; }
                        if (fenceItem.GetData().CheckCoordsInside(coordsNow)) {
                            mapFeatureSettings.fences.push({ fenceItem: fenceItem });
                            ++fenceTargets.count;
                            fenceTargets.targets[item.GetKey()] = item;
                        }
                    }
                    mapFeatureSettings.nFences = mapFeatureSettings.fences.length;
                    if (nFencesBefore != mapFeatureSettings.nFences) { mapFeature.RefreshStyle(); }
                }
            }
        }
        return targetsByFence;
    };
    function notify(eventName, props) { allEventDispatchers.Notify(eventName, tf.js.ShallowMerge(props, { sender: theThis, eventName: eventName })); }
    function notifyGeoFenceChange() { notify(changeEventName); }
    function forceMapRender() { settings.appContent.GetMap().Render(); }
    function addFence(theFence, setOrderAndKey) {
        if (!!theFence) {
            if (setOrderAndKey) {
                ++nNonInstantFences;
                var newOrder = order++;
                theFence.SetOrder(newOrder);
                theFence.SetKey('' + newOrder);
            }
            KL.AddOrGetItem(theFence);
        }
    }
    function removeFence(fenceItem) {
        if (!!fenceItem) {
            if (!fenceItem.GetData().GetIsInstant()) { --nNonInstantFences; }
            KL.RemoveItemByKey(fenceItem.GetKey(), false, false);
        }
    }
    function addRemoveInstantFence(instantFence, needAdd, needRemove) {
        var needNotify = false;
        if (needAdd) { addFence(instantFence, false); instantFence.SetIsInList(true); needNotify = true; }
        else if (needRemove) { removeFence(KL.GetItem(instantFence.GetKey())); instantFence.SetIsInList(false); needNotify = true; }
        return needNotify;
    }
    function checkMTInstantFenceStatus(needNotify) {
        var mti = settings.appContent.GetMeasureToolInterface(), mtiActive = mti.getIsActive(), instantIsInList = mtInstantFence.GetIsInList();
        var needAdd = false, needRemove = false;
        if (mtiActive) {
            var mtiInfo = mti.getInfo(), hasArea = mtiInfo.nPoints > 2;
            if (instantIsInList) { needRemove = !hasArea; } else { needAdd = hasArea; }
            if (hasArea) { mtInstantFence.SetPolyFeature(mti.getAreaFeature()); }
        }
        else { needRemove = true; }
        needNotify |= addRemoveInstantFence(mtInstantFence, needAdd, needRemove);
        if (needNotify) { notifyGeoFenceChange(); }
    }
    function onMTUpdated(notification) { checkMTInstantFenceStatus(true); }
    function onMTActivation(notification) { checkMTInstantFenceStatus(); }
    function checkDTInstantFenceStatus(needNotify) {
        var dti = settings.appContent.GetDownloadToolInterface(), dtiActive = dti.getIsActive(), instantIsInList = dtInstantFence.GetIsInList();
        var needAdd = false, needRemove = false;
        if (dtiActive) {
            var dtiInfo = dti.getInfo(), extent = dtiInfo.nPoints >= 2 ? dtiInfo.lastExtentDrawResult.vertexExtent : undefined, hasExtent = extent != undefined;
            if (instantIsInList) { needRemove = !hasExtent; } else { needAdd = hasExtent; }
            if (hasExtent) { dtInstantFence.SetExtent(extent, dtiInfo.lineString); }
        }
        else { needRemove = true; }
        needNotify |= addRemoveInstantFence(dtInstantFence, needAdd, needRemove);
        if (needNotify) { notifyGeoFenceChange(); }
    }
    function onDTUpdated(notification) { checkDTInstantFenceStatus(true); }
    function onDTActivation(notification) { checkDTInstantFenceStatus(); }
    function onMapFeaturePropsDisplayChange(notification) {
        var needNotify = false, needAdd = false, needRemove = false;
        var instantIsInList = propsInstantFence.GetIsInList();
        var appContent = settings.appContent, mapFeaturePropsDisplayer = appContent.GetMapFeaturePropsDisplayer();
        var mapFeatureWithProps = mapFeaturePropsDisplayer.GetIsVisible() ? mapFeaturePropsDisplayer.GetLastMapFeature() : undefined;
        var polyMapFeature = !!mapFeatureWithProps ? mapFeatureWithProps.GetSettings().polyMapFeature : undefined;
        var hasPolyMapFeature = polyMapFeature != undefined;
        if (hasPolyMapFeature) { needAdd = !instantIsInList; propsInstantFence.SetPolyFeature(polyMapFeature); } else { needRemove = instantIsInList; }
        needNotify |= addRemoveInstantFence(propsInstantFence, needAdd, needRemove);
        if (needNotify) { notifyGeoFenceChange(); }
    }
    function setListeners() {
        var appContent = settings.appContent;
        var mti = appContent.GetMeasureToolInterface();
        var dti = appContent.GetDownloadToolInterface();
        mtGeomUpdateListener = mti.addUpdateGeomListener(onMTUpdated);
        mtActivationListener = mti.addActivationListener(onMTActivation);
        dtGeomUpdateListener = dti.addUpdateGeomListener(onDTUpdated);
        dtActivationListener = dti.addActivationListener(onDTActivation);
        propsDisplayerVisivbilityListener = appContent.GetMapFeaturePropsDisplayer().AddVisibilityChangeListener(onMapFeaturePropsDisplayChange);
        //settings.customAppContentI.setOnMapPostCompose(onMapPostCompose);
    }
    function createKL() {
        KL = new tf.js.KeyedList({
            name: tf.js.GetNonEmptyString(settings.KLName, "geoFencesKL"),
            getKeyFromItemData: function (fence) { return fence.GetKey(); },
            needsUpdateItemData: function (updateObj) { return true },
            filterAddItem: function (itemData) { return true; }
        });
    }
    function createInstantFences() {
        var measureToolStr = "measure tool";
        var downloadToolStr = "download tool"
        order = 1;
        var commonSettings = tf.js.ShallowMerge(settings, { isInstant: true, getStyle: settings.getStyle });
        mtInstantFence = new tf.GeoFences.PolyFence(tf.js.ShallowMerge(commonSettings, { key: tf.GeoFences.instantFenceKeys.mtInstantFence, fromStr: measureToolStr, editorNameStr: measureToolStr, order: order++ }));
        dtInstantFence = new tf.GeoFences.ExtentFence(tf.js.ShallowMerge(commonSettings, { key: tf.GeoFences.instantFenceKeys.dtInstantFence, fromStr: downloadToolStr, editorNameStr: downloadToolStr, order: order++ }));
        propsInstantFence = new tf.GeoFences.PolyFence(tf.js.ShallowMerge(commonSettings, { key: tf.GeoFences.instantFenceKeys.propsInstantFence, fromStr: "marker", editorNameStr: measureToolStr, order: order++ }));
    }
    function onMapPostCompose(notification) { var fenceItems = KL.GetKeyedItemList(); for (var i in fenceItems) { fenceItems[i].GetData().OnMapPostCompose(notification); } }
    function initialize() {
        allEventDispatchers = new tf.events.MultiEventNotifier({ eventNames: [changeEventName = "chg"] });
        createKL();
        createInstantFences();
        setListeners();
        nNonInstantFences = 0;
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.GeoFences.FencesMapFeatures = function (settings) {
    var theThis, fenceFeatures, fenceUpdateSeq, changeListener, selectedMapFeature;
    this.OnVisibilityChange = function (notification) {
        settings.appContent.GetBottomCustomAppLayer().SetVisible(notification.isVisible);
    }
    this.UpdateForMapType = function (KL) { for (var i in fenceFeatures) { fenceFeatures[i].mapFeature.RefreshStyle(); } }
    this.GetMapFeatureFromItem = function (fenceItem) {
        var fenceFeature = !!fenceItem ? fenceFeatures[fenceItem.GetKey()] : udnefined;
        return !!fenceFeature ? fenceFeature.mapFeature : undefined;
    }
    this.GetItemFromMapFeature = function (mapFeature) { return !!mapFeature ? mapFeature.GetSettings().fenceItem : undefined; }
    this.GetSelectedMapFeature = function () { return selectedMapFeature; }
    this.GetSelectedItem = function () { return theThis.GetItemFromMapFeature(selectedMapFeature); }
    this.SetSelectedItem = function (fenceItem) {
        var selectedItem = theThis.GetSelectedItem();
        if (fenceItem != selectedItem) {
            if (!!selectedItem) {
                var savedSelectedMapFeature = selectedMapFeature;
                selectedMapFeature = undefined;
                savedSelectedMapFeature.SetIsAlwaysInHover(false);
                //savedSelectedMapFeature.RefreshStyle();
            }
            if (!!fenceItem) {
                var mapFeature = theThis.GetMapFeatureFromItem(fenceItem);
                if (!!mapFeature) {
                    (selectedMapFeature = mapFeature).SetIsAlwaysInHover(true);
                    //selectedMapFeature.RefreshStyle();
                }
            }
        }
    }
    function onClickFenceMapFeature(notification) {
        if (tf.js.GetFunctionOrNull(settings.onMapFeatureClick)) {
            settings.onMapFeatureClick({ sender: theThis, item: notification.mapFeature.GetSettings().fenceItem });
        }
    }
    function updateFenceFeatures() {
        var layer = settings.appContent.GetBottomCustomAppLayer(), KL = settings.list.GetKL(), fenceItems = KL.GetKeyedItemList();
        ++fenceUpdateSeq;
        for (var i in fenceItems) {
            var fi = fenceItems[i], fik = fi.GetKey();
            var existingFeature = fenceFeatures[fik];
            if (!!existingFeature) {
                existingFeature.fenceUpdateSeq = fenceUpdateSeq;
            }
            else {
                var fObj = fi.GetData();
                if (!fObj.GetIsInstant()) {
                    var mapFeature = fObj.GetMapFeature();
                    if (!!mapFeature) {
                        var mapFeatureSettings = mapFeature.GetSettings();
                        mapFeatureSettings.onCustomAppClick = onClickFenceMapFeature;
                        mapFeatureSettings.fenceItem = fi;
                        fenceFeatures[fik] = { fenceUpdateSeq: fenceUpdateSeq, mapFeature: mapFeature, fenceItem: fi };
                        layer.AddMapFeature(mapFeature, true);
                    }
                }
            }
        }
        for (var i in fenceFeatures) {
            var ff = fenceFeatures[i];
            if (ff.fenceUpdateSeq != fenceUpdateSeq) {
                if (selectedMapFeature == ff.mapFeature) { selectedMapFeature = undefined; }
                layer.DelMapFeature(ff.mapFeature, true);
                delete fenceFeatures[i];
            }
        }
        layer.AddWithheldFeatures();
        layer.DelWithheldFeatures();
    }
    function onGeoFenceListChanged() { updateFenceFeatures(); }
    function initialize() {
        fenceUpdateSeq = 0;
        fenceFeatures = {};
        changeListener = settings.list.AddChangeListener(onGeoFenceListChanged);
        updateFenceFeatures();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.GeoFences.CSSClasses = function (settings) {
    var theThis, cssTag, classNames, layoutChangeListener;
    this.GetClassNames = function () { return classNames; }
    this.GetContentWrapperDisplayVisibleVerb = function () { return "block"; }
    this.SetListVisible = function (theTLF, isVisible) {
        if (!!theTLF) {
            var verbVisible = 'flex', verbHidden = 'none';
            theTLF.wrapper.GetHTMLElement().style.display = !!isVisible ? verbVisible : verbHidden;
        }
    }
    this.CreateToolBarListFooter = function (createSettings) {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles();
        var customAppContentI = settings.customAppContentI;
        var ls = tf.TFMap.LayoutSettings;
        var delayMillis = 0;
        var toolTipClass = "*start";
        var toolTipArrowClass = "top";
        var buttonSettings = {
            offsetY: 0, onClick: undefined, onHover: undefined, delayMillis: delayMillis, toolTipClass: toolTipClass, toolTipArrowClass: toolTipArrowClass
        };
        //isRT = false;
        var theTLF = createToolBarListFooter();
        var toolBarButtonClassNames = customAppContentI.getToolBarButtonClasses();
        var toolBarSpanClassNames = customAppContentI.getToolBarSpanClasses();
        var mainToolBarButtonClassNames = customAppContentI.getMainToolBarButtonClasses();
        var mainToolBarSpanClassNames = customAppContentI.getMainToolBarSpanClasses();
        theTLF.titleButton = tf.TFMap.CreateSVGButton(appContent, tf.js.ShallowMerge(buttonSettings, {
            wrapper: theTLF.toolBar.wrapper,
            onClick: createSettings.onClickTitleButton
        }), appStyles.GetFenceSVG(), mainToolBarButtonClassNames, createSettings.titleButtonToolTipText, undefined, "titleButton");
        theTLF.clearButton = tf.TFMap.CreateSVGButton(appContent, tf.js.ShallowMerge(buttonSettings, {
            wrapper: theTLF.toolBar.wrapper,
            onClick: createSettings.onClickClearButton
        }), appStyles.GetDustBinSVG(), mainToolBarButtonClassNames, "Remove all added fences", undefined, "titleButton");
        theTLF.listTitleSpan = document.createElement('span');
        theTLF.listTitleSpan.className = mainToolBarSpanClassNames;
        theTLF.toolBar.content.AddContent(theTLF.titleButton.GetButton(), theTLF.listTitleSpan, theTLF.clearButton.GetButton());
        theTLF.listItemsPlaceHolder = new tf.dom.Div({ cssClass: classNames.listItemsPlaceHolderClassName });
        var listItemsPlaceHolderE = theTLF.listItemsPlaceHolder.GetHTMLElement(), listItemsPlaceHolderES = listItemsPlaceHolderE.style;
        theTLF.measureAId = tf.dom.CreateDomElementID('fenceLink');
        theTLF.downloadAId = tf.dom.CreateDomElementID('fenceLink');
        listItemsPlaceHolderE.innerHTML = 'Design custom fences with<br><a id="' + theTLF.measureAId + '">Measure ' + appStyles.GetMeasureSVG() +
            '</a> or <a id="' + theTLF.downloadAId + '">Download ' + appStyles.GetDownloadSVG() + '</a>';
        //theTLF.scrollContent.AddContent(theTLF.listItemsPlaceHolder);
        theTLF.scrollWrapper.AddContent(theTLF.listItemsPlaceHolder);
        //theTLF.scrollContent.GetHTMLElement().style.backgroundColor = 'black';
        return theTLF;
    }
    function createCSSClassNames() {
        classNames = {
            itemWrapperClassName: tf.TFMap.CreateClassName(cssTag, "ItemWrapper"),
            itemWrapperSelectedClassName: tf.TFMap.CreateClassName(cssTag, "ItemWrapperSelected"),
            itemContentWrapperClassName: tf.TFMap.CreateClassName(cssTag, "ItemContentWrapper"),
            itemTitleClassName: tf.TFMap.CreateClassName(cssTag, "ItemTitle"),
            itemCountClassName: tf.TFMap.CreateClassName(cssTag, "itemCount"),
            itemButtonClassName: tf.TFMap.CreateClassName(cssTag, "ItemButton"),
            itemToolBarClassName: tf.TFMap.CreateClassName(cssTag, "ItemToolBar"),
            itemToolBarTextButton: tf.TFMap.CreateClassName(cssTag, "ItemToolBarTextButton"),
            itemToolBarFixWidthTextButton: tf.TFMap.CreateClassName(cssTag, "ItemToolBarAddDelTextButton"),
            listItemsPlaceHolderClassName: tf.TFMap.CreateClassName(cssTag, "listItemsPlaceHolder")
        };
    }
    function createToolBarListFooter() {
        var ls = tf.TFMap.LayoutSettings;
        var customAppContentI = settings.customAppContentI;
        var customAppClassNames = customAppContentI.getClassNames();
        var wrapper = customAppContentI.createNonScrollVariableHeightContent(customAppClassNames.minHeightPaneClassName);
        var toolBar = customAppContentI.createMainToolBar();
        var footer = customAppContentI.createFooter();
        var scrollWrapperAndContent = customAppContentI.createVertScrollWrapperAndContentWithFade();
        wrapper.AddContent(toolBar.wrapper);
        wrapper.AddContent(scrollWrapperAndContent.scrollWrapper, footer.wrapper);
        return {
            wrapper: wrapper, toolBar: toolBar,
            scrollWrapper: scrollWrapperAndContent.scrollWrapper, scrollContent: scrollWrapperAndContent.scrollContent, footer: footer
        };
    }
    function createCSSClasses() {
        var customAppContentI = settings.customAppContentI;
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles(), CSSClasses = appStyles.GetCSSClasses();
        var isSmallScreen = appStyles.GetIsSmallScreen();
        var cssClasses = [];
        var ls = tf.TFMap.LayoutSettings;
        var paddingHorTitleInt = 2;//isSmallScreen ? 4 : 8, paddingHorTitlePx = paddingHorTitleInt + 'px';
        var widthDirectionDivInt = isSmallScreen ? 20 : 30;
        var marginLeftTitleDivInt = widthDirectionDivInt + 2;
        var stdTextOverflow = { inherits: [CSSClasses.pointerEventsNone], overflow: "hidden", whiteSpace: "nowrap", textOverflow: "ellipsis", verticalAlign: "middle" };
        var maxWidthNameInt = isSmallScreen ? 36 : 56;
        var widthTitleSubInt = isSmallScreen ? 110 : 156;
        var displayType = CSSClasses.displayInlineBlock;
        cssClasses[classNames.itemWrapperClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.positionRelative, CSSClasses.displayBlock, CSSClasses.overflowHidden],
            padding: "1px", borderRadius: "0px", width: "calc(100% - 2px)"
        };
        cssClasses[classNames.itemWrapperClassName + ":hover"] = { backgroundColor: "rgba(0, 0, 0, 0.1)" };
        cssClasses[classNames.itemWrapperSelectedClassName] = { backgroundColor: "red" };
        cssClasses[classNames.itemWrapperSelectedClassName + ":hover"] = { backgroundColor: "red" };
        cssClasses[classNames.itemButtonClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.transparentImageButton, CSSClasses.backgroundColorTransparent, CSSClasses.displayBlock, CSSClasses.positionAbsolute],
            backgroundColor: "white",
            borderRadius: "0px", left: "4px", top: "1px", width: "calc(100% - 8px)", height: "calc(100% - 2px)"
        };
        cssClasses[classNames.itemContentWrapperClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.positionRelative, CSSClasses.transparentImageButton, CSSClasses.backgroundColorTransparent,
                CSSClasses.displayBlock, CSSClasses.pointerEventsNone],
            marginLeft: "2px", marginRight: "2px",
            borderRadius: "2px", lineHeight: "0px", width: "calc(100% - 4px)"
        };
        cssClasses[classNames.itemTitleClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.positionRelative, displayType, CSSClasses.darkTextShadow, stdTextOverflow],
            textAlign: "left",
            paddingLeft: "4px",
            paddingRight: "4px",
            //margin: "auto",
            width: "auto",
            color: "#444",
            background: "white",
            fontSize: ls.itemInListTitletFontSizeInt + 'px',
            lineHeight: (ls.itemInListTitleLineHeightInt + 1) + 'px'
        };
        cssClasses[classNames.itemCountClassName] = {
            inherits: [cssClasses[classNames.itemTitleClassName]]
        };
        cssClasses[classNames.itemToolBarClassName] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.backgroundColorTransparent, displayType],
            borderRadius: "0px", left: "0px", top: "0px", width: "auto",
            paddingLeft: "4px",
            paddingRight: "4px",
            lineHeight: ls.itemInListTitleLineHeightInt + 'px',
            //backgroundColor: "blue",
            "float": "right"
        };
        cssClasses[classNames.itemToolBarTextButton] = {
            inherits: [CSSClasses.noMarginNoBorderNoPadding, CSSClasses.transparentImageButton, CSSClasses.backgroundColorTransparent, displayType, CSSClasses.pointerEventsAll],
            borderRadius: "2px",
            border: "1px solid " + ls.darkTextColor,
            marginLeft: "2px", marginRight: "2px",
            padding: "2px",
            fontSize: (ls.itemInListTitletFontSizeInt - 3) + 'px',
            lineHeight: (ls.itemInListTitleLineHeightInt - 5) + 'px'
        };
        var widthAddDelTextButtonInt = isSmallScreen ? 36 : 56;
        cssClasses[classNames.itemToolBarFixWidthTextButton] = {
            width: widthAddDelTextButtonInt + "px",
            backgroundColor: "#f0f8ff"
        };
        var borderInt = 6;
        var paddingInt = 4;
        cssClasses[classNames.listItemsPlaceHolderClassName] = {
            position: 'absolute',
            fontSize: ls.itemInListTitletFontSizeInt + 'px',
            lineHeight: (ls.itemInListTitleLineHeightInt + 10) + 'px',
            backgroundColor: "white",
            borderRadius: borderInt + "px",
            color: ls.darkTextColor,
            textShadow: ls.darkTextShadow,
            left: "0px",
            top: "0px",
            margin: borderInt + "px",
            marginTop: "4px",
            padding: paddingInt + "px",
            width: "calc(100% - " + (borderInt * 2 + paddingInt * 2) + "px)",
            textAlign: "center"
        };
        cssClasses[classNames.listItemsPlaceHolderClassName + " svg"] = {
            verticalAlign: "center",
            fill: ls.darkTextColor,
            width: ls.itemInListTitleLineHeightInt + 'px',
            height: ls.itemInListTitleLineHeightInt + 'px'
        }
        cssClasses[classNames.listItemsPlaceHolderClassName + " a"] = {
            borderRadius: "4px",
            padding: "4px",
            paddingTop: "6px",
            backgroundColor: "rgba(0, 0, 80, 0.1)",
            cursor: "pointer",
            textDecoration: "none"
        }
        /*cssClasses[classNames.listItemsPlaceHolderClassName + " a svg"] = {
            verticalAlign: "center",
            fill: ls.darkTextColor,
            width: ls.itemInListTitleLineHeightInt + 'px',
            height: ls.itemInListTitleLineHeightInt + 'px'
        }*/
        cssClasses[classNames.listItemsPlaceHolderClassName + " a:hover"] = {
            textDecoration: "underline"
        }
        return cssClasses;
    }
    function registerCSSClasses() { tf.TFMap.CreateCSSClasses(createCSSClasses()); }
    function onLayoutChange(notification) { registerCSSClasses(); }
    function initialize() {
        cssTag = 'geoFenceClasses';
        createCSSClassNames();
        registerCSSClasses();
        layoutChangeListener = settings.appContent.GetAppStyles().AddOnLayoutChangeListener(onLayoutChange);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.GeoFences.FenceListView = function (settings) {
    var theThis, tlf, isVisible, keyedListContent, selectedContent, klListener;
    this.UpdateCounts = function (currentTargetsByFence) {
        var KL = settings.list.GetKL(), fenceItems = KL.GetKeyedItemList();
        for (var i in fenceItems) {
            var fi = fenceItems[i], fiContent = getContentFromItem(fi);
            if (!!fiContent) {
                var fik = fi.GetKey(), fiCount = currentTargetsByFence[fik];
                var targetCount = fiCount != undefined ? fiCount.count : 0;
                fiContent.count.GetHTMLElement().innerHTML = '[ ' + targetCount + ' ]';
            }
        }
    }
    this.OnCreated = function (notification) {
        assignMeasureDownloadLinks();
    }
    this.OnVisibilityChange = function (notification) { theThis.SetIsVisible(notification.isVisible); }
    this.SetIsVisible = function (newIsVisible) {
        if (isVisible != (newIsVisible = !!newIsVisible)) {
            isVisible = newIsVisible;
            settings.cssClasses.SetListVisible(tlf, isVisible);
        }
    }
    this.GetTLF = function () { return tlf; }
    this.GetSelectedContent = function () { return selectedContent; }
    this.SetSelectedContent = function (newSelectedContent) {
        if (newSelectedContent != selectedContent) {
            if (!!selectedContent) {
                var savedSelectedContent = selectedContent;
                selectedContent = undefined;
                setSelectedStyle(savedSelectedContent, false);
            }
            if (!!(selectedContent = newSelectedContent)) { setSelectedStyle(selectedContent, true); }
        }
    }
    this.SetSelectedItem = function (item) { return theThis.SetSelectedContent(getContentFromItem(item)); }
    this.GetSelectedItem = function () { return getItemFromContent(theThis.GetSelectedContent()); }
    this.EnsureContentVisible = function (content) {
        if (!!content) {
            tf.dom.ScrollVerticallyToEnsureVisible(settings.contentWrapper, content.wrapper, settings.customAppContentI.getVerListWithFadePaddingTopBotInt());
        }
    }
    function getContentFromItem(item) { return keyedListContent.GetContentFromItem(item); }
    function getItemFromContent(content) { return keyedListContent.GetItemFromContent(content); }
    function updateFooterText(theText) { tlf.footer.content.GetHTMLElement().innerHTML = theText; }
    function updateFooterCount() {
        var count = settings.list.GetKL().GetItemCount();
        var footerStr;
        if (count == 0) { footerStr = "fence list is empty" }
        else {
            var fenceFences = count == 1 ? "fence is" : "fences are";
            footerStr = count + " " + fenceFences + " active";
        }
        updateFooterText(footerStr);
        var listItemsPlaceHolderDisplayVerb = count == 0 ? 'block' : 'none';
        tlf.listItemsPlaceHolder.GetHTMLElement().style.display = listItemsPlaceHolderDisplayVerb;
        assignMeasureDownloadLinks();
    }
    function onKLChange(notification) {
        keyedListContent.OnKLChange(notification);
        if (!!selectedContent) {
            if (!keyedListContent.GetItemFromContent(selectedContent)) {
                selectedContent = undefined;
                //console.log('fences kl content: deselected deleted content');
            }
        }
        updateClearButtonStatus();
        setTimeout(updateFooterCount, 0);
    }
    function updateClearButtonStatus() {
        var clearButtonDisplayVerb = settings.list.GetHasNonInstantFences() ? 'inline-block' : 'none';
        tlf.clearButton.GetButton().style.display = clearButtonDisplayVerb;
    }
    function activateDownloadTool() { var appContent = settings.appContent; if (!appContent.IsDownloadToolOn()) { appContent.ToggleDownloadTool(); } }
    function activateMeasureTool() { var appContent = settings.appContent; if (!appContent.IsMeasureToolOn()) { appContent.ToggleMeasureTool(); } }
    function onDownloadAClicked(evt) { activateDownloadTool(); }
    function onMeasureAClicked(evt) { activateMeasureTool(); }
    function assignMeasureDownloadLinks() {
        if (!tlf.measureA) { if (!!(tlf.measureA = document.getElementById(tlf.measureAId))) { tlf.measureA.addEventListener('click', onMeasureAClicked); } }
        if (!tlf.downloadA) { if (!!(tlf.downloadA = document.getElementById(tlf.downloadAId))) { tlf.downloadA.addEventListener('click', onDownloadAClicked); } }
    }
    function onClickClearButton(notification) { settings.list.RemoveNonInstantFences(); }
    function createTLF() {
        var tlfSettings = {
            onClickTitleButton: function () { settings.customAppContentI.setVisible(false); },
            onClickClearButton: onClickClearButton,
            titleButtonToolTipText: "Collapse panel"
        };
        tlf = settings.cssClasses.CreateToolBarListFooter(tlfSettings);
        var titleStr = "Fences";
        tlf.listTitleSpan.innerHTML = titleStr;
        theThis.SetIsVisible(settings.startVisible != undefined ? !!settings.startVisible : true);
        updateFooterCount();
        settings.customAppContentI.getContentWrapper().AddContent(tlf.wrapper);
        klListener = settings.list.GetKL().AddAggregateListener(onKLChange);
        updateClearButtonStatus();
        assignMeasureDownloadLinks();
    }
    function onItemClick(notification) {
        var clickCB = tf.js.GetFunctionOrNull(settings.onItemClick);
        if (!!clickCB) {
            var button = !!notification ? notification.domObj : undefined;
            if (!!button) {
                var content = button.content;
                var item = keyedListContent.GetItemFromContent(content);
                if (!!item) { clickCB({ sender: theThis, item: item }); }
            }
        }
    }
    function updateContentForItem(item) {
        var content = keyedListContent.GetContentFromItem(item);
        if (!!content) {
            var itemObj = item.GetData(), type = itemObj.GetType(), titleStr = type, isInstant = itemObj.GetIsInstant(), addDelButtonStr;
            var editButtonDisplayVerb;
            if (isInstant) {
                titleStr = itemObj.GetFromStr() + " " + titleStr; addDelButtonStr = "ADD";
                editButtonDisplayVerb = 'none';
            }
            else {
                //titleStr += " " + item.GetKey() + " " + itemObj.GetKey();
                addDelButtonStr = "DEL";
                editButtonDisplayVerb = 'inline-block';
            }
            content.title.GetHTMLElement().innerHTML = titleStr;
            content.toolBarAddDelButton.GetButton().innerHTML = addDelButtonStr;
            content.toolBarEditButton.GetButton().style.display = editButtonDisplayVerb;
        }
    }
    function setSelectedStyle(content, isSelected) {
        var classNames = settings.cssClasses.GetClassNames();
        if (isSelected) { tf.dom.AddCSSClass(content.wrapper, classNames.itemWrapperSelectedClassName); }
        else { tf.dom.RemoveCSSClass(content.wrapper, classNames.itemWrapperSelectedClassName); }
    }
    function prepareSpareContent(content, forItem) {
        content.toolBarAddDelButton.fenceItem = forItem;
        content.toolBarEditButton.fenceItem = forItem;
        setSelectedStyle(content, false);
        return content;
    }
    function getItemAddDelToolTip(notification) {
        var toolTipText = "Add or remove";
        var fenceItem = notification.fenceItem;
        if (!!fenceItem) {
            var itemObj = fenceItem.GetData();
            var isInstant = itemObj.GetIsInstant();
            var topLine, botLine;
            if (isInstant) {
                topLine = "Fence only active while being edited";
                botLine = "Add its current shape to the list";
            }
            else {
                topLine = "Fence always active";
                botLine = "Remove it from the list";
            }
            toolTipText = tf.TFMap.MapTwoLineSpan(topLine, botLine);
        }
        return toolTipText;
    }
    function onAddDelButtonClicked(notification) {
        var fenceItem = notification.sender.fenceItem;
        if (!!fenceItem) {
            var fenceObj = fenceItem.GetData(), isInstant = fenceObj.GetIsInstant();
            if(isInstant) { settings.list.AddFence(fenceObj.CreateCopy()); } else { settings.list.RemoveFence(fenceItem); }
        }
    }
    function getItemEditToolTip(notification) {
        var toolTipText = "Redesign";
        var fenceItem = notification.fenceItem;
        if (!!fenceItem) {
            var itemObj = fenceItem.GetData();
            var isInstant = itemObj.GetIsInstant();
            if (!isInstant) {
                toolTipText = "Redesign fence with the " + itemObj.GetEditorNameStr();
            }
        }
        return toolTipText;
    }
    function onEditButtonClicked(notification) {
        var fenceItem = notification.sender.fenceItem;
        if (!!fenceItem) {
            var fenceObj = fenceItem.GetData(), isInstant = fenceObj.GetIsInstant();
            if (!isInstant) {
                var appContent = settings.appContent, editorUseI, activateEditorCB, lineStringCoords;
                switch (fenceObj.GetType()) {
                    case tf.GeoFences.fenceTypes.polygon:
                        editorUseI = appContent.GetMeasureToolInterface();
                        activateEditorCB = activateMeasureTool;
                        var polyFeature = fenceObj.GetPolyFeature();
                        if (!!polyFeature) {
                            var appContent = settings.appContent;
                            var polyFeatureCoords = polyFeature.GetGeom().GetCoordinates()[0];
                            var nPolyFeatureCoords = polyFeatureCoords.length;
                            lineStringCoords = polyFeatureCoords.slice(0, nPolyFeatureCoords - 1);
                        }
                        break;
                    case tf.GeoFences.fenceTypes.extent:
                        editorUseI = appContent.GetDownloadToolInterface();
                        activateEditorCB = activateDownloadTool;
                        lineStringCoords = fenceObj.GetLineString();
                        break;
                }
                if (editorUseI != undefined) {
                    editorUseI.setLineString(lineStringCoords);
                    activateEditorCB();
                    settings.list.RemoveFence(fenceItem);
                }
            }
        }
    }
    function createNewContent(forItem) {
        var appContent = settings.appContent;
        var classNames = settings.cssClasses.GetClassNames();
        var wrapper = new tf.dom.Div({ cssClass: classNames.itemWrapperClassName });
        var contentWrapper = new tf.dom.Div({ cssClass: classNames.itemContentWrapperClassName });
        var button = new tf.dom.Button({ cssClass: classNames.itemButtonClassName, onClick: onItemClick });
        var toolBar = new tf.dom.Div({ cssClass: classNames.itemToolBarClassName });
        var title = new tf.dom.Div({ cssClass: classNames.itemTitleClassName });
        var count = new tf.dom.Div({ cssClass: classNames.itemCountClassName });
        var delayMillis = 0, toolTipClass = "*start", toolTipArrowClass = "top";
        var buttonSettings = {
            wrapper: tlf.toolBar.wrapper, offsetY: 0, onClick: undefined, onHover: undefined, delayMillis: delayMillis, toolTipClass: toolTipClass, toolTipArrowClass: toolTipArrowClass
        };
        var toolBarEditButton = tf.TFMap.CreateSVGButton(appContent, tf.js.ShallowMerge(buttonSettings, {
            onClick: onEditButtonClicked
        }), undefined, classNames.itemToolBarTextButton + " " + classNames.itemToolBarFixWidthTextButton, getItemEditToolTip, undefined, "toolBarEdit");
        var toolBarAddDelButton = tf.TFMap.CreateSVGButton(appContent, tf.js.ShallowMerge(buttonSettings, {
            onClick: onAddDelButtonClicked
        }), undefined, classNames.itemToolBarTextButton + " " + classNames.itemToolBarFixWidthTextButton, getItemAddDelToolTip, undefined, "toolBarAddDel");
        toolBarEditButton.GetButton().innerHTML = "EDIT";
        toolBar.AddContent(toolBarEditButton.GetButton(), toolBarAddDelButton.GetButton());
        contentWrapper.AddContent(title, count, toolBar);
        wrapper.AddContent(button, contentWrapper);
        toolBarEditButton.fenceItem = forItem;
        toolBarAddDelButton.fenceItem = forItem;
        var content = {
            wrapper: wrapper, button: button, contentWrapper: contentWrapper, toolBar: toolBar, title: title, count: count,
            toolBarAddDelButton: toolBarAddDelButton, toolBarEditButton: toolBarEditButton
        };
        button.content = content;
        return content;
    }
    function createListContent() {
        var contentInItemAttributeName = tf.js.GetNonEmptyString(settings.contentInItemAttributeName, "fenceContent");
        var itemInContentAttributeName = tf.js.GetNonEmptyString(settings.itemInContentAttributeName, "fenceItem");
        keyedListContent = new tf.TFMap.KeyedListContent({
            KL: settings.list.GetKL(), wrapper: tlf.scrollWrapper, contentWrapper: tlf.scrollContent,
            contentWrapperDisplayVisibleVerb: settings.cssClasses.GetContentWrapperDisplayVisibleVerb(),
            contentInItemAttributeName: contentInItemAttributeName, itemInContentAttributeName: itemInContentAttributeName,
            createNewContent: createNewContent, prepareSpareContent: prepareSpareContent, updateContentForItem: updateContentForItem,
            compareContent: tf.GeoFences.CompareFences
        });
    }
    function initialize() {
        if (settings.cssClasses == undefined) { settings.cssClasses = new tf.GeoFences.CSSClasses(settings); }
        createTLF();
        createListContent();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.GeoFences.ListViewTargetListsCombo = function (settings) {
    var theThis, list, listFeatures, view, targetLists, cssClasses, countChangeListener;
    this.OnCreated = function (notification) { return view.OnCreated(notification); }
    this.UpdateForMapType = function () { targetLists.UpdateForMapType(); listFeatures.UpdateForMapType(); }
    this.OnVisibilityChange = function (notification) { view.OnVisibilityChange(notification); listFeatures.OnVisibilityChange(notification); }
    this.AddTargetList = function (targetListName, targetListToAdd) { return targetLists.AddTargetList(targetListName, targetListToAdd); }
    this.SetCurrentTargetList = function (targetListName) { targetLists.SetCurrentTargetList(targetListName); updateListViewCounts(); }
    function selectFenceItem(fenceItem, setExtent) {
        listFeatures.SetSelectedItem(fenceItem);
        view.SetSelectedItem(fenceItem);
        if (!!setExtent) { list.SetMapExtentFromItem(fenceItem); }
    }
    function deSelectFenceItem() { selectFenceItem(undefined); }
    function onViewItemClick(notification) {
        var clickedItem = notification.item; if (view.GetSelectedItem() == clickedItem) { deSelectFenceItem(); } else { selectFenceItem(clickedItem, true); }
    }
    function onFenceMapFeatureClick(notification) {
        var clickedItem = notification.item; if (listFeatures.GetSelectedItem() == clickedItem) { deSelectFenceItem(); } else { selectFenceItem(clickedItem, false); }
    }
    function updateListViewCounts() { view.UpdateCounts(targetLists.GetCurrentTargetsByFence()); }
    function onListCountChange(notification) { updateListViewCounts(); }
    function getGeoFenceLineStyle(keyedFeature, mapFeature) {
        var isAerial = settings.appContent.GetIsShowingAerial();
        var isHover = mapFeature.GetIsDisplayingInHover();
        var isSelected = listFeatures.GetSelectedMapFeature() == mapFeature;
        var line_width_solid = isHover ? 5 : 5;
        var colorLight = "#FFDEAD", colorDark = "#F0C789";
        var line_color_solid, line_color;
        var selColor = "#f00";
        line_color = isSelected ? selColor : colorLight;
        line_color_solid = isHover ? selColor : colorDark;
        var line_width = 13;
        var dashWidth = 4;
        var displace_solid = 2;
        var displace = 2;
        var outlineColor = tf.TFMap.LayoutSettings.darkTextColor;
        var zIndex = isSelected ? 10 : (isHover ? 20 : 0);
        return [
            { fill: false, line: true, line_width: line_width_solid + displace_solid, line_color: outlineColor, zindex: zIndex++ },
            { fill: false, line: true, line_width: line_width_solid, line_color: line_color_solid, zindex: zIndex++ },
            { fill: false, line: true, line_width: line_width + displace, line_color: outlineColor, line_join: "bevel", line_cap: "butt", line_dash: [dashWidth + displace, line_width - displace], zindex: zIndex++ },
            { fill: false, line: true, line_width: line_width, line_color: line_color, line_join: "bevel", line_cap: "butt", line_dash: [dashWidth, line_width], zindex: zIndex++ }
        ];
    }
    function initialize() {
        cssClasses = new tf.GeoFences.CSSClasses(settings);
        list = new tf.GeoFences.FenceList(tf.js.ShallowMerge(settings, { getStyle: getGeoFenceLineStyle }));
        listFeatures = new tf.GeoFences.FencesMapFeatures(tf.js.ShallowMerge(settings, { list: list, onMapFeatureClick: onFenceMapFeatureClick }));
        view = new tf.GeoFences.FenceListView(tf.js.ShallowMerge(settings, { list: list, cssClasses: cssClasses, onItemClick: onViewItemClick }));
        targetLists = new tf.GeoFences.TargetLists(tf.js.ShallowMerge(settings, { list: list }));
        countChangeListener = targetLists.AddCountChangeListener(onListCountChange);
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: geofencesapp.js
tf.GeoFenceApp = {};
tf.GeoFenceApp.Content = function (settings) {
    var theThis, busRTAndHistoryContent, geoFencesListViewTargetListsCombo;
    var rtTargetListName, historyTargetListName;
    this.OnCreated = function (notification) { return geoFencesListViewTargetListsCombo.OnCreated(notification); }
    this.OnVisibilityChange = function (notification) {
        if (!!geoFencesListViewTargetListsCombo) { geoFencesListViewTargetListsCombo.OnVisibilityChange(notification); }
        if (!!busRTAndHistoryContent) { busRTAndHistoryContent.OnVisibilityChange(notification); }
    }
    this.UpdateForMapType = function () {
        if (!!geoFencesListViewTargetListsCombo) { geoFencesListViewTargetListsCombo.UpdateForMapType(); }
        if (!!busRTAndHistoryContent) { busRTAndHistoryContent.UpdateForMapType(); }
    }
    function createControl() {
        var appContent = settings.appContent, appStyles = appContent.GetAppStyles();
        var customAppContentI = settings.customAppContentI;
        var ls = tf.TFMap.LayoutSettings;
        var topCaption = customAppContentI.createTitleDescSVGLogo(settings.panelName, settings.appDesc, appStyles.GetPoweredByTerraFlySVGForMap());
        var topContent = customAppContentI.createNonScrollContent();
        topContent.AddContent(topCaption.wrapper);
        customAppContentI.getContentWrapper().AddContent(topContent);
    }
    function updateCurrentTargetList() { geoFencesListViewTargetListsCombo.SetCurrentTargetList(busRTAndHistoryContent.GetIsShowingRT() ? rtTargetListName : historyTargetListName); }
    function onChangeBusList(notification) { updateCurrentTargetList(); }
    function initialize() {
        rtTargetListName = "rttargets";
        historyTargetListName = "historytargets";
        createControl();
        geoFencesListViewTargetListsCombo = new tf.GeoFences.ListViewTargetListsCombo(settings);
        busRTAndHistoryContent = new tf.Transit.BusRTAndHistoryContent(tf.js.ShallowMerge(settings, {
            startWithHistory: settings.startWithHistory,
            showRT: settings.showRT,
            showHistory: settings.showHistory,
            layerZIndex: settings.layerZIndex
        }));
        geoFencesListViewTargetListsCombo.AddTargetList(rtTargetListName, busRTAndHistoryContent.GetRTContent());
        geoFencesListViewTargetListsCombo.AddTargetList(historyTargetListName, busRTAndHistoryContent.GetHistoryContent());
        busRTAndHistoryContent.AddListChangeListener(onChangeBusList);
        updateCurrentTargetList();
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};
tf.GeoFenceApp.App = function (settings) {
    var theThis, appName, appDesc, customApp, geoFenceAppContent;
    function onCreated(notification) {
        geoFenceAppContent.OnCreated(notification);
    }
    function onParametersParsed(notification) {
        var mapSettings = notification.mapSettings;
        mapSettings.panels = tf.urlapi.AddStringsWithSeparatorsIfAbsent(mapSettings.panels, [tf.consts.panelNameMeasure, tf.consts.panelNameDownload]);
    }
    function onContentSetInterface(theInterface) {
        geoFenceAppContent = new tf.GeoFenceApp.Content({
            appContent: customApp.GetTFMapApp().GetContent(), customAppContentI: theInterface, panelName: appName, appDesc: appDesc,
            startWithHistory: settings.startWithHistory,
            showHistory: settings.showHistory,
            showRT: settings.showRT
        });
    }
    function updateForMapType() { if (!!geoFenceAppContent) { geoFenceAppContent.UpdateForMapType(); } }
    function onVisibilityChange(notification) { if (!!geoFenceAppContent) { geoFenceAppContent.OnVisibilityChange(notification); } }
    function initialize() {
        appName = "GeoFences";
        if (!settings.showHistory) { settings.showRT = true; }
        appDesc = "Applied to Miami Dade Transit<br/>Real time and Recent vehicle activity";
        customApp = new tf.TFMap.CustomApp(tf.js.ShallowMerge(settings, {
            onVisibilityChange: onVisibilityChange,
            updateForMapType: updateForMapType,
            appName: appName, sidePanelWidthInt: 340, sidePanelWidthSmallInt: 240,
            onContentSetInterface: onContentSetInterface, onCreated: onCreated, onParametersParsed: onParametersParsed
        }));
    }
    (function actualConstructor(theThisSet) { theThis = theThisSet; initialize(); })(this);
};

// SOURCE FILE: tfmapappinit.js
function bootStrapApp(appSettings) {
    var params = tf.urlapi.ParseURLAPIParameters(appSettings.fullURL);
    var appParam = params[tf.consts.appParamName];
    var app;
    if (tf.js.GetIsNonEmptyString(appParam)) {
        var mdtAppSettings, geoFenceAppSettings;
        switch (appParam.toLowerCase()) {
            case 'mdt':
            case 'mdtrths':
                mdtAppSettings = { showRT: true, showHistory: true, startWithHistory: false };
                break;
            case 'mdthsrt':
                mdtAppSettings = { showRT: true, showHistory: true, startWithHistory: true };
                break;
            case 'mdtrt':
                mdtAppSettings = { showRT: true, showHistory: false, startWithHistory: false };
                break;
            case 'mdths':
                mdtAppSettings = { showRT: false, showHistory: true, startWithHistory: true };
                break;
            case "geofence":
            case "geofencerths":
                geoFenceAppSettings = { showRT: true, showHistory: true, startWithHistory: false };
                break;
            case 'geofencehsrt':
                geoFenceAppSettings = { showRT: true, showHistory: true, startWithHistory: true };
                break;
            case 'geofencert':
                geoFenceAppSettings = { showRT: true, showHistory: false, startWithHistory: false };
                break;
            case 'geofencehs':
                geoFenceAppSettings = { showRT: false, showHistory: true, startWithHistory: true };
                break;
        }
        if (app == undefined) {
            var layerZIndexSettings = { layerZIndex: 10 };
            if (geoFenceAppSettings != undefined) {
                app = new tf.GeoFenceApp.App(tf.js.ShallowMerge(appSettings, geoFenceAppSettings, layerZIndexSettings));
            }
            else if (mdtAppSettings != undefined) {
                app = new tf.MDTBusesApp.App(tf.js.ShallowMerge(appSettings, mdtAppSettings, layerZIndexSettings));
            }
        }
    }
    if (app == undefined) { app = new tf.TFMap.App(appSettings); }
}
//var fakeHRef = 'http://tfcore.cs.fiu.edu/hterramap/#fmap=m2&type=map&perspectivemap=&Lat=25.757765&Lon=-80.367935&res=&Legendh=$$http://n00.cs.fiu.edu/defaultmapWMFL$$&&DLayerSelect1=true&dlayerfield1=L&DLayerColor1=&DLayerLegend1=Sights&DLayerData1=http%3A//acorn.cs.fiu.edu/cgi-bin/arquery.cgi%3Fcategory%3Dgeoimages%26visualvalue%3E%3D4%26vid=itpa%26tfaction=shortdisplayflash%26filetype=.json&DLayerSelect2=true&dlayerfield2=L&DLayerColor2=&DLayerLegend2=SideView&DLayerData2=http%3A//acorn.cs.fiu.edu/cgi-bin/arquery.cgi%3Fcategory%3Dalta%26vid=itpa%26tfaction=shortdisplayflash%26filetype=.json&DLayerSelect3=true&dlayerfield3=L&DLayerColor3=&DLayerLegend3=MLS&DLayerData3=http%3A//acorn.cs.fiu.edu/cgi-bin/arquery.cgi%3Fcategory%3Dcallreal%26vid=itpa%26tfaction=shortdisplayflash%26filetype=.json&DLayerSelect4=true&dlayerfield4=L&DLayerColor4=&DLayerLegend4=Stores&DLayerData4=http%3A//n00.cs.fiu.edu/cgi-bin/arquery.cgi?category=us_companies_2013%26tfaction=shortdisplayflash%26arcriteria=1%26SIC_CODE_Description|=store+stores%26filetype=.json&DLayerSelect5=true&dlayerfield5=L&DLayerColor5=&DLayerLegend5=Hotels&DLayerData5=http%3A//acorn.cs.fiu.edu/cgi-bin/arquery.cgi%3Fcategory%3Dhotelsd%5Fwikix2011%5Fiypages%5Fdemographics%5Fsic%5Fclustering%5Felevation%26vid=itpa%26tfaction=shortdisplayflash%26filetype=.json&DLayerSelect6=true&dlayerfield6=L&DLayerColor6=&DLayerLegend6=Restaurants&DLayerData6=http%3A//n00.cs.fiu.edu/cgi-bin/arquery.cgi?category=us_companies_2013%26tfaction=shortdisplayflash%26arcriteria=1%26Industry=Eating%26filetype=.json&Panels=type+zoom+nav+overview+measure+download+legend+fullscreen&address=1225+SW+107+AVE,++MIAMI,+FLORIDA+33174&vid=itpa&tf_passtrough=%26tfaction%3Ddispense%26sreq%3Dgnisstr';
var serverURL = 'http://131.94.133.212/api/v1/';
//var serverURL = 'http://192.168.0.81/api/v1/';
//var serverURL = 'http://192.168.0.105:8080/v1/';
//var appSettings = { serverURL: serverURL, fullURL: fakeHRef };
var appSettings = { serverURL: serverURL, fullURL: window.location.href };
bootStrapApp(appSettings);
